adapted
https://github.com/wolfgar/linux/commit/c0bc6d705fa3b88f8a0587ef47a079cc5d1ef271

From c0bc6d705fa3b88f8a0587ef47a079cc5d1ef271 Mon Sep 17 00:00:00 2001
From: wolfgar <stephan.rafin@laposte.net>
Date: Thu, 12 Jun 2014 02:29:30 +0200
Subject: [PATCH] Merge latest fixes for CEC driver as alluded here
 https://github.com/xbmc-imx6/xbmc/issues/54#issuecomment-41498389

---
 drivers/mxc/hdmi-cec/mxc_hdmi-cec.c | 159 ++++++++++++++++++++----------------
 1 file changed, 90 insertions(+), 69 deletions(-)

--- a/drivers/mxc/hdmi-cec/b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c	2014-07-27 18:28:30.000000000 +0200
+++ b/drivers/mxc/hdmi-cec/mxc_hdmi-cec.c	2014-07-27 18:24:52.000000000 +0200
@@ -54,6 +54,8 @@
 #define MESSAGE_TYPE_CONNECTED                4
 #define MESSAGE_TYPE_SEND_SUCCESS                5
 
+#define CEC_TX_INPROGRESS -1
+#define CEC_TX_AVAIL 0
 
 struct hdmi_cec_priv {
         int  receive_error;
@@ -62,7 +64,9 @@
         bool cec_state;
         u8 last_msg[MAX_MESSAGE_LEN];
         u8 msg_len;
-        u8 latest_cec_stat;
+	int tx_answer;
+	u16 latest_cec_stat;
+	u8 link_status;
         u32 cec_irq;
         spinlock_t irq_lock;
         struct delayed_work hdmi_cec_work;
@@ -86,13 +90,14 @@
 
 static wait_queue_head_t hdmi_cec_queue;
 static wait_queue_head_t tx_cec_queue;
-static int tx_answer;
 
 static irqreturn_t mxc_hdmi_cec_isr(int irq, void *data)
 {
         struct hdmi_cec_priv *hdmi_cec = data;
-        u8 cec_stat = 0;
+	u16 cec_stat = 0;
         unsigned long flags;
+	u8 phy_stat0;
+	irqreturn_t ret = IRQ_HANDLED;
 
         spin_lock_irqsave(&hdmi_cec->irq_lock, flags);
 
@@ -100,21 +105,30 @@
 
         cec_stat = hdmi_readb(HDMI_IH_CEC_STAT0);
         hdmi_writeb(cec_stat, HDMI_IH_CEC_STAT0);
+	phy_stat0 = hdmi_readb(HDMI_PHY_STAT0) & 0x02;
+
         if ((cec_stat & (HDMI_IH_CEC_STAT0_ERROR_INIT | \
                 HDMI_IH_CEC_STAT0_NACK | HDMI_IH_CEC_STAT0_EOM | \
                 HDMI_IH_CEC_STAT0_DONE)) == 0) {
-                spin_unlock_irqrestore(&hdmi_cec->irq_lock, flags);
-                return IRQ_HANDLED;
+		ret = IRQ_NONE;
+		cec_stat = 0;
+	}
+	if (hdmi_cec->link_status ^ phy_stat0) {
+		/* HPD value changed */
+		hdmi_cec->link_status = phy_stat0;
+		if (hdmi_cec->link_status)
+			cec_stat |= 0x80; /* Connected */
+		else
+			cec_stat |= 0x100; /* Disconnected */
         }
         pr_debug("HDMI CEC interrupt received\n");
-        /* FIXME : there is a race with latest_cec_stat */
         hdmi_cec->latest_cec_stat = cec_stat ;
 
         schedule_delayed_work(&(hdmi_cec->hdmi_cec_work), msecs_to_jiffies(20));
 
         spin_unlock_irqrestore(&hdmi_cec->irq_lock, flags);
 
-        return IRQ_HANDLED;
+	return ret;
 }
 
 void mxc_hdmi_cec_handle(u16 cec_stat)
@@ -126,21 +140,11 @@
                 return;
 
         if (cec_stat & HDMI_IH_CEC_STAT0_DONE) {
-                event = vmalloc(sizeof(struct hdmi_cec_event));
-                if (NULL == event) {
-                        pr_err("%s:Don't get memory!\n", __func__);
-                        return;
-                }
-                memset(event, 0, sizeof(struct hdmi_cec_event));
-                event->event_type = MESSAGE_TYPE_SEND_SUCCESS;
-                mutex_lock(&hdmi_cec_data.lock);
-                list_add_tail(&event->list, &head);
-                mutex_unlock(&hdmi_cec_data.lock);
-                tx_answer = cec_stat;
+		hdmi_cec_data.tx_answer = cec_stat;
                 wake_up(&tx_cec_queue);
         }
         /*EOM is detected so that the received data is ready in the receiver data buffer*/
-        else if (cec_stat & HDMI_IH_CEC_STAT0_EOM) {
+	if (cec_stat & HDMI_IH_CEC_STAT0_EOM) {
                 hdmi_writeb(0x02, HDMI_IH_CEC_STAT0);
                 event = vmalloc(sizeof(struct hdmi_cec_event));
                 if (NULL == event) {
@@ -163,13 +167,15 @@
                 wake_up(&hdmi_cec_queue);
         }
         /*An error is detected on cec line (for initiator only). */
-        else if (cec_stat & HDMI_IH_CEC_STAT0_ERROR_INIT) {
+	if (cec_stat & HDMI_IH_CEC_STAT0_ERROR_INIT) {
                 mutex_lock(&hdmi_cec_data.lock);
                 hdmi_cec_data.send_error++;
-                if (hdmi_cec_data.send_error > 5) {
-                        pr_err("%s:Re-transmission is attempted more than 5 times!\n", __func__);
+		if (hdmi_cec_data.send_error > 2) {
+			pr_err("%s:Re-transmission is attempted more than 2 times!\n", __func__);
                         hdmi_cec_data.send_error = 0;
                         mutex_unlock(&hdmi_cec_data.lock);
+			hdmi_cec_data.tx_answer = cec_stat;
+			wake_up(&tx_cec_queue);
                         return;
                 }
                 for (i = 0; i < hdmi_cec_data.msg_len; i++)
@@ -182,25 +188,17 @@
         }
         /*A frame is not acknowledged in a directly addressed message. Or a frame is negatively acknowledged in
         a broadcast message (for initiator only).*/
-        else if (cec_stat & HDMI_IH_CEC_STAT0_NACK) {
-                event = vmalloc(sizeof(struct hdmi_cec_event));
-                if (NULL == event) {
-                        pr_err("%s:Don't get memory!\n", __func__);
-                        return;
-                }
-                memset(event, 0, sizeof(struct hdmi_cec_event));
-                event->event_type = MESSAGE_TYPE_NOACK;
-                mutex_lock(&hdmi_cec_data.lock);
-                list_add_tail(&event->list, &head);
-                mutex_unlock(&hdmi_cec_data.lock);
-                tx_answer = cec_stat;
+	if (cec_stat & HDMI_IH_CEC_STAT0_NACK) {
+		hdmi_cec_data.tx_answer = cec_stat;
                 wake_up(&tx_cec_queue);
         }
         /*An error is notified by a follower. Abnormal logic data bit error (for follower).*/
-        else if (cec_stat & HDMI_IH_CEC_STAT0_ERROR_FOLL)
+	if (cec_stat & HDMI_IH_CEC_STAT0_ERROR_FOLL) {
                 hdmi_cec_data.receive_error++;
+	}
         /*HDMI cable connected*/
-        else if (cec_stat & 0x80) {
+	if (cec_stat & 0x80) {
+		pr_info("HDMI link connected\n");
                 event = vmalloc(sizeof(struct hdmi_cec_event));
                 if (NULL == event) {
                         pr_err("%s:Don't get memory!\n", __func__);
@@ -214,7 +212,8 @@
                 wake_up(&hdmi_cec_queue);
         }
         /*HDMI cable disconnected*/
-        else if (cec_stat & 0x100) {
+	if (cec_stat & 0x100) {
+		pr_info("HDMI link disconnected\n");
                 event = vmalloc(sizeof(struct hdmi_cec_event));
                 if (NULL == event) {
                         pr_err("%s:Don't get memory!\n", __func__);
@@ -273,22 +272,24 @@
         }
 
         if (list_empty(&head)) {
-                mutex_unlock(&hdmi_cec_data.lock);
                 if (file->f_flags & O_NONBLOCK) {
+			mutex_unlock(&hdmi_cec_data.lock);
                         return -EAGAIN;
                 } else {
-                        if (wait_event_interruptible(hdmi_cec_queue, (!list_empty(&head))))
-                                return -ERESTARTSYS;
+			do {
+				mutex_unlock(&hdmi_cec_data.lock);
+				if (wait_event_interruptible(hdmi_cec_queue, (!list_empty(&head))))
+					return -ERESTARTSYS;
+				mutex_lock(&hdmi_cec_data.lock);
+			} while (list_empty(&head));
                 }
-                mutex_lock(&hdmi_cec_data.lock);
         }
 
         event = list_first_entry(&head, struct hdmi_cec_event, list);
         list_del(&event->list);
         mutex_unlock(&hdmi_cec_data.lock);
-        if (copy_to_user(buf,
-                                         event,
-                                         sizeof(struct hdmi_cec_event) - sizeof(struct list_head))) {
+	if (copy_to_user(buf, event,
+			 sizeof(struct hdmi_cec_event) - sizeof(struct list_head))) {
                 vfree(event);
                 return -EFAULT;
         }
@@ -304,6 +305,7 @@
         u8 msg_len = 0, val = 0;
 
         pr_debug("function : %s\n", __func__);
+
         if (!open_count)
                 return -ENODEV;
         mutex_lock(&hdmi_cec_data.lock);
@@ -311,6 +313,11 @@
                 mutex_unlock(&hdmi_cec_data.lock);
                 return -EACCES;
         }
+	/* Ensure that there is only one writer who is the only listener of tx_cec_queue */
+	if (hdmi_cec_data.tx_answer != CEC_TX_AVAIL) {
+		mutex_unlock(&hdmi_cec_data.lock);
+		return -EBUSY;
+	}
         mutex_unlock(&hdmi_cec_data.lock);
         if (count > MAX_MESSAGE_LEN)
                 return -EINVAL;
@@ -320,7 +327,7 @@
                 return -EACCES;
         mutex_lock(&hdmi_cec_data.lock);
         hdmi_cec_data.send_error = 0;
-        tx_answer = 0;
+	hdmi_cec_data.tx_answer = CEC_TX_INPROGRESS;
         msg_len = count;
         hdmi_writeb(msg_len, HDMI_CEC_TX_CNT);
         for (i = 0; i < msg_len; i++)
@@ -332,19 +339,42 @@
         hdmi_cec_data.msg_len = msg_len;
         mutex_unlock(&hdmi_cec_data.lock);
 
-        if (wait_event_interruptible(tx_cec_queue, tx_answer != 0)) {
-                return -ERESTARTSYS;
+	ret = wait_event_interruptible_timeout(tx_cec_queue, hdmi_cec_data.tx_answer != CEC_TX_INPROGRESS, HZ);
+	if (ret < 0) {
+		ret = -ERESTARTSYS;
+		goto tx_out;
         }
-        if (tx_answer & HDMI_IH_CEC_STAT0_DONE)
+
+	if (hdmi_cec_data.tx_answer & HDMI_IH_CEC_STAT0_DONE)
                 /* msg correctly sent */
                 ret = msg_len;
         else
                 ret =  -EIO;
 
+tx_out:
+	hdmi_cec_data.tx_answer = CEC_TX_AVAIL;
         return ret;
 }
 
 
+static void hdmi_stop_device(void)
+{ 
+	u8 val;
+
+	hdmi_writeb(0x10, HDMI_CEC_CTRL);
+	val = HDMI_IH_CEC_STAT0_WAKEUP | HDMI_IH_CEC_STAT0_ERROR_FOLL | HDMI_IH_CEC_STAT0_ERROR_INIT | HDMI_IH_CEC_STAT0_ARB_LOST | \
+			HDMI_IH_CEC_STAT0_NACK | HDMI_IH_CEC_STAT0_EOM | HDMI_IH_CEC_STAT0_DONE;
+	hdmi_writeb(val, HDMI_CEC_MASK);
+	hdmi_writeb(val, HDMI_IH_MUTE_CEC_STAT0);
+	hdmi_writeb(0x0, HDMI_CEC_POLARITY);
+	val = hdmi_readb(HDMI_MC_CLKDIS);
+	val |= HDMI_MC_CLKDIS_CECCLK_DISABLE;
+	hdmi_writeb(val, HDMI_MC_CLKDIS);
+	mutex_lock(&hdmi_cec_data.lock);
+	hdmi_cec_data.cec_state = false;
+	mutex_unlock(&hdmi_cec_data.lock);
+}
+
 /*!
  * @brief IO ctrl function for vpu file operation
  * @param cmd IO ctrl command
@@ -394,28 +424,20 @@
                 val &= ~HDMI_MC_CLKDIS_CECCLK_DISABLE;
                 hdmi_writeb(val, HDMI_MC_CLKDIS);
                 hdmi_writeb(0x02, HDMI_CEC_CTRL);
+		/* Force read unlock */
+		hdmi_writeb(0x0, HDMI_CEC_LOCK);
                 val = HDMI_IH_CEC_STAT0_ERROR_INIT | HDMI_IH_CEC_STAT0_NACK | HDMI_IH_CEC_STAT0_EOM | HDMI_IH_CEC_STAT0_DONE;
                 hdmi_writeb(val, HDMI_CEC_POLARITY);
                 val = HDMI_IH_CEC_STAT0_WAKEUP | HDMI_IH_CEC_STAT0_ERROR_FOLL | HDMI_IH_CEC_STAT0_ARB_LOST;
                 hdmi_writeb(val, HDMI_CEC_MASK);
                 hdmi_writeb(val, HDMI_IH_MUTE_CEC_STAT0);
+		hdmi_cec_data.link_status = hdmi_readb(HDMI_PHY_STAT0) & 0x02;
                 mutex_lock(&hdmi_cec_data.lock);
                 hdmi_cec_data.cec_state = true;
                 mutex_unlock(&hdmi_cec_data.lock);
                 break;
         case HDMICEC_IOC_STOPDEVICE:
-                hdmi_writeb(0x10, HDMI_CEC_CTRL);
-                val = HDMI_IH_CEC_STAT0_WAKEUP | HDMI_IH_CEC_STAT0_ERROR_FOLL | HDMI_IH_CEC_STAT0_ERROR_INIT | HDMI_IH_CEC_STAT0_ARB_LOST | \
-                                HDMI_IH_CEC_STAT0_NACK | HDMI_IH_CEC_STAT0_EOM | HDMI_IH_CEC_STAT0_DONE;
-                hdmi_writeb(val, HDMI_CEC_MASK);
-                hdmi_writeb(val, HDMI_IH_MUTE_CEC_STAT0);
-                hdmi_writeb(0x0, HDMI_CEC_POLARITY);
-                val = hdmi_readb(HDMI_MC_CLKDIS);
-                val |= HDMI_MC_CLKDIS_CECCLK_DISABLE;
-                hdmi_writeb(val, HDMI_MC_CLKDIS);
-                mutex_lock(&hdmi_cec_data.lock);
-                hdmi_cec_data.cec_state = false;
-                mutex_unlock(&hdmi_cec_data.lock);
+		hdmi_stop_device();
                 break;
         case HDMICEC_IOC_GETPHYADDRESS:
                 hdmi_get_edid_cfg(&hdmi_edid_cfg);
@@ -455,18 +477,14 @@
 
         pr_debug("function : %s\n", __func__);
 
-        if (!open_count)
-                return -ENODEV;
-        if (false == hdmi_cec_data.cec_state)
-                return -EACCES;
-
         poll_wait(file, &hdmi_cec_queue, wait);
 
-        /* Always writable */
-        mask =  (POLLOUT | POLLWRNORM);
+	mutex_lock(&hdmi_cec_data.lock);
+	if (hdmi_cec_data.tx_answer == CEC_TX_AVAIL)
+		mask =  (POLLOUT | POLLWRNORM);
         if (!list_empty(&head))
                         mask |= (POLLIN | POLLRDNORM);
-
+	mutex_unlock(&hdmi_cec_data.lock);
         return mask;
 }
 
@@ -523,6 +541,7 @@
 
         mutex_init(&hdmi_cec_data.lock);
         hdmi_cec_data.Logical_address = 15;
+	hdmi_cec_data.tx_answer = CEC_TX_AVAIL;
         platform_set_drvdata(pdev, &hdmi_cec_data);
         INIT_DELAYED_WORK(&hdmi_cec_data.hdmi_cec_work, mxc_hdmi_cec_worker);
         printk(KERN_INFO "HDMI CEC initialized\n");
@@ -583,6 +602,9 @@
 static void __exit hdmi_cec_exit(void)
 {
 
+	if (hdmi_cec_data.cec_state)
+		hdmi_stop_device();
+
         if (hdmi_cec_data.cec_irq > 0)
                 free_irq(hdmi_cec_data.cec_irq, &hdmi_cec_data);
 
@@ -593,7 +615,6 @@
                 hdmi_cec_major = 0;
         }
 
-
         platform_driver_unregister(&mxc_hdmi_cec_driver);
         return;
 }
-- 
1.9.3
