From c1d1853f2676fe21620c425b31154f76328c0a62 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 11 Dec 2013 17:21:54 +0000
Subject: [PATCH 01/99] Move the reference-counting of Begin and End calls from
 DX and GL source files into GUIFontTTF.cpp.

---
 xbmc/guilib/GUIFontTTF.cpp   |  21 ++++++
 xbmc/guilib/GUIFontTTF.h     |   6 +-
 xbmc/guilib/GUIFontTTFDX.cpp |  79 ++++++++++------------
 xbmc/guilib/GUIFontTTFDX.h   |   4 +-
 xbmc/guilib/GUIFontTTFGL.cpp | 154 ++++++++++++++++++++-----------------------
 xbmc/guilib/GUIFontTTFGL.h   |   4 +-
 6 files changed, 135 insertions(+), 133 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index 008c7ae4..e507833 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -308,6 +308,27 @@ bool CGUIFontTTFBase::Load(const CStdString& strFilename, float height, float as
   return true;
 }
 
+void CGUIFontTTFBase::Begin()
+{
+  if (m_nestedBeginCount == 0 && m_texture != NULL && FirstBegin())
+  {
+    m_vertex_count = 0;
+  }
+  // Keep track of the nested begin/end calls.
+  m_nestedBeginCount++;
+}
+
+void CGUIFontTTFBase::End()
+{
+  if (m_nestedBeginCount == 0)
+    return;
+
+  if (--m_nestedBeginCount > 0)
+    return;
+
+  LastEnd();
+}
+
 void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors, const vecText &text, uint32_t alignment, float maxPixelWidth, bool scrolling)
 {
   Begin();
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index 4501dbd..df54a5d 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -77,8 +77,8 @@ class CGUIFontTTFBase
 
   bool Load(const CStdString& strFilename, float height = 20.0f, float aspect = 1.0f, float lineSpacing = 1.0f, bool border = false);
 
-  virtual void Begin() = 0;
-  virtual void End() = 0;
+  void Begin();
+  void End();
 
   const CStdString& GetFileName() const { return m_strFileName; };
 
@@ -168,6 +168,8 @@ class CGUIFontTTFBase
   CStdString m_strFileName;
 
 private:
+  virtual bool FirstBegin() = 0;
+  virtual void LastEnd() = 0;
   CGUIFontTTFBase(const CGUIFontTTFBase&);
   CGUIFontTTFBase& operator=(const CGUIFontTTFBase&);
   int m_referenceCount;
diff --git a/xbmc/guilib/GUIFontTTFDX.cpp b/xbmc/guilib/GUIFontTTFDX.cpp
index e3eba24..2f90668 100644
--- a/xbmc/guilib/GUIFontTTFDX.cpp
+++ b/xbmc/guilib/GUIFontTTFDX.cpp
@@ -51,65 +51,56 @@ CGUIFontTTFDX::~CGUIFontTTFDX(void)
   free(m_index);
 }
 
-void CGUIFontTTFDX::Begin()
+bool CGUIFontTTFDX::FirstBegin()
 {
   LPDIRECT3DDEVICE9 pD3DDevice = g_Windowing.Get3DDevice();
 
   if (pD3DDevice == NULL)
+  {
     CLog::Log(LOGERROR, __FUNCTION__" - failed to get Direct3D device");
+    return false;
+  }
 
-  if (m_nestedBeginCount == 0 && pD3DDevice != NULL && m_texture != NULL)
+  int unit = 0;
+  // just have to blit from our texture.
+  m_texture->BindToUnit(unit);
+  pD3DDevice->SetTextureStageState( unit, D3DTSS_COLOROP, D3DTOP_SELECTARG1 ); // only use diffuse
+  pD3DDevice->SetTextureStageState( unit, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
+  pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAOP, D3DTOP_MODULATE );
+  pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
+  pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
+  unit++;
+
+  if(g_Windowing.UseLimitedColor())
   {
-    int unit = 0;
-    // just have to blit from our texture.
-    m_texture->BindToUnit(unit);
-    pD3DDevice->SetTextureStageState( unit, D3DTSS_COLOROP, D3DTOP_SELECTARG1 ); // only use diffuse
-    pD3DDevice->SetTextureStageState( unit, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
-    pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAOP, D3DTOP_MODULATE );
-    pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
-    pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
+    pD3DDevice->SetTextureStageState( unit, D3DTSS_COLOROP  , D3DTOP_ADD );
+    pD3DDevice->SetTextureStageState( unit, D3DTSS_COLORARG1, D3DTA_CURRENT) ;
+    pD3DDevice->SetRenderState( D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA(16,16,16,0) );
+    pD3DDevice->SetTextureStageState( unit, D3DTSS_COLORARG2, D3DTA_TFACTOR );
     unit++;
-
-    if(g_Windowing.UseLimitedColor())
-    {
-      pD3DDevice->SetTextureStageState( unit, D3DTSS_COLOROP  , D3DTOP_ADD );
-      pD3DDevice->SetTextureStageState( unit, D3DTSS_COLORARG1, D3DTA_CURRENT) ;
-      pD3DDevice->SetRenderState( D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA(16,16,16,0) );
-      pD3DDevice->SetTextureStageState( unit, D3DTSS_COLORARG2, D3DTA_TFACTOR );
-      unit++;
-    }
-
-    // no other texture stages needed
-    pD3DDevice->SetTextureStageState( unit, D3DTSS_COLOROP, D3DTOP_DISABLE);
-    pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
-
-    pD3DDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
-    pD3DDevice->SetRenderState( D3DRS_FOGENABLE, FALSE );
-    pD3DDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID );
-    pD3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
-    pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
-    pD3DDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
-    pD3DDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
-    pD3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE);
-
-    pD3DDevice->SetFVF(D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1);
-    m_vertex_count = 0;
   }
 
-  // Keep track of the nested begin/end calls.
-  m_nestedBeginCount++;
+  // no other texture stages needed
+  pD3DDevice->SetTextureStageState( unit, D3DTSS_COLOROP, D3DTOP_DISABLE);
+  pD3DDevice->SetTextureStageState( unit, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
+
+  pD3DDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
+  pD3DDevice->SetRenderState( D3DRS_FOGENABLE, FALSE );
+  pD3DDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID );
+  pD3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
+  pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
+  pD3DDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
+  pD3DDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
+  pD3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE);
+
+  pD3DDevice->SetFVF(D3DFVF_XYZ | D3DFVF_DIFFUSE | D3DFVF_TEX1);
+  return true;
 }
 
-void CGUIFontTTFDX::End()
+void CGUIFontTTFDX::LastEnd()
 {
   LPDIRECT3DDEVICE9 pD3DDevice = g_Windowing.Get3DDevice();
 
-  if (m_nestedBeginCount == 0)
-    return;
-
-  if (--m_nestedBeginCount > 0)
-    return;
-
   if (m_vertex_count == 0)
     return;
 
diff --git a/xbmc/guilib/GUIFontTTFDX.h b/xbmc/guilib/GUIFontTTFDX.h
index 0431085..17dfefe 100644
--- a/xbmc/guilib/GUIFontTTFDX.h
+++ b/xbmc/guilib/GUIFontTTFDX.h
@@ -41,8 +41,8 @@ class CGUIFontTTFDX : public CGUIFontTTFBase
   CGUIFontTTFDX(const CStdString& strFileName);
   virtual ~CGUIFontTTFDX(void);
 
-  virtual void Begin();
-  virtual void End();
+  virtual bool FirstBegin();
+  virtual void LastEnd();
 
 protected:
   virtual CBaseTexture* ReallocTexture(unsigned int& newHeight);
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index 6a8291b..97853fd 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -53,108 +53,96 @@ CGUIFontTTFGL::~CGUIFontTTFGL(void)
 {
 }
 
-void CGUIFontTTFGL::Begin()
+bool CGUIFontTTFGL::FirstBegin()
 {
-  if (m_nestedBeginCount == 0 && m_texture != NULL)
+  if (m_textureStatus == TEXTURE_REALLOCATED)
   {
-    if (m_textureStatus == TEXTURE_REALLOCATED)
-    {
-      if (glIsTexture(m_nTexture))
-        g_TextureManager.ReleaseHwTexture(m_nTexture);
-      m_textureStatus = TEXTURE_VOID;
-    }
-    
-    if (m_textureStatus == TEXTURE_VOID)
-    {
-      // Have OpenGL generate a texture object handle for us
-      glGenTextures(1, (GLuint*) &m_nTexture);
+    if (glIsTexture(m_nTexture))
+      g_TextureManager.ReleaseHwTexture(m_nTexture);
+    m_textureStatus = TEXTURE_VOID;
+  }
 
-      // Bind the texture object
-      glBindTexture(GL_TEXTURE_2D, m_nTexture);
+  if (m_textureStatus == TEXTURE_VOID)
+  {
+    // Have OpenGL generate a texture object handle for us
+    glGenTextures(1, (GLuint*) &m_nTexture);
+
+    // Bind the texture object
+    glBindTexture(GL_TEXTURE_2D, m_nTexture);
 #ifdef HAS_GL
-      glEnable(GL_TEXTURE_2D);
+    glEnable(GL_TEXTURE_2D);
 #endif
-      // Set the texture's stretching properties
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    // Set the texture's stretching properties
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 
-      // Set the texture image -- THIS WORKS, so the pixels must be wrong.
-      glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, m_texture->GetWidth(), m_texture->GetHeight(), 0,
-                   GL_ALPHA, GL_UNSIGNED_BYTE, 0);
-      
-      VerifyGLState();
-      m_textureStatus = TEXTURE_UPDATED;
-    }
+    // Set the texture image -- THIS WORKS, so the pixels must be wrong.
+    glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, m_texture->GetWidth(), m_texture->GetHeight(), 0,
+        GL_ALPHA, GL_UNSIGNED_BYTE, 0);
 
-    if (m_textureStatus == TEXTURE_UPDATED)
-    {
-      glBindTexture(GL_TEXTURE_2D, m_nTexture);
-      glTexSubImage2D(GL_TEXTURE_2D, 0, 0, m_updateY1, m_texture->GetWidth(), m_updateY2 - m_updateY1, GL_ALPHA, GL_UNSIGNED_BYTE,
-                      m_texture->GetPixels() + m_updateY1 * m_texture->GetPitch());
-      glDisable(GL_TEXTURE_2D);
-        
-      m_updateY1 = m_updateY2 = 0;
-      m_textureStatus = TEXTURE_READY;
-    }
+    VerifyGLState();
+    m_textureStatus = TEXTURE_UPDATED;
+  }
 
-    // Turn Blending On
-    glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_ONE);
-    glEnable(GL_BLEND);
+  if (m_textureStatus == TEXTURE_UPDATED)
+  {
+    glBindTexture(GL_TEXTURE_2D, m_nTexture);
+    glTexSubImage2D(GL_TEXTURE_2D, 0, 0, m_updateY1, m_texture->GetWidth(), m_updateY2 - m_updateY1, GL_ALPHA, GL_UNSIGNED_BYTE,
+        m_texture->GetPixels() + m_updateY1 * m_texture->GetPitch());
+    glDisable(GL_TEXTURE_2D);
+
+    m_updateY1 = m_updateY2 = 0;
+    m_textureStatus = TEXTURE_READY;
+  }
+
+  // Turn Blending On
+  glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_ONE);
+  glEnable(GL_BLEND);
 #ifdef HAS_GL
-    glEnable(GL_TEXTURE_2D);
+  glEnable(GL_TEXTURE_2D);
 #endif
-    glBindTexture(GL_TEXTURE_2D, m_nTexture);
+  glBindTexture(GL_TEXTURE_2D, m_nTexture);
 
 #ifdef HAS_GL
-    glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_COMBINE);
-    glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_RGB,GL_REPLACE);
-    glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_PRIMARY_COLOR);
-    glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB, GL_SRC_COLOR);
-    glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA, GL_MODULATE);
-    glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA, GL_TEXTURE0);
-    glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA, GL_SRC_ALPHA);
-    glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA, GL_PRIMARY_COLOR);
-    glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_ALPHA, GL_SRC_ALPHA);
-    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
-    VerifyGLState();
+  glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_COMBINE);
+  glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_RGB,GL_REPLACE);
+  glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_PRIMARY_COLOR);
+  glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB, GL_SRC_COLOR);
+  glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA, GL_MODULATE);
+  glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA, GL_TEXTURE0);
+  glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA, GL_SRC_ALPHA);
+  glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA, GL_PRIMARY_COLOR);
+  glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_ALPHA, GL_SRC_ALPHA);
+  glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+  VerifyGLState();
+
+  if(g_Windowing.UseLimitedColor())
+  {
+    glActiveTexture(GL_TEXTURE1);
+    glBindTexture(GL_TEXTURE_2D, m_nTexture); // dummy bind
+    glEnable(GL_TEXTURE_2D);
 
-    if(g_Windowing.UseLimitedColor())
-    {
-      glActiveTexture(GL_TEXTURE1);
-      glBindTexture(GL_TEXTURE_2D, m_nTexture); // dummy bind
-      glEnable(GL_TEXTURE_2D);
-
-      const GLfloat rgba[4] = {16.0f / 255.0f, 16.0f / 255.0f, 16.0f / 255.0f, 0.0f};
-      glTexEnvi (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE , GL_COMBINE);
-      glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, rgba);
-      glTexEnvi (GL_TEXTURE_ENV, GL_COMBINE_RGB      , GL_ADD);
-      glTexEnvi (GL_TEXTURE_ENV, GL_SOURCE0_RGB      , GL_PREVIOUS);
-      glTexEnvi (GL_TEXTURE_ENV, GL_SOURCE1_RGB      , GL_CONSTANT);
-      glTexEnvi (GL_TEXTURE_ENV, GL_OPERAND0_RGB     , GL_SRC_COLOR);
-      glTexEnvi (GL_TEXTURE_ENV, GL_OPERAND1_RGB     , GL_SRC_COLOR);
-      glTexEnvi (GL_TEXTURE_ENV, GL_COMBINE_ALPHA    , GL_REPLACE);
-      glTexEnvi (GL_TEXTURE_ENV, GL_SOURCE0_ALPHA    , GL_PREVIOUS);
-      VerifyGLState();
-    }
+    const GLfloat rgba[4] = {16.0f / 255.0f, 16.0f / 255.0f, 16.0f / 255.0f, 0.0f};
+    glTexEnvi (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE , GL_COMBINE);
+    glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, rgba);
+    glTexEnvi (GL_TEXTURE_ENV, GL_COMBINE_RGB      , GL_ADD);
+    glTexEnvi (GL_TEXTURE_ENV, GL_SOURCE0_RGB      , GL_PREVIOUS);
+    glTexEnvi (GL_TEXTURE_ENV, GL_SOURCE1_RGB      , GL_CONSTANT);
+    glTexEnvi (GL_TEXTURE_ENV, GL_OPERAND0_RGB     , GL_SRC_COLOR);
+    glTexEnvi (GL_TEXTURE_ENV, GL_OPERAND1_RGB     , GL_SRC_COLOR);
+    glTexEnvi (GL_TEXTURE_ENV, GL_COMBINE_ALPHA    , GL_REPLACE);
+    glTexEnvi (GL_TEXTURE_ENV, GL_SOURCE0_ALPHA    , GL_PREVIOUS);
+    VerifyGLState();
+  }
 
 #else
-    g_Windowing.EnableGUIShader(SM_FONTS);
+  g_Windowing.EnableGUIShader(SM_FONTS);
 #endif
-
-    m_vertex_count = 0;
-  }
-  // Keep track of the nested begin/end calls.
-  m_nestedBeginCount++;
+  return true;
 }
 
-void CGUIFontTTFGL::End()
+void CGUIFontTTFGL::LastEnd()
 {
-  if (m_nestedBeginCount == 0)
-    return;
-
-  if (--m_nestedBeginCount > 0)
-    return;
-
 #ifdef HAS_GL
   glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT);
 
diff --git a/xbmc/guilib/GUIFontTTFGL.h b/xbmc/guilib/GUIFontTTFGL.h
index c0bb53a..735fb3a 100644
--- a/xbmc/guilib/GUIFontTTFGL.h
+++ b/xbmc/guilib/GUIFontTTFGL.h
@@ -41,8 +41,8 @@ class CGUIFontTTFGL : public CGUIFontTTFBase
   CGUIFontTTFGL(const CStdString& strFileName);
   virtual ~CGUIFontTTFGL(void);
 
-  virtual void Begin();
-  virtual void End();
+  virtual bool FirstBegin();
+  virtual void LastEnd();
 
 protected:
   virtual CBaseTexture* ReallocTexture(unsigned int& newHeight);
-- 
1.9.3


From 336187530dddcb9c84e4f004b7bca154c39ce19d Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 11 Dec 2013 18:47:54 +0000
Subject: [PATCH 02/99] Convert CGUIFontTTFBase::m_vertex to be managed as a
 std::vector.

Also retired CGUIFontTTFBase::m_vertex_count and
CGUIFontTTFBase::m_vertex_size because these can be derived from vector
member functions.
---
 xbmc/guilib/GUIFontTTF.cpp   | 29 +++++------------------------
 xbmc/guilib/GUIFontTTF.h     |  4 +---
 xbmc/guilib/GUIFontTTFDX.cpp | 12 ++++++------
 xbmc/guilib/GUIFontTTFGL.cpp | 12 ++++++------
 4 files changed, 18 insertions(+), 39 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index e507833..0a80471 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -138,8 +138,7 @@ CGUIFontTTFBase::CGUIFontTTFBase(const CStdString& strFileName)
   m_maxChars = 0;
   m_nestedBeginCount = 0;
 
-  m_vertex_size   = 4*1024;
-  m_vertex        = (SVertex*)malloc(m_vertex_size * sizeof(SVertex));
+  m_vertex.reserve(4*1024);
 
   m_face = NULL;
   m_stroker = NULL;
@@ -154,7 +153,6 @@ CGUIFontTTFBase::CGUIFontTTFBase(const CStdString& strFileName)
   m_textureScaleX = m_textureScaleY = 0.0;
   m_ellipsesWidth = m_height = 0.0f;
   m_color = 0;
-  m_vertex_count = 0;
   m_nTexture = 0;
 }
 
@@ -215,9 +213,7 @@ void CGUIFontTTFBase::Clear()
     g_freeTypeLibrary.ReleaseStroker(m_stroker);
   m_stroker = NULL;
 
-  free(m_vertex);
-  m_vertex = NULL;
-  m_vertex_count = 0;
+  m_vertex.clear();
 }
 
 bool CGUIFontTTFBase::Load(const CStdString& strFilename, float height, float aspect, float lineSpacing, bool border)
@@ -312,7 +308,7 @@ void CGUIFontTTFBase::Begin()
 {
   if (m_nestedBeginCount == 0 && m_texture != NULL && FirstBegin())
   {
-    m_vertex_count = 0;
+    m_vertex.clear();
   }
   // Keep track of the nested begin/end calls.
   m_nestedBeginCount++;
@@ -745,22 +741,9 @@ void CGUIFontTTFBase::RenderCharacter(float posX, float posY, const Character *c
   float tt = texture.y1 * m_textureScaleY;
   float tb = texture.y2 * m_textureScaleY;
 
-  // grow the vertex buffer if required
-  if(m_vertex_count >= m_vertex_size)
-  {
-    m_vertex_size *= 2;
-    void* old      = m_vertex;
-    m_vertex       = (SVertex*)realloc(m_vertex, m_vertex_size * sizeof(SVertex));
-    if (!m_vertex)
-    {
-      free(old);
-      CLog::Log(LOGSEVERE, "%s: can't allocate %" PRIdS" bytes for texture", __FUNCTION__ , m_vertex_size * sizeof(SVertex));
-      return;
-    }
-  }
-
+  m_vertex.resize(m_vertex.size() + 4);
+  SVertex* v = &m_vertex[m_vertex.size() - 4];
   m_color = color;
-  SVertex* v = m_vertex + m_vertex_count;
 
   unsigned char r = GET_R(color)
               , g = GET_G(color)
@@ -827,8 +810,6 @@ void CGUIFontTTFBase::RenderCharacter(float posX, float posY, const Character *c
   v[3].y = y[2];
   v[3].z = z[2];
 #endif
-
-  m_vertex_count+=4;
 }
 
 // Oblique code - original taken from freetype2 (ftsynth.c)
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index df54a5d..10a7060 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -156,9 +156,7 @@ class CGUIFontTTFBase
 
   unsigned int m_nTexture;
 
-  SVertex* m_vertex;
-  int      m_vertex_count;
-  int      m_vertex_size;
+  std::vector<SVertex> m_vertex;
 
   float    m_textureScaleX;
   float    m_textureScaleY;
diff --git a/xbmc/guilib/GUIFontTTFDX.cpp b/xbmc/guilib/GUIFontTTFDX.cpp
index 2f90668..6ef8984 100644
--- a/xbmc/guilib/GUIFontTTFDX.cpp
+++ b/xbmc/guilib/GUIFontTTFDX.cpp
@@ -101,17 +101,17 @@ void CGUIFontTTFDX::LastEnd()
 {
   LPDIRECT3DDEVICE9 pD3DDevice = g_Windowing.Get3DDevice();
 
-  if (m_vertex_count == 0)
+  if (m_vertex.size() == 0)
     return;
 
-  unsigned index_size = m_vertex_size * 6 / 4;
+  unsigned index_size = m_vertex.capacity() * 6 / 4;
   if(m_index_size < index_size)
   {
     uint16_t* id  = (uint16_t*)calloc(index_size, sizeof(uint16_t));
     if(id == NULL)
       return;
 
-    for(int i = 0, b = 0; i < m_vertex_size; i += 4, b += 6)
+    for(int i = 0, b = 0; i < m_vertex.capacity(); i += 4, b += 6)
     {
       id[b+0] = i + 0;
       id[b+1] = i + 1;
@@ -140,11 +140,11 @@ void CGUIFontTTFDX::LastEnd()
 
   pD3DDevice->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST
                                     , 0
-                                    , m_vertex_count
-                                    , m_vertex_count / 2
+                                    , m_vertex.size()
+                                    , m_vertex.size() / 2
                                     , m_index
                                     , D3DFMT_INDEX16
-                                    , m_vertex
+                                    , &m_vertex[0]
                                     , sizeof(SVertex));
   pD3DDevice->SetTransform(D3DTS_WORLD, &orig);
 
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index 97853fd..b76c6a5 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -146,13 +146,13 @@ void CGUIFontTTFGL::LastEnd()
 #ifdef HAS_GL
   glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT);
 
-  glColorPointer   (4, GL_UNSIGNED_BYTE, sizeof(SVertex), (char*)m_vertex + offsetof(SVertex, r));
-  glVertexPointer  (3, GL_FLOAT        , sizeof(SVertex), (char*)m_vertex + offsetof(SVertex, x));
-  glTexCoordPointer(2, GL_FLOAT        , sizeof(SVertex), (char*)m_vertex + offsetof(SVertex, u));
+  glColorPointer   (4, GL_UNSIGNED_BYTE, sizeof(SVertex), (char*)&m_vertex[0] + offsetof(SVertex, r));
+  glVertexPointer  (3, GL_FLOAT        , sizeof(SVertex), (char*)&m_vertex[0] + offsetof(SVertex, x));
+  glTexCoordPointer(2, GL_FLOAT        , sizeof(SVertex), (char*)&m_vertex[0] + offsetof(SVertex, u));
   glEnableClientState(GL_COLOR_ARRAY);
   glEnableClientState(GL_VERTEX_ARRAY);
   glEnableClientState(GL_TEXTURE_COORD_ARRAY);
-  glDrawArrays(GL_QUADS, 0, m_vertex_count);
+  glDrawArrays(GL_QUADS, 0, m_vertex.size());
   glPopClientAttrib();
 
   glActiveTexture(GL_TEXTURE1);
@@ -168,10 +168,10 @@ void CGUIFontTTFGL::LastEnd()
   GLint tex0Loc = g_Windowing.GUIShaderGetCoord0();
 
   // stack object until VBOs will be used
-  std::vector<SVertex> vecVertices( 6 * (m_vertex_count / 4) );
+  std::vector<SVertex> vecVertices( 6 * (m_vertex.size() / 4) );
   SVertex *vertices = &vecVertices[0];
 
-  for (int i=0; i<m_vertex_count; i+=4)
+  for (size_t i=0; i<m_vertex.size(); i+=4)
   {
     *vertices++ = m_vertex[i];
     *vertices++ = m_vertex[i+1];
-- 
1.9.3


From 55ce8a11c8aa11ad253dbf8e5583a8af377a2131 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Mon, 16 Dec 2013 18:58:12 +0000
Subject: [PATCH 03/99] CGUIFontTTFBase::RenderCharacter can now append to
 arbitrary vectors of vertices rather than only CGUIFontTTFBase::m_vertex

---
 xbmc/guilib/GUIFontTTF.cpp | 12 +++++++-----
 xbmc/guilib/GUIFontTTF.h   |  2 +-
 2 files changed, 8 insertions(+), 6 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index 0a80471..848c5c8 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -329,6 +329,8 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
 {
   Begin();
 
+  std::vector<SVertex> &vertices = m_vertex;
+
   // save the origin, which is scaled separately
   m_originX = x;
   m_originY = y;
@@ -409,7 +411,7 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
 
         for (int i = 0; i < 3; i++)
         {
-          RenderCharacter(startX + cursorX, startY, period, color, !scrolling);
+          RenderCharacter(startX + cursorX, startY, period, color, !scrolling, vertices);
           cursorX += period->advance;
         }
         break;
@@ -418,7 +420,7 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
     else if (maxPixelWidth > 0 && cursorX > maxPixelWidth)
       break;  // exceeded max allowed width - stop rendering
 
-    RenderCharacter(startX + cursorX, startY, ch, color, !scrolling);
+    RenderCharacter(startX + cursorX, startY, ch, color, !scrolling, vertices);
     if ( alignment & XBFONT_JUSTIFIED )
     {
       if ((*pos & 0xffff) == L' ')
@@ -675,7 +677,7 @@ bool CGUIFontTTFBase::CacheCharacter(wchar_t letter, uint32_t style, Character *
   return true;
 }
 
-void CGUIFontTTFBase::RenderCharacter(float posX, float posY, const Character *ch, color_t color, bool roundX)
+void CGUIFontTTFBase::RenderCharacter(float posX, float posY, const Character *ch, color_t color, bool roundX, std::vector<SVertex> &vertices)
 {
   // actual image width isn't same as the character width as that is
   // just baseline width and height should include the descent
@@ -741,8 +743,8 @@ void CGUIFontTTFBase::RenderCharacter(float posX, float posY, const Character *c
   float tt = texture.y1 * m_textureScaleY;
   float tb = texture.y2 * m_textureScaleY;
 
-  m_vertex.resize(m_vertex.size() + 4);
-  SVertex* v = &m_vertex[m_vertex.size() - 4];
+  vertices.resize(vertices.size() + 4);
+  SVertex* v = &vertices[vertices.size() - 4];
   m_color = color;
 
   unsigned char r = GET_R(color)
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index 10a7060..dde0350 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -109,7 +109,7 @@ class CGUIFontTTFBase
   // Stuff for pre-rendering for speed
   inline Character *GetCharacter(character_t letter);
   bool CacheCharacter(wchar_t letter, uint32_t style, Character *ch);
-  void RenderCharacter(float posX, float posY, const Character *ch, color_t color, bool roundX);
+  void RenderCharacter(float posX, float posY, const Character *ch, color_t color, bool roundX, std::vector<SVertex> &vertices);
   void ClearCharacterCache();
 
   virtual CBaseTexture* ReallocTexture(unsigned int& newHeight) = 0;
-- 
1.9.3


From ba19fcf5df448324fc403267638b65207a04bce4 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 15 Jan 2014 17:18:38 +0000
Subject: [PATCH 04/99] Add a cache of font glyph bounding box vertices.

This is implemented as a template because ultimately we will key on different
parameters and store values of different types, depending upon whether we
have a GLES or non-GLES backend, and for GLES, whether or not the currently
applicable transformation matrices permit the use of hardware clipping.
---
 XBMC.xcodeproj/project.pbxproj             |  10 ++
 project/VS2010Express/XBMC.vcxproj         |   2 +
 project/VS2010Express/XBMC.vcxproj.filters |   8 +-
 xbmc/guilib/GUIFontCache.cpp               | 105 ++++++++++++++
 xbmc/guilib/GUIFontCache.h                 | 217 +++++++++++++++++++++++++++++
 xbmc/guilib/GUIFontTTF.cpp                 | 181 +++++++++++++-----------
 xbmc/guilib/GUIFontTTF.h                   |   5 +
 xbmc/guilib/GUIFontTTFGL.cpp               |   1 +
 xbmc/guilib/GraphicContext.h               |   1 +
 xbmc/guilib/Makefile.in                    |   1 +
 xbmc/guilib/TransformMatrix.h              |  11 ++
 11 files changed, 457 insertions(+), 85 deletions(-)
 create mode 100644 xbmc/guilib/GUIFontCache.cpp
 create mode 100644 xbmc/guilib/GUIFontCache.h

diff --git a/XBMC.xcodeproj/project.pbxproj b/XBMC.xcodeproj/project.pbxproj
index 137a8cd..15aa46d 100644
--- a/XBMC.xcodeproj/project.pbxproj
+++ b/XBMC.xcodeproj/project.pbxproj
@@ -168,6 +168,9 @@
 		1D638128161E211E003603ED /* PeripheralImon.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 1D638126161E211E003603ED /* PeripheralImon.cpp */; };
 		1DAFDB7C16DFDCA7007F8C68 /* PeripheralBusCEC.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 1DAFDB7A16DFDCA7007F8C68 /* PeripheralBusCEC.cpp */; };
 		1DE0443515828F4B005DDB4D /* Exception.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 1DE0443315828F4B005DDB4D /* Exception.cpp */; };
+		2F4564D51970129A00396109 /* GUIFontCache.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2F4564D31970129A00396109 /* GUIFontCache.cpp */; };
+		2F4564D61970129A00396109 /* GUIFontCache.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2F4564D31970129A00396109 /* GUIFontCache.cpp */; };
+		2F4564D71970129A00396109 /* GUIFontCache.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 2F4564D31970129A00396109 /* GUIFontCache.cpp */; };
 		32C631281423A90F00F18420 /* JpegIO.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 32C631261423A90F00F18420 /* JpegIO.cpp */; };
 		36A9443D15821E2800727135 /* DatabaseUtils.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 36A9443B15821E2800727135 /* DatabaseUtils.cpp */; };
 		36A9444115821E7C00727135 /* SortUtils.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 36A9443F15821E7C00727135 /* SortUtils.cpp */; };
@@ -4008,6 +4011,8 @@
 		1DAFDB7B16DFDCA7007F8C68 /* PeripheralBusCEC.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PeripheralBusCEC.h; sourceTree = "<group>"; };
 		1DE0443315828F4B005DDB4D /* Exception.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Exception.cpp; path = commons/Exception.cpp; sourceTree = "<group>"; };
 		1DE0443415828F4B005DDB4D /* Exception.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Exception.h; path = commons/Exception.h; sourceTree = "<group>"; };
+		2F4564D31970129A00396109 /* GUIFontCache.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GUIFontCache.cpp; sourceTree = "<group>"; };
+		2F4564D41970129A00396109 /* GUIFontCache.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GUIFontCache.h; sourceTree = "<group>"; };
 		32C631261423A90F00F18420 /* JpegIO.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = JpegIO.cpp; sourceTree = "<group>"; };
 		32C631271423A90F00F18420 /* JpegIO.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JpegIO.h; sourceTree = "<group>"; };
 		36A9443B15821E2800727135 /* DatabaseUtils.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DatabaseUtils.cpp; sourceTree = "<group>"; };
@@ -6512,6 +6517,8 @@
 				18B7C7101294222D009E7A26 /* GUIFixedListContainer.h */,
 				18B7C76B1294222E009E7A26 /* GUIFont.cpp */,
 				18B7C7111294222D009E7A26 /* GUIFont.h */,
+				2F4564D31970129A00396109 /* GUIFontCache.cpp */,
+				2F4564D41970129A00396109 /* GUIFontCache.h */,
 				18B7C76C1294222E009E7A26 /* GUIFontManager.cpp */,
 				18B7C7121294222D009E7A26 /* GUIFontManager.h */,
 				18B7C76D1294222E009E7A26 /* GUIFontTTF.cpp */,
@@ -10989,6 +10996,7 @@
 				7C5608C70F1754930056433A /* ExternalPlayer.cpp in Sources */,
 				F584E12E0F257C5100DB26A5 /* HTTPDirectory.cpp in Sources */,
 				F54C51D20F1E783200D46E3C /* GUIDialogKaraokeSongSelector.cpp in Sources */,
+				2F4564D51970129A00396109 /* GUIFontCache.cpp in Sources */,
 				F54C51D50F1E784800D46E3C /* karaokelyricscdg.cpp in Sources */,
 				F54C51D80F1E785700D46E3C /* karaokelyrics.cpp in Sources */,
 				F54C51E50F1E787700D46E3C /* karaokelyricstextkar.cpp in Sources */,
@@ -12657,6 +12665,7 @@
 				DFF0F45B17528350002DA3A4 /* Control.cpp in Sources */,
 				DFF0F45C17528350002DA3A4 /* Dialog.cpp in Sources */,
 				DFF0F45D17528350002DA3A4 /* File.cpp in Sources */,
+				2F4564D71970129A00396109 /* GUIFontCache.cpp in Sources */,
 				DFF0F45E17528350002DA3A4 /* InfoTagMusic.cpp in Sources */,
 				DFF0F45F17528350002DA3A4 /* InfoTagVideo.cpp in Sources */,
 				DFF0F46017528350002DA3A4 /* Keyboard.cpp in Sources */,
@@ -13456,6 +13465,7 @@
 				E499131D174E5DAD00741B6D /* GUIVisualisationControl.cpp in Sources */,
 				E499131E174E5DAD00741B6D /* GUIWindow.cpp in Sources */,
 				E499131F174E5DAD00741B6D /* GUIWindowManager.cpp in Sources */,
+				2F4564D61970129A00396109 /* GUIFontCache.cpp in Sources */,
 				E4991320174E5DAD00741B6D /* GUIWrappingListContainer.cpp in Sources */,
 				E4991321174E5DAD00741B6D /* imagefactory.cpp in Sources */,
 				E4991322174E5DAD00741B6D /* IWindowManagerCallback.cpp in Sources */,
diff --git a/project/VS2010Express/XBMC.vcxproj b/project/VS2010Express/XBMC.vcxproj
index 9ee2694..7208542 100644
--- a/project/VS2010Express/XBMC.vcxproj
+++ b/project/VS2010Express/XBMC.vcxproj
@@ -426,6 +426,7 @@
     <ClCompile Include="..\..\xbmc\guilib\GUIFadeLabelControl.cpp" />
     <ClCompile Include="..\..\xbmc\guilib\GUIFixedListContainer.cpp" />
     <ClCompile Include="..\..\xbmc\guilib\GUIFont.cpp" />
+    <ClCompile Include="..\..\xbmc\guilib\GUIFontCache.cpp" />
     <ClCompile Include="..\..\xbmc\guilib\GUIFontManager.cpp" />
     <ClCompile Include="..\..\xbmc\guilib\GUIFontTTF.cpp" />
     <ClCompile Include="..\..\xbmc\guilib\GUIFontTTFDX.cpp" />
@@ -1741,6 +1742,7 @@
     <ClInclude Include="..\..\xbmc\guilib\GUIFadeLabelControl.h" />
     <ClInclude Include="..\..\xbmc\guilib\GUIFixedListContainer.h" />
     <ClInclude Include="..\..\xbmc\guilib\GUIFont.h" />
+    <ClInclude Include="..\..\xbmc\guilib\GUIFontCache.h" />
     <ClInclude Include="..\..\xbmc\guilib\GUIFontManager.h" />
     <ClInclude Include="..\..\xbmc\guilib\GUIFontTTF.h" />
     <ClInclude Include="..\..\xbmc\guilib\GUIFontTTFDX.h" />
diff --git a/project/VS2010Express/XBMC.vcxproj.filters b/project/VS2010Express/XBMC.vcxproj.filters
index fa284e6..f78e4fa 100644
--- a/project/VS2010Express/XBMC.vcxproj.filters
+++ b/project/VS2010Express/XBMC.vcxproj.filters
@@ -994,6 +994,9 @@
     <ClCompile Include="..\..\xbmc\guilib\GUIFont.cpp">
       <Filter>guilib</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\xbmc\guilib\GUIFontCache.cpp">
+      <Filter>guilib</Filter>
+    </ClCompile>
     <ClCompile Include="..\..\xbmc\guilib\GUIFontManager.cpp">
       <Filter>guilib</Filter>
     </ClCompile>
@@ -3882,6 +3885,9 @@
     <ClInclude Include="..\..\xbmc\guilib\GUIFont.h">
       <Filter>guilib</Filter>
     </ClInclude>
+    <ClInclude Include="..\..\xbmc\guilib\GUIFontCache.h">
+      <Filter>guilib</Filter>
+    </ClInclude>
     <ClInclude Include="..\..\xbmc\guilib\GUIFontManager.h">
       <Filter>guilib</Filter>
     </ClInclude>
@@ -6034,4 +6040,4 @@
       <Filter>interfaces\swig</Filter>
     </None>
   </ItemGroup>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/xbmc/guilib/GUIFontCache.cpp b/xbmc/guilib/GUIFontCache.cpp
new file mode 100644
index 0000000..2c72f9c
--- /dev/null
+++ b/xbmc/guilib/GUIFontCache.cpp
@@ -0,0 +1,105 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <stdint.h>
+#include <vector>
+#include "utils/StdString.h" // required by GUIFontTTF.h
+#include "GUIFontTTF.h"
+#include "GraphicContext.h"
+
+template<class Position, class Value>
+void CGUIFontCacheEntry<Position, Value>::Reassign::operator()(CGUIFontCacheEntry<Position, Value> &entry)
+{
+  entry.m_key.m_pos = m_key.m_pos;
+  entry.m_key.m_colors.assign(m_key.m_colors.begin(), m_key.m_colors.end());
+  entry.m_key.m_text.assign(m_key.m_text.begin(), m_key.m_text.end());
+  entry.m_key.m_alignment = m_key.m_alignment;
+  entry.m_key.m_maxPixelWidth = m_key.m_maxPixelWidth;
+  entry.m_key.m_scrolling = m_key.m_scrolling;
+  entry.m_matrix = m_key.m_matrix;
+  entry.m_key.m_scaleX = m_key.m_scaleX;
+  entry.m_key.m_scaleY = m_key.m_scaleY;
+
+  entry.m_lastUsedMillis = m_nowMillis;
+  entry.m_value.clear();
+}
+
+template<class Position, class Value>
+CGUIFontCacheEntry<Position, Value>::~CGUIFontCacheEntry()
+{
+  delete &m_key.m_colors;
+  delete &m_key.m_text;
+  m_value.clear();
+}
+
+template<class Position, class Value>
+Value &CGUIFontCache<Position, Value>::Lookup(Position &pos,
+                                              const vecColors &colors, const vecText &text,
+                                              uint32_t alignment, float maxPixelWidth,
+                                              bool scrolling,
+                                              unsigned int nowMillis, bool &dirtyCache)
+{
+  const CGUIFontCacheKey<Position> key(pos,
+                                       const_cast<vecColors &>(colors), const_cast<vecText &>(text),
+                                       alignment, maxPixelWidth,
+                                       scrolling, g_graphicsContext.GetGUIMatrix(),
+                                       g_graphicsContext.GetGUIScaleX(), g_graphicsContext.GetGUIScaleY());
+  EntryHashIterator i = m_list.template get<Hash>().find(key);
+  if (i == m_list.template get<Hash>().end())
+  {
+    /* Cache miss */
+    EntryAgeIterator oldest = m_list.template get<Age>().begin();
+    if (!m_list.template get<Age>().empty() && nowMillis - oldest->m_lastUsedMillis > FONT_CACHE_TIME_LIMIT)
+    {
+      /* The oldest existing entry is old enough to expire and reuse */
+      m_list.template get<Hash>().modify(m_list.template project<Hash>(oldest), typename CGUIFontCacheEntry<Position, Value>::Reassign(key, nowMillis));
+      m_list.template get<Age>().relocate(m_list.template get<Age>().end(), oldest);
+    }
+    else
+    {
+      /* We need a new entry instead */
+      /* Yes, this causes the creation an destruction of a temporary entry, but
+       * this code ought to only be used infrequently, when the cache needs to grow */
+      m_list.template get<Age>().push_back(CGUIFontCacheEntry<Position, Value>(*this, key, nowMillis));
+    }
+    dirtyCache = true;
+    return (--m_list.template get<Age>().end())->m_value;
+  }
+  else
+  {
+    /* Cache hit */
+    /* Update time in entry and move to the back of the list */
+    i->m_lastUsedMillis = nowMillis;
+    m_list.template get<Age>().relocate(m_list.template get<Age>().end(), m_list.template project<Age>(i));
+    dirtyCache = false;
+    return i->m_value;
+  }
+}
+
+template<class Position, class Value>
+void CGUIFontCache<Position, Value>::Flush()
+{
+  m_list.template get<Age>().clear();
+}
+
+template void CGUIFontCacheEntry<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::Reassign::operator()(CGUIFontCacheEntry<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue> &entry);
+template CGUIFontCacheEntry<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::~CGUIFontCacheEntry();
+template CGUIFontCacheStaticValue &CGUIFontCache<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::Lookup(CGUIFontCacheStaticPosition &, const vecColors &, const vecText &, uint32_t, float, bool, unsigned int, bool &);
+template void CGUIFontCache<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::Flush();
diff --git a/xbmc/guilib/GUIFontCache.h b/xbmc/guilib/GUIFontCache.h
new file mode 100644
index 0000000..ef65845
--- /dev/null
+++ b/xbmc/guilib/GUIFontCache.h
@@ -0,0 +1,217 @@
+/*!
+\file GUIFontCache.h
+\brief
+*/
+
+#ifndef CGUILIB_GUIFONTCACHE_H
+#define CGUILIB_GUIFONTCACHE_H
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <cstddef>
+#include <cstring>
+#include <stdint.h>
+
+#include <algorithm>
+#include <vector>
+
+#include "boost/multi_index_container.hpp"
+#include "boost/multi_index/sequenced_index.hpp"
+#include "boost/multi_index/hashed_index.hpp"
+#include "boost/multi_index/member.hpp"
+
+#include "TransformMatrix.h"
+
+using namespace boost::multi_index;
+
+#define FONT_CACHE_TIME_LIMIT (1000)
+
+template<class Position, class Value> class CGUIFontCache;
+class CGUIFontTTFBase;
+
+template<class Position>
+struct CGUIFontCacheKey
+{
+  Position m_pos;
+  vecColors &m_colors;
+  vecText &m_text;
+  uint32_t m_alignment;
+  float m_maxPixelWidth;
+  bool m_scrolling;
+  const TransformMatrix &m_matrix;
+  float m_scaleX;
+  float m_scaleY;
+
+  CGUIFontCacheKey(Position pos,
+                   vecColors &colors, vecText &text,
+                   uint32_t alignment, float maxPixelWidth,
+                   bool scrolling, const TransformMatrix &matrix,
+                   float scaleX, float scaleY) :
+    m_pos(pos),
+    m_colors(colors), m_text(text),
+    m_alignment(alignment), m_maxPixelWidth(maxPixelWidth),
+    m_scrolling(scrolling), m_matrix(matrix),
+    m_scaleX(scaleX), m_scaleY(scaleY)
+  {}
+};
+
+template<class Position, class Value>
+struct CGUIFontCacheEntry
+{
+  const CGUIFontCache<Position, Value> &m_cache;
+  CGUIFontCacheKey<Position> m_key;
+  TransformMatrix m_matrix;
+
+  /* These need to be declared as mutable to get round the fact that only
+   * const iterators are available. These fields do not affect comparison or
+   * hash functors, so from the container's point of view, they are mutable. */
+  mutable unsigned int m_lastUsedMillis;
+  mutable Value m_value;
+
+  CGUIFontCacheEntry(const CGUIFontCache<Position, Value> &cache, const CGUIFontCacheKey<Position> &key, unsigned int nowMillis) :
+    m_cache(cache),
+    m_key(key.m_pos,
+          *new vecColors, *new vecText,
+          key.m_alignment, key.m_maxPixelWidth,
+          key.m_scrolling, m_matrix,
+          key.m_scaleX, key.m_scaleY),
+    m_lastUsedMillis(nowMillis)
+  {
+    m_key.m_colors.assign(key.m_colors.begin(), key.m_colors.end());
+    m_key.m_text.assign(key.m_text.begin(), key.m_text.end());
+    m_matrix = key.m_matrix;
+  }
+
+  CGUIFontCacheEntry(const CGUIFontCacheEntry &other) :
+    m_cache(other.m_cache),
+    m_key(other.m_key.m_pos,
+          *new vecColors, *new vecText,
+          other.m_key.m_alignment, other.m_key.m_maxPixelWidth,
+          other.m_key.m_scrolling, m_matrix,
+          other.m_key.m_scaleX, other.m_key.m_scaleY),
+    m_lastUsedMillis(other.m_lastUsedMillis),
+    m_value(other.m_value)
+  {
+    m_key.m_colors.assign(other.m_key.m_colors.begin(), other.m_key.m_colors.end());
+    m_key.m_text.assign(other.m_key.m_text.begin(), other.m_key.m_text.end());
+    m_matrix = other.m_key.m_matrix;
+  }
+
+  struct Reassign
+  {
+    Reassign(const CGUIFontCacheKey<Position> &key, unsigned int nowMillis) : m_key(key), m_nowMillis(nowMillis) {}
+    void operator()(CGUIFontCacheEntry &entry);
+  private:
+    const CGUIFontCacheKey<Position> &m_key;
+    unsigned int m_nowMillis;
+  };
+
+  ~CGUIFontCacheEntry();
+};
+
+template<class Position>
+struct CGUIFontCacheHash
+{
+  size_t operator()(const CGUIFontCacheKey<Position> &key) const
+  {
+    /* Not much effort has gone into choosing this hash function */
+    size_t hash = 0, i;
+    for (i = 0; i < 3 && i < key.m_text.size(); ++i)
+      hash += key.m_text[i];
+    if (key.m_colors.size())
+      hash += key.m_colors[0];
+    hash += MatrixHashContribution(key);
+    return hash;
+  }
+};
+
+template<class Position>
+struct CGUIFontCacheKeysMatch
+{
+  bool operator()(const CGUIFontCacheKey<Position> &a, const CGUIFontCacheKey<Position> &b) const
+  {
+    return a.m_text == b.m_text &&
+           a.m_colors == b.m_colors &&
+           a.m_alignment == b.m_alignment &&
+           a.m_scrolling == b.m_scrolling &&
+           a.m_maxPixelWidth == b.m_maxPixelWidth &&
+           Match(a.m_pos, a.m_matrix, b.m_pos, b.m_matrix, a.m_scrolling) &&
+           a.m_scaleX == b.m_scaleX &&
+           a.m_scaleY == b.m_scaleY;
+  }
+};
+
+template<class Position, class Value>
+class CGUIFontCache
+{
+  /* Empty structs used as tags to identify indexes */
+  struct Age {};
+  struct Hash {};
+
+  typedef multi_index_container<
+      CGUIFontCacheEntry<Position, Value>,
+      indexed_by<
+          sequenced<tag<Age> >,
+          hashed_unique<tag<Hash>, member<CGUIFontCacheEntry<Position, Value>, CGUIFontCacheKey<Position>, &CGUIFontCacheEntry<Position, Value>::m_key>, CGUIFontCacheHash<Position>, CGUIFontCacheKeysMatch<Position> >
+      >
+  > EntryList;
+
+  typedef typename EntryList::template index<Age>::type::iterator EntryAgeIterator;
+  typedef typename EntryList::template index<Hash>::type::iterator EntryHashIterator;
+
+  EntryList m_list;
+
+public:
+  const CGUIFontTTFBase &m_font;
+
+  CGUIFontCache(CGUIFontTTFBase &font) : m_font(font) {}
+  Value &Lookup(Position &pos,
+                const vecColors &colors, const vecText &text,
+                uint32_t alignment, float maxPixelWidth,
+                bool scrolling,
+                unsigned int nowMillis, bool &dirtyCache);
+  void Flush();
+};
+
+struct CGUIFontCacheStaticPosition
+{
+  float m_x;
+  float m_y;
+  CGUIFontCacheStaticPosition(float x, float y) : m_x(x), m_y(y) {}
+};
+
+typedef std::vector<SVertex> CGUIFontCacheStaticValue;
+
+inline bool Match(const CGUIFontCacheStaticPosition &a, const TransformMatrix &a_m,
+                  const CGUIFontCacheStaticPosition &b, const TransformMatrix &b_m,
+                  bool scrolling)
+{
+  return a.m_x == b.m_x && a.m_y == b.m_y && a_m == b_m;
+}
+
+inline float MatrixHashContribution(const CGUIFontCacheKey<CGUIFontCacheStaticPosition> &a)
+{
+  /* Ensure horizontally translated versions end up in different buckets */
+  return a.m_matrix.m[0][3];
+}
+
+#endif
diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index 848c5c8..0290fc4 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -27,6 +27,7 @@
 #include "utils/MathUtils.h"
 #include "utils/log.h"
 #include "windowing/WindowingFactory.h"
+#include "threads/SystemClock.h"
 
 #include <math.h>
 
@@ -131,7 +132,7 @@ class CFreeTypeLibrary
 XBMC_GLOBAL_REF(CFreeTypeLibrary, g_freeTypeLibrary); // our freetype library
 #define g_freeTypeLibrary XBMC_GLOBAL_USE(CFreeTypeLibrary)
 
-CGUIFontTTFBase::CGUIFontTTFBase(const CStdString& strFileName)
+CGUIFontTTFBase::CGUIFontTTFBase(const CStdString& strFileName) : m_staticCache(*this)
 {
   m_texture = NULL;
   m_char = NULL;
@@ -329,108 +330,120 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
 {
   Begin();
 
-  std::vector<SVertex> &vertices = m_vertex;
-
-  // save the origin, which is scaled separately
-  m_originX = x;
-  m_originY = y;
-
-  // Check if we will really need to truncate or justify the text
-  if ( alignment & XBFONT_TRUNCATED )
+  bool dirtyCache;
+  CGUIFontCacheStaticPosition staticPos(x, y);
+  std::vector<SVertex> &vertices = m_staticCache.Lookup(staticPos,
+                                                        colors, text,
+                                                        alignment, maxPixelWidth,
+                                                        scrolling,
+                                                        XbmcThreads::SystemClockMillis(),
+                                                        dirtyCache);
+  if (dirtyCache)
   {
-    if ( maxPixelWidth <= 0.0f || GetTextWidthInternal(text.begin(), text.end()) <= maxPixelWidth)
-      alignment &= ~XBFONT_TRUNCATED;
-  }
-  else if ( alignment & XBFONT_JUSTIFIED )
-  {
-    if ( maxPixelWidth <= 0.0f )
-      alignment &= ~XBFONT_JUSTIFIED;
-  }
+    // save the origin, which is scaled separately
+    m_originX = x;
+    m_originY = y;
 
-  // calculate sizing information
-  float startX = 0;
-  float startY = (alignment & XBFONT_CENTER_Y) ? -0.5f*m_cellHeight : 0;  // vertical centering
+    // Check if we will really need to truncate or justify the text
+    if ( alignment & XBFONT_TRUNCATED )
+    {
+      if ( maxPixelWidth <= 0.0f || GetTextWidthInternal(text.begin(), text.end()) <= maxPixelWidth)
+        alignment &= ~XBFONT_TRUNCATED;
+    }
+    else if ( alignment & XBFONT_JUSTIFIED )
+    {
+      if ( maxPixelWidth <= 0.0f )
+        alignment &= ~XBFONT_JUSTIFIED;
+    }
 
-  if ( alignment & (XBFONT_RIGHT | XBFONT_CENTER_X) )
-  {
-    // Get the extent of this line
-    float w = GetTextWidthInternal( text.begin(), text.end() );
+    // calculate sizing information
+    float startX = 0;
+    float startY = (alignment & XBFONT_CENTER_Y) ? -0.5f*m_cellHeight : 0;  // vertical centering
 
-    if ( alignment & XBFONT_TRUNCATED && w > maxPixelWidth + 0.5f ) // + 0.5f due to rounding issues
-      w = maxPixelWidth;
+    if ( alignment & (XBFONT_RIGHT | XBFONT_CENTER_X) )
+    {
+      // Get the extent of this line
+      float w = GetTextWidthInternal( text.begin(), text.end() );
 
-    if ( alignment & XBFONT_CENTER_X)
-      w *= 0.5f;
-    // Offset this line's starting position
-    startX -= w;
-  }
+      if ( alignment & XBFONT_TRUNCATED && w > maxPixelWidth + 0.5f ) // + 0.5f due to rounding issues
+        w = maxPixelWidth;
 
-  float spacePerLetter = 0; // for justification effects
-  if ( alignment & XBFONT_JUSTIFIED )
-  {
-    // first compute the size of the text to render in both characters and pixels
-    unsigned int lineChars = 0;
-    float linePixels = 0;
-    for (vecText::const_iterator pos = text.begin(); pos != text.end(); ++pos)
+      if ( alignment & XBFONT_CENTER_X)
+        w *= 0.5f;
+      // Offset this line's starting position
+      startX -= w;
+    }
+
+    float spacePerLetter = 0; // for justification effects
+    if ( alignment & XBFONT_JUSTIFIED )
     {
-      Character *ch = GetCharacter(*pos);
-      if (ch)
-      { // spaces have multiple times the justification spacing of normal letters
-        lineChars += ((*pos & 0xffff) == L' ') ? justification_word_weight : 1;
-        linePixels += ch->advance;
+      // first compute the size of the text to render in both characters and pixels
+      unsigned int lineChars = 0;
+      float linePixels = 0;
+      for (vecText::const_iterator pos = text.begin(); pos != text.end(); ++pos)
+      {
+        Character *ch = GetCharacter(*pos);
+        if (ch)
+        { // spaces have multiple times the justification spacing of normal letters
+          lineChars += ((*pos & 0xffff) == L' ') ? justification_word_weight : 1;
+          linePixels += ch->advance;
+        }
       }
+      if (lineChars > 1)
+        spacePerLetter = (maxPixelWidth - linePixels) / (lineChars - 1);
     }
-    if (lineChars > 1)
-      spacePerLetter = (maxPixelWidth - linePixels) / (lineChars - 1);
-  }
-  float cursorX = 0; // current position along the line
-
-  for (vecText::const_iterator pos = text.begin(); pos != text.end(); ++pos)
-  {
-    // If starting text on a new line, determine justification effects
-    // Get the current letter in the CStdString
-    color_t color = (*pos & 0xff0000) >> 16;
-    if (color >= colors.size())
-      color = 0;
-    color = colors[color];
+    float cursorX = 0; // current position along the line
 
-    // grab the next character
-    Character *ch = GetCharacter(*pos);
-    if (!ch) continue;
-
-    if ( alignment & XBFONT_TRUNCATED )
+    for (vecText::const_iterator pos = text.begin(); pos != text.end(); ++pos)
     {
-      // Check if we will be exceeded the max allowed width
-      if ( cursorX + ch->advance + 3 * m_ellipsesWidth > maxPixelWidth )
-      {
-        // Yup. Let's draw the ellipses, then bail
-        // Perhaps we should really bail to the next line in this case??
-        Character *period = GetCharacter(L'.');
-        if (!period)
-          break;
+      // If starting text on a new line, determine justification effects
+      // Get the current letter in the CStdString
+      color_t color = (*pos & 0xff0000) >> 16;
+      if (color >= colors.size())
+        color = 0;
+      color = colors[color];
+
+      // grab the next character
+      Character *ch = GetCharacter(*pos);
+      if (!ch) continue;
 
-        for (int i = 0; i < 3; i++)
+      if ( alignment & XBFONT_TRUNCATED )
+      {
+        // Check if we will be exceeded the max allowed width
+        if ( cursorX + ch->advance + 3 * m_ellipsesWidth > maxPixelWidth )
         {
-          RenderCharacter(startX + cursorX, startY, period, color, !scrolling, vertices);
-          cursorX += period->advance;
+          // Yup. Let's draw the ellipses, then bail
+          // Perhaps we should really bail to the next line in this case??
+          Character *period = GetCharacter(L'.');
+          if (!period)
+            break;
+
+          for (int i = 0; i < 3; i++)
+          {
+            RenderCharacter(startX + cursorX, startY, period, color, !scrolling, vertices);
+            cursorX += period->advance;
+          }
+          break;
         }
-        break;
       }
-    }
-    else if (maxPixelWidth > 0 && cursorX > maxPixelWidth)
-      break;  // exceeded max allowed width - stop rendering
+      else if (maxPixelWidth > 0 && cursorX > maxPixelWidth)
+        break;  // exceeded max allowed width - stop rendering
 
-    RenderCharacter(startX + cursorX, startY, ch, color, !scrolling, vertices);
-    if ( alignment & XBFONT_JUSTIFIED )
-    {
-      if ((*pos & 0xffff) == L' ')
-        cursorX += ch->advance + spacePerLetter * justification_word_weight;
+      RenderCharacter(startX + cursorX, startY, ch, color, !scrolling, vertices);
+      if ( alignment & XBFONT_JUSTIFIED )
+      {
+        if ((*pos & 0xffff) == L' ')
+          cursorX += ch->advance + spacePerLetter * justification_word_weight;
+        else
+          cursorX += ch->advance + spacePerLetter;
+      }
       else
-        cursorX += ch->advance + spacePerLetter;
+        cursorX += ch->advance;
     }
-    else
-      cursorX += ch->advance;
   }
+  /* Append the new vertices (from the cache or otherwise) to the set collected
+   * since the first Begin() call */
+  m_vertex.insert(m_vertex.end(), vertices.begin(), vertices.end());
 
   End();
 }
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index dde0350..77111bc 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -64,6 +64,9 @@ struct SVertex
 };
 
 
+#include "GUIFontCache.h"
+
+
 class CGUIFontTTFBase
 {
   friend class CGUIFont;
@@ -165,6 +168,8 @@ class CGUIFontTTFBase
 
   CStdString m_strFileName;
 
+  CGUIFontCache<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue> m_staticCache;
+
 private:
   virtual bool FirstBegin() = 0;
   virtual void LastEnd() = 0;
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index b76c6a5..9935ea4 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -221,6 +221,7 @@ CBaseTexture* CGUIFontTTFGL::ReallocTexture(unsigned int& newHeight)
   m_textureScaleX = 1.0f / m_textureWidth;
   if (m_textureHeight < newHeight)
     CLog::Log(LOGWARNING, "%s: allocated new texture with height of %d, requested %d", __FUNCTION__, m_textureHeight, newHeight);
+  m_staticCache.Flush();
 
   memset(newTexture->GetPixels(), 0, m_textureHeight * newTexture->GetPitch());
   if (m_texture)
diff --git a/xbmc/guilib/GraphicContext.h b/xbmc/guilib/GraphicContext.h
index 6c2dcd4..bab2457 100644
--- a/xbmc/guilib/GraphicContext.h
+++ b/xbmc/guilib/GraphicContext.h
@@ -146,6 +146,7 @@ class CGraphicContext : public CCriticalSection,
   inline void ScaleFinalCoords(float &x, float &y, float &z) const XBMC_FORCE_INLINE { m_finalTransform.matrix.TransformPosition(x, y, z); }
   bool RectIsAngled(float x1, float y1, float x2, float y2) const;
 
+  inline const TransformMatrix &GetGUIMatrix() const XBMC_FORCE_INLINE { return m_finalTransform.matrix; }
   inline float GetGUIScaleX() const XBMC_FORCE_INLINE { return m_finalTransform.scaleX; }
   inline float GetGUIScaleY() const XBMC_FORCE_INLINE { return m_finalTransform.scaleY; }
   inline color_t MergeAlpha(color_t color) const XBMC_FORCE_INLINE
diff --git a/xbmc/guilib/Makefile.in b/xbmc/guilib/Makefile.in
index 086fb0d..af82979 100644
--- a/xbmc/guilib/Makefile.in
+++ b/xbmc/guilib/Makefile.in
@@ -23,6 +23,7 @@ SRCS += GUIEditControl.cpp
 SRCS += GUIFadeLabelControl.cpp
 SRCS += GUIFixedListContainer.cpp
 SRCS += GUIFont.cpp
+SRCS += GUIFontCache.cpp
 SRCS += GUIFontManager.cpp
 SRCS += GUIFontTTF.cpp
 SRCS += GUIImage.cpp
diff --git a/xbmc/guilib/TransformMatrix.h b/xbmc/guilib/TransformMatrix.h
index f351c99..9036ba9 100644
--- a/xbmc/guilib/TransformMatrix.h
+++ b/xbmc/guilib/TransformMatrix.h
@@ -245,3 +245,14 @@ class TransformMatrix
   float alpha;
   bool identity;
 };
+
+inline bool operator==(const TransformMatrix &a, const TransformMatrix &b)
+{
+  return a.alpha == b.alpha && ((a.identity && b.identity) ||
+      (!a.identity && !b.identity && std::equal(&a.m[0][0], &a.m[0][0] + sizeof a.m / sizeof a.m[0][0], &b.m[0][0])));
+}
+
+inline bool operator!=(const TransformMatrix &a, const TransformMatrix &b)
+{
+  return !operator==(a, b);
+}
-- 
1.9.3


From d58c6b187e77401f46855f6185d198b00e39a488 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Thu, 23 Jan 2014 22:24:17 +0000
Subject: [PATCH 05/99] Lay the groundwork for hardware clipping.

For glScissor() to replace CGraphicContext::ClipRect, a necessary condition
is that no shear or rotation is introduced between the coordinate systems
they use; this depends upon the settings of the GUI matrix m_finalTransform
as well as the OpenGL model-view and projection matrices. These all remain
unchanged between paired calls of CGUIShader::OnEnabled and
CGUIShader::OnDisabled, so we scan the matrices in CGUIShader::OnEnabled to
see whether hardware clipping is possible.

Then, in CGUIFontTTFBase::RenderCharacter, we don't apply software clipping
in such cases. However, because vertices arising from multiple
CGUIFontTTFBase::DrawTextInternal calls (each of which often uses a different
clip rectangle) get lumped into the same vector, which only at the end is
passed to OpenGL for rendering, we need to wait a few commits before we can
actually apply hardware clipping. In the meantime, expect to see rendering
errors.
---
 xbmc/guilib/GUIFontTTF.cpp               |  3 +-
 xbmc/guilib/GUIShader.cpp                | 80 +++++++++++++++++++++++++++++++-
 xbmc/guilib/GUIShader.h                  | 11 +++++
 xbmc/guilib/GraphicContext.cpp           | 10 ++++
 xbmc/guilib/GraphicContext.h             |  1 +
 xbmc/rendering/RenderSystem.h            |  2 +
 xbmc/rendering/gles/RenderSystemGLES.cpp | 22 +++++++++
 xbmc/rendering/gles/RenderSystemGLES.h   |  2 +
 8 files changed, 128 insertions(+), 3 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index 0290fc4..e3808d9 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -709,7 +709,8 @@ void CGUIFontTTFBase::RenderCharacter(float posX, float posY, const Character *c
                (posY + ch->offsetY + height) * g_graphicsContext.GetGUIScaleY());
   vertex += CPoint(m_originX, m_originY);
   CRect texture(ch->left, ch->top, ch->right, ch->bottom);
-  g_graphicsContext.ClipRect(vertex, texture);
+  if (!g_Windowing.ScissorsCanEffectClipping())
+    g_graphicsContext.ClipRect(vertex, texture);
 
   // transform our positions - note, no scaling due to GUI calibration/resolution occurs
   float x[4], y[4], z[4];
diff --git a/xbmc/guilib/GUIShader.cpp b/xbmc/guilib/GUIShader.cpp
index 23cb84f..5d836cee 100644
--- a/xbmc/guilib/GUIShader.cpp
+++ b/xbmc/guilib/GUIShader.cpp
@@ -26,6 +26,8 @@
 #include "GUIShader.h"
 #include "MatrixGLES.h"
 #include "utils/log.h"
+#include "windowing/WindowingFactory.h"
+#include "guilib/GraphicContext.h"
 
 using namespace Shaders;
 
@@ -88,8 +90,82 @@ bool CGUIShader::OnEnabled()
 {
   // This is called after glUseProgram()
 
-  glUniformMatrix4fv(m_hProj,  1, GL_FALSE, g_matrices.GetMatrix(MM_PROJECTION));
-  glUniformMatrix4fv(m_hModel, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
+  GLfloat *projMatrix = g_matrices.GetMatrix(MM_PROJECTION);
+  GLfloat *modelMatrix = g_matrices.GetMatrix(MM_MODELVIEW);
+  glUniformMatrix4fv(m_hProj,  1, GL_FALSE, projMatrix);
+  glUniformMatrix4fv(m_hModel, 1, GL_FALSE, modelMatrix);
+
+  const TransformMatrix &guiMatrix = g_graphicsContext.GetGUIMatrix();
+  CRect viewPort; // absolute positions of corners
+  g_Windowing.GetViewPort(viewPort);
+
+  /* glScissor operates in window coordinates. In order that we can use it to
+   * perform clipping, we must ensure that there is an independent linear
+   * transformation from the coordinate system used by CGraphicContext::ClipRect
+   * to window coordinates, separately for X and Y (in other words, no
+   * rotation or shear is introduced at any stage). To do, this, we need to
+   * check that zeros are present in the following locations:
+   *
+   * GUI matrix:
+   * / * 0 * * \
+   * | 0 * * * |
+   * \ 0 0 * * /
+   *       ^ TransformMatrix::TransformX/Y/ZCoord are only ever called with
+   *         input z = 0, so this column doesn't matter
+   * Model-view matrix:
+   * / * 0 0 * \
+   * | 0 * 0 * |
+   * | 0 0 * * |
+   * \ * * * * /  <- eye w has no influence on window x/y (last column below
+   *                                                       is either 0 or ignored)
+   * Projection matrix:
+   * / * 0 0 0 \
+   * | 0 * 0 0 |
+   * | * * * * |  <- normalised device coordinate z has no influence on window x/y
+   * \ 0 0 * 0 /
+   *
+   * Some of these zeros are not strictly required to ensure this, but they tend
+   * to be zeroed in the common case, so by checking for zeros here, we simplify
+   * the calculation of the window x/y coordinates further down the line.
+   *
+   * (Minor detail: we don't quite deal in window coordinates as defined by
+   * OpenGL, because CRenderSystemGLES::SetScissors flips the Y axis. But all
+   * that's needed to handle that is an effective negation at the stage where
+   * Y is in normalised device coordinates.)
+   */
+  m_clipPossible = guiMatrix.m[0][1] == 0 &&
+      guiMatrix.m[1][0] == 0 &&
+      guiMatrix.m[2][0] == 0 &&
+      guiMatrix.m[2][1] == 0 &&
+      modelMatrix[0+1*4] == 0 &&
+      modelMatrix[0+2*4] == 0 &&
+      modelMatrix[1+0*4] == 0 &&
+      modelMatrix[1+2*4] == 0 &&
+      modelMatrix[2+0*4] == 0 &&
+      modelMatrix[2+1*4] == 0 &&
+      projMatrix[0+1*4] == 0 &&
+      projMatrix[0+2*4] == 0 &&
+      projMatrix[0+3*4] == 0 &&
+      projMatrix[1+0*4] == 0 &&
+      projMatrix[1+2*4] == 0 &&
+      projMatrix[1+3*4] == 0 &&
+      projMatrix[3+0*4] == 0 &&
+      projMatrix[3+1*4] == 0 &&
+      projMatrix[3+3*4] == 0;
+  if (m_clipPossible)
+  {
+    m_clipXFactor = guiMatrix.m[0][0] * modelMatrix[0+0*4] * projMatrix[0+0*4];
+    m_clipXOffset = (guiMatrix.m[0][3] * modelMatrix[0+0*4] + modelMatrix[0+3*4]) * projMatrix[0+0*4];
+    m_clipYFactor = guiMatrix.m[1][1] * modelMatrix[1+1*4] * projMatrix[1+1*4];
+    m_clipYOffset = (guiMatrix.m[1][3] * modelMatrix[1+1*4] + modelMatrix[1+3*4]) * projMatrix[1+1*4];
+    float clipW = (guiMatrix.m[2][3] * modelMatrix[2+2*4] + modelMatrix[2+3*4]) * projMatrix[3+2*4];
+    float xMult = (viewPort.x2 - viewPort.x1) / (2 * clipW);
+    float yMult = (viewPort.y1 - viewPort.y2) / (2 * clipW); // correct for inverted window coordinate scheme
+    m_clipXFactor = m_clipXFactor * xMult;
+    m_clipXOffset = m_clipXOffset * xMult + (viewPort.x2 + viewPort.x1) / 2;
+    m_clipYFactor = m_clipYFactor * yMult;
+    m_clipYOffset = m_clipYOffset * yMult + (viewPort.y2 + viewPort.y1) / 2;
+  }
 
   return true;
 }
diff --git a/xbmc/guilib/GUIShader.h b/xbmc/guilib/GUIShader.h
index f7b5d9a..fdf7452 100644
--- a/xbmc/guilib/GUIShader.h
+++ b/xbmc/guilib/GUIShader.h
@@ -39,6 +39,11 @@ class CGUIShader : public Shaders::CGLSLShaderProgram
   GLint GetCord1Loc() { return m_hCord1; }
   GLint GetUniColLoc() { return m_hUniCol; }
   GLint GetCoord0MatrixLoc() { return m_hCoord0Matrix; }
+  bool HardwareClipIsPossible() { return m_clipPossible; }
+  GLfloat GetClipXFactor() { return m_clipXFactor; }
+  GLfloat GetClipXOffset() { return m_clipXOffset; }
+  GLfloat GetClipYFactor() { return m_clipYFactor; }
+  GLfloat GetClipYOffset() { return m_clipYOffset; }
 
 protected:
   GLint m_hTex0;
@@ -54,6 +59,12 @@ class CGUIShader : public Shaders::CGLSLShaderProgram
 
   GLfloat *m_proj;
   GLfloat *m_model;
+
+  bool m_clipPossible;
+  GLfloat m_clipXFactor;
+  GLfloat m_clipXOffset;
+  GLfloat m_clipYFactor;
+  GLfloat m_clipYOffset;
 };
 
 #endif // GUI_SHADER_H
diff --git a/xbmc/guilib/GraphicContext.cpp b/xbmc/guilib/GraphicContext.cpp
index 38f17a7..5bffdf5 100644
--- a/xbmc/guilib/GraphicContext.cpp
+++ b/xbmc/guilib/GraphicContext.cpp
@@ -167,6 +167,16 @@ void CGraphicContext::ClipRect(CRect &vertex, CRect &texture, CRect *texture2)
   }
 }
 
+CRect CGraphicContext::GetClipRegion()
+{
+  if (m_clipRegions.empty())
+    return CRect(0, 0, m_iScreenWidth, m_iScreenHeight);
+  CRect clipRegion(m_clipRegions.top());
+  if (!m_origins.empty())
+    clipRegion -= m_origins.top();
+  return clipRegion;
+}
+
 bool CGraphicContext::SetViewPort(float fx, float fy, float fwidth, float fheight, bool intersectPrevious /* = false */)
 {
   // transform coordinates - we may have a rotation which changes the positioning of the
diff --git a/xbmc/guilib/GraphicContext.h b/xbmc/guilib/GraphicContext.h
index bab2457..0a27643 100644
--- a/xbmc/guilib/GraphicContext.h
+++ b/xbmc/guilib/GraphicContext.h
@@ -199,6 +199,7 @@ class CGraphicContext : public CCriticalSection,
   void ApplyHardwareTransform();
   void RestoreHardwareTransform();
   void ClipRect(CRect &vertex, CRect &texture, CRect *diffuse = NULL);
+  CRect GetClipRegion();
   inline void AddGUITransform()
   {
     m_transforms.push(m_finalTransform);
diff --git a/xbmc/rendering/RenderSystem.h b/xbmc/rendering/RenderSystem.h
index fa64eba..c1dfb93 100644
--- a/xbmc/rendering/RenderSystem.h
+++ b/xbmc/rendering/RenderSystem.h
@@ -110,6 +110,8 @@ class CRenderSystemBase
   virtual void GetViewPort(CRect& viewPort) = 0;
   virtual void RestoreViewPort() {};
 
+  virtual bool ScissorsCanEffectClipping() { return false; }
+  virtual CRect ClipRectToScissorRect(const CRect &rect) { return CRect(); }
   virtual void SetScissors(const CRect &rect) = 0;
   virtual void ResetScissors() = 0;
 
diff --git a/xbmc/rendering/gles/RenderSystemGLES.cpp b/xbmc/rendering/gles/RenderSystemGLES.cpp
index 653c9ec..deb3afc 100644
--- a/xbmc/rendering/gles/RenderSystemGLES.cpp
+++ b/xbmc/rendering/gles/RenderSystemGLES.cpp
@@ -533,6 +533,28 @@ void CRenderSystemGLES::SetViewPort(CRect& viewPort)
   m_viewPort[3] = viewPort.Height();
 }
 
+bool CRenderSystemGLES::ScissorsCanEffectClipping()
+{
+  if (m_pGUIshader[m_method])
+    return m_pGUIshader[m_method]->HardwareClipIsPossible();
+
+  return false;
+}
+
+CRect CRenderSystemGLES::ClipRectToScissorRect(const CRect &rect)
+{
+  if (!m_pGUIshader[m_method])
+    return CRect();
+  float xFactor = m_pGUIshader[m_method]->GetClipXFactor();
+  float xOffset = m_pGUIshader[m_method]->GetClipXOffset();
+  float yFactor = m_pGUIshader[m_method]->GetClipYFactor();
+  float yOffset = m_pGUIshader[m_method]->GetClipYOffset();
+  return CRect(rect.x1 * xFactor + xOffset,
+               rect.y1 * yFactor + yOffset,
+               rect.x2 * xFactor + xOffset,
+               rect.y2 * yFactor + yOffset);
+}
+
 void CRenderSystemGLES::SetScissors(const CRect &rect)
 {
   if (!m_bRenderCreated)
diff --git a/xbmc/rendering/gles/RenderSystemGLES.h b/xbmc/rendering/gles/RenderSystemGLES.h
index 98e398a..81ee49e 100644
--- a/xbmc/rendering/gles/RenderSystemGLES.h
+++ b/xbmc/rendering/gles/RenderSystemGLES.h
@@ -63,6 +63,8 @@ class CRenderSystemGLES : public CRenderSystemBase
   virtual void SetViewPort(CRect& viewPort);
   virtual void GetViewPort(CRect& viewPort);
 
+  virtual bool ScissorsCanEffectClipping();
+  virtual CRect ClipRectToScissorRect(const CRect &rect);
   virtual void SetScissors(const CRect& rect);
   virtual void ResetScissors();
 
-- 
1.9.3


From 3424a50db35b53cf86a67734a923cda2b2faad0b Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Thu, 23 Jan 2014 16:42:22 +0000
Subject: [PATCH 06/99] Increase font cache hit rate by keying on the
 fractional part of m_originX and m_originY *after* they have been through the
 graphics context's transformation matrix, plus the scale/rotation elements of
 the matrix, rather than the origin in the original frame of reference plus
 the complete transformation matrix. All vertices of individual glyph bounding
 boxes are a constant offset from this position, and when the fractional part
 of the translation is a match, the rounding of each vertex will be in the
 same direction; this permits us to calculate the desired vertices from the
 cached ones simply by adding the integer parts of the translations with no
 additional rounding steps.

Note that this requires that software clipping is *not* performed.
---
 xbmc/guilib/GUIFontCache.cpp |  8 +++++++
 xbmc/guilib/GUIFontCache.h   | 43 +++++++++++++++++++++++++++++++++++
 xbmc/guilib/GUIFontTTF.cpp   | 53 +++++++++++++++++++++++++++++++++++---------
 xbmc/guilib/GUIFontTTF.h     |  1 +
 4 files changed, 95 insertions(+), 10 deletions(-)

diff --git a/xbmc/guilib/GUIFontCache.cpp b/xbmc/guilib/GUIFontCache.cpp
index 2c72f9c..df466a5 100644
--- a/xbmc/guilib/GUIFontCache.cpp
+++ b/xbmc/guilib/GUIFontCache.cpp
@@ -85,6 +85,9 @@ Value &CGUIFontCache<Position, Value>::Lookup(Position &pos,
   else
   {
     /* Cache hit */
+    /* Update the translation arguments so that they hold the offset to apply
+     * to the cached values (but only in the dynamic case) */
+    pos.UpdateWithOffsets(i->m_key.m_pos, scrolling);
     /* Update time in entry and move to the back of the list */
     i->m_lastUsedMillis = nowMillis;
     m_list.template get<Age>().relocate(m_list.template get<Age>().end(), m_list.template project<Age>(i));
@@ -103,3 +106,8 @@ template void CGUIFontCacheEntry<CGUIFontCacheStaticPosition, CGUIFontCacheStati
 template CGUIFontCacheEntry<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::~CGUIFontCacheEntry();
 template CGUIFontCacheStaticValue &CGUIFontCache<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::Lookup(CGUIFontCacheStaticPosition &, const vecColors &, const vecText &, uint32_t, float, bool, unsigned int, bool &);
 template void CGUIFontCache<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue>::Flush();
+
+template void CGUIFontCacheEntry<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue>::Reassign::operator()(CGUIFontCacheEntry<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue> &entry);
+template CGUIFontCacheEntry<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue>::~CGUIFontCacheEntry();
+template CGUIFontCacheDynamicValue &CGUIFontCache<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue>::Lookup(CGUIFontCacheDynamicPosition &, const vecColors &, const vecText &, uint32_t, float, bool, unsigned int, bool &);
+template void CGUIFontCache<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue>::Flush();
diff --git a/xbmc/guilib/GUIFontCache.h b/xbmc/guilib/GUIFontCache.h
index ef65845..d913dee 100644
--- a/xbmc/guilib/GUIFontCache.h
+++ b/xbmc/guilib/GUIFontCache.h
@@ -44,6 +44,7 @@
 using namespace boost::multi_index;
 
 #define FONT_CACHE_TIME_LIMIT (1000)
+#define FONT_CACHE_DIST_LIMIT (0.01)
 
 template<class Position, class Value> class CGUIFontCache;
 class CGUIFontTTFBase;
@@ -197,6 +198,7 @@ struct CGUIFontCacheStaticPosition
   float m_x;
   float m_y;
   CGUIFontCacheStaticPosition(float x, float y) : m_x(x), m_y(y) {}
+  void UpdateWithOffsets(const CGUIFontCacheStaticPosition &cached, bool scrolling) {}
 };
 
 typedef std::vector<SVertex> CGUIFontCacheStaticValue;
@@ -214,4 +216,45 @@ inline float MatrixHashContribution(const CGUIFontCacheKey<CGUIFontCacheStaticPo
   return a.m_matrix.m[0][3];
 }
 
+struct CGUIFontCacheDynamicPosition
+{
+  float m_x;
+  float m_y;
+  float m_z;
+  CGUIFontCacheDynamicPosition() {}
+  CGUIFontCacheDynamicPosition(float x, float y, float z) : m_x(x), m_y(y), m_z(z) {}
+  void UpdateWithOffsets(const CGUIFontCacheDynamicPosition &cached, bool scrolling)
+  {
+    if (scrolling)
+      m_x = m_x - cached.m_x;
+    else
+      m_x = floorf(m_x - cached.m_x + FONT_CACHE_DIST_LIMIT);
+    m_y = floorf(m_y - cached.m_y + FONT_CACHE_DIST_LIMIT);
+    m_z = floorf(m_z - cached.m_z + FONT_CACHE_DIST_LIMIT);
+  }
+};
+
+typedef std::vector<SVertex> CGUIFontCacheDynamicValue;
+
+inline bool Match(const CGUIFontCacheDynamicPosition &a, const TransformMatrix &a_m,
+                  const CGUIFontCacheDynamicPosition &b, const TransformMatrix &b_m,
+                  bool scrolling)
+{
+  float diffX = a.m_x - b.m_x + FONT_CACHE_DIST_LIMIT;
+  float diffY = a.m_y - b.m_y + FONT_CACHE_DIST_LIMIT;
+  float diffZ = a.m_z - b.m_z + FONT_CACHE_DIST_LIMIT;
+  return (scrolling || diffX - floorf(diffX) < 2 * FONT_CACHE_DIST_LIMIT) &&
+          diffY - floorf(diffY) < 2 * FONT_CACHE_DIST_LIMIT &&
+          diffZ - floorf(diffZ) < 2 * FONT_CACHE_DIST_LIMIT &&
+          a_m.m[0][0] == b_m.m[0][0] &&
+          a_m.m[1][1] == b_m.m[1][1] &&
+          a_m.m[2][2] == b_m.m[2][2];
+          // We already know the first 3 columns of both matrices are diagonal, so no need to check the other elements
+}
+
+inline float MatrixHashContribution(const CGUIFontCacheKey<CGUIFontCacheDynamicPosition> &a)
+{
+  return 0;
+}
+
 #endif
diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index e3808d9..412f47a 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -132,7 +132,7 @@ class CFreeTypeLibrary
 XBMC_GLOBAL_REF(CFreeTypeLibrary, g_freeTypeLibrary); // our freetype library
 #define g_freeTypeLibrary XBMC_GLOBAL_USE(CFreeTypeLibrary)
 
-CGUIFontTTFBase::CGUIFontTTFBase(const CStdString& strFileName) : m_staticCache(*this)
+CGUIFontTTFBase::CGUIFontTTFBase(const CStdString& strFileName) : m_staticCache(*this), m_dynamicCache(*this)
 {
   m_texture = NULL;
   m_char = NULL;
@@ -331,13 +331,28 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
   Begin();
 
   bool dirtyCache;
+  bool hardwareClipping = g_Windowing.ScissorsCanEffectClipping();
   CGUIFontCacheStaticPosition staticPos(x, y);
-  std::vector<SVertex> &vertices = m_staticCache.Lookup(staticPos,
-                                                        colors, text,
-                                                        alignment, maxPixelWidth,
-                                                        scrolling,
-                                                        XbmcThreads::SystemClockMillis(),
-                                                        dirtyCache);
+  CGUIFontCacheDynamicPosition dynamicPos;
+  if (hardwareClipping)
+  {
+    dynamicPos = CGUIFontCacheDynamicPosition(g_graphicsContext.ScaleFinalXCoord(x, y),
+                                              g_graphicsContext.ScaleFinalYCoord(x, y),
+                                              g_graphicsContext.ScaleFinalZCoord(x, y));
+  }
+  std::vector<SVertex> &vertices = hardwareClipping ?
+      m_dynamicCache.Lookup(dynamicPos,
+                            colors, text,
+                            alignment, maxPixelWidth,
+                            scrolling,
+                            XbmcThreads::SystemClockMillis(),
+                            dirtyCache) :
+      m_staticCache.Lookup(staticPos,
+                           colors, text,
+                           alignment, maxPixelWidth,
+                           scrolling,
+                           XbmcThreads::SystemClockMillis(),
+                           dirtyCache);
   if (dirtyCache)
   {
     // save the origin, which is scaled separately
@@ -440,10 +455,28 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
       else
         cursorX += ch->advance;
     }
+    if (hardwareClipping)
+      /* Append the new vertices (which we have just constructed in the cache)
+       * to the set collected since the first Begin() call */
+      m_vertex.insert(m_vertex.end(), vertices.begin(), vertices.end());
+  }
+  else if (hardwareClipping)
+  {
+    /* Apply the translation offset to the vertices from the cache after
+     * appending them to the set collected since the first Begin() call */
+    m_vertex.insert(m_vertex.end(), vertices.begin(), vertices.end());
+    SVertex *v;
+    for (v = &*m_vertex.end() - vertices.size(); v != &*m_vertex.end(); v++)
+    {
+      v->x += dynamicPos.m_x;
+      v->y += dynamicPos.m_y;
+      v->z += dynamicPos.m_z;
+    }
   }
-  /* Append the new vertices (from the cache or otherwise) to the set collected
-   * since the first Begin() call */
-  m_vertex.insert(m_vertex.end(), vertices.begin(), vertices.end());
+  if (!hardwareClipping)
+    /* Append the new vertices (from the cache or otherwise) to the set collected
+     * since the first Begin() call */
+    m_vertex.insert(m_vertex.end(), vertices.begin(), vertices.end());
 
   End();
 }
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index 77111bc..39bfa52 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -169,6 +169,7 @@ class CGUIFontTTFBase
   CStdString m_strFileName;
 
   CGUIFontCache<CGUIFontCacheStaticPosition, CGUIFontCacheStaticValue> m_staticCache;
+  CGUIFontCache<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue> m_dynamicCache;
 
 private:
   virtual bool FirstBegin() = 0;
-- 
1.9.3


From cd59927bb82659956650f9d8b929f4587a776133 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 8 Jan 2014 12:16:33 +0000
Subject: [PATCH 07/99] Rewrite of scrolling text code.

No longer shuffles the string round to minimise the number of characters
before the clipping rectangle; this doesn't save much on rendering time but
does harm the effectiveness of the cache. Now uses a pixel offset into the
string rather than a character + pixel offset, and plots the entire string
every time (execpt when the wrap point is visible, in which case the entire
string is plotted twice).

It also makes motion smoother, because (possibly unintentionally) the
previous code preferred to align the scroll offset with character boundaries.
This would lead to uneven changes of position, especially when the width of
the character currently being scrolled off the edge was only slightly more
than an integral multiple of the scroll increment.
---
 xbmc/guilib/GUIFadeLabelControl.cpp |   8 +--
 xbmc/guilib/GUIFont.cpp             | 123 +++++++++++++-----------------------
 xbmc/guilib/GUIFont.h               |  17 ++---
 xbmc/guilib/GUIRSSControl.cpp       |   6 +-
 xbmc/utils/RssReader.cpp            |   2 +-
 xbmc/utils/RssReader.h              |   2 +-
 6 files changed, 58 insertions(+), 100 deletions(-)

diff --git a/xbmc/guilib/GUIFadeLabelControl.cpp b/xbmc/guilib/GUIFadeLabelControl.cpp
index 844f960..5859d9f 100644
--- a/xbmc/guilib/GUIFadeLabelControl.cpp
+++ b/xbmc/guilib/GUIFadeLabelControl.cpp
@@ -109,18 +109,14 @@ void CGUIFadeLabelControl::Process(unsigned int currentTime, CDirtyRegionList &d
     bool moveToNextLabel = false;
     if (!m_scrollOut)
     {
-      vecText text;
-      m_textLayout.GetFirstText(text);
-      if (m_scrollInfo.characterPos && m_scrollInfo.characterPos < text.size())
-        text.erase(text.begin(), text.begin() + min((int)m_scrollInfo.characterPos - 1, (int)text.size()));
-      if (m_label.font->GetTextWidth(text) < m_width)
+      if (m_scrollInfo.pixelPos + m_width > m_scrollInfo.m_textWidth)
       {
         if (m_fadeAnim.GetProcess() != ANIM_PROCESS_NORMAL)
           m_fadeAnim.QueueAnimation(ANIM_PROCESS_NORMAL);
         moveToNextLabel = true;
       }
     }
-    else if (m_scrollInfo.characterPos > m_textLayout.GetTextLength())
+    else if (m_scrollInfo.pixelPos > m_scrollInfo.m_textWidth)
       moveToNextLabel = true;
     
     // apply the fading animation
diff --git a/xbmc/guilib/GUIFont.cpp b/xbmc/guilib/GUIFont.cpp
index a7ee668..eb8efdb 100644
--- a/xbmc/guilib/GUIFont.cpp
+++ b/xbmc/guilib/GUIFont.cpp
@@ -36,7 +36,12 @@ CScrollInfo::CScrollInfo(unsigned int wait /* = 50 */, float pos /* = 0 */,
     initialWait = wait;
     initialPos = pos;
     SetSpeed(speed ? speed : defaultSpeed);
-    g_charsetConverter.utf8ToW(scrollSuffix, suffix);
+    CStdStringW wsuffix;
+    g_charsetConverter.utf8ToW(scrollSuffix, wsuffix);
+    suffix.clear();
+    suffix.reserve(wsuffix.size());
+    for (vecText::size_type i = 0; i < wsuffix.size(); i++)
+      suffix.push_back(wsuffix[i]);
     Reset();
 }
 
@@ -115,11 +120,12 @@ bool CGUIFont::UpdateScrollInfo(const vecText &text, CScrollInfo &scrollInfo)
 {
   // draw at our scroll position
   // we handle the scrolling as follows:
-  //   We scroll on a per-pixel basis up until we have scrolled the first character outside
-  //   of our viewport, whereby we cycle the string around, and reset the scroll position.
-  //
-  //   pixelPos is the amount in pixels to move the string by.
-  //   characterPos is the amount in characters to rotate the string by.
+  //   We scroll on a per-pixel basis (eschewing the use of character indices
+  //   which were also in use previously). The complete string, including suffix,
+  //   is plotted to achieve the desired effect - normally just the one time, but
+  //   if there is a wrap point within the viewport then it will be plotted twice.
+  //   If the string is smaller than the viewport, then it may be plotted even
+  //   more times than that.
   //
   if (scrollInfo.waitTime)
   {
@@ -135,54 +141,19 @@ bool CGUIFont::UpdateScrollInfo(const vecText &text, CScrollInfo &scrollInfo)
   // move along by the appropriate scroll amount
   float scrollAmount = fabs(scrollInfo.GetPixelsPerFrame() * g_graphicsContext.GetGUIScaleX());
 
-  if (scrollInfo.pixelSpeed > 0)
+  if (!scrollInfo.m_widthValid)
   {
-    // we want to move scrollAmount, grab the next character
-    float charWidth = GetCharWidth(scrollInfo.GetCurrentChar(text));
-    if (scrollInfo.pixelPos + scrollAmount < charWidth)
-      scrollInfo.pixelPos += scrollAmount;  // within the current character
-    else
-    { // past the current character, decrement scrollAmount by the charWidth and move to the next character
-      while (scrollInfo.pixelPos + scrollAmount >= charWidth)
-      {
-        scrollAmount -= (charWidth - scrollInfo.pixelPos);
-        scrollInfo.pixelPos = 0;
-        scrollInfo.characterPos++;
-        if (scrollInfo.characterPos >= text.size() + scrollInfo.suffix.size())
-        {
-          scrollInfo.Reset();
-          break;
-        }
-        charWidth = GetCharWidth(scrollInfo.GetCurrentChar(text));
-      }
-    }
-  }
-  else if (scrollInfo.pixelSpeed < 0)
-  { // scrolling backwards
-    // we want to move scrollAmount, grab the next character
-    float charWidth = GetCharWidth(scrollInfo.GetCurrentChar(text));
-    if (scrollInfo.pixelPos + scrollAmount < charWidth)
-      scrollInfo.pixelPos += scrollAmount;  // within the current character
-    else
-    { // past the current character, decrement scrollAmount by the charWidth and move to the next character
-      while (scrollInfo.pixelPos + scrollAmount >= charWidth)
-      {
-        scrollAmount -= (charWidth - scrollInfo.pixelPos);
-        scrollInfo.pixelPos = 0;
-        if (scrollInfo.characterPos == 0)
-        {
-          scrollInfo.Reset();
-          scrollInfo.characterPos = text.size() + scrollInfo.suffix.size() - 1;
-          break;
-        }
-        scrollInfo.characterPos--;
-        charWidth = GetCharWidth(scrollInfo.GetCurrentChar(text));
-      }
-    }
+    /* Calculate the pixel width of the complete string */
+    scrollInfo.m_textWidth = GetTextWidth(text);
+    scrollInfo.m_totalWidth = scrollInfo.m_textWidth + GetTextWidth(scrollInfo.suffix);
+    scrollInfo.m_widthValid = true;
   }
+  scrollInfo.pixelPos += scrollAmount;
+  assert(scrollInfo.m_totalWidth != 0);
+  while (scrollInfo.pixelPos >= scrollInfo.m_totalWidth)
+    scrollInfo.pixelPos -= scrollInfo.m_totalWidth;
 
-  if(scrollInfo.characterPos != old.characterPos
-  || scrollInfo.pixelPos     != old.pixelPos)
+  if (scrollInfo.pixelPos != old.pixelPos)
     return true;
   else
     return false;
@@ -194,39 +165,27 @@ void CGUIFont::DrawScrollingText(float x, float y, const vecColors &colors, colo
   if (!m_font) return;
   if (!shadowColor) shadowColor = m_shadowColor;
 
-  float spaceWidth = GetCharWidth(L' ');
-  // max chars on screen + extra margin chars
-  vecText::size_type maxChars =
-    std::min<vecText::size_type>(
-      (text.size() + (vecText::size_type)scrollInfo.suffix.size()),
-      (vecText::size_type)((maxWidth * 1.05f) / spaceWidth));
-
   if (!text.size() || ClippedRegionIsEmpty(x, y, maxWidth, alignment))
     return; // nothing to render
 
-  maxWidth = ROUND((maxWidth + scrollInfo.pixelPos) / g_graphicsContext.GetGUIScaleX());
+  if (!scrollInfo.m_widthValid)
+  {
+    /* Calculate the pixel width of the complete string */
+    scrollInfo.m_textWidth = GetTextWidth(text);
+    scrollInfo.m_totalWidth = scrollInfo.m_textWidth + GetTextWidth(scrollInfo.suffix);
+    scrollInfo.m_widthValid = true;
+  }
+
+  assert(scrollInfo.m_totalWidth != 0);
+
+  float textPixelWidth = ROUND(scrollInfo.m_textWidth / g_graphicsContext.GetGUIScaleX());
+  float suffixPixelWidth = ROUND((scrollInfo.m_totalWidth - scrollInfo.m_textWidth) / g_graphicsContext.GetGUIScaleX());
 
-  float charWidth = GetCharWidth(scrollInfo.GetCurrentChar(text));
   float offset;
   if(scrollInfo.pixelSpeed >= 0)
     offset = scrollInfo.pixelPos;
   else
-    offset = charWidth - scrollInfo.pixelPos;
-
-  // Now rotate our string as needed, only take a slightly larger then visible part of the text.
-  unsigned int pos = scrollInfo.characterPos;
-  vecText renderText;
-  renderText.reserve(maxChars);
-  for (vecText::size_type i = 0; i < maxChars; i++)
-  {
-    if (pos >= text.size() + scrollInfo.suffix.size())
-      pos = 0;
-    if (pos < text.size())
-      renderText.push_back(text[pos]);
-    else
-      renderText.push_back(scrollInfo.suffix[pos - text.size()]);
-    pos++;
-  }
+    offset = scrollInfo.m_totalWidth - scrollInfo.pixelPos;
 
   vecColors renderColors;
   for (unsigned int i = 0; i < colors.size(); i++)
@@ -239,9 +198,17 @@ void CGUIFont::DrawScrollingText(float x, float y, const vecColors &colors, colo
     vecColors shadowColors;
     for (unsigned int i = 0; i < renderColors.size(); i++)
       shadowColors.push_back((renderColors[i] & 0xff000000) != 0 ? shadowColor : 0);
-    m_font->DrawTextInternal(x - offset + 1, y + 1, shadowColors, renderText, alignment, maxWidth + m_font->GetLineHeight(2.0f), scroll);
+    for (float dx = -offset; dx < maxWidth; dx += scrollInfo.m_totalWidth)
+    {
+      m_font->DrawTextInternal(x + dx + 1, y + 1, shadowColors, text, alignment, textPixelWidth, scroll);
+      m_font->DrawTextInternal(x + dx + scrollInfo.m_textWidth + 1, y + 1, shadowColors, scrollInfo.suffix, alignment, suffixPixelWidth, scroll);
+    }
+  }
+  for (float dx = -offset; dx < maxWidth; dx += scrollInfo.m_totalWidth)
+  {
+    m_font->DrawTextInternal(x + dx, y, renderColors, text, alignment, textPixelWidth, scroll);
+    m_font->DrawTextInternal(x + dx + scrollInfo.m_textWidth, y, renderColors, scrollInfo.suffix, alignment, suffixPixelWidth, scroll);
   }
-  m_font->DrawTextInternal(x - offset, y, renderColors, renderText, alignment, maxWidth + m_font->GetLineHeight(2.0f), scroll);
 
   g_graphicsContext.RestoreClipRegion();
 }
diff --git a/xbmc/guilib/GUIFont.h b/xbmc/guilib/GUIFont.h
index c55db48..09cf9b3 100644
--- a/xbmc/guilib/GUIFont.h
+++ b/xbmc/guilib/GUIFont.h
@@ -64,7 +64,6 @@ class CScrollInfo
   void Reset()
   {
     waitTime = initialWait;
-    characterPos = 0;
     // pixelPos is where we start the current letter, so is measured
     // to the left of the text rendering's left edge.  Thus, a negative
     // value will mean the text starts to the right
@@ -72,25 +71,19 @@ class CScrollInfo
     // privates:
     m_averageFrameTime = 1000.f / abs(defaultSpeed);
     m_lastFrameTime = 0;
-  }
-  uint32_t GetCurrentChar(const vecText &text) const
-  {
-    assert(text.size());
-    if (characterPos < text.size())
-      return text[characterPos];
-    else if (characterPos < text.size() + suffix.size())
-      return suffix[characterPos - text.size()];
-    return text[0];
+    m_widthValid = false;
   }
   float GetPixelsPerFrame();
 
   float pixelPos;
   float pixelSpeed;
   unsigned int waitTime;
-  unsigned int characterPos;
   unsigned int initialWait;
   float initialPos;
-  CStdStringW suffix;
+  vecText suffix;
+  mutable float m_textWidth;
+  mutable float m_totalWidth;
+  mutable bool m_widthValid;
 
   static const int defaultSpeed = 60;
 private:
diff --git a/xbmc/guilib/GUIRSSControl.cpp b/xbmc/guilib/GUIRSSControl.cpp
index 8d985cf..a8e20fc 100644
--- a/xbmc/guilib/GUIRSSControl.cpp
+++ b/xbmc/guilib/GUIRSSControl.cpp
@@ -119,7 +119,9 @@ void CGUIRSSControl::Process(unsigned int currentTime, CDirtyRegionList &dirtyre
       dirty = true;
 
       if (CRssManager::Get().GetReader(GetID(), GetParentID(), this, m_pReader))
-        m_scrollInfo.characterPos = m_pReader->m_SavedScrollPos;
+      {
+        m_scrollInfo.pixelPos = m_pReader->m_savedScrollPixelPos;
+      }
       else
       {
         if (m_strRSSTags != "")
@@ -174,7 +176,7 @@ void CGUIRSSControl::Render()
     if (m_pReader)
     {
       m_pReader->CheckForUpdates();
-      m_pReader->m_SavedScrollPos = m_scrollInfo.characterPos;
+      m_pReader->m_savedScrollPixelPos = m_scrollInfo.pixelPos;
     }
   }
   CGUIControl::Render();
diff --git a/xbmc/utils/RssReader.cpp b/xbmc/utils/RssReader.cpp
index 3636c3e..ac066ee 100644
--- a/xbmc/utils/RssReader.cpp
+++ b/xbmc/utils/RssReader.cpp
@@ -55,7 +55,7 @@ CRssReader::CRssReader() : CThread("RSSReader")
   m_pObserver = NULL;
   m_spacesBetweenFeeds = 0;
   m_bIsRunning = false;
-  m_SavedScrollPos = 0;
+  m_savedScrollPixelPos = 0;
   m_rtlText = false;
   m_requestRefresh = false;
 }
diff --git a/xbmc/utils/RssReader.h b/xbmc/utils/RssReader.h
index 2cda726..fbc579e 100644
--- a/xbmc/utils/RssReader.h
+++ b/xbmc/utils/RssReader.h
@@ -43,7 +43,7 @@ class CRssReader : public CThread
   void SetObserver(IRssObserver* observer);
   void CheckForUpdates();
   void requestRefresh();
-  unsigned int m_SavedScrollPos;
+  float m_savedScrollPixelPos;
 
 private:
   void Process();
-- 
1.9.3


From 05ce888df8828b2dd3ca2459dcf83e84d94777b6 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Mon, 27 Jan 2014 23:21:10 +0000
Subject: [PATCH 08/99] Move the application of the translation offsets into
 the GLES code.

Still all pure software at this stage. Main change is in the data types at
the interface between CGUIFontTTFBase and CGUIFontTTFGL. The old way
(array of vertices in m_vertex) are retained in addition, for the sake`of
cases that need to use software clipping on GLES, as well as for DX and GL
support where the new scheme is not (yet?) used.
---
 xbmc/guilib/GUIFontTTF.cpp   | 19 +++---------
 xbmc/guilib/GUIFontTTF.h     | 17 +++++++++++
 xbmc/guilib/GUIFontTTFGL.cpp | 72 ++++++++++++++++++++++++++++++++------------
 3 files changed, 73 insertions(+), 35 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index 412f47a..b0e69c0 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -214,6 +214,7 @@ void CGUIFontTTFBase::Clear()
     g_freeTypeLibrary.ReleaseStroker(m_stroker);
   m_stroker = NULL;
 
+  m_vertexTrans.clear();
   m_vertex.clear();
 }
 
@@ -309,6 +310,7 @@ void CGUIFontTTFBase::Begin()
 {
   if (m_nestedBeginCount == 0 && m_texture != NULL && FirstBegin())
   {
+    m_vertexTrans.clear();
     m_vertex.clear();
   }
   // Keep track of the nested begin/end calls.
@@ -456,23 +458,10 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
         cursorX += ch->advance;
     }
     if (hardwareClipping)
-      /* Append the new vertices (which we have just constructed in the cache)
-       * to the set collected since the first Begin() call */
-      m_vertex.insert(m_vertex.end(), vertices.begin(), vertices.end());
+      m_vertexTrans.push_back(CTranslatedVertices(0, 0, 0, &vertices));
   }
   else if (hardwareClipping)
-  {
-    /* Apply the translation offset to the vertices from the cache after
-     * appending them to the set collected since the first Begin() call */
-    m_vertex.insert(m_vertex.end(), vertices.begin(), vertices.end());
-    SVertex *v;
-    for (v = &*m_vertex.end() - vertices.size(); v != &*m_vertex.end(); v++)
-    {
-      v->x += dynamicPos.m_x;
-      v->y += dynamicPos.m_y;
-      v->z += dynamicPos.m_z;
-    }
-  }
+    m_vertexTrans.push_back(CTranslatedVertices(dynamicPos.m_x, dynamicPos.m_y, dynamicPos.m_z, &vertices));
   if (!hardwareClipping)
     /* Append the new vertices (from the cache or otherwise) to the set collected
      * since the first Begin() call */
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index 39bfa52..e8afc1c 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -61,6 +61,14 @@ struct SVertex
   unsigned char r, g, b, a;
 #endif
   float u, v;
+  struct SVertex Offset(float translate[3]) const
+  {
+    SVertex out = *this;
+    out.x += translate[0];
+    out.y += translate[1];
+    out.z += translate[2];
+    return out;
+  }
 };
 
 
@@ -159,6 +167,15 @@ class CGUIFontTTFBase
 
   unsigned int m_nTexture;
 
+  struct CTranslatedVertices
+  {
+    float translateX;
+    float translateY;
+    float translateZ;
+    const std::vector<SVertex> *vertexBuffer;
+    CTranslatedVertices(float translateX, float translateY, float translateZ, const std::vector<SVertex> *vertexBuffer) : translateX(translateX), translateY(translateY), translateZ(translateZ), vertexBuffer(vertexBuffer) {}
+  };
+  std::vector<CTranslatedVertices> m_vertexTrans;
   std::vector<SVertex> m_vertex;
 
   float    m_textureScaleX;
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index 9935ea4..18c9358 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -167,34 +167,65 @@ void CGUIFontTTFGL::LastEnd()
   GLint colLoc  = g_Windowing.GUIShaderGetCol();
   GLint tex0Loc = g_Windowing.GUIShaderGetCoord0();
 
-  // stack object until VBOs will be used
-  std::vector<SVertex> vecVertices( 6 * (m_vertex.size() / 4) );
-  SVertex *vertices = &vecVertices[0];
+  // Enable the attributes used by this shader
+  glEnableVertexAttribArray(posLoc);
+  glEnableVertexAttribArray(colLoc);
+  glEnableVertexAttribArray(tex0Loc);
 
-  for (size_t i=0; i<m_vertex.size(); i+=4)
+  if (m_vertex.size() > 0)
   {
-    *vertices++ = m_vertex[i];
-    *vertices++ = m_vertex[i+1];
-    *vertices++ = m_vertex[i+2];
+    // Deal with vertices that had to use software clipping
+    std::vector<SVertex> vecVertices( 6 * (m_vertex.size() / 4) );
+    SVertex *vertices = &vecVertices[0];
 
-    *vertices++ = m_vertex[i+1];
-    *vertices++ = m_vertex[i+3];
-    *vertices++ = m_vertex[i+2];
-  }
+    for (size_t i=0; i<m_vertex.size(); i+=4)
+    {
+      *vertices++ = m_vertex[i];
+      *vertices++ = m_vertex[i+1];
+      *vertices++ = m_vertex[i+2];
 
-  vertices = &vecVertices[0];
+      *vertices++ = m_vertex[i+1];
+      *vertices++ = m_vertex[i+3];
+      *vertices++ = m_vertex[i+2];
+    }
 
-  glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, x));
-  // Normalize color values. Does not affect Performance at all.
-  glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, r));
-  glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, u));
+    vertices = &vecVertices[0];
 
-  glEnableVertexAttribArray(posLoc);
-  glEnableVertexAttribArray(colLoc);
-  glEnableVertexAttribArray(tex0Loc);
+    glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, x));
+    // Normalize color values. Does not affect Performance at all.
+    glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, r));
+    glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, u));
+
+    glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
+  }
+  if (m_vertexTrans.size() > 0)
+  {
+    // Deal with the vertices that can be hardware clipped and therefore translated
+    std::vector<SVertex> vecVertices;
+    for (size_t i = 0; i < m_vertexTrans.size(); i++)
+    {
+      float translate[3] = { m_vertexTrans[i].translateX, m_vertexTrans[i].translateY, m_vertexTrans[i].translateZ };
+      for (size_t j = 0; j < m_vertexTrans[i].vertexBuffer->size(); j += 4)
+      {
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j].Offset(translate));
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1].Offset(translate));
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2].Offset(translate));
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1].Offset(translate));
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+3].Offset(translate));
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2].Offset(translate));
+      }
+    }
+    SVertex *vertices = &vecVertices[0];
 
-  glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
+    glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, x));
+    // Normalize color values. Does not affect Performance at all.
+    glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, r));
+    glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, u));
+
+    glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
+  }
 
+  // Disable the attributes used by this shader
   glDisableVertexAttribArray(posLoc);
   glDisableVertexAttribArray(colLoc);
   glDisableVertexAttribArray(tex0Loc);
@@ -222,6 +253,7 @@ CBaseTexture* CGUIFontTTFGL::ReallocTexture(unsigned int& newHeight)
   if (m_textureHeight < newHeight)
     CLog::Log(LOGWARNING, "%s: allocated new texture with height of %d, requested %d", __FUNCTION__, m_textureHeight, newHeight);
   m_staticCache.Flush();
+  m_dynamicCache.Flush();
 
   memset(newTexture->GetPixels(), 0, m_textureHeight * newTexture->GetPitch());
   if (m_texture)
-- 
1.9.3


From 1a5fc663da29146c6e11764aff1c99e0fb0c3fd4 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 15 Jan 2014 15:28:06 +0000
Subject: [PATCH 09/99] Rather than applying the translation offsets to the
 vertices, now applies them to the model view matrix from the top of the
 matrix stack and pushes it over to OpenGL. The vertices themselves are still
 all held client-side.

---
 xbmc/guilib/GUIFontTTF.h                 |  8 -------
 xbmc/guilib/GUIFontTTFGL.cpp             | 40 +++++++++++++++++++++-----------
 xbmc/guilib/GUIShader.h                  |  1 +
 xbmc/rendering/gles/RenderSystemGLES.cpp |  8 +++++++
 xbmc/rendering/gles/RenderSystemGLES.h   |  1 +
 5 files changed, 36 insertions(+), 22 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index e8afc1c..573039d 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -61,14 +61,6 @@ struct SVertex
   unsigned char r, g, b, a;
 #endif
   float u, v;
-  struct SVertex Offset(float translate[3]) const
-  {
-    SVertex out = *this;
-    out.x += translate[0];
-    out.y += translate[1];
-    out.z += translate[2];
-    return out;
-  }
 };
 
 
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index 18c9358..ea08bf4 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -29,6 +29,7 @@
 #include "utils/log.h"
 #include "utils/GLUtils.h"
 #include "windowing/WindowingFactory.h"
+#include "guilib/MatrixGLES.h"
 
 // stuff for freetype
 #include <ft2build.h>
@@ -166,6 +167,7 @@ void CGUIFontTTFGL::LastEnd()
   GLint posLoc  = g_Windowing.GUIShaderGetPos();
   GLint colLoc  = g_Windowing.GUIShaderGetCol();
   GLint tex0Loc = g_Windowing.GUIShaderGetCoord0();
+  GLint modelLoc = g_Windowing.GUIShaderGetModel();
 
   // Enable the attributes used by this shader
   glEnableVertexAttribArray(posLoc);
@@ -204,25 +206,35 @@ void CGUIFontTTFGL::LastEnd()
     std::vector<SVertex> vecVertices;
     for (size_t i = 0; i < m_vertexTrans.size(); i++)
     {
-      float translate[3] = { m_vertexTrans[i].translateX, m_vertexTrans[i].translateY, m_vertexTrans[i].translateZ };
+      // Apply the translation to the currently active (top-of-stack) model view matrix
+      g_matrices.MatrixMode(MM_MODELVIEW);
+      g_matrices.PushMatrix();
+      g_matrices.Translatef(m_vertexTrans[i].translateX, m_vertexTrans[i].translateY, m_vertexTrans[i].translateZ);
+      glUniformMatrix4fv(modelLoc, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
+
+      vecVertices.clear();
       for (size_t j = 0; j < m_vertexTrans[i].vertexBuffer->size(); j += 4)
       {
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j].Offset(translate));
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1].Offset(translate));
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2].Offset(translate));
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1].Offset(translate));
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+3].Offset(translate));
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2].Offset(translate));
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j]);
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1]);
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2]);
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1]);
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+3]);
+        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2]);
       }
-    }
-    SVertex *vertices = &vecVertices[0];
+      SVertex *vertices = &vecVertices[0];
 
-    glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, x));
-    // Normalize color values. Does not affect Performance at all.
-    glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, r));
-    glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, u));
+      glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, x));
+      // Normalize color values. Does not affect Performance at all.
+      glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, r));
+      glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, u));
 
-    glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
+      glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
+
+      g_matrices.PopMatrix();
+    }
+    // Restore the original model view matrix
+    glUniformMatrix4fv(modelLoc, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
   }
 
   // Disable the attributes used by this shader
diff --git a/xbmc/guilib/GUIShader.h b/xbmc/guilib/GUIShader.h
index fdf7452..abbe21c 100644
--- a/xbmc/guilib/GUIShader.h
+++ b/xbmc/guilib/GUIShader.h
@@ -39,6 +39,7 @@ class CGUIShader : public Shaders::CGLSLShaderProgram
   GLint GetCord1Loc() { return m_hCord1; }
   GLint GetUniColLoc() { return m_hUniCol; }
   GLint GetCoord0MatrixLoc() { return m_hCoord0Matrix; }
+  GLint GetModelLoc() { return m_hModel; }
   bool HardwareClipIsPossible() { return m_clipPossible; }
   GLfloat GetClipXFactor() { return m_clipXFactor; }
   GLfloat GetClipXOffset() { return m_clipXOffset; }
diff --git a/xbmc/rendering/gles/RenderSystemGLES.cpp b/xbmc/rendering/gles/RenderSystemGLES.cpp
index deb3afc..0904d1f 100644
--- a/xbmc/rendering/gles/RenderSystemGLES.cpp
+++ b/xbmc/rendering/gles/RenderSystemGLES.cpp
@@ -691,4 +691,12 @@ bool CRenderSystemGLES::SupportsStereo(RENDER_STEREO_MODE mode)
   }
 }
 
+GLint CRenderSystemGLES::GUIShaderGetModel()
+{
+  if (m_pGUIshader[m_method])
+    return m_pGUIshader[m_method]->GetModelLoc();
+
+  return -1;
+}
+
 #endif
diff --git a/xbmc/rendering/gles/RenderSystemGLES.h b/xbmc/rendering/gles/RenderSystemGLES.h
index 81ee49e..d2f9cd1 100644
--- a/xbmc/rendering/gles/RenderSystemGLES.h
+++ b/xbmc/rendering/gles/RenderSystemGLES.h
@@ -91,6 +91,7 @@ class CRenderSystemGLES : public CRenderSystemBase
   GLint GUIShaderGetCoord1();
   GLint GUIShaderGetUniCol();
   GLint GUIShaderGetCoord0Matrix();
+  GLint GUIShaderGetModel();
 
 protected:
   virtual void SetVSyncImpl(bool enable) = 0;
-- 
1.9.3


From 851167c3a56064b82e0b431fd326af7ca5d0b88f Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 29 Jan 2014 13:21:19 +0000
Subject: [PATCH 10/99] Enable hardware clipping.

---
 xbmc/guilib/GUIFontTTF.cpp   | 4 ++--
 xbmc/guilib/GUIFontTTF.h     | 5 ++++-
 xbmc/guilib/GUIFontTTFGL.cpp | 6 ++++++
 3 files changed, 12 insertions(+), 3 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index b0e69c0..3ea1051 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -458,10 +458,10 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
         cursorX += ch->advance;
     }
     if (hardwareClipping)
-      m_vertexTrans.push_back(CTranslatedVertices(0, 0, 0, &vertices));
+      m_vertexTrans.push_back(CTranslatedVertices(0, 0, 0, &vertices, g_graphicsContext.GetClipRegion()));
   }
   else if (hardwareClipping)
-    m_vertexTrans.push_back(CTranslatedVertices(dynamicPos.m_x, dynamicPos.m_y, dynamicPos.m_z, &vertices));
+    m_vertexTrans.push_back(CTranslatedVertices(dynamicPos.m_x, dynamicPos.m_y, dynamicPos.m_z, &vertices, g_graphicsContext.GetClipRegion()));
   if (!hardwareClipping)
     /* Append the new vertices (from the cache or otherwise) to the set collected
      * since the first Begin() call */
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index 573039d..a6931c1 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -27,6 +27,8 @@
  *
  */
 
+#include "Geometry.h"
+
 // forward definition
 class CBaseTexture;
 
@@ -165,7 +167,8 @@ class CGUIFontTTFBase
     float translateY;
     float translateZ;
     const std::vector<SVertex> *vertexBuffer;
-    CTranslatedVertices(float translateX, float translateY, float translateZ, const std::vector<SVertex> *vertexBuffer) : translateX(translateX), translateY(translateY), translateZ(translateZ), vertexBuffer(vertexBuffer) {}
+    CRect clip;
+    CTranslatedVertices(float translateX, float translateY, float translateZ, const std::vector<SVertex> *vertexBuffer, const CRect &clip) : translateX(translateX), translateY(translateY), translateZ(translateZ), vertexBuffer(vertexBuffer), clip(clip) {}
   };
   std::vector<CTranslatedVertices> m_vertexTrans;
   std::vector<SVertex> m_vertex;
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index ea08bf4..b63e337 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -206,6 +206,10 @@ void CGUIFontTTFGL::LastEnd()
     std::vector<SVertex> vecVertices;
     for (size_t i = 0; i < m_vertexTrans.size(); i++)
     {
+      // Apply the clip rectangle
+      CRect clip = g_Windowing.ClipRectToScissorRect(m_vertexTrans[i].clip);
+      g_Windowing.SetScissors(clip);
+
       // Apply the translation to the currently active (top-of-stack) model view matrix
       g_matrices.MatrixMode(MM_MODELVIEW);
       g_matrices.PushMatrix();
@@ -233,6 +237,8 @@ void CGUIFontTTFGL::LastEnd()
 
       g_matrices.PopMatrix();
     }
+    // Restore the original scissor rectangle
+    g_Windowing.ResetScissors();
     // Restore the original model view matrix
     glUniformMatrix4fv(modelLoc, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
   }
-- 
1.9.3


From 7a0931a8e33a9386ab2e2a0beacf2c939d64a0e2 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 15 Jan 2014 15:32:51 +0000
Subject: [PATCH 11/99] Move the vertex data across to a vertex buffer object
 just prior to drawing.

---
 xbmc/guilib/GUIFontTTFGL.cpp | 24 +++++++++++++++++++-----
 1 file changed, 19 insertions(+), 5 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index b63e337..b00055d 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -228,12 +228,24 @@ void CGUIFontTTFGL::LastEnd()
       }
       SVertex *vertices = &vecVertices[0];
 
-      glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, x));
-      // Normalize color values. Does not affect Performance at all.
-      glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, r));
-      glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (char*)vertices + offsetof(SVertex, u));
-
+      // Generate a unique buffer object name and put it in vertexBuffer
+      GLuint vertexBuffer;
+      glGenBuffers(1, &vertexBuffer);
+      // Bind the buffer to the OpenGL context's GL_ARRAY_BUFFER binding point
+      glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
+      // Create a data store for the buffer object bound to the GL_ARRAY_BUFFER
+      // binding point (i.e. our buffer object) and initialise it from the
+      // specified client-side pointer
+      glBufferData(GL_ARRAY_BUFFER, vecVertices.size() * sizeof *vertices, vertices, GL_STATIC_DRAW);
+      // Set up the offsets of the various vertex attributes within the buffer
+      // object bound to GL_ARRAY_BUFFER
+      glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) offsetof(SVertex, x));
+      glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE,  sizeof(SVertex), (GLvoid *) offsetof(SVertex, r));
+      glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) offsetof(SVertex, u));
+      // Do the actual drawing operation, using the full set of vertices in the buffer
       glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
+      // Release the buffer name for reuse
+      glDeleteBuffers(1, &vertexBuffer);
 
       g_matrices.PopMatrix();
     }
@@ -241,6 +253,8 @@ void CGUIFontTTFGL::LastEnd()
     g_Windowing.ResetScissors();
     // Restore the original model view matrix
     glUniformMatrix4fv(modelLoc, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
+    // Unbind GL_ARRAY_BUFFER
+    glBindBuffer(GL_ARRAY_BUFFER, 0);
   }
 
   // Disable the attributes used by this shader
-- 
1.9.3


From 8366fd3f6c9169c6c7de4f0a25a26fe2d40bf476 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Wed, 15 Jan 2014 16:04:04 +0000
Subject: [PATCH 12/99] Move vertex data into an OpenGL VBO when the font cache
 entry is populated.

The font cache now stores the "name" (handle) of the VBO, rather than a vector
of vertices.
---
 xbmc/guilib/GUIFontCache.cpp |  6 ++++
 xbmc/guilib/GUIFontCache.h   | 30 +++++++++++++++++-
 xbmc/guilib/GUIFontTTF.cpp   | 15 +++++++--
 xbmc/guilib/GUIFontTTF.h     |  7 +++--
 xbmc/guilib/GUIFontTTFGL.cpp | 74 ++++++++++++++++++++++++++++++--------------
 xbmc/guilib/GUIFontTTFGL.h   |  5 +++
 6 files changed, 107 insertions(+), 30 deletions(-)

diff --git a/xbmc/guilib/GUIFontCache.cpp b/xbmc/guilib/GUIFontCache.cpp
index df466a5..bd84b9a 100644
--- a/xbmc/guilib/GUIFontCache.cpp
+++ b/xbmc/guilib/GUIFontCache.cpp
@@ -111,3 +111,9 @@ template void CGUIFontCacheEntry<CGUIFontCacheDynamicPosition, CGUIFontCacheDyna
 template CGUIFontCacheEntry<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue>::~CGUIFontCacheEntry();
 template CGUIFontCacheDynamicValue &CGUIFontCache<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue>::Lookup(CGUIFontCacheDynamicPosition &, const vecColors &, const vecText &, uint32_t, float, bool, unsigned int, bool &);
 template void CGUIFontCache<CGUIFontCacheDynamicPosition, CGUIFontCacheDynamicValue>::Flush();
+
+void CVertexBuffer::clear()
+{
+  if (m_font != NULL)
+    m_font->DestroyVertexBuffer(*this);
+}
diff --git a/xbmc/guilib/GUIFontCache.h b/xbmc/guilib/GUIFontCache.h
index d913dee..ff766bf 100644
--- a/xbmc/guilib/GUIFontCache.h
+++ b/xbmc/guilib/GUIFontCache.h
@@ -234,7 +234,35 @@ struct CGUIFontCacheDynamicPosition
   }
 };
 
-typedef std::vector<SVertex> CGUIFontCacheDynamicValue;
+struct CVertexBuffer
+{
+  void *bufferHandle;
+  size_t size;
+  CVertexBuffer() : bufferHandle(NULL), size(0), m_font(NULL) {}
+  CVertexBuffer(void *bufferHandle, size_t size, const CGUIFontTTFBase *font) : bufferHandle(bufferHandle), size(size), m_font(font) {}
+  CVertexBuffer(const CVertexBuffer &other) : bufferHandle(other.bufferHandle), size(other.size), m_font(other.m_font)
+  {
+    /* In practice, the copy constructor is only called before a vertex buffer
+     * has been attached. If this should ever change, we'll need another support
+     * function in GUIFontTTFGL/DX to duplicate a buffer, given its handle. */
+    assert(other.bufferHandle == 0);
+  }
+  CVertexBuffer &operator=(CVertexBuffer &other)
+  {
+    /* This is used with move-assignment semantics for initialising the object in the font cache */
+    assert(bufferHandle == 0);
+    bufferHandle = other.bufferHandle;
+    other.bufferHandle = 0;
+    size = other.size;
+    m_font = other.m_font;
+    return *this;
+  }
+  void clear();
+private:
+  const CGUIFontTTFBase *m_font;
+};
+
+typedef CVertexBuffer CGUIFontCacheDynamicValue;
 
 inline bool Match(const CGUIFontCacheDynamicPosition &a, const TransformMatrix &a_m,
                   const CGUIFontCacheDynamicPosition &b, const TransformMatrix &b_m,
diff --git a/xbmc/guilib/GUIFontTTF.cpp b/xbmc/guilib/GUIFontTTF.cpp
index 3ea1051..ea510f4 100644
--- a/xbmc/guilib/GUIFontTTF.cpp
+++ b/xbmc/guilib/GUIFontTTF.cpp
@@ -342,13 +342,18 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
                                               g_graphicsContext.ScaleFinalYCoord(x, y),
                                               g_graphicsContext.ScaleFinalZCoord(x, y));
   }
-  std::vector<SVertex> &vertices = hardwareClipping ?
+  CVertexBuffer unusedVertexBuffer;
+  CVertexBuffer &vertexBuffer = hardwareClipping ?
       m_dynamicCache.Lookup(dynamicPos,
                             colors, text,
                             alignment, maxPixelWidth,
                             scrolling,
                             XbmcThreads::SystemClockMillis(),
                             dirtyCache) :
+      unusedVertexBuffer;
+  std::vector<SVertex> tempVertices;
+  std::vector<SVertex> &vertices = hardwareClipping ?
+      tempVertices :
       m_staticCache.Lookup(staticPos,
                            colors, text,
                            alignment, maxPixelWidth,
@@ -458,10 +463,14 @@ void CGUIFontTTFBase::DrawTextInternal(float x, float y, const vecColors &colors
         cursorX += ch->advance;
     }
     if (hardwareClipping)
-      m_vertexTrans.push_back(CTranslatedVertices(0, 0, 0, &vertices, g_graphicsContext.GetClipRegion()));
+    {
+      CVertexBuffer newVertexBuffer = CreateVertexBuffer(tempVertices);
+      vertexBuffer = newVertexBuffer;
+      m_vertexTrans.push_back(CTranslatedVertices(0, 0, 0, &vertexBuffer, g_graphicsContext.GetClipRegion()));
+    }
   }
   else if (hardwareClipping)
-    m_vertexTrans.push_back(CTranslatedVertices(dynamicPos.m_x, dynamicPos.m_y, dynamicPos.m_z, &vertices, g_graphicsContext.GetClipRegion()));
+    m_vertexTrans.push_back(CTranslatedVertices(dynamicPos.m_x, dynamicPos.m_y, dynamicPos.m_z, &vertexBuffer, g_graphicsContext.GetClipRegion()));
   if (!hardwareClipping)
     /* Append the new vertices (from the cache or otherwise) to the set collected
      * since the first Begin() call */
diff --git a/xbmc/guilib/GUIFontTTF.h b/xbmc/guilib/GUIFontTTF.h
index a6931c1..9a35ac4 100644
--- a/xbmc/guilib/GUIFontTTF.h
+++ b/xbmc/guilib/GUIFontTTF.h
@@ -84,6 +84,9 @@ class CGUIFontTTFBase
 
   void Begin();
   void End();
+  /* The next two should only be called if we've declared we can do hardware clipping */
+  virtual CVertexBuffer CreateVertexBuffer(const std::vector<SVertex> &vertices) const { assert(false); return CVertexBuffer(); }
+  virtual void DestroyVertexBuffer(CVertexBuffer &bufferHandle) const {}
 
   const CStdString& GetFileName() const { return m_strFileName; };
 
@@ -166,9 +169,9 @@ class CGUIFontTTFBase
     float translateX;
     float translateY;
     float translateZ;
-    const std::vector<SVertex> *vertexBuffer;
+    const CVertexBuffer *vertexBuffer;
     CRect clip;
-    CTranslatedVertices(float translateX, float translateY, float translateZ, const std::vector<SVertex> *vertexBuffer, const CRect &clip) : translateX(translateX), translateY(translateY), translateZ(translateZ), vertexBuffer(vertexBuffer), clip(clip) {}
+    CTranslatedVertices(float translateX, float translateY, float translateZ, const CVertexBuffer *vertexBuffer, const CRect &clip) : translateX(translateX), translateY(translateY), translateZ(translateZ), vertexBuffer(vertexBuffer), clip(clip) {}
   };
   std::vector<CTranslatedVertices> m_vertexTrans;
   std::vector<SVertex> m_vertex;
diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index b00055d..aabb9a6 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -52,6 +52,10 @@ CGUIFontTTFGL::CGUIFontTTFGL(const CStdString& strFileName)
 
 CGUIFontTTFGL::~CGUIFontTTFGL(void)
 {
+  // It's important that all the CGUIFontCacheEntry objects are
+  // destructed before the CGUIFontTTFGL goes out of scope, because
+  // our virtual methods won't be accessible after this point
+  m_dynamicCache.Flush();
 }
 
 bool CGUIFontTTFGL::FirstBegin()
@@ -203,7 +207,6 @@ void CGUIFontTTFGL::LastEnd()
   if (m_vertexTrans.size() > 0)
   {
     // Deal with the vertices that can be hardware clipped and therefore translated
-    std::vector<SVertex> vecVertices;
     for (size_t i = 0; i < m_vertexTrans.size(); i++)
     {
       // Apply the clip rectangle
@@ -216,36 +219,17 @@ void CGUIFontTTFGL::LastEnd()
       g_matrices.Translatef(m_vertexTrans[i].translateX, m_vertexTrans[i].translateY, m_vertexTrans[i].translateZ);
       glUniformMatrix4fv(modelLoc, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
 
-      vecVertices.clear();
-      for (size_t j = 0; j < m_vertexTrans[i].vertexBuffer->size(); j += 4)
-      {
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j]);
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1]);
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2]);
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+1]);
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+3]);
-        vecVertices.push_back((*m_vertexTrans[i].vertexBuffer)[j+2]);
-      }
-      SVertex *vertices = &vecVertices[0];
-
-      // Generate a unique buffer object name and put it in vertexBuffer
-      GLuint vertexBuffer;
-      glGenBuffers(1, &vertexBuffer);
       // Bind the buffer to the OpenGL context's GL_ARRAY_BUFFER binding point
-      glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
-      // Create a data store for the buffer object bound to the GL_ARRAY_BUFFER
-      // binding point (i.e. our buffer object) and initialise it from the
-      // specified client-side pointer
-      glBufferData(GL_ARRAY_BUFFER, vecVertices.size() * sizeof *vertices, vertices, GL_STATIC_DRAW);
+      glBindBuffer(GL_ARRAY_BUFFER, (GLuint) m_vertexTrans[i].vertexBuffer->bufferHandle);
+
       // Set up the offsets of the various vertex attributes within the buffer
       // object bound to GL_ARRAY_BUFFER
       glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) offsetof(SVertex, x));
       glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE,  sizeof(SVertex), (GLvoid *) offsetof(SVertex, r));
       glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) offsetof(SVertex, u));
+
       // Do the actual drawing operation, using the full set of vertices in the buffer
-      glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
-      // Release the buffer name for reuse
-      glDeleteBuffers(1, &vertexBuffer);
+      glDrawArrays(GL_TRIANGLES, 0, 6 * m_vertexTrans[i].vertexBuffer->size);
 
       g_matrices.PopMatrix();
     }
@@ -266,6 +250,48 @@ void CGUIFontTTFGL::LastEnd()
 #endif
 }
 
+#if HAS_GLES
+CVertexBuffer CGUIFontTTFGL::CreateVertexBuffer(const std::vector<SVertex> &vertices) const
+{
+  // Rearrange the vertices to describe triangles
+  std::vector<SVertex> triangleVertices;
+  triangleVertices.reserve(vertices.size() * 6 / 4);
+  for (size_t i = 0; i < vertices.size(); i += 4)
+  {
+    triangleVertices.push_back(vertices[i]);
+    triangleVertices.push_back(vertices[i+1]);
+    triangleVertices.push_back(vertices[i+2]);
+    triangleVertices.push_back(vertices[i+1]);
+    triangleVertices.push_back(vertices[i+3]);
+    triangleVertices.push_back(vertices[i+2]);
+  }
+
+  // Generate a unique buffer object name and put it in bufferHandle
+  GLuint bufferHandle;
+  glGenBuffers(1, &bufferHandle);
+  // Bind the buffer to the OpenGL context's GL_ARRAY_BUFFER binding point
+  glBindBuffer(GL_ARRAY_BUFFER, bufferHandle);
+  // Create a data store for the buffer object bound to the GL_ARRAY_BUFFER
+  // binding point (i.e. our buffer object) and initialise it from the
+  // specified client-side pointer
+  glBufferData(GL_ARRAY_BUFFER, triangleVertices.size() * sizeof (SVertex), &triangleVertices[0], GL_STATIC_DRAW);
+  // Unbind GL_ARRAY_BUFFER
+  glBindBuffer(GL_ARRAY_BUFFER, 0);
+
+  return CVertexBuffer((void *) bufferHandle, vertices.size() / 4, this);
+}
+
+void CGUIFontTTFGL::DestroyVertexBuffer(CVertexBuffer &buffer) const
+{
+  if (buffer.bufferHandle != 0)
+  {
+    // Release the buffer name for reuse
+    glDeleteBuffers(1, (GLuint *) &buffer.bufferHandle);
+    buffer.bufferHandle = 0;
+  }
+}
+#endif
+
 CBaseTexture* CGUIFontTTFGL::ReallocTexture(unsigned int& newHeight)
 {
   newHeight = CBaseTexture::PadPow2(newHeight);
diff --git a/xbmc/guilib/GUIFontTTFGL.h b/xbmc/guilib/GUIFontTTFGL.h
index 735fb3a..6102c90 100644
--- a/xbmc/guilib/GUIFontTTFGL.h
+++ b/xbmc/guilib/GUIFontTTFGL.h
@@ -29,6 +29,7 @@
 
 
 #include "GUIFontTTF.h"
+#include "system.h"
 
 
 /*!
@@ -43,6 +44,10 @@ class CGUIFontTTFGL : public CGUIFontTTFBase
 
   virtual bool FirstBegin();
   virtual void LastEnd();
+#if HAS_GLES
+  virtual CVertexBuffer CreateVertexBuffer(const std::vector<SVertex> &vertices) const;
+  virtual void DestroyVertexBuffer(CVertexBuffer &bufferHandle) const;
+#endif
 
 protected:
   virtual CBaseTexture* ReallocTexture(unsigned int& newHeight);
-- 
1.9.3


From 3155d94b6163e8f9b5158721ae78e9af40b92ed0 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Thu, 16 Jan 2014 16:29:42 +0000
Subject: [PATCH 13/99] Switch from glDrawArrays() to glDrawElements().

This involves setting up a static VBO containing the indexes necessary to
convert from quads to triangles on the fly in the GPU.
---
 xbmc/guilib/GUIFontTTFGL.cpp        | 72 +++++++++++++++++++++++++------------
 xbmc/guilib/GUIFontTTFGL.h          | 11 +++++-
 xbmc/windowing/egl/WinSystemEGL.cpp | 17 +++++++++
 3 files changed, 77 insertions(+), 23 deletions(-)

diff --git a/xbmc/guilib/GUIFontTTFGL.cpp b/xbmc/guilib/GUIFontTTFGL.cpp
index aabb9a6..812662c 100644
--- a/xbmc/guilib/GUIFontTTFGL.cpp
+++ b/xbmc/guilib/GUIFontTTFGL.cpp
@@ -207,6 +207,10 @@ void CGUIFontTTFGL::LastEnd()
   if (m_vertexTrans.size() > 0)
   {
     // Deal with the vertices that can be hardware clipped and therefore translated
+
+    // Bind our pre-calculated array to GL_ELEMENT_ARRAY_BUFFER
+    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_elementArrayHandle);
+
     for (size_t i = 0; i < m_vertexTrans.size(); i++)
     {
       // Apply the clip rectangle
@@ -222,14 +226,21 @@ void CGUIFontTTFGL::LastEnd()
       // Bind the buffer to the OpenGL context's GL_ARRAY_BUFFER binding point
       glBindBuffer(GL_ARRAY_BUFFER, (GLuint) m_vertexTrans[i].vertexBuffer->bufferHandle);
 
-      // Set up the offsets of the various vertex attributes within the buffer
-      // object bound to GL_ARRAY_BUFFER
-      glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) offsetof(SVertex, x));
-      glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE,  sizeof(SVertex), (GLvoid *) offsetof(SVertex, r));
-      glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) offsetof(SVertex, u));
+      // Do the actual drawing operation, split into groups of characters no
+      // larger than the pre-determined size of the element array
+      for (size_t character = 0; m_vertexTrans[i].vertexBuffer->size > character; character += ELEMENT_ARRAY_MAX_CHAR_INDEX)
+      {
+        size_t count = m_vertexTrans[i].vertexBuffer->size - character;
+        count = std::min<size_t>(count, ELEMENT_ARRAY_MAX_CHAR_INDEX);
+
+        // Set up the offsets of the various vertex attributes within the buffer
+        // object bound to GL_ARRAY_BUFFER
+        glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) (character*sizeof(SVertex)*4 + offsetof(SVertex, x)));
+        glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE,  sizeof(SVertex), (GLvoid *) (character*sizeof(SVertex)*4 + offsetof(SVertex, r)));
+        glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(SVertex), (GLvoid *) (character*sizeof(SVertex)*4 + offsetof(SVertex, u)));
 
-      // Do the actual drawing operation, using the full set of vertices in the buffer
-      glDrawArrays(GL_TRIANGLES, 0, 6 * m_vertexTrans[i].vertexBuffer->size);
+        glDrawElements(GL_TRIANGLES, 6 * count, GL_UNSIGNED_SHORT, 0);
+      }
 
       g_matrices.PopMatrix();
     }
@@ -237,8 +248,9 @@ void CGUIFontTTFGL::LastEnd()
     g_Windowing.ResetScissors();
     // Restore the original model view matrix
     glUniformMatrix4fv(modelLoc, 1, GL_FALSE, g_matrices.GetMatrix(MM_MODELVIEW));
-    // Unbind GL_ARRAY_BUFFER
+    // Unbind GL_ARRAY_BUFFER and GL_ELEMENT_ARRAY_BUFFER
     glBindBuffer(GL_ARRAY_BUFFER, 0);
+    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
   }
 
   // Disable the attributes used by this shader
@@ -253,19 +265,6 @@ void CGUIFontTTFGL::LastEnd()
 #if HAS_GLES
 CVertexBuffer CGUIFontTTFGL::CreateVertexBuffer(const std::vector<SVertex> &vertices) const
 {
-  // Rearrange the vertices to describe triangles
-  std::vector<SVertex> triangleVertices;
-  triangleVertices.reserve(vertices.size() * 6 / 4);
-  for (size_t i = 0; i < vertices.size(); i += 4)
-  {
-    triangleVertices.push_back(vertices[i]);
-    triangleVertices.push_back(vertices[i+1]);
-    triangleVertices.push_back(vertices[i+2]);
-    triangleVertices.push_back(vertices[i+1]);
-    triangleVertices.push_back(vertices[i+3]);
-    triangleVertices.push_back(vertices[i+2]);
-  }
-
   // Generate a unique buffer object name and put it in bufferHandle
   GLuint bufferHandle;
   glGenBuffers(1, &bufferHandle);
@@ -274,7 +273,7 @@ CVertexBuffer CGUIFontTTFGL::CreateVertexBuffer(const std::vector<SVertex> &vert
   // Create a data store for the buffer object bound to the GL_ARRAY_BUFFER
   // binding point (i.e. our buffer object) and initialise it from the
   // specified client-side pointer
-  glBufferData(GL_ARRAY_BUFFER, triangleVertices.size() * sizeof (SVertex), &triangleVertices[0], GL_STATIC_DRAW);
+  glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof (SVertex), &vertices[0], GL_STATIC_DRAW);
   // Unbind GL_ARRAY_BUFFER
   glBindBuffer(GL_ARRAY_BUFFER, 0);
 
@@ -393,4 +392,33 @@ void CGUIFontTTFGL::DeleteHardwareTexture()
   }
 }
 
+#if HAS_GLES
+void CGUIFontTTFGL::CreateStaticVertexBuffers(void)
+{
+  // Bind a new buffer to the OpenGL context's GL_ELEMENT_ARRAY_BUFFER binding point
+  glGenBuffers(1, &m_elementArrayHandle);
+  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_elementArrayHandle);
+  // Create an array holding the mesh indices to convert quads to triangles
+  GLushort index[ELEMENT_ARRAY_MAX_CHAR_INDEX][6];
+  for (size_t i = 0; i < ELEMENT_ARRAY_MAX_CHAR_INDEX; i++)
+  {
+    index[i][0] = 4*i;
+    index[i][1] = 4*i+1;
+    index[i][2] = 4*i+2;
+    index[i][3] = 4*i+1;
+    index[i][4] = 4*i+3;
+    index[i][5] = 4*i+2;
+  }
+  glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof index, index, GL_STATIC_DRAW);
+  glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
+}
+
+void CGUIFontTTFGL::DestroyStaticVertexBuffers(void)
+{
+  glDeleteBuffers(1, &m_elementArrayHandle);
+}
+
+GLuint CGUIFontTTFGL::m_elementArrayHandle;
+#endif
+
 #endif
diff --git a/xbmc/guilib/GUIFontTTFGL.h b/xbmc/guilib/GUIFontTTFGL.h
index 6102c90..dcf9ca1 100644
--- a/xbmc/guilib/GUIFontTTFGL.h
+++ b/xbmc/guilib/GUIFontTTFGL.h
@@ -30,6 +30,7 @@
 
 #include "GUIFontTTF.h"
 #include "system.h"
+#include "system_gl.h"
 
 
 /*!
@@ -47,13 +48,21 @@ class CGUIFontTTFGL : public CGUIFontTTFBase
 #if HAS_GLES
   virtual CVertexBuffer CreateVertexBuffer(const std::vector<SVertex> &vertices) const;
   virtual void DestroyVertexBuffer(CVertexBuffer &bufferHandle) const;
+  static void CreateStaticVertexBuffers(void);
+  static void DestroyStaticVertexBuffers(void);
 #endif
 
 protected:
   virtual CBaseTexture* ReallocTexture(unsigned int& newHeight);
   virtual bool CopyCharToTexture(FT_BitmapGlyph bitGlyph, unsigned int x1, unsigned int y1, unsigned int x2, unsigned int y2);
   virtual void DeleteHardwareTexture();
-    
+
+#if HAS_GLES
+#define ELEMENT_ARRAY_MAX_CHAR_INDEX (1000)
+
+  static GLuint m_elementArrayHandle;
+#endif
+
 private:
   unsigned int m_updateY1;
   unsigned int m_updateY2;
diff --git a/xbmc/windowing/egl/WinSystemEGL.cpp b/xbmc/windowing/egl/WinSystemEGL.cpp
index 6de3532..258a293 100644
--- a/xbmc/windowing/egl/WinSystemEGL.cpp
+++ b/xbmc/windowing/egl/WinSystemEGL.cpp
@@ -29,6 +29,7 @@
 #include "settings/AdvancedSettings.h"
 #include "settings/Settings.h"
 #include "settings/DisplaySettings.h"
+#include "guilib/GUIFontTTFGL.h"
 #include "utils/log.h"
 #include "EGLWrapper.h"
 #include "EGLQuirks.h"
@@ -193,6 +194,9 @@ bool CWinSystemEGL::CreateWindow(RESOLUTION_INFO &res)
     return false;
   }
 
+#if HAS_GLES
+  bool newContext = false;
+#endif
   if (m_context == EGL_NO_CONTEXT)
   {
     if (!m_egl->CreateContext(m_display, m_config, contextAttrs, &m_context))
@@ -200,6 +204,9 @@ bool CWinSystemEGL::CreateWindow(RESOLUTION_INFO &res)
       CLog::Log(LOGERROR, "%s: Could not create context",__FUNCTION__);
       return false;
     }
+#if HAS_GLES
+    newContext = true;
+#endif
   }
 
   if (!m_egl->BindContext(m_display, m_surface, m_context))
@@ -208,6 +215,11 @@ bool CWinSystemEGL::CreateWindow(RESOLUTION_INFO &res)
     return false;
   }
 
+#if HAS_GLES
+  if (newContext)
+    CGUIFontTTFGL::CreateStaticVertexBuffers();
+#endif
+
   // for the non-trivial dirty region modes, we need the EGL buffer to be preserved across updates
   if (g_advancedSettings.m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_COST_REDUCTION ||
       g_advancedSettings.m_guiAlgorithmDirtyRegions == DIRTYREGION_SOLVER_UNION)
@@ -229,7 +241,12 @@ bool CWinSystemEGL::DestroyWindowSystem()
   DestroyWindow();
 
   if (m_context != EGL_NO_CONTEXT)
+  {
+#if HAS_GLES
+    CGUIFontTTFGL::DestroyStaticVertexBuffers();
+#endif
     m_egl->DestroyContext(m_display, m_context);
+  }
   m_context = EGL_NO_CONTEXT;
 
   if (m_display != EGL_NO_DISPLAY)
-- 
1.9.3


From 5c5d8889a0feb1914a4dfb7435df56a81e2ac887 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 10 Jan 2014 12:10:43 +0000
Subject: [PATCH 14/99] [rbp] Don't override dvdplayer with omxplayer.

Using dvdplayer can be useful on the Pi. We can actually play sd (up to 640x480 MPEG-4 video) video in real time.
This is useful for codec variants like DivX3 which we don't currently play.

This may expose bugs where dvdplayer is incorrectly used as the default player which will need to be fixed
---
 xbmc/cores/playercorefactory/PlayerCoreConfig.h | 7 -------
 1 file changed, 7 deletions(-)

diff --git a/xbmc/cores/playercorefactory/PlayerCoreConfig.h b/xbmc/cores/playercorefactory/PlayerCoreConfig.h
index 9524f94..2789bd8 100644
--- a/xbmc/cores/playercorefactory/PlayerCoreConfig.h
+++ b/xbmc/cores/playercorefactory/PlayerCoreConfig.h
@@ -88,14 +88,7 @@ friend class CPlayerCoreFactory;
     {
       case EPC_MPLAYER:
       // TODO: this hack needs removal until we have a better player selection
-#if defined(HAS_OMXPLAYER)
-      case EPC_DVDPLAYER: 
-        pPlayer = new COMXPlayer(callback); 
-        CLog::Log(LOGINFO, "Created player %s for core %d / OMXPlayer forced as DVDPlayer", "OMXPlayer", m_eCore);
-        break;
-#else
       case EPC_DVDPLAYER: pPlayer = new CDVDPlayer(callback); break;
-#endif
       case EPC_PAPLAYER: pPlayer = new PAPlayer(callback); break;
       case EPC_EXTPLAYER: pPlayer = new CExternalPlayer(callback); break;
 #if defined(HAS_OMXPLAYER)
-- 
1.9.3


From 0f194812cc12c1ef74845f2512174ca138cf4674 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 10 Jan 2014 15:37:41 +0000
Subject: [PATCH 15/99] [players] Use default players rather than hard coded
 DVDPlayer/PAPlayer

---
 system/playercorefactory.xml | 23 ++++++++++++-----------
 1 file changed, 12 insertions(+), 11 deletions(-)

diff --git a/system/playercorefactory.xml b/system/playercorefactory.xml
index 57dfcdd..7be9799 100644
--- a/system/playercorefactory.xml
+++ b/system/playercorefactory.xml
@@ -11,31 +11,32 @@
   </players>
 
   <rules name="system rules">
-    <rule name="rtv" protocols="rtv" player="DVDPlayer" />
-    <rule name="hdhomerun/myth/mms/udp" protocols="hdhomerun|myth|cmyth|mms|mmsh|udp" player="DVDPlayer" />
-    <rule name="lastfm/shout" protocols="lastfm|shout" player="PAPlayer" />
+    <rule name="rtv" protocols="rtv" player="videodefaultplayer" />
+    <rule name="hdhomerun/myth/mms/udp" protocols="hdhomerun|myth|cmyth|mms|mmsh|udp" player="videodefaultplayer" />
+    <rule name="lastfm/shout" protocols="lastfm|shout" player="audiodefaultplayer" />
     <rule name="rtmp" protocols="rtmp" player="videodefaultplayer" />
 
     <!-- dvdplayer can play standard rtsp streams -->
-    <rule name="rtsp" protocols="rtsp" filetypes="!(rm|ra)"  player="PAPlayer" />
+    <rule name="rtsp" protocols="rtsp" filetypes="!(rm|ra)"  player="audiodefaultplayer" />
 
     <!-- Internet streams -->
     <rule name="streams" internetstream="true">
-      <rule name="aacp/sdp" mimetypes="audio/aacp|application/sdp" player="DVDPlayer" />
-      <rule name="mp2" mimetypes="application/octet-stream" filetypes="mp2" player="PAPlayer" />
+      <rule name="aacp/sdp" mimetypes="audio/aacp|application/sdp" player="videodefaultplayer" />
+      <rule name="mp2" mimetypes="application/octet-stream" filetypes="mp2" player="audiodefaultplayer" />
     </rule>
 
     <!-- DVDs -->
-    <rule name="dvd" dvd="true" player="DVDPlayer" />
-    <rule name="dvdimage" dvdimage="true" player="DVDPlayer" />
+    <rule name="dvd" dvd="true" player="videodefaultdvdplayer" />
+    <rule name="dvdfile" dvdfile="true" player="videodefaultdvdplayer" />
+    <rule name="dvdimage" dvdimage="true" player="videodefaultdvdplayer" />
 
     <!-- Only dvdplayer can handle these normally -->
-    <rule name="sdp/asf" filetypes="sdp|asf" player="DVDPlayer" />
+    <rule name="sdp/asf" filetypes="sdp|asf" player="videodefaultplayer" />
 
     <!-- Pass these to dvdplayer as we do not know if they are audio or video -->
-    <rule name="nsv" filetypes="nsv" player="DVDPlayer" />
+    <rule name="nsv" filetypes="nsv" player="videodefaultplayer" />
 
     <!-- pvr radio channels should be played by dvdplayer because they need buffering -->
-    <rule name="radio" filetypes="pvr" filename=".*/radio/.*" player="DVDPlayer" />
+    <rule name="radio" filetypes="pvr" filename=".*/radio/.*" player="videodefaultplayer" />
   </rules>
 </playercorefactory>
-- 
1.9.3


From 49897fff3b04a7ac092e874a55c26476bf915143 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 11 Jan 2014 18:23:42 +0000
Subject: [PATCH 16/99] [rbp] Don't force dvdplayer for airplay

---
 xbmc/network/AirPlayServer.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/network/AirPlayServer.cpp b/xbmc/network/AirPlayServer.cpp
index 80ea552..497898f 100644
--- a/xbmc/network/AirPlayServer.cpp
+++ b/xbmc/network/AirPlayServer.cpp
@@ -903,9 +903,11 @@ int CAirPlayServer::CTCPClient::ProcessRequest( std::string& responseHeader,
       CFileItem fileToPlay(location, false);
       fileToPlay.SetProperty("StartPercent", position*100.0f);
       ServerInstance->AnnounceToClients(EVENT_LOADING);
+#ifndef TARGET_RASPBERRY_PI
       // froce to internal dvdplayer cause it is the only
       // one who will work well with airplay
       g_application.m_eForcedNextPlayer = EPC_DVDPLAYER;
+#endif
       CApplicationMessenger::Get().MediaPlay(fileToPlay);
     }
   }
-- 
1.9.3


From 9e7232aeed1265d898b016dee2ec1198c1d12c1a Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 13 Jan 2014 13:11:06 +0000
Subject: [PATCH 17/99] [rbp] Give plugins omxplayer when they request
 dvdplayer on pi

---
 xbmc/interfaces/legacy/ModuleXbmc.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/interfaces/legacy/ModuleXbmc.cpp b/xbmc/interfaces/legacy/ModuleXbmc.cpp
index dfdca99..2a819ef 100644
--- a/xbmc/interfaces/legacy/ModuleXbmc.cpp
+++ b/xbmc/interfaces/legacy/ModuleXbmc.cpp
@@ -527,7 +527,11 @@ namespace XBMCAddon
     int getPLAYLIST_MUSIC() { return PLAYLIST_MUSIC; }
     int getPLAYLIST_VIDEO() { return PLAYLIST_VIDEO; }
     int getPLAYER_CORE_AUTO() { return EPC_NONE; }
+#ifdef TARGET_RASPBERRY_PI
+    int getPLAYER_CORE_DVDPLAYER() { return EPC_OMXPLAYER; }
+#else
     int getPLAYER_CORE_DVDPLAYER() { return EPC_DVDPLAYER; }
+#endif
     int getPLAYER_CORE_MPLAYER() { return EPC_MPLAYER; }
     int getPLAYER_CORE_PAPLAYER() { return EPC_PAPLAYER; }
     int getTRAY_OPEN() { return TRAY_OPEN; }
-- 
1.9.3


From 66715e35594eb121f33df1e4793ed7497ed53284 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 14 Jan 2014 18:04:07 +0000
Subject: [PATCH 18/99] [rbp] Allow ALSA to be chosen in addition to Pi sink

Needs --enable-alsa in ./configure step and alsa support on platform
---
 configure.in                             |  1 -
 tools/depends/target/Makefile            |  5 +++--
 xbmc/cores/AudioEngine/AESinkFactory.cpp | 15 ++++++++++++++-
 3 files changed, 17 insertions(+), 4 deletions(-)

diff --git a/configure.in b/configure.in
index 83687bb..43e1f82 100644
--- a/configure.in
+++ b/configure.in
@@ -693,7 +693,6 @@ case $use_platform in
      use_arch="arm"
      use_cpu=arm1176jzf-s
      use_hardcoded_tables="yes"
-     use_alsa="no"
      ARCH="arm"
      AC_DEFINE(HAS_EGLGLES, [1], [Define if supporting EGL based GLES Framebuffer])
      USE_OMXLIB=1; AC_DEFINE([HAVE_OMXLIB],[1],["Define to 1 if OMX libs is enabled"])
diff --git a/tools/depends/target/Makefile b/tools/depends/target/Makefile
index fce60df..8a3858e 100644
--- a/tools/depends/target/Makefile
+++ b/tools/depends/target/Makefile
@@ -58,10 +58,11 @@ LINUX_SYSTEM_LIBS=
 ifeq ($(OS),linux)
   #not for raspberry pi
   ifneq ($(TARGET_PLATFORM),raspberry-pi)
-    DEPENDS += alsa-lib libsdl linux-system-libs
-    ALSA_LIB = alsa-lib
+    DEPENDS += libsdl linux-system-libs
     LINUX_SYSTEM_LIBS = linux-system-libs
   endif
+  DEPENDS += alsa-lib
+  ALSA_LIB = alsa-lib
   FFMPEG_DEPENDS = gnutls
 endif
 
diff --git a/xbmc/cores/AudioEngine/AESinkFactory.cpp b/xbmc/cores/AudioEngine/AESinkFactory.cpp
index e42d973..715b4f1 100644
--- a/xbmc/cores/AudioEngine/AESinkFactory.cpp
+++ b/xbmc/cores/AudioEngine/AESinkFactory.cpp
@@ -27,6 +27,7 @@
   #include "Sinks/AESinkAUDIOTRACK.h"
 #elif defined(TARGET_RASPBERRY_PI)
   #include "Sinks/AESinkPi.h"
+  #include "Sinks/AESinkALSA.h"
 #elif defined(TARGET_DARWIN_IOS)
   #include "Sinks/AESinkDARWINIOS.h"
 #elif defined(TARGET_DARWIN_OSX)
@@ -66,6 +67,7 @@ void CAESinkFactory::ParseDevice(std::string &device, std::string &driver)
         driver == "AUDIOTRACK"  ||
 #elif defined(TARGET_RASPBERRY_PI)
         driver == "PI"          ||
+        driver == "ALSA"        ||
 #elif defined(TARGET_DARWIN_IOS)
         driver == "DARWINIOS"  ||
 #elif defined(TARGET_DARWIN_OSX)
@@ -105,7 +107,12 @@ IAESink *CAESinkFactory::TrySink(std::string &driver, std::string &device, AEAud
 #elif defined(TARGET_ANDROID)
     sink = new CAESinkAUDIOTRACK();
 #elif defined(TARGET_RASPBERRY_PI)
+  if (driver == "PI")
     sink = new CAESinkPi();
+  #if defined(HAS_ALSA)
+  if (driver == "ALSA")
+    sink = new CAESinkALSA();
+  #endif
 #elif defined(TARGET_DARWIN_IOS)
     sink = new CAESinkDARWINIOS();
 #elif defined(TARGET_DARWIN_OSX)
@@ -196,7 +203,13 @@ void CAESinkFactory::EnumerateEx(AESinkInfoList &list, bool force)
   CAESinkPi::EnumerateDevicesEx(info.m_deviceInfoList, force);
   if(!info.m_deviceInfoList.empty())
     list.push_back(info);
-
+  #if defined(HAS_ALSA)
+  info.m_deviceInfoList.clear();
+  info.m_sinkName = "ALSA";
+  CAESinkALSA::EnumerateDevicesEx(info.m_deviceInfoList, force);
+  if(!info.m_deviceInfoList.empty())
+    list.push_back(info);
+  #endif
 #elif defined(TARGET_DARWIN_IOS)
 
   info.m_deviceInfoList.clear();
-- 
1.9.3


From 0999497d6452e83ab5e708d871b5ee2d4866a68a Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 16 Jan 2014 01:39:29 +0000
Subject: [PATCH 19/99] [omxcodec] Add hardware decode to dvdplayer for Pi

Hijack the abandoned OpenMaxVideo codec
---
 configure.in                                       |   21 +-
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp    |   12 +-
 xbmc/cores/VideoRenderers/LinuxRendererGLES.h      |    6 +-
 xbmc/cores/VideoRenderers/RenderManager.cpp        |    2 +-
 xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp |    7 +-
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodec.h      |    7 +-
 .../DVDCodecs/Video/DVDVideoCodecOpenMax.cpp       |  295 +---
 .../DVDCodecs/Video/DVDVideoCodecOpenMax.h         |   34 +-
 xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in   |    1 -
 .../dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp     | 1418 ++++++++++----------
 .../cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h |  120 +-
 xbmc/cores/dvdplayer/DVDPlayer.cpp                 |    2 +
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp            |   21 +-
 xbmc/linux/OMXCore.cpp                             |   45 +-
 xbmc/linux/OMXCore.h                               |    2 +-
 15 files changed, 894 insertions(+), 1099 deletions(-)

diff --git a/configure.in b/configure.in
index 43e1f82..fb73c5f 100644
--- a/configure.in
+++ b/configure.in
@@ -1925,9 +1925,24 @@ if test "$host_vendor" = "apple" ; then
   USE_OPENMAX=0
   AC_MSG_NOTICE($openmax_disabled)
 elif test "$target_platform" = "target_raspberry_pi"; then
-  use_openmax="no"
-  USE_OPENMAX=0
-  AC_MSG_NOTICE($openmax_disabled)
+  if test "$use_gles" = "yes" && test "$use_openmax" = "auto"; then
+    use_openmax="yes"
+    USE_OPENMAX=1
+    HAVE_LIBOPENMAX=1
+    AC_DEFINE([HAVE_LIBOPENMAX], [1], [Define to 1 if you have the 'LIBOPENMAX' library.])
+    AC_DEFINE([OMX_SKIP64BIT], [1], [Define to 1 if you have the 'LIBOPENMAX' library.])
+    AC_MSG_NOTICE($openmax_enabled)
+  elif test "$use_gles" = "yes" && test "$use_openmax" = "yes"; then
+    use_openmax="yes"
+    USE_OPENMAX=1
+    HAVE_LIBOPENMAX=1
+    AC_DEFINE([HAVE_LIBOPENMAX], [1], [Define to 1 if you have the 'LIBOPENMAX' library.])
+    AC_MSG_NOTICE($openmax_enabled)
+  else
+    AC_MSG_NOTICE($openmax_disabled)
+    use_openmax=no
+    USE_OPENMAX=0
+  fi
 else
   if test "$use_gles" = "yes" && test "$use_openmax" = "auto"; then
     PKG_CHECK_MODULES([OPENMAX], [libomxil-bellagio],
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index 72eb725..2e0d0ca 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -44,7 +44,7 @@
 #include "VideoShaders/VideoFilterShader.h"
 #include "windowing/WindowingFactory.h"
 #include "guilib/Texture.h"
-#include "../dvdplayer/DVDCodecs/Video/OpenMaxVideo.h"
+#include "DVDCodecs/Video/OpenMaxVideo.h"
 #include "threads/SingleLock.h"
 #include "RenderCapture.h"
 #include "RenderFormats.h"
@@ -1328,6 +1328,10 @@ void CLinuxRendererGLES::RenderOpenMax(int index, int field)
   glActiveTexture(GL_TEXTURE0);
   glBindTexture(m_textureTarget, textureId);
 
+  GLint filter = m_scalingMethod == VS_SCALINGMETHOD_NEAREST ? GL_NEAREST : GL_LINEAR;
+  glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, filter);
+  glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, filter);
+
   g_Windowing.EnableGUIShader(SM_TEXTURE_RGBA);
 
   GLubyte idx[4] = {0, 1, 3, 2};        //determines order of triangle strip
@@ -2674,10 +2678,12 @@ unsigned int CLinuxRendererGLES::GetProcessorSize()
 }
 
 #ifdef HAVE_LIBOPENMAX
-void CLinuxRendererGLES::AddProcessor(COpenMax* openMax, DVDVideoPicture *picture, int index)
+void CLinuxRendererGLES::AddProcessor(COpenMaxVideoBuffer *openMaxBuffer, int index)
 {
   YUVBUFFER &buf = m_buffers[index];
-  buf.openMaxBuffer = picture->openMaxBuffer;
+  COpenMaxVideoBuffer *pic = openMaxBuffer->Acquire();
+  SAFE_RELEASE(buf.openMaxBuffer);
+  buf.openMaxBuffer = pic;
 }
 #endif
 #ifdef HAVE_VIDEOTOOLBOXDECODER
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
index 642cded..5a6a2be 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
@@ -39,7 +39,7 @@ class CRenderCapture;
 class CBaseTexture;
 namespace Shaders { class BaseYUV2RGBShader; }
 namespace Shaders { class BaseVideoFilterShader; }
-class COpenMaxVideo;
+class COpenMaxVideoBuffer;
 class CDVDVideoCodecStageFright;
 class CDVDMediaCodecInfo;
 typedef std::vector<int>     Features;
@@ -158,7 +158,7 @@ class CLinuxRendererGLES : public CBaseRenderer
   virtual std::vector<ERenderFormat> SupportedFormats() { return m_formats; }
 
 #ifdef HAVE_LIBOPENMAX
-  virtual void         AddProcessor(COpenMax* openMax, DVDVideoPicture *picture, int index);
+  virtual void         AddProcessor(COpenMaxVideoBuffer *openMaxVideoBuffer, int index);
 #endif
 #ifdef HAVE_VIDEOTOOLBOXDECODER
   virtual void         AddProcessor(struct __CVBuffer *cvBufferRef, int index);
@@ -272,7 +272,7 @@ class CLinuxRendererGLES : public CBaseRenderer
     unsigned  flipindex; /* used to decide if this has been uploaded */
 
 #ifdef HAVE_LIBOPENMAX
-    OpenMaxVideoBuffer *openMaxBuffer;
+    COpenMaxVideoBuffer *openMaxBuffer;
 #endif
 #ifdef HAVE_VIDEOTOOLBOXDECODER
     struct __CVBuffer *cvBufferRef;
diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index b6fb1a3..be3ce46 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -914,7 +914,7 @@ int CXBMCRenderManager::AddVideoPicture(DVDVideoPicture& pic)
 #endif
 #ifdef HAVE_LIBOPENMAX
   else if(pic.format == RENDER_FMT_OMXEGL)
-    m_pRenderer->AddProcessor(pic.openMax, &pic, index);
+    m_pRenderer->AddProcessor(pic.openMaxBuffer, index);
 #endif
 #ifdef TARGET_DARWIN
   else if(pic.format == RENDER_FMT_CVBREF)
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
index 32d58d4..d58067c 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
@@ -268,9 +268,12 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, unsigne
 #endif
 
 #if defined(HAVE_LIBOPENMAX)
-  if (CSettings::Get().GetBool("videoplayer.useomx") && !hint.software )
+  if (!hint.software && CSettings::Get().GetBool("videoplayer.useomx"))
   {
-      if (hint.codec == AV_CODEC_ID_H264 || hint.codec == AV_CODEC_ID_MPEG2VIDEO || hint.codec == AV_CODEC_ID_VC1)
+    if (hint.codec == AV_CODEC_ID_H264 || hint.codec == AV_CODEC_ID_H263 || hint.codec == AV_CODEC_ID_MPEG4 ||
+        hint.codec == AV_CODEC_ID_MPEG1VIDEO || hint.codec == AV_CODEC_ID_MPEG2VIDEO ||
+        hint.codec == AV_CODEC_ID_VP6 || hint.codec == AV_CODEC_ID_VP6F || hint.codec == AV_CODEC_ID_VP6A || hint.codec == AV_CODEC_ID_VP8 ||
+        hint.codec == AV_CODEC_ID_THEORA || hint.codec == AV_CODEC_ID_MJPEG || hint.codec == AV_CODEC_ID_MJPEGB || hint.codec == AV_CODEC_ID_VC1 || hint.codec == AV_CODEC_ID_WMV3)
     {
       if ( (pCodec = OpenCodec(new CDVDVideoCodecOpenMax(), hint, options)) ) return pCodec;
     }
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
index 741017d..7daed00 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
@@ -48,9 +48,7 @@ struct DVDCodecAvailableType
 namespace DXVA { class CSurfaceContext; }
 namespace VAAPI { struct CHolder; }
 namespace VDPAU { class CVdpauRenderPicture; }
-class COpenMax;
-class COpenMaxVideo;
-struct OpenMaxVideoBuffer;
+class COpenMaxVideoBuffer;
 class CDVDVideoCodecStageFright;
 class CDVDMediaCodecInfo;
 typedef void* EGLImageKHR;
@@ -79,8 +77,7 @@ struct DVDVideoPicture
     };
 
     struct {
-      COpenMax *openMax;
-      OpenMaxVideoBuffer *openMaxBuffer;
+      COpenMaxVideoBuffer *openMaxBuffer;
     };
 
     struct {
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
index b2e7816..7d33192 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
@@ -29,113 +29,43 @@
 #include "DVDStreamInfo.h"
 #include "DVDVideoCodecOpenMax.h"
 #include "OpenMaxVideo.h"
+#include "settings/Settings.h"
 #include "utils/log.h"
 
-#define CLASSNAME "COpenMax"
+#define CLASSNAME "CDVDVideoCodecOpenMax"
 ////////////////////////////////////////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////////////////////////////////////////
-CDVDVideoCodecOpenMax::CDVDVideoCodecOpenMax() : CDVDVideoCodec()
+CDVDVideoCodecOpenMax::CDVDVideoCodecOpenMax()
 {
   m_omx_decoder = NULL;
-  m_pFormatName = "omx-xxxx";
-
-  m_convert_bitstream = false;
-  memset(&m_videobuffer, 0, sizeof(DVDVideoPicture));
+  CLog::Log(LOGDEBUG, "%s::%s %p\n", CLASSNAME, __func__, this);
 }
 
 CDVDVideoCodecOpenMax::~CDVDVideoCodecOpenMax()
 {
+  CLog::Log(LOGDEBUG, "%s::%s %p\n", CLASSNAME, __func__, this);
   Dispose();
 }
 
 bool CDVDVideoCodecOpenMax::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
-  // we always qualify even if DVDFactoryCodec does this too.
-  if (CSettings::Get().GetBool("videoplayer.useomx") && !hints.software)
-  {
-    m_convert_bitstream = false;
-
-    switch (hints.codec)
-    {
-      case AV_CODEC_ID_H264:
-      {
-        m_pFormatName = "omx-h264";
-        if (hints.extrasize < 7 || hints.extradata == NULL)
-        {
-          CLog::Log(LOGNOTICE,
-            "%s::%s - avcC data too small or missing", CLASSNAME, __func__);
-          return false;
-        }
-        // valid avcC data (bitstream) always starts with the value 1 (version)
-        if ( *(char*)hints.extradata == 1 )
-          m_convert_bitstream = bitstream_convert_init(hints.extradata, hints.extrasize);
-      }
-      break;
-      case AV_CODEC_ID_MPEG4:
-        m_pFormatName = "omx-mpeg4";
-      break;
-      case AV_CODEC_ID_MPEG2VIDEO:
-        m_pFormatName = "omx-mpeg2";
-      break;
-      case AV_CODEC_ID_VC1:
-        m_pFormatName = "omx-vc1";
-      break;
-      default:
-        return false;
-      break;
-    }
-
-    m_omx_decoder = new COpenMaxVideo;
-    if (!m_omx_decoder->Open(hints))
-    {
-      CLog::Log(LOGERROR,
-        "%s::%s - failed to open, codec(%d), profile(%d), level(%d)", 
-        CLASSNAME, __func__, hints.codec, hints.profile, hints.level);
-      return false;
-    }
-
-    // allocate a YV12 DVDVideoPicture buffer.
-    // first make sure all properties are reset.
-    memset(&m_videobuffer, 0, sizeof(DVDVideoPicture));
-
-    m_videobuffer.dts = DVD_NOPTS_VALUE;
-    m_videobuffer.pts = DVD_NOPTS_VALUE;
-    //m_videobuffer.format = RENDER_FMT_YUV420P;
-    m_videobuffer.format = RENDER_FMT_OMXEGL;
-    m_videobuffer.color_range  = 0;
-    m_videobuffer.color_matrix = 4;
-    m_videobuffer.iFlags  = DVP_FLAG_ALLOCATED;
-    m_videobuffer.iWidth  = hints.width;
-    m_videobuffer.iHeight = hints.height;
-    m_videobuffer.iDisplayWidth  = hints.width;
-    m_videobuffer.iDisplayHeight = hints.height;
-
-    return true;
-  }
+  m_omx_decoder = new COpenMaxVideo;
+  return m_omx_decoder->Open(hints, options);
+}
 
-  return false;
+const char* CDVDVideoCodecOpenMax::GetName(void)
+{
+  return m_omx_decoder ? m_omx_decoder->GetName() : "omx-xxx";
 }
 
 void CDVDVideoCodecOpenMax::Dispose()
 {
   if (m_omx_decoder)
   {
-    m_omx_decoder->Close();
+    m_omx_decoder->Dispose();
     delete m_omx_decoder;
     m_omx_decoder = NULL;
   }
-  if (m_videobuffer.iFlags & DVP_FLAG_ALLOCATED)
-  {
-    m_videobuffer.iFlags = 0;
-  }
-  if (m_convert_bitstream)
-  {
-    if (m_sps_pps_context.sps_pps_data)
-    {
-      free(m_sps_pps_context.sps_pps_data);
-      m_sps_pps_context.sps_pps_data = NULL;
-    }
-  }
 }
 
 void CDVDVideoCodecOpenMax::SetDropState(bool bDrop)
@@ -145,37 +75,12 @@ void CDVDVideoCodecOpenMax::SetDropState(bool bDrop)
 
 int CDVDVideoCodecOpenMax::Decode(uint8_t* pData, int iSize, double dts, double pts)
 {
-  if (pData)
-  {
-    int rtn;
-    int demuxer_bytes = iSize;
-    uint8_t *demuxer_content = pData;
-    bool bitstream_convered  = false;
-
-    if (m_convert_bitstream)
-    {
-      // convert demuxer packet from bitstream to bytestream (AnnexB)
-      int bytestream_size = 0;
-      uint8_t *bytestream_buff = NULL;
-
-      bitstream_convert(demuxer_content, demuxer_bytes, &bytestream_buff, &bytestream_size);
-      if (bytestream_buff && (bytestream_size > 0))
-      {
-        bitstream_convered = true;
-        demuxer_bytes = bytestream_size;
-        demuxer_content = bytestream_buff;
-      }
-    }
-
-    rtn = m_omx_decoder->Decode(demuxer_content, demuxer_bytes, dts, pts);
-
-    if (bitstream_convered)
-      free(demuxer_content);
+  return m_omx_decoder->Decode(pData, iSize, dts, pts);
+}
 
-    return rtn;
-  }
-  
-  return VC_BUFFER;
+unsigned CDVDVideoCodecOpenMax::GetAllowedReferences()
+{
+  return m_omx_decoder->GetAllowedReferences();
 }
 
 void CDVDVideoCodecOpenMax::Reset(void)
@@ -185,172 +90,12 @@ void CDVDVideoCodecOpenMax::Reset(void)
 
 bool CDVDVideoCodecOpenMax::GetPicture(DVDVideoPicture* pDvdVideoPicture)
 {
-  m_omx_decoder->GetPicture(&m_videobuffer);
-  *pDvdVideoPicture = m_videobuffer;
-
-  return VC_PICTURE | VC_BUFFER;
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////
-bool CDVDVideoCodecOpenMax::bitstream_convert_init(void *in_extradata, int in_extrasize)
-{
-  // based on h264_mp4toannexb_bsf.c (ffmpeg)
-  // which is Copyright (c) 2007 Benoit Fouet <benoit.fouet@free.fr>
-  // and Licensed GPL 2.1 or greater
-
-  m_sps_pps_size = 0;
-  m_sps_pps_context.sps_pps_data = NULL;
-  
-  // nothing to filter
-  if (!in_extradata || in_extrasize < 6)
-    return false;
-
-  uint16_t unit_size;
-  uint32_t total_size = 0;
-  uint8_t *out = NULL, unit_nb, sps_done = 0;
-  const uint8_t *extradata = (uint8_t*)in_extradata + 4;
-  static const uint8_t nalu_header[4] = {0, 0, 0, 1};
-
-  // retrieve length coded size
-  m_sps_pps_context.length_size = (*extradata++ & 0x3) + 1;
-  if (m_sps_pps_context.length_size == 3)
-    return false;
-
-  // retrieve sps and pps unit(s)
-  unit_nb = *extradata++ & 0x1f;  // number of sps unit(s)
-  if (!unit_nb)
-  {
-    unit_nb = *extradata++;       // number of pps unit(s)
-    sps_done++;
-  }
-  while (unit_nb--)
-  {
-    unit_size = extradata[0] << 8 | extradata[1];
-    total_size += unit_size + 4;
-    if ( (extradata + 2 + unit_size) > ((uint8_t*)in_extradata + in_extrasize) )
-    {
-      free(out);
-      return false;
-    }
-    uint8_t* new_out = (uint8_t*)realloc(out, total_size);
-    if (new_out)
-    {
-      out = new_out;
-    }
-    else
-    {
-      CLog::Log(LOGERROR, "bitstream_convert_init failed - %s : could not realloc the buffer out",  __FUNCTION__);
-      free(out);
-      return false;
-    }
-
-    memcpy(out + total_size - unit_size - 4, nalu_header, 4);
-    memcpy(out + total_size - unit_size, extradata + 2, unit_size);
-    extradata += 2 + unit_size;
-
-    if (!unit_nb && !sps_done++)
-      unit_nb = *extradata++;     // number of pps unit(s)
-  }
-
-  m_sps_pps_context.sps_pps_data = out;
-  m_sps_pps_context.size = total_size;
-  m_sps_pps_context.first_idr = 1;
-
-  return true;
-}
-
-bool CDVDVideoCodecOpenMax::bitstream_convert(uint8_t* pData, int iSize, uint8_t **poutbuf, int *poutbuf_size)
-{
-  // based on h264_mp4toannexb_bsf.c (ffmpeg)
-  // which is Copyright (c) 2007 Benoit Fouet <benoit.fouet@free.fr>
-  // and Licensed GPL 2.1 or greater
-
-  uint8_t *buf = pData;
-  uint32_t buf_size = iSize;
-  uint8_t  unit_type;
-  int32_t  nal_size;
-  uint32_t cumul_size = 0;
-  const uint8_t *buf_end = buf + buf_size;
-
-  do
-  {
-    if (buf + m_sps_pps_context.length_size > buf_end)
-      goto fail;
-
-    if (m_sps_pps_context.length_size == 1)
-      nal_size = buf[0];
-    else if (m_sps_pps_context.length_size == 2)
-      nal_size = buf[0] << 8 | buf[1];
-    else
-      nal_size = buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3];
-
-    buf += m_sps_pps_context.length_size;
-    unit_type = *buf & 0x1f;
-
-    if (buf + nal_size > buf_end || nal_size < 0)
-      goto fail;
-
-    // prepend only to the first type 5 NAL unit of an IDR picture
-    if (m_sps_pps_context.first_idr && unit_type == 5)
-    {
-      bitstream_alloc_and_copy(poutbuf, poutbuf_size,
-        m_sps_pps_context.sps_pps_data, m_sps_pps_context.size, buf, nal_size);
-      m_sps_pps_context.first_idr = 0;
-    }
-    else
-    {
-      bitstream_alloc_and_copy(poutbuf, poutbuf_size, NULL, 0, buf, nal_size);
-      if (!m_sps_pps_context.first_idr && unit_type == 1)
-          m_sps_pps_context.first_idr = 1;
-    }
-
-    buf += nal_size;
-    cumul_size += nal_size + m_sps_pps_context.length_size;
-  } while (cumul_size < buf_size);
-
-  return true;
-
-fail:
-  free(*poutbuf);
-  *poutbuf = NULL;
-  *poutbuf_size = 0;
-  return false;
+  return m_omx_decoder->GetPicture(pDvdVideoPicture);
 }
 
-void CDVDVideoCodecOpenMax::bitstream_alloc_and_copy(
-  uint8_t **poutbuf,      int *poutbuf_size,
-  const uint8_t *sps_pps, uint32_t sps_pps_size,
-  const uint8_t *in,      uint32_t in_size)
+bool CDVDVideoCodecOpenMax::ClearPicture(DVDVideoPicture* pDvdVideoPicture)
 {
-  // based on h264_mp4toannexb_bsf.c (ffmpeg)
-  // which is Copyright (c) 2007 Benoit Fouet <benoit.fouet@free.fr>
-  // and Licensed GPL 2.1 or greater
-
-  #define CHD_WB32(p, d) { \
-    ((uint8_t*)(p))[3] = (d); \
-    ((uint8_t*)(p))[2] = (d) >> 8; \
-    ((uint8_t*)(p))[1] = (d) >> 16; \
-    ((uint8_t*)(p))[0] = (d) >> 24; }
-
-  uint32_t offset = *poutbuf_size;
-  uint8_t nal_header_size = offset ? 3 : 4;
-
-  *poutbuf_size += sps_pps_size + in_size + nal_header_size;
-  *poutbuf = (uint8_t*)realloc(*poutbuf, *poutbuf_size);
-  if (sps_pps)
-    memcpy(*poutbuf + offset, sps_pps, sps_pps_size);
-
-  memcpy(*poutbuf + sps_pps_size + nal_header_size + offset, in, in_size);
-  if (!offset)
-  {
-    CHD_WB32(*poutbuf + sps_pps_size, 1);
-  }
-  else
-  {
-    (*poutbuf + offset + sps_pps_size)[0] = 0;
-    (*poutbuf + offset + sps_pps_size)[1] = 0;
-    (*poutbuf + offset + sps_pps_size)[2] = 1;
-  }
+  return m_omx_decoder->ClearPicture(pDvdVideoPicture);
 }
 
 #endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
index fb80d02..67cc235 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
@@ -23,7 +23,7 @@
 
 #include "DVDVideoCodec.h"
 
-class COpenVideoMax;
+class COpenMaxVideo;
 class CDVDVideoCodecOpenMax : public CDVDVideoCodec
 {
 public:
@@ -36,39 +36,13 @@ class CDVDVideoCodecOpenMax : public CDVDVideoCodec
   virtual int  Decode(uint8_t *pData, int iSize, double dts, double pts);
   virtual void Reset(void);
   virtual bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
+  virtual bool ClearPicture(DVDVideoPicture* pDvdVideoPicture);
+  virtual unsigned GetAllowedReferences();
   virtual void SetDropState(bool bDrop);
-  virtual const char* GetName(void) { return (const char*)m_pFormatName; }
+  virtual const char* GetName(void);
   
 protected:
-  const char        *m_pFormatName;
   COpenMaxVideo     *m_omx_decoder;
-  DVDVideoPicture   m_videobuffer;
-
-  // bitstream to bytestream (Annex B) conversion support.
-  bool bitstream_convert_init(void *in_extradata, int in_extrasize);
-  bool bitstream_convert(uint8_t* pData, int iSize, uint8_t **poutbuf, int *poutbuf_size);
-  static void bitstream_alloc_and_copy( uint8_t **poutbuf, int *poutbuf_size,
-    const uint8_t *sps_pps, uint32_t sps_pps_size, const uint8_t *in, uint32_t in_size);
-
-  typedef struct omx_bitstream_ctx {
-      uint8_t  length_size;
-      uint8_t  first_idr;
-      uint8_t *sps_pps_data;
-      uint32_t size;
-
-      omx_bitstream_ctx()
-      {
-        length_size = 0;
-        first_idr = 0;
-        sps_pps_data = NULL;
-        size = 0;
-      }
-
-  } omx_bitstream_ctx;
-
-  uint32_t          m_sps_pps_size;
-  omx_bitstream_ctx m_sps_pps_context;
-  bool              m_convert_bitstream;
 };
 
 #endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in b/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
index 8a97889..ebf7123 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
@@ -20,7 +20,6 @@ SRCS += DVDVideoCodecVDA.cpp
 SRCS += VDA.cpp
 endif
 ifeq (@USE_OPENMAX@,1)
-SRCS += OpenMax.cpp
 SRCS += OpenMaxVideo.cpp
 SRCS += DVDVideoCodecOpenMax.cpp
 endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
index dcbdb1e..aca2e0d 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
@@ -32,673 +32,891 @@
 #include "DVDVideoCodec.h"
 #include "utils/log.h"
 #include "utils/TimeUtils.h"
+#include "settings/Settings.h"
 #include "ApplicationMessenger.h"
 #include "Application.h"
+#include "threads/Atomics.h"
 
-#include <OMX_Core.h>
-#include <OMX_Component.h>
-#include <OMX_Index.h>
-#include <OMX_Image.h>
+#include <IL/OMX_Core.h>
+#include <IL/OMX_Component.h>
+#include <IL/OMX_Index.h>
+#include <IL/OMX_Image.h>
 
+#include "cores/omxplayer/OMXImage.h"
+
+#define DTS_QUEUE
+
+#define DEFAULT_TIMEOUT 1000
+#ifdef _DEBUG
+#define OMX_DEBUG_VERBOSE
+#endif
 
 #define CLASSNAME "COpenMaxVideo"
 
-// TODO: These are Nvidia Tegra2 dependent, need to dynamiclly find the
-// right codec matched to video format.
-#define OMX_H264BASE_DECODER    "OMX.Nvidia.h264.decode"
-// OMX.Nvidia.h264ext.decode segfaults, not sure why.
-//#define OMX_H264MAIN_DECODER  "OMX.Nvidia.h264ext.decode"
-#define OMX_H264MAIN_DECODER    "OMX.Nvidia.h264.decode"
-#define OMX_H264HIGH_DECODER    "OMX.Nvidia.h264ext.decode"
-#define OMX_MPEG4_DECODER       "OMX.Nvidia.mp4.decode"
-#define OMX_MPEG4EXT_DECODER    "OMX.Nvidia.mp4ext.decode"
-#define OMX_MPEG2V_DECODER      "OMX.Nvidia.mpeg2v.decode"
-#define OMX_VC1_DECODER         "OMX.Nvidia.vc1.decode"
-
-// EGL extension functions
-static PFNEGLCREATEIMAGEKHRPROC eglCreateImageKHR;
-static PFNEGLDESTROYIMAGEKHRPROC eglDestroyImageKHR;
-#define GETEXTENSION(type, ext) \
-do \
-{ \
-    ext = (type) eglGetProcAddress(#ext); \
-    if (!ext) \
-    { \
-        CLog::Log(LOGERROR, "%s::%s - ERROR getting proc addr of " #ext "\n", CLASSNAME, __func__); \
-    } \
-} while (0);
-
-#define OMX_INIT_STRUCTURE(a) \
-  memset(&(a), 0, sizeof(a)); \
-  (a).nSize = sizeof(a); \
-  (a).nVersion.s.nVersionMajor = OMX_VERSION_MAJOR; \
-  (a).nVersion.s.nVersionMinor = OMX_VERSION_MINOR; \
-  (a).nVersion.s.nRevision = OMX_VERSION_REVISION; \
-  (a).nVersion.s.nStep = OMX_VERSION_STEP
+COpenMaxVideoBuffer::COpenMaxVideoBuffer(COpenMaxVideo *omv)
+    : m_omv(omv), m_refs(0)
+{
+  CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, this);
+  omx_buffer = NULL;
+  width = 0;
+  height = 0;
+  index = 0;
+  egl_image = 0;
+  texture_id = 0;
+}
+
+COpenMaxVideoBuffer::~COpenMaxVideoBuffer()
+{
+  CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, this);
+}
 
 
-COpenMaxVideo::COpenMaxVideo()
+// DecoderFillBufferDone -- OpenMax output buffer has been filled
+static OMX_ERRORTYPE DecoderFillBufferDoneCallback(
+  OMX_HANDLETYPE hComponent,
+  OMX_PTR pAppData,
+  OMX_BUFFERHEADERTYPE* pBuffer)
+{
+  COpenMaxVideoBuffer *pic = static_cast<COpenMaxVideoBuffer*>(pBuffer->pAppPrivate);
+  COpenMaxVideo *ctx = pic->m_omv;
+  return ctx->DecoderFillBufferDone(hComponent, pBuffer);
+}
+
+
+COpenMaxVideoBuffer* COpenMaxVideoBuffer::Acquire()
+{
+  long count = AtomicIncrement(&m_refs);
+  #if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s %p ref:%ld", CLASSNAME, __func__, this, count);
+  #endif
+  (void)count;
+  return this;
+}
+
+long COpenMaxVideoBuffer::Release()
 {
-  m_portChanging = false;
+  long count = AtomicDecrement(&m_refs);
+  if (count == 0)
+  {
+    m_omv->ReleaseOpenMaxBuffer(this);
+  }
+
+  #if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s %p ref:%ld", CLASSNAME, __func__, this, count);
+  #endif
+  return count;
+}
 
-  pthread_mutex_init(&m_omx_input_mutex, NULL);
+void COpenMaxVideoBuffer::Sync()
+{
+  #if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s %p ref:%ld", CLASSNAME, __func__, this, m_refs);
+  #endif
+  Release();
+}
+
+COpenMaxVideo::COpenMaxVideo()
+{
+  CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, this);
   pthread_mutex_init(&m_omx_output_mutex, NULL);
 
-  m_omx_decoder_state_change = (sem_t*)malloc(sizeof(sem_t));
-  sem_init(m_omx_decoder_state_change, 0, 0);
-  memset(&m_videobuffer, 0, sizeof(DVDVideoPicture));
   m_drop_state = false;
   m_decoded_width = 0;
   m_decoded_height = 0;
-  m_omx_input_eos = false;
-  m_omx_input_port = 0;
-  m_omx_output_eos = false;
-  m_omx_output_port = 0;
-  m_videoplayback_done = false;
+  m_egl_buffer_count = 0;
+
+  m_port_settings_changed = false;
+  m_pFormatName = "omx-xxxx";
 }
 
 COpenMaxVideo::~COpenMaxVideo()
 {
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
+  CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, this);
   #endif
-  if (m_is_open)
-    Close();
-  pthread_mutex_destroy(&m_omx_input_mutex);
+  if (m_omx_decoder.IsInitialized())
+  {
+    if (m_omx_tunnel.IsInitialized())
+      m_omx_tunnel.Deestablish();
+
+    StopDecoder();
+
+    if (m_omx_egl_render.IsInitialized())
+      m_omx_egl_render.Deinitialize();
+    if (m_omx_decoder.IsInitialized())
+      m_omx_decoder.Deinitialize();
+  }
   pthread_mutex_destroy(&m_omx_output_mutex);
-  sem_destroy(m_omx_decoder_state_change);
-  free(m_omx_decoder_state_change);
 }
 
-bool COpenMaxVideo::Open(CDVDStreamInfo &hints)
+bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   #endif
 
+  // we always qualify even if DVDFactoryCodec does this too.
+  if (!CSettings::Get().GetBool("videoplayer.useomx") || hints.software)
+    return false;
+
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  std::string decoder_name;
 
   m_decoded_width  = hints.width;
   m_decoded_height = hints.height;
 
+  m_egl_display = g_Windowing.GetEGLDisplay();
+  m_egl_context = g_Windowing.GetEGLContext();
+  m_egl_buffer_count = 4;
+
+  m_codingType = OMX_VIDEO_CodingUnused;
+
   switch (hints.codec)
   {
     case AV_CODEC_ID_H264:
-    {
-      switch(hints.profile)
-      {
-        case FF_PROFILE_H264_BASELINE:
-          // (role name) video_decoder.avc
-          // H.264 Baseline profile
-          decoder_name = OMX_H264BASE_DECODER;
-        break;
-        case FF_PROFILE_H264_MAIN:
-          // (role name) video_decoder.avc
-          // H.264 Main profile
-          decoder_name = OMX_H264MAIN_DECODER;
-        break;
-        case FF_PROFILE_H264_HIGH:
-          // (role name) video_decoder.avc
-          // H.264 Main profile
-          decoder_name = OMX_H264HIGH_DECODER;
-        break;
-        default:
-          return false;
-        break;
-      }
-    }
+      // H.264
+      m_codingType = OMX_VIDEO_CodingAVC;
+      m_pFormatName = "omx-h264";
     break;
+    case AV_CODEC_ID_H263:
     case AV_CODEC_ID_MPEG4:
-      // (role name) video_decoder.mpeg4
-      // MPEG-4, DivX 4/5 and Xvid compatible
-      decoder_name = OMX_MPEG4_DECODER;
-    break;
-    /*
-    TODO: what mpeg4 formats are "ext" ????
-    case NvxStreamType_MPEG4Ext:
-      // (role name) video_decoder.mpeg4
       // MPEG-4, DivX 4/5 and Xvid compatible
-      decoder_name = OMX_MPEG4EXT_DECODER;
+      m_codingType = OMX_VIDEO_CodingMPEG4;
       m_pFormatName = "omx-mpeg4";
     break;
-    */
+    case AV_CODEC_ID_MPEG1VIDEO:
     case AV_CODEC_ID_MPEG2VIDEO:
-      // (role name) video_decoder.mpeg2
       // MPEG-2
-      decoder_name = OMX_MPEG2V_DECODER;
+      m_codingType = OMX_VIDEO_CodingMPEG2;
+      m_pFormatName = "omx-mpeg2";
+    break;
+    case AV_CODEC_ID_VP6:
+      // this form is encoded upside down
+      // fall through
+    case AV_CODEC_ID_VP6F:
+    case AV_CODEC_ID_VP6A:
+      // VP6
+      m_codingType = OMX_VIDEO_CodingVP6;
+      m_pFormatName = "omx-vp6";
+    break;
+    case AV_CODEC_ID_VP8:
+      // VP8
+      m_codingType = OMX_VIDEO_CodingVP8;
+      m_pFormatName = "omx-vp8";
+    break;
+    case AV_CODEC_ID_THEORA:
+      // theora
+      m_codingType = OMX_VIDEO_CodingTheora;
+      m_pFormatName = "omx-theora";
+    break;
+    case AV_CODEC_ID_MJPEG:
+    case AV_CODEC_ID_MJPEGB:
+      // mjpg
+      m_codingType = OMX_VIDEO_CodingMJPEG;
+      m_pFormatName = "omx-mjpg";
     break;
     case AV_CODEC_ID_VC1:
-      // (role name) video_decoder.vc1
+    case AV_CODEC_ID_WMV3:
       // VC-1, WMV9
-      decoder_name = OMX_VC1_DECODER;
-    break;
+      m_codingType = OMX_VIDEO_CodingWMV;
+      m_pFormatName = "omx-vc1";
+      break;
     default:
+      CLog::Log(LOGERROR, "%s::%s : Video codec unknown: %x", CLASSNAME, __func__, hints.codec);
       return false;
     break;
   }
 
   // initialize OpenMAX.
-  if (!Initialize(decoder_name))
+  if (!m_omx_decoder.Initialize("OMX.broadcom.video_decode", OMX_IndexParamVideoInit))
   {
+    CLog::Log(LOGERROR, "%s::%s error m_omx_decoder.Initialize", CLASSNAME, __func__);
     return false;
   }
 
-  // TODO: Find component from role name.
-  // Get the port information. This will obtain information about the
-  // number of ports and index of the first port.
-  OMX_PORT_PARAM_TYPE port_param;
-  OMX_INIT_STRUCTURE(port_param);
-  omx_err = OMX_GetParameter(m_omx_decoder, OMX_IndexParamVideoInit, &port_param);
-  if (omx_err)
+  omx_err = m_omx_decoder.SetStateForComponent(OMX_StateIdle);
+  if (omx_err != OMX_ErrorNone)
   {
-    Deinitialize();
+    CLog::Log(LOGERROR, "%s::%s m_omx_decoder.SetStateForComponent omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
     return false;
   }
-  m_omx_input_port = port_param.nStartPortNumber;
-  m_omx_output_port = m_omx_input_port + 1;
-  #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG,
-    "%s::%s - decoder_component(0x%p), input_port(0x%x), output_port(0x%x)\n",
-    CLASSNAME, __func__, m_omx_decoder, m_omx_input_port, m_omx_output_port);
-  #endif
 
-  // TODO: Set role for the component because components could have multiple roles.
-  //QueryCodec();
+  OMX_VIDEO_PARAM_PORTFORMATTYPE formatType;
+  OMX_INIT_STRUCTURE(formatType);
+  formatType.nPortIndex = m_omx_decoder.GetInputPort();
+  formatType.eCompressionFormat = m_codingType;
+
+  omx_err = m_omx_decoder.SetParameter(OMX_IndexParamVideoPortFormat, &formatType);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s m_omx_decoder.SetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+  OMX_PARAM_PORTDEFINITIONTYPE portParam;
+  OMX_INIT_STRUCTURE(portParam);
+  portParam.nPortIndex = m_omx_decoder.GetInputPort();
+
+  omx_err = m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &portParam);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s error OMX_IndexParamPortDefinition omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  portParam.nPortIndex = m_omx_decoder.GetInputPort();
+  portParam.nBufferCountActual = 20;
+  portParam.format.video.nFrameWidth  = m_decoded_width;
+  portParam.format.video.nFrameHeight = m_decoded_height;
+
+  omx_err = m_omx_decoder.SetParameter(OMX_IndexParamPortDefinition, &portParam);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s error OMX_IndexParamPortDefinition omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  // request portsettingschanged on aspect ratio change
+  OMX_CONFIG_REQUESTCALLBACKTYPE notifications;
+  OMX_INIT_STRUCTURE(notifications);
+  notifications.nPortIndex = m_omx_decoder.GetOutputPort();
+  notifications.nIndex = OMX_IndexParamBrcmPixelAspectRatio;
+  notifications.bEnable = OMX_TRUE;
+
+  omx_err = m_omx_decoder.SetParameter((OMX_INDEXTYPE)OMX_IndexConfigRequestCallback, &notifications);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s OMX_IndexConfigRequestCallback error (0%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  if (NaluFormatStartCodes(hints.codec, (uint8_t *)hints.extradata, hints.extrasize))
+  {
+    OMX_NALSTREAMFORMATTYPE nalStreamFormat;
+    OMX_INIT_STRUCTURE(nalStreamFormat);
+    nalStreamFormat.nPortIndex = m_omx_decoder.GetInputPort();
+    nalStreamFormat.eNaluFormat = OMX_NaluFormatStartCodes;
+
+    omx_err = m_omx_decoder.SetParameter((OMX_INDEXTYPE)OMX_IndexParamNalStreamFormatSelect, &nalStreamFormat);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s OMX_IndexParamNalStreamFormatSelect error (0%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
 
-  // Component will be in OMX_StateLoaded now so we can alloc omx input/output buffers.
-  // we can only alloc them in OMX_StateLoaded state or if the component port is disabled
   // Alloc buffers for the omx input port.
-  omx_err = AllocOMXInputBuffers();
-  if (omx_err)
+  omx_err = m_omx_decoder.AllocInputBuffers();
+  if (omx_err != OMX_ErrorNone)
   {
-    Deinitialize();
+    CLog::Log(LOGERROR, "%s::%s AllocInputBuffers error (0%08x)", CLASSNAME, __func__, omx_err);
     return false;
   }
-  // Alloc buffers for the omx output port.
-  m_egl_display = g_Windowing.GetEGLDisplay();
-  m_egl_context = g_Windowing.GetEGLContext();
-  omx_err = AllocOMXOutputBuffers();
-  if (omx_err)
+
+  omx_err = m_omx_decoder.SetStateForComponent(OMX_StateExecuting);
+  if (omx_err != OMX_ErrorNone)
   {
-    FreeOMXInputBuffers(false);
-    Deinitialize();
+    CLog::Log(LOGERROR, "%s::%s error m_omx_decoder.SetStateForComponent error (0%08x)", CLASSNAME, __func__, omx_err);
     return false;
   }
 
-  m_is_open = true;
-  m_drop_state = false;
-  m_videoplayback_done = false;
+  if (!SendDecoderConfig((uint8_t *)hints.extradata, hints.extrasize))
+    return false;
 
-  // crank it up.
-  StartDecoder();
+  m_drop_state = false;
 
   return true;
 }
 
-void COpenMaxVideo::Close()
+void COpenMaxVideo::Dispose()
 {
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   #endif
-  if (m_omx_decoder)
-  {
-    if (m_omx_decoder_state != OMX_StateLoaded)
-      StopDecoder();
-    Deinitialize();
-  }
-  m_is_open = false;
 }
 
 void COpenMaxVideo::SetDropState(bool bDrop)
 {
+#if defined(OMX_DEBUG_VERBOSE)
+  if (m_drop_state != bDrop)
+    CLog::Log(LOGDEBUG, "%s::%s - m_drop_state(%d)",
+      CLASSNAME, __func__, bDrop);
+#endif
   m_drop_state = bDrop;
+}
 
-  if (m_drop_state)
+bool COpenMaxVideo::SendDecoderConfig(uint8_t *extradata, int extrasize)
+{
+  OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
+
+  /* send decoder config */
+  if (extrasize > 0 && extradata != NULL)
   {
-    OMX_ERRORTYPE omx_err;
+    OMX_BUFFERHEADERTYPE *omx_buffer = m_omx_decoder.GetInputBuffer();
 
-    // blow all but the last ready video frame
-    pthread_mutex_lock(&m_omx_output_mutex);
-    while (m_omx_output_ready.size() > 1)
+    if (omx_buffer == NULL)
     {
-      m_dts_queue.pop();
-      OMX_BUFFERHEADERTYPE *omx_buffer = m_omx_output_ready.front()->omx_buffer;
-      m_omx_output_ready.pop();
-      // return the omx buffer back to OpenMax to fill.
-      omx_err = OMX_FillThisBuffer(m_omx_decoder, omx_buffer);
-      if (omx_err)
-        CLog::Log(LOGERROR, "%s::%s - OMX_FillThisBuffer, omx_err(0x%x)\n",
-          CLASSNAME, __func__, omx_err);
+      CLog::Log(LOGERROR, "%s::%s - buffer error 0x%08x", CLASSNAME, __func__, omx_err);
+      return false;
     }
-    pthread_mutex_unlock(&m_omx_output_mutex);
 
-    #if defined(OMX_DEBUG_VERBOSE)
-    CLog::Log(LOGDEBUG, "%s::%s - m_drop_state(%d)\n",
-      CLASSNAME, __func__, m_drop_state);
-    #endif
+    omx_buffer->nOffset = 0;
+    omx_buffer->nFilledLen = extrasize;
+    if (omx_buffer->nFilledLen > omx_buffer->nAllocLen)
+    {
+      CLog::Log(LOGERROR, "%s::%s - omx_buffer->nFilledLen > omx_buffer->nAllocLen", CLASSNAME, __func__);
+      return false;
+    }
+
+    memcpy((unsigned char *)omx_buffer->pBuffer, extradata, omx_buffer->nFilledLen);
+    omx_buffer->nFlags = OMX_BUFFERFLAG_CODECCONFIG | OMX_BUFFERFLAG_ENDOFFRAME;
+
+//CLog::Log(LOGINFO, "%s::%s - Empty(%d,%x)", CLASSNAME, __func__, omx_buffer->nFilledLen, omx_buffer->nFlags); CLog::MemDump((char *)omx_buffer->pBuffer, std::min(64U, omx_buffer->nFilledLen));
+    omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - OMX_EmptyThisBuffer() failed with result(0x%x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
   }
+  return true;
 }
 
-int COpenMaxVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
+bool COpenMaxVideo::NaluFormatStartCodes(enum AVCodecID codec, uint8_t *extradata, int extrasize)
+{
+  switch(codec)
+  {
+    case AV_CODEC_ID_H264:
+      if (extrasize < 7 || extradata == NULL)
+        return true;
+      // valid avcC atom data always starts with the value 1 (version), otherwise annexb
+      else if ( *extradata != 1 )
+        return true;
+    default: break;
+  }
+  return false;
+}
+
+bool COpenMaxVideo::PortSettingsChanged()
 {
-  if (pData)
+  OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
+
+  if (m_port_settings_changed)
+  {
+    m_omx_decoder.DisablePort(m_omx_decoder.GetOutputPort(), true);
+  }
+
+  OMX_PARAM_PORTDEFINITIONTYPE port_def;
+  OMX_INIT_STRUCTURE(port_def);
+  port_def.nPortIndex = m_omx_decoder.GetOutputPort();
+  omx_err = m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition, &port_def);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - error m_omx_decoder.GetParameter(OMX_IndexParamPortDefinition) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  OMX_CONFIG_POINTTYPE pixel_aspect;
+  OMX_INIT_STRUCTURE(pixel_aspect);
+  pixel_aspect.nPortIndex = m_omx_decoder.GetOutputPort();
+  omx_err = m_omx_decoder.GetParameter(OMX_IndexParamBrcmPixelAspectRatio, &pixel_aspect);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - error m_omx_decoder.GetParameter(OMX_IndexParamBrcmPixelAspectRatio) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  if (m_port_settings_changed)
   {
-    int demuxer_bytes = iSize;
-    uint8_t *demuxer_content = pData;
+    m_omx_decoder.EnablePort(m_omx_decoder.GetOutputPort(), true);
+    return true;
+  }
+
+  // convert in stripes
+  port_def.format.video.nSliceHeight = 16;
+  port_def.format.video.nStride = 0;
+
+  omx_err = m_omx_decoder.SetParameter(OMX_IndexParamPortDefinition, &port_def);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s m_omx_decoder.SetParameter result(0x%x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  OMX_CALLBACKTYPE callbacks = { NULL, NULL, DecoderFillBufferDoneCallback };
+  if (!m_omx_egl_render.Initialize("OMX.broadcom.egl_render", OMX_IndexParamVideoInit, &callbacks))
+  {
+    CLog::Log(LOGERROR, "%s::%s error m_omx_egl_render.Initialize", CLASSNAME, __func__);
+    return false;
+  }
+
+  OMX_CONFIG_PORTBOOLEANTYPE discardMode;
+  OMX_INIT_STRUCTURE(discardMode);
+  discardMode.nPortIndex = m_omx_egl_render.GetInputPort();
+  discardMode.bEnabled = OMX_FALSE;
+  omx_err = m_omx_egl_render.SetParameter(OMX_IndexParamBrcmVideoEGLRenderDiscardMode, &discardMode);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - error m_omx_egl_render.SetParameter(OMX_IndexParamBrcmVideoEGLRenderDiscardMode) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  m_omx_egl_render.ResetEos();
+
+  CLog::Log(LOGDEBUG, "%s::%s - %dx%d@%.2f interlace:%d deinterlace:%d", CLASSNAME, __func__,
+      port_def.format.video.nFrameWidth, port_def.format.video.nFrameHeight,
+      port_def.format.video.xFramerate / (float)(1<<16), 0,0);
+
+  m_omx_tunnel.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_egl_render, m_omx_egl_render.GetInputPort());
+
+  omx_err = m_omx_tunnel.Establish();
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  // Obtain the information about the output port.
+  OMX_PARAM_PORTDEFINITIONTYPE port_format;
+  OMX_INIT_STRUCTURE(port_format);
+  port_format.nPortIndex = m_omx_egl_render.GetOutputPort();
+  omx_err = m_omx_egl_render.GetParameter(OMX_IndexParamPortDefinition, &port_format);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s::%s - m_omx_egl_render.GetParameter OMX_IndexParamPortDefinition omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  port_format.nBufferCountActual = m_egl_buffer_count;
+  omx_err = m_omx_egl_render.SetParameter(OMX_IndexParamPortDefinition, &port_format);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s::%s - m_omx_egl_render.SetParameter OMX_IndexParamPortDefinition omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  #if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG,
+    "%s::%s (1) - oport(%d), nFrameWidth(%u), nFrameHeight(%u), nStride(%x), nBufferCountMin(%u), nBufferCountActual(%u), nBufferSize(%u)",
+    CLASSNAME, __func__, m_omx_egl_render.GetOutputPort(),
+    port_format.format.video.nFrameWidth, port_format.format.video.nFrameHeight,port_format.format.video.nStride,
+    port_format.nBufferCountMin, port_format.nBufferCountActual, port_format.nBufferSize);
+  #endif
+
 
-    // we need to queue then de-queue the demux packet, seems silly but
-    // omx might not have a omx input buffer avaliable when we are called
-    // and we must store the demuxer packet and try again later.
+  omx_err =  m_omx_egl_render.EnablePort(m_omx_egl_render.GetOutputPort(), false);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - m_omx_egl_render.EnablePort omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  if (!AllocOMXOutputBuffers())
+  {
+    CLog::Log(LOGERROR, "%s::%s - AllocOMXOutputBuffers failed", CLASSNAME, __func__);
+    return false;
+  }
+
+  omx_err = m_omx_egl_render.WaitForCommand(OMX_CommandPortEnable, m_omx_egl_render.GetOutputPort());
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s m_omx_egl_render.WaitForCommand(OMX_CommandPortEnable) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  assert(m_omx_output_busy.empty());
+  assert(m_omx_output_ready.empty());
+
+  omx_err = m_omx_egl_render.SetStateForComponent(OMX_StateExecuting);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - m_omx_egl_render.SetStateForComponent omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  omx_err = PrimeFillBuffers();
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - m_omx_egl_render.PrimeFillBuffers omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  m_port_settings_changed = true;
+  return true;
+}
+
+
+int COpenMaxVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
+{
+  #if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - %-8p %-6d dts:%.3f pts:%.3f demux_queue(%d) dts_queue(%d) ready_queue(%d) busy_queue(%d)",
+     CLASSNAME, __func__, pData, iSize, dts == DVD_NOPTS_VALUE ? 0.0 : dts*1e-6, pts == DVD_NOPTS_VALUE ? 0.0 : pts*1e-6, m_demux_queue.size(), m_dts_queue.size(), m_omx_output_ready.size(), m_omx_output_busy.size());
+  #endif
+
+  OMX_ERRORTYPE omx_err;
+  unsigned int demuxer_bytes = 0;
+  uint8_t *demuxer_content = NULL;
+
+  // we need to queue then de-queue the demux packet, seems silly but
+  // omx might not have a omx input buffer available when we are called
+  // and we must store the demuxer packet and try again later.
+  if (pData && m_demux_queue.empty() && m_omx_decoder.GetInputBufferSpace() >= (unsigned int)iSize)
+  {
+    demuxer_bytes = iSize;
+    demuxer_content = pData;
+  }
+  else if (pData && iSize)
+  {
     omx_demux_packet demux_packet;
     demux_packet.dts = dts;
     demux_packet.pts = pts;
-
-    demux_packet.size = demuxer_bytes;
-    demux_packet.buff = new OMX_U8[demuxer_bytes];
-    memcpy(demux_packet.buff, demuxer_content, demuxer_bytes);
+    demux_packet.size = iSize;
+    demux_packet.buff = new OMX_U8[iSize];
+    memcpy(demux_packet.buff, pData, iSize);
     m_demux_queue.push(demux_packet);
+  }
 
-    // we can look at m_omx_input_avaliable.empty without needing to lock/unlock
+  OMX_U8 *buffer_to_free = NULL;
+  while (1)
+  {
     // try to send any/all demux packets to omx decoder.
-    while (!m_omx_input_avaliable.empty() && !m_demux_queue.empty() )
+    if (!demuxer_bytes && !m_demux_queue.empty())
     {
-      OMX_ERRORTYPE omx_err;
-      OMX_BUFFERHEADERTYPE* omx_buffer;
-
-      demux_packet = m_demux_queue.front();
-      m_demux_queue.pop();
-      // need to lock here to retreve an input buffer and pop the queue
-      pthread_mutex_lock(&m_omx_input_mutex);
-      omx_buffer = m_omx_input_avaliable.front();
-      m_omx_input_avaliable.pop();
-      pthread_mutex_unlock(&m_omx_input_mutex);
-
-      // delete the previous demuxer buffer
-      delete [] omx_buffer->pBuffer;
-      // setup a new omx_buffer.
-      omx_buffer->nFlags  = m_omx_input_eos ? OMX_BUFFERFLAG_EOS : 0;
+      omx_demux_packet &demux_packet = m_demux_queue.front();
+      if (m_omx_decoder.GetInputBufferSpace() >= (unsigned int)demux_packet.size)
+      {
+        // need to lock here to retrieve an input buffer and pop the queue
+        m_demux_queue.pop();
+        demuxer_bytes = (unsigned int)demux_packet.size;
+        demuxer_content = demux_packet.buff;
+        buffer_to_free = demux_packet.buff;
+        dts = demux_packet.dts;
+        pts = demux_packet.pts;
+      }
+    }
+
+    if (demuxer_content)
+    {
+      // 500ms timeout
+      OMX_BUFFERHEADERTYPE *omx_buffer = m_omx_decoder.GetInputBuffer(500);
+      if (omx_buffer == NULL)
+      {
+        CLog::Log(LOGERROR, "%s::%s - m_omx_decoder.GetInputBuffer timeout", CLASSNAME, __func__);
+        return VC_ERROR;
+      }
+      #if defined(OMX_DEBUG_VERBOSE)
+      //CLog::Log(LOGDEBUG, "%s::%s - omx_buffer=%p", CLASSNAME, __func__, omx_buffer);
+      #endif
+      omx_buffer->nFlags  = 0;
       omx_buffer->nOffset = 0;
-      omx_buffer->pBuffer = demux_packet.buff;
-      omx_buffer->nAllocLen  = demux_packet.size;
-      omx_buffer->nFilledLen = demux_packet.size;
-      omx_buffer->nTimeStamp = (demux_packet.pts == DVD_NOPTS_VALUE) ? 0 : demux_packet.pts * 1000.0; // in microseconds;
+
+      omx_buffer->nFilledLen = (demuxer_bytes > omx_buffer->nAllocLen) ? omx_buffer->nAllocLen : demuxer_bytes;
+      omx_buffer->nTimeStamp = ToOMXTime((uint64_t)(pts == DVD_NOPTS_VALUE) ? 0 : pts);
       omx_buffer->pAppPrivate = omx_buffer;
-      omx_buffer->nInputPortIndex = m_omx_input_port;
+      memcpy(omx_buffer->pBuffer, demuxer_content, omx_buffer->nFilledLen);
 
-      #if defined(OMX_DEBUG_EMPTYBUFFERDONE)
-      CLog::Log(LOGDEBUG,
-        "%s::%s - feeding decoder, omx_buffer->pBuffer(0x%p), demuxer_bytes(%d)\n",
-        CLASSNAME, __func__, omx_buffer->pBuffer, demuxer_bytes);
-      #endif
-      // Give this omx_buffer to OpenMax to be decoded.
-      omx_err = OMX_EmptyThisBuffer(m_omx_decoder, omx_buffer);
-      if (omx_err)
+      demuxer_bytes -= omx_buffer->nFilledLen;
+      demuxer_content += omx_buffer->nFilledLen;
+
+      if (demuxer_bytes == 0)
+        omx_buffer->nFlags |= OMX_BUFFERFLAG_ENDOFFRAME;
+      if (pts == DVD_NOPTS_VALUE)
+        omx_buffer->nFlags |= OMX_BUFFERFLAG_TIME_UNKNOWN;
+      if (m_drop_state) // hijack an omx flag to signal this frame to be dropped - it will be returned with the picture (but otherwise ignored)
+        omx_buffer->nFlags |= OMX_BUFFERFLAG_DATACORRUPT;
+
+#if defined(OMX_DEBUG_VERBOSE)
+      CLog::Log(LOGDEBUG, "%s::%s - %-6d dts:%.3f pts:%.3f flags:%x",
+        CLASSNAME, __func__, omx_buffer->nFilledLen, dts == DVD_NOPTS_VALUE ? 0.0 : dts*1e-6, pts == DVD_NOPTS_VALUE ? 0.0 : pts*1e-6, omx_buffer->nFlags);
+#endif
+
+      omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
+      if (omx_err != OMX_ErrorNone)
       {
-        CLog::Log(LOGDEBUG,
-          "%s::%s - OMX_EmptyThisBuffer() failed with result(0x%x)\n",
-          CLASSNAME, __func__, omx_err);
+        CLog::Log(LOGERROR, "%s::%s - OMX_EmptyThisBuffer() failed with result(0x%x)", CLASSNAME, __func__, omx_err);
         return VC_ERROR;
       }
-      // only push if we are successful with feeding OMX_EmptyThisBuffer
-      m_dts_queue.push(demux_packet.dts);
-
-      // if m_omx_input_avaliable and/or demux_queue are now empty,
-      // wait up to 20ms for OpenMax to consume a demux packet
-      if (m_omx_input_avaliable.empty() || m_demux_queue.empty())
-        m_input_consumed_event.WaitMSec(1);
+      if (demuxer_bytes == 0)
+      {
+#ifdef DTS_QUEUE
+        // only push if we are successful with feeding OMX_EmptyThisBuffer
+        m_dts_queue.push(dts);
+        assert(m_dts_queue.size() < 32);
+#endif
+        if (buffer_to_free)
+        {
+          delete [] buffer_to_free;
+          buffer_to_free = NULL;
+          demuxer_content = NULL;
+          continue;
+        }
+      }
+    }
+    omx_err = m_omx_decoder.WaitForEvent(OMX_EventPortSettingsChanged, 0);
+    if (omx_err == OMX_ErrorNone)
+    {
+      if (!PortSettingsChanged())
+      {
+        CLog::Log(LOGERROR, "%s::%s - error PortSettingsChanged omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+        return VC_ERROR;
+      }
+    }
+    else if (omx_err != OMX_ErrorTimeout)
+    {
+      CLog::Log(LOGERROR, "%s::%s - video not supported omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return VC_ERROR;
     }
-    if (m_omx_input_avaliable.empty() && !m_demux_queue.empty())
-      m_input_consumed_event.WaitMSec(1);
-
-    #if defined(OMX_DEBUG_VERBOSE)
-    if (m_omx_input_avaliable.empty())
-      CLog::Log(LOGDEBUG,
-        "%s::%s - buffering demux, m_demux_queue_size(%d), demuxer_bytes(%d)\n",
-        CLASSNAME, __func__, m_demux_queue.size(), demuxer_bytes);
-    #endif
+    omx_err = m_omx_decoder.WaitForEvent(OMX_EventParamOrConfigChanged, 0);
+    if (omx_err == OMX_ErrorNone)
+    {
+      if (!PortSettingsChanged())
+      {
+        CLog::Log(LOGERROR, "%s::%s - error PortSettingsChanged (EventParamOrConfigChanged) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+        return VC_ERROR;
+      }
+    }
+    else if (omx_err == OMX_ErrorStreamCorrupt)
+    {
+      CLog::Log(LOGERROR, "%s::%s - video not supported 2 omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return VC_ERROR;
+    }
+    if (!demuxer_bytes)
+      break;
   }
 
+#if defined(OMX_DEBUG_VERBOSE)
+  if (!m_omx_decoder.GetInputBufferSpace())
+    CLog::Log(LOGDEBUG,
+      "%s::%s - buffering demux, m_demux_queue_size(%d), demuxer_bytes(%d) m_dts_queue.size(%d)",
+      CLASSNAME, __func__, m_demux_queue.size(), demuxer_bytes, m_dts_queue.size());
+  #endif
+
   if (m_omx_output_ready.empty())
+  {
+    //CLog::Log(LOGDEBUG, "%s::%s - empty: buffers:%d", CLASSNAME, __func__, m_omx_output_ready.size());
     return VC_BUFFER;
+  }
 
-  return VC_PICTURE | VC_BUFFER;
+  //CLog::Log(LOGDEBUG, "%s::%s -  full: buffers:%d", CLASSNAME, __func__, m_omx_output_ready.size());
+  return VC_PICTURE;
 }
 
 void COpenMaxVideo::Reset(void)
 {
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   #endif
-/*
-  // only reset OpenMax decoder if it's running
-  if (m_omx_decoder_state == OMX_StateExecuting)
+  m_omx_egl_render.FlushAll();
+  m_omx_decoder.FlushAll();
+  // blow all ready video frames
+  while (!m_omx_output_ready.empty())
   {
-    OMX_ERRORTYPE omx_err;
-
-    omx_err = StopDecoder();
-    // Alloc OpenMax input buffers.
-    omx_err = AllocOMXInputBuffers();
-    // Alloc OpenMax output buffers.
-    omx_err = AllocOMXOutputBuffers();
-
-    omx_err = StartDecoder();
+    pthread_mutex_lock(&m_omx_output_mutex);
+    COpenMaxVideoBuffer *pic = m_omx_output_ready.front();
+    m_omx_output_ready.pop();
+    pthread_mutex_unlock(&m_omx_output_mutex);
+    // return the omx buffer back to OpenMax to fill.
+    ReturnOpenMaxBuffer(pic);
   }
-*/
-  ::Sleep(100);
+#ifdef DTS_QUEUE
+  while (!m_dts_queue.empty())
+    m_dts_queue.pop();
+#endif
+
+  while (!m_demux_queue.empty())
+    m_demux_queue.pop();
 }
 
-bool COpenMaxVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
+
+OMX_ERRORTYPE COpenMaxVideo::ReturnOpenMaxBuffer(COpenMaxVideoBuffer *buffer)
 {
-  while (m_omx_output_busy.size() > 1)
+  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
+#if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s %p (%d)", CLASSNAME, __func__, buffer, m_omx_output_busy.size());
+#endif
+  bool done = buffer->omx_buffer->nFlags & OMX_BUFFERFLAG_EOS;
+  if (!done)
   {
-    // fetch a output buffer and pop it off the busy list
-    pthread_mutex_lock(&m_omx_output_mutex);
-    OpenMaxVideoBuffer *buffer = m_omx_output_busy.front();
-    m_omx_output_busy.pop();
-    pthread_mutex_unlock(&m_omx_output_mutex);
+    // return the omx buffer back to OpenMax to fill.
+    buffer->omx_buffer->nFlags = 0;
+    buffer->omx_buffer->nFilledLen = 0;
 
-    bool done = buffer->omx_buffer->nFlags & OMX_BUFFERFLAG_EOS;
-    if (!done)
-    {
-      // return the omx buffer back to OpenMax to fill.
-      OMX_ERRORTYPE omx_err = OMX_FillThisBuffer(m_omx_decoder, buffer->omx_buffer);
-      if (omx_err)
-        CLog::Log(LOGERROR, "%s::%s - OMX_FillThisBuffer, omx_err(0x%x)\n",
-          CLASSNAME, __func__, omx_err);
-    }
+    assert(buffer->omx_buffer->nOutputPortIndex == m_omx_egl_render.GetOutputPort());
+#if defined(OMX_DEBUG_VERBOSE)
+    CLog::Log(LOGDEBUG, "%s::%s FillThisBuffer(%p) %p->%ld", CLASSNAME, __func__, buffer, buffer->omx_buffer, buffer->m_refs);
+#endif
+    OMX_ERRORTYPE omx_err = m_omx_egl_render.FillThisBuffer(buffer->omx_buffer);
+
+    if (omx_err)
+      CLog::Log(LOGERROR, "%s::%s - OMX_FillThisBuffer, omx_err(0x%x)", CLASSNAME, __func__, omx_err);
   }
+  return omx_err;
+}
+
+void COpenMaxVideo::ReleaseOpenMaxBuffer(COpenMaxVideoBuffer *buffer)
+{
+  // remove from busy list
+  pthread_mutex_lock(&m_omx_output_mutex);
+  m_omx_output_busy.erase(std::remove(m_omx_output_busy.begin(), m_omx_output_busy.end(), buffer), m_omx_output_busy.end());
+  pthread_mutex_unlock(&m_omx_output_mutex);
+  ReturnOpenMaxBuffer(buffer);
+}
+
+bool COpenMaxVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
+{
+  //CLog::Log(LOGDEBUG, "%s::%s - m_omx_output_busy.size()=%d m_omx_output_ready.size()=%d", CLASSNAME, __func__, m_omx_output_busy.size(), m_omx_output_ready.size());
+  //CLog::Log(LOGDEBUG, "%s::%s -  full: buffers:%d", CLASSNAME, __func__, m_omx_output_ready.size());
 
   if (!m_omx_output_ready.empty())
   {
-    OpenMaxVideoBuffer *buffer;
+    COpenMaxVideoBuffer *buffer;
     // fetch a output buffer and pop it off the ready list
     pthread_mutex_lock(&m_omx_output_mutex);
     buffer = m_omx_output_ready.front();
     m_omx_output_ready.pop();
-    m_omx_output_busy.push(buffer);
+    m_omx_output_busy.push_back(buffer);
     pthread_mutex_unlock(&m_omx_output_mutex);
 
+    memset(pDvdVideoPicture, 0, sizeof *pDvdVideoPicture);
     pDvdVideoPicture->dts = DVD_NOPTS_VALUE;
     pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
     pDvdVideoPicture->format = RENDER_FMT_OMXEGL;
-    pDvdVideoPicture->openMax = this;
     pDvdVideoPicture->openMaxBuffer = buffer;
-
+    pDvdVideoPicture->color_range  = 0;
+    pDvdVideoPicture->color_matrix = 4;
+    pDvdVideoPicture->iWidth  = m_decoded_width;
+    pDvdVideoPicture->iHeight = m_decoded_height;
+    pDvdVideoPicture->iDisplayWidth  = m_decoded_width;
+    pDvdVideoPicture->iDisplayHeight = m_decoded_height;
+
+#ifdef DTS_QUEUE
     if (!m_dts_queue.empty())
     {
       pDvdVideoPicture->dts = m_dts_queue.front();
       m_dts_queue.pop();
     }
+#endif
     // nTimeStamp is in microseconds
-    pDvdVideoPicture->pts = (buffer->omx_buffer->nTimeStamp == 0) ? DVD_NOPTS_VALUE : (double)buffer->omx_buffer->nTimeStamp / 1000.0;
+    double ts = FromOMXTime(buffer->omx_buffer->nTimeStamp);
+    pDvdVideoPicture->pts = (ts == 0) ? DVD_NOPTS_VALUE : ts;
+    pDvdVideoPicture->openMaxBuffer->Acquire();
+    pDvdVideoPicture->iFlags  = DVP_FLAG_ALLOCATED;
+    if (buffer->omx_buffer->nFlags & OMX_BUFFERFLAG_DATACORRUPT)
+      pDvdVideoPicture->iFlags |= DVP_FLAG_DROPPED;
+#if defined(OMX_DEBUG_VERBOSE)
+    CLog::Log(LOGINFO, "%s::%s dts:%.3f pts:%.3f flags:%x:%x openMaxBuffer:%p omx_buffer:%p egl_image:%p texture_id:%x", CLASSNAME, __func__,
+        pDvdVideoPicture->dts == DVD_NOPTS_VALUE ? 0.0 : pDvdVideoPicture->dts*1e-6, pDvdVideoPicture->pts == DVD_NOPTS_VALUE ? 0.0 : pDvdVideoPicture->pts*1e-6,
+        pDvdVideoPicture->iFlags, buffer->omx_buffer->nFlags, pDvdVideoPicture->openMaxBuffer, pDvdVideoPicture->openMaxBuffer->omx_buffer, pDvdVideoPicture->openMaxBuffer->egl_image, pDvdVideoPicture->openMaxBuffer->texture_id);
+#endif
   }
-  #if defined(OMX_DEBUG_VERBOSE)
   else
   {
-    CLog::Log(LOGDEBUG, "%s::%s - called but m_omx_output_ready is empty\n",
-      CLASSNAME, __func__);
+    CLog::Log(LOGERROR, "%s::%s - called but m_omx_output_ready is empty", CLASSNAME, __func__);
+    return false;
   }
-  #endif
-
-  pDvdVideoPicture->iFlags  = DVP_FLAG_ALLOCATED;
-  pDvdVideoPicture->iFlags |= m_drop_state ? DVP_FLAG_DROPPED : 0;
-
   return true;
 }
 
-
-// DecoderEmptyBufferDone -- OpenMax input buffer has been emptied
-OMX_ERRORTYPE COpenMaxVideo::DecoderEmptyBufferDone(
-  OMX_HANDLETYPE hComponent,
-  OMX_PTR pAppData,
-  OMX_BUFFERHEADERTYPE* pBuffer)
+bool COpenMaxVideo::ClearPicture(DVDVideoPicture* pDvdVideoPicture)
 {
-  COpenMaxVideo *ctx = static_cast<COpenMaxVideo*>(pAppData);
-/*
-  #if defined(OMX_DEBUG_EMPTYBUFFERDONE)
-  CLog::Log(LOGDEBUG, "%s::%s - buffer_size(%lu), timestamp(%f)\n",
-    CLASSNAME, __func__, pBuffer->nFilledLen, (double)pBuffer->nTimeStamp / 1000.0);
-  #endif
-*/
-  // queue free input buffer to avaliable list.
-  pthread_mutex_lock(&ctx->m_omx_input_mutex);
-  ctx->m_omx_input_avaliable.push(pBuffer);
-  ctx->m_input_consumed_event.Set();
-  pthread_mutex_unlock(&ctx->m_omx_input_mutex);
-
-  return OMX_ErrorNone;
+#if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - %p", CLASSNAME, __func__, pDvdVideoPicture->openMaxBuffer);
+#endif
+  if (pDvdVideoPicture->format == RENDER_FMT_OMXEGL)
+    pDvdVideoPicture->openMaxBuffer->Release();
+  memset(pDvdVideoPicture, 0, sizeof *pDvdVideoPicture);
+  return true;
 }
 
-// DecoderFillBufferDone -- OpenMax output buffer has been filled
+  // DecoderFillBufferDone -- OpenMax output buffer has been filled
 OMX_ERRORTYPE COpenMaxVideo::DecoderFillBufferDone(
   OMX_HANDLETYPE hComponent,
-  OMX_PTR pAppData,
   OMX_BUFFERHEADERTYPE* pBuffer)
 {
-  COpenMaxVideo *ctx = static_cast<COpenMaxVideo*>(pAppData);
-  OpenMaxVideoBuffer *buffer = (OpenMaxVideoBuffer*)pBuffer->pAppPrivate;
+  COpenMaxVideoBuffer *buffer = (COpenMaxVideoBuffer*)pBuffer->pAppPrivate;
 
-  #if defined(OMX_DEBUG_FILLBUFFERDONE)
-  CLog::Log(LOGDEBUG, "%s::%s - buffer_size(%lu), timestamp(%f)\n",
-    CLASSNAME, __func__, pBuffer->nFilledLen, (double)pBuffer->nTimeStamp / 1000.0);
+  #if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - %p (%p,%p) buffer_size(%u), pts:%.3f",
+    CLASSNAME, __func__, buffer, pBuffer, buffer->omx_buffer, pBuffer->nFilledLen, (double)FromOMXTime(buffer->omx_buffer->nTimeStamp)*1e-6);
   #endif
 
-  if (!ctx->m_portChanging)
-  {
-    // queue output omx buffer to ready list.
-    pthread_mutex_lock(&ctx->m_omx_output_mutex);
-    ctx->m_omx_output_ready.push(buffer);
-    pthread_mutex_unlock(&ctx->m_omx_output_mutex);
-  }
+  // queue output omx buffer to ready list.
+  pthread_mutex_lock(&m_omx_output_mutex);
+  m_omx_output_ready.push(buffer);
+  pthread_mutex_unlock(&m_omx_output_mutex);
 
   return OMX_ErrorNone;
 }
 
-void COpenMaxVideo::QueryCodec(void)
-{
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  OMX_VIDEO_PARAM_PROFILELEVELTYPE port_param;
-  OMX_INIT_STRUCTURE(port_param);
-
-  port_param.nPortIndex = m_omx_input_port;
-
-  for (port_param.nProfileIndex = 0;; port_param.nProfileIndex++)
-  {
-    omx_err = OMX_GetParameter(m_omx_decoder,
-      OMX_IndexParamVideoProfileLevelQuerySupported, &port_param);
-    if (omx_err)
-      break;
-
-    omx_codec_capability omx_capability;
-    omx_capability.level = port_param.eLevel;
-    omx_capability.profile = port_param.eProfile;
-    m_omx_decoder_capabilities.push_back(omx_capability);
-  }
-}
-
 OMX_ERRORTYPE COpenMaxVideo::PrimeFillBuffers(void)
 {
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  OpenMaxVideoBuffer *buffer;
+  COpenMaxVideoBuffer *buffer;
 
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   #endif
   // tell OpenMax to start filling output buffers
   for (size_t i = 0; i < m_omx_output_buffers.size(); i++)
   {
     buffer = m_omx_output_buffers[i];
     // always set the port index.
-    buffer->omx_buffer->nOutputPortIndex = m_omx_output_port;
-    // Need to clear the EOS flag.
-    buffer->omx_buffer->nFlags &= ~OMX_BUFFERFLAG_EOS;
+    buffer->omx_buffer->nOutputPortIndex = m_omx_egl_render.GetOutputPort();
     buffer->omx_buffer->pAppPrivate = buffer;
-
-    omx_err = OMX_FillThisBuffer(m_omx_decoder, buffer->omx_buffer);
-    if (omx_err)
-      CLog::Log(LOGERROR, "%s::%s - OMX_FillThisBuffer failed with omx_err(0x%x)\n",
-        CLASSNAME, __func__, omx_err);
+    omx_err = ReturnOpenMaxBuffer(buffer);
   }
-
   return omx_err;
 }
 
-OMX_ERRORTYPE COpenMaxVideo::AllocOMXInputBuffers(void)
-{
-  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-
-  // Obtain the information about the decoder input port.
-  OMX_PARAM_PORTDEFINITIONTYPE port_format;
-  OMX_INIT_STRUCTURE(port_format);
-  port_format.nPortIndex = m_omx_input_port;
-  OMX_GetParameter(m_omx_decoder, OMX_IndexParamPortDefinition, &port_format);
-
-  #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG,
-    "%s::%s - iport(%d), nBufferCountMin(%lu), nBufferSize(%lu)\n",
-    CLASSNAME, __func__, m_omx_input_port, port_format.nBufferCountMin, port_format.nBufferSize);
-  #endif
-  for (size_t i = 0; i < port_format.nBufferCountMin; i++)
-  {
-    OMX_BUFFERHEADERTYPE *buffer = NULL;
-    // use an external buffer that's sized according to actual demux
-    // packet size, start at internal's buffer size, will get deleted when
-    // we start pulling demuxer packets and using demux packet sized buffers.
-    OMX_U8* data = new OMX_U8[port_format.nBufferSize];
-    omx_err = OMX_UseBuffer(m_omx_decoder, &buffer, m_omx_input_port, NULL, port_format.nBufferSize, data);
-    if (omx_err)
-    {
-      CLog::Log(LOGERROR, "%s::%s - OMX_UseBuffer failed with omx_err(0x%x)\n",
-        CLASSNAME, __func__, omx_err);
-      return(omx_err);
-    }
-    m_omx_input_buffers.push_back(buffer);
-    // don't have to lock/unlock here, we are not decoding
-    m_omx_input_avaliable.push(buffer);
-  }
-  m_omx_input_eos = false;
-
-  return(omx_err);
-}
-OMX_ERRORTYPE COpenMaxVideo::FreeOMXInputBuffers(bool wait)
+OMX_ERRORTYPE COpenMaxVideo::FreeOMXInputBuffers(void)
 {
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
 
-  /*
-  omx_err = OMX_SendCommand(m_omx_decoder, OMX_CommandFlush, m_omx_input_port, 0);
-  if (omx_err)
-    CLog::Log(LOGERROR, "%s::%s - OMX_CommandFlush failed with omx_err(0x%x)\n",
-      CLASSNAME, __func__, omx_err);
-  else if (wait)
-    sem_wait(m_omx_flush_input);
-  */
-
-  // free omx input port buffers.
-  for (size_t i = 0; i < m_omx_input_buffers.size(); i++)
-  {
-    // using external buffers (OMX_UseBuffer), free our external buffers
-    //  before calling OMX_FreeBuffer which frees the omx buffer.
-    delete [] m_omx_input_buffers[i]->pBuffer;
-    m_omx_input_buffers[i]->pBuffer = NULL;
-    omx_err = OMX_FreeBuffer(m_omx_decoder, m_omx_input_port, m_omx_input_buffers[i]);
-  }
-  m_omx_input_buffers.clear();
-
   // empty input buffer queue. not decoding so don't need lock/unlock.
-  while (!m_omx_input_avaliable.empty())
-    m_omx_input_avaliable.pop();
   while (!m_demux_queue.empty())
     m_demux_queue.pop();
+#ifdef DTS_QUEUE
   while (!m_dts_queue.empty())
     m_dts_queue.pop();
-
+#endif
   return(omx_err);
 }
 
-void COpenMaxVideo::CallbackAllocOMXEGLTextures(void *userdata)
+bool COpenMaxVideo::CallbackAllocOMXEGLTextures(void *userdata)
 {
   COpenMaxVideo *omx = static_cast<COpenMaxVideo*>(userdata);
-  omx->AllocOMXOutputEGLTextures();
+  return omx->AllocOMXOutputEGLTextures() == OMX_ErrorNone;
 }
 
-void COpenMaxVideo::CallbackFreeOMXEGLTextures(void *userdata)
+bool COpenMaxVideo::CallbackFreeOMXEGLTextures(void *userdata)
 {
   COpenMaxVideo *omx = static_cast<COpenMaxVideo*>(userdata);
-  omx->FreeOMXOutputEGLTextures(true);
+  return omx->FreeOMXOutputEGLTextures() == OMX_ErrorNone;
 }
 
-OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputBuffers(void)
+bool COpenMaxVideo::AllocOMXOutputBuffers(void)
 {
-  OMX_ERRORTYPE omx_err;
-
-  if ( g_application.IsCurrentThread() )
-  {
-    omx_err = AllocOMXOutputEGLTextures();
-  }
-  else
-  {
-    ThreadMessageCallback callbackData;
-    callbackData.callback = &CallbackAllocOMXEGLTextures;
-    callbackData.userptr = (void *)this;
-
-    ThreadMessage tMsg;
-    tMsg.dwMessage = TMSG_CALLBACK;
-    tMsg.lpVoid = (void*)&callbackData;
-
-    g_application.getApplicationMessenger().SendMessage(tMsg, true);
-
-    omx_err = OMX_ErrorNone;
-  }
-
-  return omx_err;
+  return g_OMXImage.SendMessage(CallbackAllocOMXEGLTextures, (void *)this);
 }
 
-OMX_ERRORTYPE COpenMaxVideo::FreeOMXOutputBuffers(bool wait)
+bool COpenMaxVideo::FreeOMXOutputBuffers(void)
 {
-  OMX_ERRORTYPE omx_err = FreeOMXOutputEGLTextures(wait);
-
-  return omx_err;
+  return g_OMXImage.SendMessage(CallbackFreeOMXEGLTextures, (void *)this);
 }
 
 OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputEGLTextures(void)
 {
-  OMX_ERRORTYPE omx_err;
-
-  if (!eglCreateImageKHR)
-  {
-    GETEXTENSION(PFNEGLCREATEIMAGEKHRPROC,  eglCreateImageKHR);
-  }
-
+  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
   EGLint attrib = EGL_NONE;
-  OpenMaxVideoBuffer *egl_buffer;
-
-  // Obtain the information about the output port.
-  OMX_PARAM_PORTDEFINITIONTYPE port_format;
-  OMX_INIT_STRUCTURE(port_format);
-  port_format.nPortIndex = m_omx_output_port;
-  omx_err = OMX_GetParameter(m_omx_decoder, OMX_IndexParamPortDefinition, &port_format);
-
-  #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG,
-    "%s::%s (1) - oport(%d), nFrameWidth(%lu), nFrameHeight(%lu), nStride(%lx), nBufferCountMin(%lu), nBufferSize(%lu)\n",
-    CLASSNAME, __func__, m_omx_output_port,
-    port_format.format.video.nFrameWidth, port_format.format.video.nFrameHeight,port_format.format.video.nStride,
-    port_format.nBufferCountMin, port_format.nBufferSize);
-  #endif
+  COpenMaxVideoBuffer *egl_buffer;
 
   glActiveTexture(GL_TEXTURE0);
 
-  for (size_t i = 0; i < port_format.nBufferCountMin; i++)
+  for (size_t i = 0; i < m_egl_buffer_count; i++)
   {
-    egl_buffer = new OpenMaxVideoBuffer;
-    memset(egl_buffer, 0, sizeof(*egl_buffer));
+    egl_buffer = new COpenMaxVideoBuffer(this);
     egl_buffer->width  = m_decoded_width;
     egl_buffer->height = m_decoded_height;
 
     glGenTextures(1, &egl_buffer->texture_id);
     glBindTexture(GL_TEXTURE_2D, egl_buffer->texture_id);
 
+    // no mipmaps
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+
     // create space for buffer with a texture
     glTexImage2D(
       GL_TEXTURE_2D,      // target
@@ -710,8 +928,6 @@ OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputEGLTextures(void)
       GL_RGBA,            // format
       GL_UNSIGNED_BYTE,   // type
       NULL);              // pixels -- will be provided later
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-      glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
 
     // create EGLImage from texture
     egl_buffer->egl_image = eglCreateImageKHR(
@@ -722,49 +938,40 @@ OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputEGLTextures(void)
       &attrib);
     if (!egl_buffer->egl_image)
     {
-      CLog::Log(LOGERROR, "%s::%s - ERROR creating EglImage\n", CLASSNAME, __func__);
+      CLog::Log(LOGERROR, "%s::%s - ERROR creating EglImage", CLASSNAME, __func__);
       return(OMX_ErrorUndefined);
     }
     egl_buffer->index = i;
 
     // tell decoder output port that it will be using EGLImage
-    omx_err = OMX_UseEGLImage(
-      m_omx_decoder, &egl_buffer->omx_buffer, m_omx_output_port, egl_buffer, egl_buffer->egl_image);
+    omx_err = m_omx_egl_render.UseEGLImage(
+      &egl_buffer->omx_buffer, m_omx_egl_render.GetOutputPort(), egl_buffer, egl_buffer->egl_image);
     if (omx_err)
     {
-      CLog::Log(LOGERROR, "%s::%s - OMX_UseEGLImage failed with omx_err(0x%x)\n",
+      CLog::Log(LOGERROR, "%s::%s - OMX_UseEGLImage failed with omx_err(0x%x)",
         CLASSNAME, __func__, omx_err);
       return(omx_err);
     }
     m_omx_output_buffers.push_back(egl_buffer);
 
-    CLog::Log(LOGDEBUG, "%s::%s - Texture %p Width %d Height %d\n",
+    CLog::Log(LOGDEBUG, "%s::%s - Texture %p Width %d Height %d",
       CLASSNAME, __func__, egl_buffer->egl_image, egl_buffer->width, egl_buffer->height);
   }
-  m_omx_output_eos = false;
-  while (!m_omx_output_busy.empty())
-    m_omx_output_busy.pop();
-  while (!m_omx_output_ready.empty())
-    m_omx_output_ready.pop();
-
   return omx_err;
 }
 
-OMX_ERRORTYPE COpenMaxVideo::FreeOMXOutputEGLTextures(bool wait)
+OMX_ERRORTYPE COpenMaxVideo::FreeOMXOutputEGLTextures(void)
 {
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  OpenMaxVideoBuffer *egl_buffer;
-
-  if (!eglDestroyImageKHR)
-  {
-    GETEXTENSION(PFNEGLDESTROYIMAGEKHRPROC, eglDestroyImageKHR);
-  }
+  COpenMaxVideoBuffer *egl_buffer;
 
   for (size_t i = 0; i < m_omx_output_buffers.size(); i++)
   {
     egl_buffer = m_omx_output_buffers[i];
     // tell decoder output port to stop using the EGLImage
-    omx_err = OMX_FreeBuffer(m_omx_decoder, m_omx_output_port, egl_buffer->omx_buffer);
+    omx_err = m_omx_egl_render.FreeOutputBuffer(egl_buffer->omx_buffer);
+    if (omx_err != OMX_ErrorNone)
+      CLog::Log(LOGERROR, "%s::%s m_omx_egl_render.FreeOutputBuffer(%p) omx_err(0x%08x)", CLASSNAME, __func__, egl_buffer->omx_buffer, omx_err);
     // destroy egl_image
     eglDestroyImageKHR(m_egl_display, egl_buffer->egl_image);
     // free texture
@@ -777,274 +984,45 @@ OMX_ERRORTYPE COpenMaxVideo::FreeOMXOutputEGLTextures(bool wait)
 }
 
 
-////////////////////////////////////////////////////////////////////////////////////////////
-// DecoderEventHandler -- OMX event callback
-OMX_ERRORTYPE COpenMaxVideo::DecoderEventHandler(
-  OMX_HANDLETYPE hComponent,
-  OMX_PTR pAppData,
-  OMX_EVENTTYPE eEvent,
-  OMX_U32 nData1,
-  OMX_U32 nData2,
-  OMX_PTR pEventData)
-{
-  OMX_ERRORTYPE omx_err;
-  COpenMaxVideo *ctx = static_cast<COpenMaxVideo*>(pAppData);
-
-/*
-  #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG,
-    "COpenMax::%s - hComponent(0x%p), eEvent(0x%x), nData1(0x%lx), nData2(0x%lx), pEventData(0x%p)\n",
-    __func__, hComponent, eEvent, nData1, nData2, pEventData);
-  #endif
-*/
-
-  switch (eEvent)
-  {
-    case OMX_EventCmdComplete:
-      switch(nData1)
-      {
-        case OMX_CommandStateSet:
-          ctx->m_omx_decoder_state = (int)nData2;
-          switch (ctx->m_omx_decoder_state)
-          {
-            case OMX_StateInvalid:
-              CLog::Log(LOGDEBUG, "%s::%s - OMX_StateInvalid\n", CLASSNAME, __func__);
-            break;
-            case OMX_StateLoaded:
-              CLog::Log(LOGDEBUG, "%s::%s - OMX_StateLoaded\n", CLASSNAME, __func__);
-            break;
-            case OMX_StateIdle:
-              CLog::Log(LOGDEBUG, "%s::%s - OMX_StateIdle\n", CLASSNAME, __func__);
-            break;
-            case OMX_StateExecuting:
-              CLog::Log(LOGDEBUG, "%s::%s - OMX_StateExecuting\n", CLASSNAME, __func__);
-            break;
-            case OMX_StatePause:
-              CLog::Log(LOGDEBUG, "%s::%s - OMX_StatePause\n", CLASSNAME, __func__);
-            break;
-            case OMX_StateWaitForResources:
-              CLog::Log(LOGDEBUG, "%s::%s - OMX_StateWaitForResources\n", CLASSNAME, __func__);
-            break;
-            default:
-              CLog::Log(LOGDEBUG,
-                "%s::%s - Unknown OMX_Statexxxxx, state(%d)\n",
-                CLASSNAME, __func__, ctx->m_omx_decoder_state);
-            break;
-          }
-          sem_post(ctx->m_omx_decoder_state_change);
-        break;
-        case OMX_CommandFlush:
-          /*
-          if (OMX_ALL == (int)nData2)
-          {
-            sem_post(ctx->m_omx_flush_input);
-            sem_post(ctx->m_omx_flush_output);
-            CLog::Log(LOGDEBUG, "COpenMax::%s - OMX_CommandFlush input/output\n",__func__);
-          }
-          else if (ctx->m_omx_input_port == (int)nData2)
-          {
-            sem_post(ctx->m_omx_flush_input);
-            CLog::Log(LOGDEBUG, "COpenMax::%s - OMX_CommandFlush input\n",__func__);
-          }
-          else if (ctx->m_omx_output_port == (int)nData2)
-          {
-            sem_post(ctx->m_omx_flush_output);
-            CLog::Log(LOGDEBUG, "COpenMax::%s - OMX_CommandFlush ouput\n",__func__);
-          }
-          else
-          */
-          {
-            #if defined(OMX_DEBUG_EVENTHANDLER)
-            CLog::Log(LOGDEBUG,
-              "%s::%s - OMX_CommandFlush, nData2(0x%lx)\n",
-              CLASSNAME, __func__, nData2);
-            #endif
-          }
-        break;
-        case OMX_CommandPortDisable:
-          #if defined(OMX_DEBUG_EVENTHANDLER)
-          CLog::Log(LOGDEBUG,
-            "%s::%s - OMX_CommandPortDisable, nData1(0x%lx), nData2(0x%lx)\n",
-            CLASSNAME, __func__, nData1, nData2);
-          #endif
-          if (ctx->m_omx_output_port == (int)nData2)
-          {
-            // Got OMX_CommandPortDisable event, alloc new buffers for the output port.
-            ctx->AllocOMXOutputBuffers();
-            omx_err = OMX_SendCommand(ctx->m_omx_decoder, OMX_CommandPortEnable, ctx->m_omx_output_port, NULL);
-          }
-        break;
-        case OMX_CommandPortEnable:
-          #if defined(OMX_DEBUG_EVENTHANDLER)
-          CLog::Log(LOGDEBUG,
-            "%s::%s - OMX_CommandPortEnable, nData1(0x%lx), nData2(0x%lx)\n",
-            CLASSNAME, __func__, nData1, nData2);
-          #endif
-          if (ctx->m_omx_output_port == (int)nData2)
-          {
-            // Got OMX_CommandPortEnable event.
-            // OMX_CommandPortDisable will have re-alloced new ones so re-prime
-            ctx->PrimeFillBuffers();
-          }
-          ctx->m_portChanging = false;
-        break;
-        #if defined(OMX_DEBUG_EVENTHANDLER)
-        case OMX_CommandMarkBuffer:
-          CLog::Log(LOGDEBUG,
-            "%s::%s - OMX_CommandMarkBuffer, nData1(0x%lx), nData2(0x%lx)\n",
-            CLASSNAME, __func__, nData1, nData2);
-        break;
-        #endif
-      }
-    break;
-    case OMX_EventBufferFlag:
-      if (ctx->m_omx_decoder == hComponent && (nData2 & OMX_BUFFERFLAG_EOS)) {
-        #if defined(OMX_DEBUG_EVENTHANDLER)
-        if(ctx->m_omx_input_port  == (int)nData1)
-            CLog::Log(LOGDEBUG, "%s::%s - OMX_EventBufferFlag(input)\n",
-            CLASSNAME, __func__);
-        #endif
-        if(ctx->m_omx_output_port == (int)nData1)
-        {
-            ctx->m_videoplayback_done = true;
-            #if defined(OMX_DEBUG_EVENTHANDLER)
-            CLog::Log(LOGDEBUG, "%s::%s - OMX_EventBufferFlag(output)\n",
-            CLASSNAME, __func__);
-            #endif
-        }
-      }
-    break;
-    case OMX_EventPortSettingsChanged:
-      #if defined(OMX_DEBUG_EVENTHANDLER)
-      CLog::Log(LOGDEBUG,
-        "%s::%s - OMX_EventPortSettingsChanged(output)\n", CLASSNAME, __func__);
-      #endif
-      // not sure nData2 is the input/output ports in this call, docs don't say
-      if (ctx->m_omx_output_port == (int)nData2)
-      {
-        // free the current OpenMax output buffers, you must do this before sending
-        // OMX_CommandPortDisable to component as it expects output buffers
-        // to be freed before it will issue a OMX_CommandPortDisable event.
-        ctx->m_portChanging = true;
-        OMX_SendCommand(ctx->m_omx_decoder, OMX_CommandPortDisable, ctx->m_omx_output_port, NULL);
-        omx_err = ctx->FreeOMXOutputBuffers(false);
-      }
-    break;
-    #if defined(OMX_DEBUG_EVENTHANDLER)
-    case OMX_EventMark:
-      CLog::Log(LOGDEBUG, "%s::%s - OMX_EventMark\n", CLASSNAME, __func__);
-    break;
-    case OMX_EventResourcesAcquired:
-      CLog::Log(LOGDEBUG, "%s::%s - OMX_EventResourcesAcquired\n", CLASSNAME, __func__);
-    break;
-    #endif
-    case OMX_EventError:
-      switch((OMX_S32)nData1)
-      {
-        case OMX_ErrorInsufficientResources:
-          CLog::Log(LOGERROR, "%s::%s - OMX_EventError, insufficient resources\n",
-            CLASSNAME, __func__);
-          // we are so frack'ed
-          //exit(0);
-        break;
-        case OMX_ErrorFormatNotDetected:
-          CLog::Log(LOGERROR, "%s::%s - OMX_EventError, cannot parse input stream\n",
-            CLASSNAME, __func__);
-        break;
-        case OMX_ErrorPortUnpopulated:
-          // silently ignore these. We can get them when setting OMX_CommandPortDisable
-          // on the output port and the component flushes the output buffers.
-        break;
-        case OMX_ErrorStreamCorrupt:
-          CLog::Log(LOGERROR, "%s::%s - OMX_EventError, Bitstream corrupt\n",
-            CLASSNAME, __func__);
-          ctx->m_videoplayback_done = true;
-        break;
-        default:
-          CLog::Log(LOGERROR, "%s::%s - OMX_EventError detected, nData1(0x%lx), nData2(0x%lx)\n",
-            CLASSNAME, __func__, nData1, nData2);
-        break;
-      }
-      // do this so we don't hang on errors
-      /*
-      sem_post(ctx->m_omx_flush_input);
-      sem_post(ctx->m_omx_flush_output);
-      */
-      sem_post(ctx->m_omx_decoder_state_change);
-    break;
-    default:
-      CLog::Log(LOGWARNING,
-        "%s::%s - Unknown eEvent(0x%x), nData1(0x%lx), nData2(0x%lx)\n",
-        CLASSNAME, __func__, eEvent, nData1, nData2);
-    break;
-  }
-
-  return OMX_ErrorNone;
-}
-
-// StartPlayback -- Kick off video playback.
-OMX_ERRORTYPE COpenMaxVideo::StartDecoder(void)
-{
-  OMX_ERRORTYPE omx_err;
-
-  #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
-  #endif
-
-  // transition decoder component to IDLE state
-  omx_err = SetStateForComponent(OMX_StateIdle);
-  if (omx_err)
-  {
-    CLog::Log(LOGERROR, "%s::%s - setting OMX_StateIdle failed with omx_err(0x%x)\n",
-      CLASSNAME, __func__, omx_err);
-    return omx_err;
-  }
-
-  // transition decoder component to executing state
-  omx_err = SetStateForComponent(OMX_StateExecuting);
-  if (omx_err)
-  {
-    CLog::Log(LOGERROR, "%s::%s - setting OMX_StateExecuting failed with omx_err(0x%x)\n",
-      CLASSNAME, __func__, omx_err);
-    return omx_err;
-  }
-
-  //prime the omx output buffers.
-  PrimeFillBuffers();
-
-  return omx_err;
-}
-
 // StopPlayback -- Stop video playback
 OMX_ERRORTYPE COpenMaxVideo::StopDecoder(void)
 {
-  OMX_ERRORTYPE omx_err;
+  OMX_ERRORTYPE omx_err = OMX_ErrorNone;
 
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s\n", CLASSNAME, __func__);
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   #endif
+
   // transition decoder component from executing to idle
-  omx_err = SetStateForComponent(OMX_StateIdle);
-  if (omx_err)
+  if (m_omx_decoder.IsInitialized())
   {
-    CLog::Log(LOGERROR, "%s::%s - setting OMX_StateIdle failed with omx_err(0x%x)\n",
-      CLASSNAME, __func__, omx_err);
-    return omx_err;
+    omx_err = m_omx_decoder.SetStateForComponent(OMX_StateIdle);
+    if (omx_err)
+      CLog::Log(LOGERROR, "%s::%s - setting OMX_StateIdle failed with omx_err(0x%x)",
+        CLASSNAME, __func__, omx_err);
   }
 
   // we can free our allocated port buffers in OMX_StateIdle state.
   // free OpenMax input buffers.
-  FreeOMXInputBuffers(true);
-  // free OpenMax output buffers.
-  FreeOMXOutputBuffers(true);
+  FreeOMXInputBuffers();
+
+  if (m_omx_egl_render.IsInitialized())
+  {
+      omx_err = m_omx_egl_render.SetStateForComponent(OMX_StateIdle);
+      if (omx_err)
+        CLog::Log(LOGERROR, "%s::%s - setting egl OMX_StateIdle failed with omx_err(0x%x)",
+          CLASSNAME, __func__, omx_err);
+      // free OpenMax output buffers.
+      omx_err = m_omx_egl_render.DisablePort(m_omx_egl_render.GetOutputPort(), false);
+      if (omx_err != OMX_ErrorNone)
+        CLog::Log(LOGERROR, "%s::%s m_omx_egl_render.DisablePort(%d) omx_err(0x%08x)", CLASSNAME, __func__, m_omx_egl_render.GetOutputPort(), omx_err);
 
-  // transition decoder component from idle to loaded
-  omx_err = SetStateForComponent(OMX_StateLoaded);
-  if (omx_err)
-    CLog::Log(LOGERROR,
-      "%s::%s - setting OMX_StateLoaded failed with omx_err(0x%x)\n",
-      CLASSNAME, __func__, omx_err);
+      FreeOMXOutputBuffers();
 
+      omx_err = m_omx_egl_render.WaitForCommand(OMX_CommandPortDisable, m_omx_egl_render.GetOutputPort());
+      if (omx_err != OMX_ErrorNone)
+        CLog::Log(LOGERROR, "%s::%s WaitForCommand:OMX_CommandPortDisable omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+  }
   return omx_err;
 }
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
index e06c41d..9079c13 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
@@ -21,12 +21,35 @@
 
 #if defined(HAVE_LIBOPENMAX)
 
-#include "OpenMax.h"
+#include "system_gl.h"
 #include <EGL/egl.h>
 #include <EGL/eglext.h>
 
+#include "linux/OMXCore.h"
+#include "linux/OMXClock.h"
+
+#include "cores/dvdplayer/DVDStreamInfo.h"
+#include "DVDVideoCodec.h"
+#include "threads/Event.h"
+
+#include <queue>
+#include <semaphore.h>
+
+typedef struct omx_demux_packet {
+  OMX_U8 *buff;
+  int size;
+  double dts;
+  double pts;
+} omx_demux_packet;
+
+class COpenMaxVideo;
 // an omx egl video frame
-typedef struct OpenMaxVideoBuffer {
+class COpenMaxVideoBuffer
+{
+public:
+  COpenMaxVideoBuffer(COpenMaxVideo *omv);
+  virtual ~COpenMaxVideoBuffer();
+
   OMX_BUFFERHEADERTYPE *omx_buffer;
   int width;
   int height;
@@ -35,79 +58,86 @@ typedef struct OpenMaxVideoBuffer {
   // used for egl based rendering if active
   EGLImageKHR egl_image;
   GLuint texture_id;
-} OpenMaxVideoBuffer;
+  // reference counting
+  COpenMaxVideoBuffer* Acquire();
+  long                 Release();
+  void                 Sync();
+
+  COpenMaxVideo *m_omv;
+  long m_refs;
+private:
+};
 
-class COpenMaxVideo : public COpenMax
+class COpenMaxVideo
 {
 public:
   COpenMaxVideo();
   virtual ~COpenMaxVideo();
 
   // Required overrides
-  bool Open(CDVDStreamInfo &hints);
-  void Close(void);
-  int  Decode(uint8_t *pData, int iSize, double dts, double pts);
-  void Reset(void);
-  bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
-  void SetDropState(bool bDrop);
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
+  virtual void Dispose(void);
+  virtual int  Decode(uint8_t *pData, int iSize, double dts, double pts);
+  virtual void Reset(void);
+  virtual bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
+  virtual bool ClearPicture(DVDVideoPicture* pDvdVideoPicture);
+  virtual unsigned GetAllowedReferences() { return 2; }
+  virtual void SetDropState(bool bDrop);
+  virtual const char* GetName(void) { return (const char*)m_pFormatName; }
+
+  // OpenMax decoder callback routines.
+  OMX_ERRORTYPE DecoderFillBufferDone(OMX_HANDLETYPE hComponent, OMX_BUFFERHEADERTYPE* pBuffer);
+  void ReleaseOpenMaxBuffer(COpenMaxVideoBuffer *buffer);
+
 protected:
   void QueryCodec(void);
   OMX_ERRORTYPE PrimeFillBuffers(void);
   OMX_ERRORTYPE AllocOMXInputBuffers(void);
-  OMX_ERRORTYPE FreeOMXInputBuffers(bool wait);
-  OMX_ERRORTYPE AllocOMXOutputBuffers(void);
-  OMX_ERRORTYPE FreeOMXOutputBuffers(bool wait);
-  static void CallbackAllocOMXEGLTextures(void*);
+  OMX_ERRORTYPE FreeOMXInputBuffers(void);
+  bool AllocOMXOutputBuffers(void);
+  bool FreeOMXOutputBuffers(void);
+  static bool CallbackAllocOMXEGLTextures(void*);
   OMX_ERRORTYPE AllocOMXOutputEGLTextures(void);
-  static void CallbackFreeOMXEGLTextures(void*);
-  OMX_ERRORTYPE FreeOMXOutputEGLTextures(bool wait);
-
-  // TODO Those should move into the base class. After start actions can be executed by callbacks.
-  OMX_ERRORTYPE StartDecoder(void);
+  static bool CallbackFreeOMXEGLTextures(void*);
+  OMX_ERRORTYPE FreeOMXOutputEGLTextures(void);
   OMX_ERRORTYPE StopDecoder(void);
-
-  // OpenMax decoder callback routines.
-  virtual OMX_ERRORTYPE DecoderEventHandler(OMX_HANDLETYPE hComponent, OMX_PTR pAppData,
-    OMX_EVENTTYPE eEvent, OMX_U32 nData1, OMX_U32 nData2, OMX_PTR pEventData);
-  virtual OMX_ERRORTYPE DecoderEmptyBufferDone(
-    OMX_HANDLETYPE hComponent, OMX_PTR pAppData, OMX_BUFFERHEADERTYPE* pBuffer);
-  virtual OMX_ERRORTYPE DecoderFillBufferDone(
-    OMX_HANDLETYPE hComponent, OMX_PTR pAppData, OMX_BUFFERHEADERTYPE* pBufferHeader);
+  OMX_ERRORTYPE ReturnOpenMaxBuffer(COpenMaxVideoBuffer *buffer);
 
   // EGL Resources
   EGLDisplay        m_egl_display;
   EGLContext        m_egl_context;
 
   // Video format
-  DVDVideoPicture   m_videobuffer;
   bool              m_drop_state;
   int               m_decoded_width;
   int               m_decoded_height;
+  unsigned int      m_egl_buffer_count;
+
+  bool m_port_settings_changed;
+  const char        *m_pFormatName;
 
   std::queue<double> m_dts_queue;
   std::queue<omx_demux_packet> m_demux_queue;
 
-  // OpenMax input buffers (demuxer packets)
-  pthread_mutex_t   m_omx_input_mutex;
-  std::queue<OMX_BUFFERHEADERTYPE*> m_omx_input_avaliable;
-  std::vector<OMX_BUFFERHEADERTYPE*> m_omx_input_buffers;
-  bool              m_omx_input_eos;
-  int               m_omx_input_port;
-  //sem_t             *m_omx_flush_input;
-  CEvent            m_input_consumed_event;
-
   // OpenMax output buffers (video frames)
   pthread_mutex_t   m_omx_output_mutex;
-  std::queue<OpenMaxVideoBuffer*> m_omx_output_busy;
-  std::queue<OpenMaxVideoBuffer*> m_omx_output_ready;
-  std::vector<OpenMaxVideoBuffer*> m_omx_output_buffers;
-  bool              m_omx_output_eos;
-  int               m_omx_output_port;
-  //sem_t             *m_omx_flush_output;
+  std::vector<COpenMaxVideoBuffer*> m_omx_output_busy;
+  std::queue<COpenMaxVideoBuffer*> m_omx_output_ready;
+  std::vector<COpenMaxVideoBuffer*> m_omx_output_buffers;
+
+  // initialize OpenMax and get decoder component
+  bool Initialize( const CStdString &decoder_name);
+
+  // Components
+  COMXCoreComponent m_omx_decoder;
+  COMXCoreComponent m_omx_egl_render;
 
-  bool              m_portChanging;
+  COMXCoreTunel     m_omx_tunnel;
+  OMX_VIDEO_CODINGTYPE m_codingType;
 
-  volatile bool     m_videoplayback_done;
+  bool PortSettingsChanged();
+  bool SendDecoderConfig(uint8_t *extradata, int extrasize);
+  bool NaluFormatStartCodes(enum AVCodecID codec, uint8_t *extradata, int extrasize);
 };
 
 // defined(HAVE_LIBOPENMAX)
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index 4f85e2a..adbc312 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -2968,7 +2968,9 @@ bool CDVDPlayer::OpenVideoStream(CDVDStreamInfo& hint, bool reset)
       hint.aspect = aspect;
       hint.forced_aspect = true;
     }
+#ifndef TARGET_RASPBERRY_PI
     hint.software = true;
+#endif
   }
 
   CDVDInputStream::IMenus* pMenus = dynamic_cast<CDVDInputStream::IMenus*>(m_pInputStream);
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index be532ec..7403fd4 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -324,6 +324,9 @@ void CDVDPlayerVideo::Process()
 
   while (!m_bStop)
   {
+    DemuxPacket staticPacket = {};
+    DemuxPacket* pPacket = NULL;
+    bool bPacketDrop = false;
     int iQueueTimeOut = (int)(m_stalled ? frametime / 4 : frametime * 10) / 1000;
     int iPriority = (m_speed == DVD_PLAYSPEED_PAUSE && m_started) ? 1 : 0;
 
@@ -360,8 +363,10 @@ void CDVDPlayerVideo::Process()
         OutputPicture(&picture, pts);
         pts+= frametime;
       }
-
-      continue;
+      pPacket = &staticPacket;
+      bPacketDrop = false;
+      goto submit_empty_packet;
+      //continue;
     }
 
     if (pMsg->IsType(CDVDMsg::GENERAL_SYNCHRONIZE))
@@ -490,9 +495,12 @@ void CDVDPlayerVideo::Process()
 
     if (pMsg->IsType(CDVDMsg::DEMUXER_PACKET))
     {
-      DemuxPacket* pPacket = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacket();
-      bool bPacketDrop     = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacketDrop();
-
+      pPacket = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacket();
+      bPacketDrop     = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacketDrop();
+    }
+submit_empty_packet:
+    if (ret == MSGQ_TIMEOUT || pMsg->IsType(CDVDMsg::DEMUXER_PACKET))
+    {
       if (m_stalled)
       {
         CLog::Log(LOGINFO, "CDVDPlayerVideo - Stillframe left, switching to normal playback");
@@ -750,7 +758,8 @@ void CDVDPlayerVideo::Process()
     }
 
     // all data is used by the decoder, we can safely free it now
-    pMsg->Release();
+    if (ret != MSGQ_TIMEOUT)
+        pMsg->Release();
   }
 
   // we need to let decoder release any picture retained resources.
diff --git a/xbmc/linux/OMXCore.cpp b/xbmc/linux/OMXCore.cpp
index 6e7d9a9..99e407a 100644
--- a/xbmc/linux/OMXCore.cpp
+++ b/xbmc/linux/OMXCore.cpp
@@ -460,7 +460,12 @@ void COMXCoreComponent::FlushInput()
     CLog::Log(LOGERROR, "COMXCoreComponent::FlushInput - Error on component %s omx_err(0x%08x)", 
               m_componentName.c_str(), (int)omx_err);
   }
-  WaitForCommand(OMX_CommandFlush, m_input_port);
+  omx_err = WaitForCommand(OMX_CommandFlush, m_input_port);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "COMXCoreComponent::FlushInput - %s WaitForCommand omx_err(0x%08x)",
+              m_componentName.c_str(), (int)omx_err);
+  }
 }
 
 void COMXCoreComponent::FlushOutput()
@@ -477,7 +482,12 @@ void COMXCoreComponent::FlushOutput()
     CLog::Log(LOGERROR, "COMXCoreComponent::FlushOutput - Error on component %s omx_err(0x%08x)", 
               m_componentName.c_str(), (int)omx_err);
   }
-  WaitForCommand(OMX_CommandFlush, m_output_port);
+  omx_err = WaitForCommand(OMX_CommandFlush, m_output_port);
+  if(omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "COMXCoreComponent::FlushOutput - %s WaitForCommand omx_err(0x%08x)",
+              m_componentName.c_str(), (int)omx_err);
+  }
 }
 
 // timeout in milliseconds
@@ -1149,7 +1159,12 @@ OMX_STATETYPE COMXCoreComponent::GetState()
 
   OMX_STATETYPE state;
 
-  OMX_GetState(m_handle, &state);
+  OMX_ERRORTYPE omx_err = OMX_GetState(m_handle, &state);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "COMXCoreComponent::GetState - %s failed with omx_err(0x%x)\n",
+      m_componentName.c_str(), omx_err);
+  }
   return state;
 }
 
@@ -1307,6 +1322,8 @@ OMX_ERRORTYPE COMXCoreComponent::DisablePort(unsigned int port, bool wait)
 
 OMX_ERRORTYPE COMXCoreComponent::UseEGLImage(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex, OMX_PTR pAppPrivate, void* eglImage)
 {
+if (m_callbacks.FillBufferDone == &COMXCoreComponent::DecoderFillBufferDoneCallback)
+{
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
 
   if(!m_handle)
@@ -1383,8 +1400,21 @@ OMX_ERRORTYPE COMXCoreComponent::UseEGLImage(OMX_BUFFERHEADERTYPE** ppBufferHdr,
 
   return omx_err;
 }
+else
+{
+  OMX_ERRORTYPE omx_err;
+    omx_err = OMX_UseEGLImage(m_handle, ppBufferHdr, nPortIndex, pAppPrivate, eglImage);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - %s failed with omx_err(0x%x)\n",
+                CLASSNAME, __func__, m_componentName.c_str(), omx_err);
+      return omx_err;
+    }
+  return omx_err;
+}
+}
 
-bool COMXCoreComponent::Initialize( const std::string &component_name, OMX_INDEXTYPE index)
+bool COMXCoreComponent::Initialize( const std::string &component_name, OMX_INDEXTYPE index, OMX_CALLBACKTYPE *callbacks)
 {
   OMX_ERRORTYPE omx_err;
 
@@ -1419,6 +1449,13 @@ bool COMXCoreComponent::Initialize( const std::string &component_name, OMX_INDEX
   m_callbacks.EmptyBufferDone = &COMXCoreComponent::DecoderEmptyBufferDoneCallback;
   m_callbacks.FillBufferDone  = &COMXCoreComponent::DecoderFillBufferDoneCallback;
 
+  if (callbacks && callbacks->EventHandler)
+    m_callbacks.EventHandler    = callbacks->EventHandler;
+  if (callbacks && callbacks->EmptyBufferDone)
+    m_callbacks.EmptyBufferDone = callbacks->EmptyBufferDone;
+  if (callbacks && callbacks->FillBufferDone)
+    m_callbacks.FillBufferDone  = callbacks->FillBufferDone;
+
   // Get video component handle setting up callbacks, component is in loaded state on return.
   if(!m_handle)
   {
diff --git a/xbmc/linux/OMXCore.h b/xbmc/linux/OMXCore.h
index 1efb313..b4c8626 100644
--- a/xbmc/linux/OMXCore.h
+++ b/xbmc/linux/OMXCore.h
@@ -107,7 +107,7 @@ class COMXCoreComponent
   OMX_ERRORTYPE DisablePort(unsigned int port, bool wait = true);
   OMX_ERRORTYPE UseEGLImage(OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_U32 nPortIndex, OMX_PTR pAppPrivate, void* eglImage);
 
-  bool          Initialize( const std::string &component_name, OMX_INDEXTYPE index);
+  bool          Initialize( const std::string &component_name, OMX_INDEXTYPE index, OMX_CALLBACKTYPE *callbacks = NULL);
   bool          IsInitialized();
   bool          Deinitialize();
 
-- 
1.9.3


From c95085d8a9875edb51081787641fb3abb56d7b0e Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 20 Jan 2014 16:03:40 +0000
Subject: [PATCH 20/99] [omxcodec] Enable for dvd menus

---
 xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
index d58067c..f3fd3e2 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
@@ -192,6 +192,10 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, unsigne
 
   CLog::Log(LOGDEBUG, "CDVDFactoryCodec: compiled in hardware support: %s", hwSupport.c_str());
 
+#if defined(HAVE_LIBOPENMAX)
+  // libopenmax can handle dvd playback including stills
+  if (!CSettings::Get().GetBool("videoplayer.useomx"))
+#endif
   if (hint.stills && (hint.codec == AV_CODEC_ID_MPEG2VIDEO || hint.codec == AV_CODEC_ID_MPEG1VIDEO))
   {
      // If dvd is an mpeg2 and hint.stills
-- 
1.9.3


From 70e31ee44d902739bd25f31c25c4f6211932ad68 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Feb 2014 22:27:44 +0000
Subject: [PATCH 21/99] [omxcodec] Add omx specific texture
 create/upload/delete functions

---
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp | 33 +++++++++++++++++++++++++
 xbmc/cores/VideoRenderers/LinuxRendererGLES.h   |  4 +++
 2 files changed, 37 insertions(+)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index 2e0d0ca..b8af8d0 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -803,6 +803,12 @@ void CLinuxRendererGLES::LoadShaders(int field)
     m_textureCreate = &CLinuxRendererGLES::CreateNV12Texture;
     m_textureDelete = &CLinuxRendererGLES::DeleteNV12Texture;
   }
+  else if (m_format == RENDER_FMT_OMXEGL)
+  {
+    m_textureUpload = &CLinuxRendererGLES::UploadOMXEGLTexture;
+    m_textureCreate = &CLinuxRendererGLES::CreateOMXEGLTexture;
+    m_textureDelete = &CLinuxRendererGLES::DeleteOMXEGLTexture;
+  }
   else
   {
     // default to YV12 texture handlers
@@ -2485,6 +2491,33 @@ bool CLinuxRendererGLES::CreateSurfaceTexture(int index)
   return true;
 }
 
+//********************************************************************************************************
+// SurfaceTexture creation, deletion, copying + clearing
+//********************************************************************************************************
+void CLinuxRendererGLES::UploadOMXEGLTexture(int index)
+{
+#ifdef HAVE_LIBOPENMAX
+  YUVBUFFER &buf = m_buffers[index];
+  if (buf.openMaxBuffer)
+  {
+    //buf.openMaxBuffer->Sync();
+  }
+#endif
+}
+void CLinuxRendererGLES::DeleteOMXEGLTexture(int index)
+{
+#ifdef HAVE_LIBOPENMAX
+  YUVBUFFER &buf = m_buffers[index];
+  if (buf.openMaxBuffer)
+    SAFE_RELEASE(buf.openMaxBuffer);
+#endif
+}
+bool CLinuxRendererGLES::CreateOMXEGLTexture(int index)
+{
+  DeleteOMXEGLTexture(index);
+  return true;
+}
+
 void CLinuxRendererGLES::SetTextureFilter(GLenum method)
 {
   for (int i = 0 ; i<m_NumYV12Buffers ; i++)
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
index 5a6a2be..52df291 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
@@ -209,6 +209,10 @@ class CLinuxRendererGLES : public CBaseRenderer
   void DeleteSurfaceTexture(int index);
   bool CreateSurfaceTexture(int index);
 
+  void UploadOMXEGLTexture(int index);
+  void DeleteOMXEGLTexture(int index);
+  bool CreateOMXEGLTexture(int index);
+
   void CalculateTextureSourceRects(int source, int num_planes);
 
   // renderers
-- 
1.9.3


From 6e0a43ebc430fe18fc0f0956aa9703792db5e425 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Feb 2014 22:50:43 +0000
Subject: [PATCH 22/99] [omxcodec] Add shared pointer to delay shutdown of
 codec until buffers are returned

---
 .../DVDCodecs/Video/DVDVideoCodecOpenMax.cpp        | 13 +++----------
 .../DVDCodecs/Video/DVDVideoCodecOpenMax.h          |  3 ++-
 .../dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp      | 21 ++++++++++++++++++++-
 xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h |  5 ++++-
 4 files changed, 29 insertions(+), 13 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
index 7d33192..ef10555 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
@@ -28,7 +28,6 @@
 #include "DVDClock.h"
 #include "DVDStreamInfo.h"
 #include "DVDVideoCodecOpenMax.h"
-#include "OpenMaxVideo.h"
 #include "settings/Settings.h"
 #include "utils/log.h"
 
@@ -36,8 +35,8 @@
 ////////////////////////////////////////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////////////////////////////////////////
 CDVDVideoCodecOpenMax::CDVDVideoCodecOpenMax()
+ : m_omx_decoder( new COpenMaxVideo )
 {
-  m_omx_decoder = NULL;
   CLog::Log(LOGDEBUG, "%s::%s %p\n", CLASSNAME, __func__, this);
 }
 
@@ -49,8 +48,7 @@ CDVDVideoCodecOpenMax::~CDVDVideoCodecOpenMax()
 
 bool CDVDVideoCodecOpenMax::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
-  m_omx_decoder = new COpenMaxVideo;
-  return m_omx_decoder->Open(hints, options);
+  return m_omx_decoder->Open(hints, options, m_omx_decoder);
 }
 
 const char* CDVDVideoCodecOpenMax::GetName(void)
@@ -60,12 +58,7 @@ const char* CDVDVideoCodecOpenMax::GetName(void)
 
 void CDVDVideoCodecOpenMax::Dispose()
 {
-  if (m_omx_decoder)
-  {
-    m_omx_decoder->Dispose();
-    delete m_omx_decoder;
-    m_omx_decoder = NULL;
-  }
+  m_omx_decoder->Dispose();
 }
 
 void CDVDVideoCodecOpenMax::SetDropState(bool bDrop)
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
index 67cc235..b7c0c1b 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
@@ -22,6 +22,7 @@
 #if defined(HAVE_LIBOPENMAX)
 
 #include "DVDVideoCodec.h"
+#include "OpenMaxVideo.h"
 
 class COpenMaxVideo;
 class CDVDVideoCodecOpenMax : public CDVDVideoCodec
@@ -42,7 +43,7 @@ class CDVDVideoCodecOpenMax : public CDVDVideoCodec
   virtual const char* GetName(void);
   
 protected:
-  COpenMaxVideo     *m_omx_decoder;
+  OpenMaxVideoPtr m_omx_decoder;
 };
 
 #endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
index aca2e0d..29b5bb9 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
@@ -126,6 +126,7 @@ COpenMaxVideo::COpenMaxVideo()
   m_egl_buffer_count = 0;
 
   m_port_settings_changed = false;
+  m_finished = false;
   m_pFormatName = "omx-xxxx";
 }
 
@@ -134,6 +135,7 @@ COpenMaxVideo::~COpenMaxVideo()
   #if defined(OMX_DEBUG_VERBOSE)
   CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, this);
   #endif
+  assert(m_finished);
   if (m_omx_decoder.IsInitialized())
   {
     if (m_omx_tunnel.IsInitialized())
@@ -149,7 +151,7 @@ COpenMaxVideo::~COpenMaxVideo()
   pthread_mutex_destroy(&m_omx_output_mutex);
 }
 
-bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
+bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, OpenMaxVideoPtr myself)
 {
   #if defined(OMX_DEBUG_VERBOSE)
   CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
@@ -161,6 +163,7 @@ bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
 
+  m_myself = myself;
   m_decoded_width  = hints.width;
   m_decoded_height = hints.height;
 
@@ -331,6 +334,15 @@ void COpenMaxVideo::Dispose()
   #if defined(OMX_DEBUG_VERBOSE)
   CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   #endif
+  // we are happy to exit, but let last shared pointer being deleted trigger the destructor
+  bool done = false;
+  pthread_mutex_lock(&m_omx_output_mutex);
+  if (m_omx_output_busy.empty())
+    done = true;
+  m_finished = true;
+  pthread_mutex_unlock(&m_omx_output_mutex);
+  if (done)
+    m_myself.reset();
 }
 
 void COpenMaxVideo::SetDropState(bool bDrop)
@@ -752,6 +764,13 @@ void COpenMaxVideo::ReleaseOpenMaxBuffer(COpenMaxVideoBuffer *buffer)
   m_omx_output_busy.erase(std::remove(m_omx_output_busy.begin(), m_omx_output_busy.end(), buffer), m_omx_output_busy.end());
   pthread_mutex_unlock(&m_omx_output_mutex);
   ReturnOpenMaxBuffer(buffer);
+  bool done = false;
+  pthread_mutex_lock(&m_omx_output_mutex);
+  if (m_finished && m_omx_output_busy.empty())
+    done = true;
+  pthread_mutex_unlock(&m_omx_output_mutex);
+  if (done)
+    m_myself.reset();
 }
 
 bool COpenMaxVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
index 9079c13..0975e8a 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
@@ -43,6 +43,7 @@ typedef struct omx_demux_packet {
 } omx_demux_packet;
 
 class COpenMaxVideo;
+typedef boost::shared_ptr<COpenMaxVideo> OpenMaxVideoPtr;
 // an omx egl video frame
 class COpenMaxVideoBuffer
 {
@@ -75,7 +76,7 @@ class COpenMaxVideo
   virtual ~COpenMaxVideo();
 
   // Required overrides
-  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, OpenMaxVideoPtr myself);
   virtual void Dispose(void);
   virtual int  Decode(uint8_t *pData, int iSize, double dts, double pts);
   virtual void Reset(void);
@@ -112,9 +113,11 @@ class COpenMaxVideo
   int               m_decoded_width;
   int               m_decoded_height;
   unsigned int      m_egl_buffer_count;
+  bool              m_finished;
 
   bool m_port_settings_changed;
   const char        *m_pFormatName;
+  OpenMaxVideoPtr   m_myself;
 
   std::queue<double> m_dts_queue;
   std::queue<omx_demux_packet> m_demux_queue;
-- 
1.9.3


From fd4617eec60aedd955a92de9f10bff68d85ec730 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Feb 2014 23:11:31 +0000
Subject: [PATCH 23/99] [omxcodec] Fix for aspect ratio in non-square pixel
 modes

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp | 17 +++++++++++++++++
 xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h   |  3 +++
 2 files changed, 20 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
index 29b5bb9..7e23c87 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
@@ -63,6 +63,7 @@ COpenMaxVideoBuffer::COpenMaxVideoBuffer(COpenMaxVideo *omv)
   index = 0;
   egl_image = 0;
   texture_id = 0;
+  m_aspect_ratio = 0.0f;
 }
 
 COpenMaxVideoBuffer::~COpenMaxVideoBuffer()
@@ -166,6 +167,8 @@ bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, OpenM
   m_myself = myself;
   m_decoded_width  = hints.width;
   m_decoded_height = hints.height;
+  m_forced_aspect_ratio = hints.forced_aspect;
+  m_aspect_ratio = hints.aspect;
 
   m_egl_display = g_Windowing.GetEGLDisplay();
   m_egl_context = g_Windowing.GetEGLContext();
@@ -435,6 +438,9 @@ bool COpenMaxVideo::PortSettingsChanged()
     CLog::Log(LOGERROR, "%s::%s - error m_omx_decoder.GetParameter(OMX_IndexParamBrcmPixelAspectRatio) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
     return false;
   }
+  if (!m_forced_aspect_ratio && pixel_aspect.nX && pixel_aspect.nY)
+    m_aspect_ratio = (float)pixel_aspect.nX * port_def.format.video.nFrameWidth /
+      ((float)pixel_aspect.nY * port_def.format.video.nFrameHeight);
 
   if (m_port_settings_changed)
   {
@@ -800,6 +806,16 @@ bool COpenMaxVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
     pDvdVideoPicture->iDisplayWidth  = m_decoded_width;
     pDvdVideoPicture->iDisplayHeight = m_decoded_height;
 
+    if (buffer->m_aspect_ratio > 0.0 && !m_forced_aspect_ratio)
+    {
+      pDvdVideoPicture->iDisplayWidth  = ((int)lrint(pDvdVideoPicture->iHeight * buffer->m_aspect_ratio)) & -3;
+      if (pDvdVideoPicture->iDisplayWidth > pDvdVideoPicture->iWidth)
+      {
+        pDvdVideoPicture->iDisplayWidth  = pDvdVideoPicture->iWidth;
+        pDvdVideoPicture->iDisplayHeight = ((int)lrint(pDvdVideoPicture->iWidth / buffer->m_aspect_ratio)) & -3;
+      }
+    }
+
 #ifdef DTS_QUEUE
     if (!m_dts_queue.empty())
     {
@@ -853,6 +869,7 @@ OMX_ERRORTYPE COpenMaxVideo::DecoderFillBufferDone(
 
   // queue output omx buffer to ready list.
   pthread_mutex_lock(&m_omx_output_mutex);
+  buffer->m_aspect_ratio = m_aspect_ratio;
   m_omx_output_ready.push(buffer);
   pthread_mutex_unlock(&m_omx_output_mutex);
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
index 0975e8a..9138a20 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
@@ -54,6 +54,7 @@ class COpenMaxVideoBuffer
   OMX_BUFFERHEADERTYPE *omx_buffer;
   int width;
   int height;
+  float m_aspect_ratio;
   int index;
 
   // used for egl based rendering if active
@@ -114,6 +115,8 @@ class COpenMaxVideo
   int               m_decoded_height;
   unsigned int      m_egl_buffer_count;
   bool              m_finished;
+  float             m_aspect_ratio;
+  bool              m_forced_aspect_ratio;
 
   bool m_port_settings_changed;
   const char        *m_pFormatName;
-- 
1.9.3


From 958aa93e74eaddb4a36a090febd53ef11ac1530e Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Feb 2014 23:19:22 +0000
Subject: [PATCH 24/99] [omxcodec] Report error when codec not enabled

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
index 7e23c87..2ae722b 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
@@ -43,6 +43,7 @@
 #include <IL/OMX_Image.h>
 
 #include "cores/omxplayer/OMXImage.h"
+#include "linux/RBP.h"
 
 #define DTS_QUEUE
 
@@ -155,7 +156,7 @@ COpenMaxVideo::~COpenMaxVideo()
 bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, OpenMaxVideoPtr myself)
 {
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+  CLog::Log(LOGDEBUG, "%s::%s useomx:%d software:%d", CLASSNAME, __func__, CSettings::Get().GetBool("videoplayer.useomx"), hints.software);
   #endif
 
   // we always qualify even if DVDFactoryCodec does this too.
@@ -232,6 +233,13 @@ bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, OpenM
     break;
   }
 
+  if ( (m_codingType == OMX_VIDEO_CodingMPEG2 && !g_RBP.GetCodecMpg2() ) ||
+       (m_codingType == OMX_VIDEO_CodingWMV   && !g_RBP.GetCodecWvc1() ) )
+  {
+    CLog::Log(LOGWARNING, "%s::%s Codec %s is not supported\n", CLASSNAME, __func__, m_pFormatName);
+    return false;
+  }
+
   // initialize OpenMAX.
   if (!m_omx_decoder.Initialize("OMX.broadcom.video_decode", OMX_IndexParamVideoInit))
   {
-- 
1.9.3


From cb0c54b0740722ecb04170b4dd5cf4979e45cd68 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 4 Feb 2014 17:29:37 +0000
Subject: [PATCH 25/99] [omxcodec] Add deinterlace support

---
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp    |   2 +-
 .../dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp     | 106 ++++++++++++++++++---
 .../cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h |   9 +-
 3 files changed, 103 insertions(+), 14 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index b8af8d0..51f56aa 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -2605,7 +2605,7 @@ bool CLinuxRendererGLES::Supports(EDEINTERLACEMODE mode)
     return true;
 
   if(m_renderMethod & RENDER_OMXEGL)
-    return false;
+    return true;
 
   if(m_renderMethod & RENDER_EGLIMG)
     return false;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
index 2ae722b..fbf1458 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
@@ -33,6 +33,7 @@
 #include "utils/log.h"
 #include "utils/TimeUtils.h"
 #include "settings/Settings.h"
+#include "settings/MediaSettings.h"
 #include "ApplicationMessenger.h"
 #include "Application.h"
 #include "threads/Atomics.h"
@@ -130,6 +131,10 @@ COpenMaxVideo::COpenMaxVideo()
   m_port_settings_changed = false;
   m_finished = false;
   m_pFormatName = "omx-xxxx";
+
+  m_deinterlace = false;
+  m_deinterlace_request = VS_DEINTERLACEMODE_OFF;
+  m_deinterlace_second_field = false;
 }
 
 COpenMaxVideo::~COpenMaxVideo()
@@ -140,13 +145,17 @@ COpenMaxVideo::~COpenMaxVideo()
   assert(m_finished);
   if (m_omx_decoder.IsInitialized())
   {
-    if (m_omx_tunnel.IsInitialized())
-      m_omx_tunnel.Deestablish();
+    if (m_omx_tunnel_decoder.IsInitialized())
+      m_omx_tunnel_decoder.Deestablish();
+    if (m_omx_tunnel_image_fx.IsInitialized())
+      m_omx_tunnel_image_fx.Deestablish();
 
     StopDecoder();
 
     if (m_omx_egl_render.IsInitialized())
       m_omx_egl_render.Deinitialize();
+    if (m_omx_image_fx.IsInitialized())
+      m_omx_image_fx.Deinitialize();
     if (m_omx_decoder.IsInitialized())
       m_omx_decoder.Deinitialize();
   }
@@ -165,6 +174,8 @@ bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, OpenM
 
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
 
+  m_deinterlace_request = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+
   m_myself = myself;
   m_decoded_width  = hints.width;
   m_decoded_height = hints.height;
@@ -467,6 +478,49 @@ bool COpenMaxVideo::PortSettingsChanged()
     return false;
   }
 
+  OMX_CONFIG_INTERLACETYPE interlace;
+  OMX_INIT_STRUCTURE(interlace);
+  interlace.nPortIndex = m_omx_decoder.GetOutputPort();
+  omx_err = m_omx_decoder.GetConfig(OMX_IndexConfigCommonInterlace, &interlace);
+
+  if (m_deinterlace_request == VS_DEINTERLACEMODE_FORCE)
+    m_deinterlace = true;
+  else if (m_deinterlace_request == VS_DEINTERLACEMODE_OFF)
+    m_deinterlace = false;
+  else
+    m_deinterlace = interlace.eMode != OMX_InterlaceProgressive;
+
+  CLog::Log(LOGDEBUG, "%s::%s - %dx%d@%.2f interlace:%d deinterlace:%d",
+  CLASSNAME, __func__, port_def.format.video.nFrameWidth, port_def.format.video.nFrameHeight, port_def.format.video.xFramerate / (float) (1 << 16),
+      interlace.eMode, m_deinterlace);
+
+  if (m_deinterlace)
+  {
+    if (!m_omx_image_fx.Initialize("OMX.broadcom.image_fx", OMX_IndexParamImageInit))
+    {
+      CLog::Log(LOGERROR, "%s::%s error m_omx_image_fx.Initialize", CLASSNAME, __func__);
+      return false;
+    }
+  }
+
+  if (m_deinterlace)
+  {
+    OMX_CONFIG_IMAGEFILTERPARAMSTYPE image_filter;
+    OMX_INIT_STRUCTURE(image_filter);
+
+    image_filter.nPortIndex = m_omx_image_fx.GetOutputPort();
+    image_filter.nNumParams = 1;
+    image_filter.nParams[0] = 3;
+    image_filter.eImageFilter = OMX_ImageFilterDeInterlaceAdvanced;
+
+    omx_err = m_omx_image_fx.SetConfig(OMX_IndexConfigCommonImageFilterParameters, &image_filter);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - OMX_IndexConfigCommonImageFilterParameters omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+
   OMX_CALLBACKTYPE callbacks = { NULL, NULL, DecoderFillBufferDoneCallback };
   if (!m_omx_egl_render.Initialize("OMX.broadcom.egl_render", OMX_IndexParamVideoInit, &callbacks))
   {
@@ -487,19 +541,40 @@ bool COpenMaxVideo::PortSettingsChanged()
 
   m_omx_egl_render.ResetEos();
 
-  CLog::Log(LOGDEBUG, "%s::%s - %dx%d@%.2f interlace:%d deinterlace:%d", CLASSNAME, __func__,
-      port_def.format.video.nFrameWidth, port_def.format.video.nFrameHeight,
-      port_def.format.video.xFramerate / (float)(1<<16), 0,0);
-
-  m_omx_tunnel.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_egl_render, m_omx_egl_render.GetInputPort());
+  if (m_deinterlace)
+  {
+    m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_image_fx, m_omx_image_fx.GetInputPort());
+    m_omx_tunnel_image_fx.Initialize(&m_omx_image_fx, m_omx_image_fx.GetOutputPort(), &m_omx_egl_render, m_omx_egl_render.GetInputPort());
+  }
+  else
+  {
+    m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_egl_render, m_omx_egl_render.GetInputPort());
+  }
 
-  omx_err = m_omx_tunnel.Establish();
+  omx_err = m_omx_tunnel_decoder.Establish();
   if (omx_err != OMX_ErrorNone)
   {
-    CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+    CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel_decoder.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
     return false;
   }
 
+  if (m_deinterlace)
+  {
+    omx_err = m_omx_tunnel_image_fx.Establish();
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_tunnel_image_fx.Establish omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+    omx_err = m_omx_image_fx.SetStateForComponent(OMX_StateExecuting);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s - m_omx_image_fx.SetStateForComponent omx_err(0x%08x)",
+      CLASSNAME, __func__, omx_err);
+      return false;
+    }
+  }
+
   // Obtain the information about the output port.
   OMX_PARAM_PORTDEFINITIONTYPE port_format;
   OMX_INIT_STRUCTURE(port_format);
@@ -724,8 +799,12 @@ void COpenMaxVideo::Reset(void)
   #if defined(OMX_DEBUG_VERBOSE)
   CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   #endif
-  m_omx_egl_render.FlushAll();
-  m_omx_decoder.FlushAll();
+  if (m_omx_egl_render.IsInitialized())
+    m_omx_egl_render.FlushAll();
+  if (m_omx_image_fx.IsInitialized())
+    m_omx_image_fx.FlushAll();
+  if (m_omx_decoder.IsInitialized())
+    m_omx_decoder.FlushAll();
   // blow all ready video frames
   while (!m_omx_output_ready.empty())
   {
@@ -825,11 +904,14 @@ bool COpenMaxVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
     }
 
 #ifdef DTS_QUEUE
-    if (!m_dts_queue.empty())
+    if (!m_deinterlace_second_field)
     {
+      assert(!m_dts_queue.empty());
       pDvdVideoPicture->dts = m_dts_queue.front();
       m_dts_queue.pop();
     }
+    if (m_deinterlace)
+      m_deinterlace_second_field = !m_deinterlace_second_field;
 #endif
     // nTimeStamp is in microseconds
     double ts = FromOMXTime(buffer->omx_buffer->nTimeStamp);
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
index 9138a20..c8ad4d8 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
@@ -31,6 +31,7 @@
 #include "cores/dvdplayer/DVDStreamInfo.h"
 #include "DVDVideoCodec.h"
 #include "threads/Event.h"
+#include "xbmc/settings/VideoSettings.h"
 
 #include <queue>
 #include <semaphore.h>
@@ -136,11 +137,17 @@ class COpenMaxVideo
 
   // Components
   COMXCoreComponent m_omx_decoder;
+  COMXCoreComponent m_omx_image_fx;
   COMXCoreComponent m_omx_egl_render;
 
-  COMXCoreTunel     m_omx_tunnel;
+  COMXCoreTunel     m_omx_tunnel_decoder;
+  COMXCoreTunel     m_omx_tunnel_image_fx;
   OMX_VIDEO_CODINGTYPE m_codingType;
 
+  bool              m_deinterlace;
+  EDEINTERLACEMODE  m_deinterlace_request;
+  bool              m_deinterlace_second_field;
+
   bool PortSettingsChanged();
   bool SendDecoderConfig(uint8_t *extradata, int extrasize);
   bool NaluFormatStartCodes(enum AVCodecID codec, uint8_t *extradata, int extrasize);
-- 
1.9.3


From e6cc3100344927e13a5be2050d59f675636542ef Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 5 Feb 2014 11:46:33 +0000
Subject: [PATCH 26/99] [rbp/settings] Allow av sync type to be enabled

It works for dvdplayer
---
 system/settings/rbp.xml | 7 -------
 1 file changed, 7 deletions(-)

diff --git a/system/settings/rbp.xml b/system/settings/rbp.xml
index 2b7d0a6..1429256 100644
--- a/system/settings/rbp.xml
+++ b/system/settings/rbp.xml
@@ -1,13 +1,6 @@
 <?xml version="1.0" encoding="utf-8" ?>
 <settings>
   <section id="videos">
-    <category id="videoplayer">
-      <group id="2">
-        <setting id="videoplayer.synctype">
-          <visible>false</visible>
-        </setting>
-      </group>
-    </category>
     <category id="videoacceleration">
       <group id="1">
         <visible>false</visible>
-- 
1.9.3


From f327c953cc9d77c4f02a01bca3d5e7ad9e2c041e Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Thu, 1 May 2014 16:28:39 +0100
Subject: [PATCH 27/99] Improved file buffering in CArchive

Even though memcpy is typically inlined by the compiler into byte/word loads
and stores (at least for release builds), the frequency with which 1, 2 and 4
byte loads/stores are encountered in cases where the size is *not*
determinable at compile time is still high enough that it's worth handling
these specially. On the ARM1176JZF-S in the Raspberry Pi, this improves the
total time to open a library (in the case where it's fetched from a CArchive)
by around 4%.

It should be noted that this code uses 16-bit and 32-bit word loads and
stores that are not necessarily aligned to their respective widths. It is
possible that there are some architectures out there which do not support
this, although all ARMs since ARMv6 have supported it (and ARMs earlier than
that are probably not powerful enough to be good targets for XBMC).
---
 xbmc/utils/Archive.h | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/xbmc/utils/Archive.h b/xbmc/utils/Archive.h
index 6ed0f8f..8506d95 100644
--- a/xbmc/utils/Archive.h
+++ b/xbmc/utils/Archive.h
@@ -154,9 +154,17 @@ class CArchive
      * than waiting until we attempt to put more data into an already full buffer */
     if (m_BufferRemain > size)
     {
+      switch (size)
+      {
+      case 1: *m_BufferPos++ = *ptr; m_BufferRemain--; break;
+      case 2: *(uint16_t *) m_BufferPos = *(const uint16_t *) ptr; m_BufferPos += 2; m_BufferRemain -= 2; break;
+      case 4: *(uint32_t *) m_BufferPos = *(const uint32_t *) ptr; m_BufferPos += 4; m_BufferRemain -= 4; break;
+      default:
       memcpy(m_BufferPos, ptr, size);
       m_BufferPos += size;
       m_BufferRemain -= size;
+      break;
+      }
       return *this;
     }
     else
@@ -171,9 +179,17 @@ class CArchive
     /* Note, refilling the buffer is deferred until we know we need to read more from it */
     if (m_BufferRemain >= size)
     {
+      switch (size)
+      {
+      case 1: *ptr = *m_BufferPos++; m_BufferRemain--; break;
+      case 2: *(uint16_t *) ptr = *(const uint16_t *) m_BufferPos; m_BufferPos += 2; m_BufferRemain -= 2; break;
+      case 4: *(uint32_t *) ptr = *(const uint32_t *) m_BufferPos; m_BufferPos += 4; m_BufferRemain -= 4; break;
+      default:
       memcpy(ptr, m_BufferPos, size);
       m_BufferPos += size;
       m_BufferRemain -= size;
+      break;
+      }
       return *this;
     }
     else
-- 
1.9.3


From 673af4509532521db5b4dc739906d03e849d984e Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 16 Feb 2014 17:38:05 +0000
Subject: [PATCH 28/99] [omxcodec] Only do essential calls in texture thread
 [omxcodec] Fix for files with no valid pts values. [omxcodec] Fix stall on
 seek/trickplay - need to reset start flag [omxcodec] Make sure we have a
 valid context when video decode starts before first fanart is decoded
 [omxcodec] More care with dropping frames quickly

---
 .../dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp     | 127 ++++++++++++++-------
 .../cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h |  14 +--
 2 files changed, 89 insertions(+), 52 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
index fbf1458..71d19af 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
@@ -55,6 +55,9 @@
 
 #define CLASSNAME "COpenMaxVideo"
 
+#define OMX_BUFFERFLAG_PTS_INVALID (1<<28)
+#define OMX_BUFFERFLAG_DROPPED     (1<<29)
+
 COpenMaxVideoBuffer::COpenMaxVideoBuffer(COpenMaxVideo *omv)
     : m_omv(omv), m_refs(0)
 {
@@ -120,7 +123,9 @@ void COpenMaxVideoBuffer::Sync()
 
 COpenMaxVideo::COpenMaxVideo()
 {
+  #if defined(OMX_DEBUG_VERBOSE)
   CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, this);
+  #endif
   pthread_mutex_init(&m_omx_output_mutex, NULL);
 
   m_drop_state = false;
@@ -135,6 +140,7 @@ COpenMaxVideo::COpenMaxVideo()
   m_deinterlace = false;
   m_deinterlace_request = VS_DEINTERLACEMODE_OFF;
   m_deinterlace_second_field = false;
+  m_startframe = false;
 }
 
 COpenMaxVideo::~COpenMaxVideo()
@@ -182,8 +188,6 @@ bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, OpenM
   m_forced_aspect_ratio = hints.forced_aspect;
   m_aspect_ratio = hints.aspect;
 
-  m_egl_display = g_Windowing.GetEGLDisplay();
-  m_egl_context = g_Windowing.GetEGLContext();
   m_egl_buffer_count = 4;
 
   m_codingType = OMX_VIDEO_CodingUnused;
@@ -347,6 +351,7 @@ bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, OpenM
     return false;
 
   m_drop_state = false;
+  m_startframe = false;
 
   return true;
 }
@@ -375,6 +380,25 @@ void COpenMaxVideo::SetDropState(bool bDrop)
       CLASSNAME, __func__, bDrop);
 #endif
   m_drop_state = bDrop;
+  if (m_drop_state)
+  {
+    while (1)
+    {
+      COpenMaxVideoBuffer *buffer = NULL;
+      pthread_mutex_lock(&m_omx_output_mutex);
+      // fetch a output buffer and pop it off the ready list
+      if (!m_omx_output_ready.empty())
+      {
+        buffer = m_omx_output_ready.front();
+        m_omx_output_ready.pop();
+      }
+      pthread_mutex_unlock(&m_omx_output_mutex);
+      if (buffer)
+        ReturnOpenMaxBuffer(buffer);
+      else
+        break;
+    }
+  }
 }
 
 bool COpenMaxVideo::SendDecoderConfig(uint8_t *extradata, int extrasize)
@@ -713,10 +737,13 @@ int COpenMaxVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
 
       if (demuxer_bytes == 0)
         omx_buffer->nFlags |= OMX_BUFFERFLAG_ENDOFFRAME;
-      if (pts == DVD_NOPTS_VALUE)
+      // openmax doesn't like an unknown timestamp as first frame
+      if (pts == DVD_NOPTS_VALUE && m_startframe)
         omx_buffer->nFlags |= OMX_BUFFERFLAG_TIME_UNKNOWN;
+      if (pts == DVD_NOPTS_VALUE) // hijack an omx flag to indicate there wasn't a real timestamp - it will be returned with the picture (but otherwise ignored)
+        omx_buffer->nFlags |= OMX_BUFFERFLAG_PTS_INVALID;
       if (m_drop_state) // hijack an omx flag to signal this frame to be dropped - it will be returned with the picture (but otherwise ignored)
-        omx_buffer->nFlags |= OMX_BUFFERFLAG_DATACORRUPT;
+        omx_buffer->nFlags |= OMX_BUFFERFLAG_DECODEONLY | OMX_BUFFERFLAG_DROPPED;
 
 #if defined(OMX_DEBUG_VERBOSE)
       CLog::Log(LOGDEBUG, "%s::%s - %-6d dts:%.3f pts:%.3f flags:%x",
@@ -731,10 +758,14 @@ int COpenMaxVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
       }
       if (demuxer_bytes == 0)
       {
+        m_startframe = true;
 #ifdef DTS_QUEUE
-        // only push if we are successful with feeding OMX_EmptyThisBuffer
-        m_dts_queue.push(dts);
-        assert(m_dts_queue.size() < 32);
+        if (!m_drop_state)
+        {
+          // only push if we are successful with feeding OMX_EmptyThisBuffer
+          m_dts_queue.push(dts);
+          assert(m_dts_queue.size() < 32);
+        }
 #endif
         if (buffer_to_free)
         {
@@ -806,15 +837,8 @@ void COpenMaxVideo::Reset(void)
   if (m_omx_decoder.IsInitialized())
     m_omx_decoder.FlushAll();
   // blow all ready video frames
-  while (!m_omx_output_ready.empty())
-  {
-    pthread_mutex_lock(&m_omx_output_mutex);
-    COpenMaxVideoBuffer *pic = m_omx_output_ready.front();
-    m_omx_output_ready.pop();
-    pthread_mutex_unlock(&m_omx_output_mutex);
-    // return the omx buffer back to OpenMax to fill.
-    ReturnOpenMaxBuffer(pic);
-  }
+  SetDropState(true);
+  SetDropState(false);
 #ifdef DTS_QUEUE
   while (!m_dts_queue.empty())
     m_dts_queue.pop();
@@ -822,6 +846,7 @@ void COpenMaxVideo::Reset(void)
 
   while (!m_demux_queue.empty())
     m_demux_queue.pop();
+  m_startframe = false;
 }
 
 
@@ -914,17 +939,17 @@ bool COpenMaxVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
       m_deinterlace_second_field = !m_deinterlace_second_field;
 #endif
     // nTimeStamp is in microseconds
-    double ts = FromOMXTime(buffer->omx_buffer->nTimeStamp);
-    pDvdVideoPicture->pts = (ts == 0) ? DVD_NOPTS_VALUE : ts;
+    pDvdVideoPicture->pts = FromOMXTime(buffer->omx_buffer->nTimeStamp);
     pDvdVideoPicture->openMaxBuffer->Acquire();
     pDvdVideoPicture->iFlags  = DVP_FLAG_ALLOCATED;
-    if (buffer->omx_buffer->nFlags & OMX_BUFFERFLAG_DATACORRUPT)
-      pDvdVideoPicture->iFlags |= DVP_FLAG_DROPPED;
+    if (buffer->omx_buffer->nFlags & OMX_BUFFERFLAG_PTS_INVALID)
+      pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
 #if defined(OMX_DEBUG_VERBOSE)
     CLog::Log(LOGINFO, "%s::%s dts:%.3f pts:%.3f flags:%x:%x openMaxBuffer:%p omx_buffer:%p egl_image:%p texture_id:%x", CLASSNAME, __func__,
         pDvdVideoPicture->dts == DVD_NOPTS_VALUE ? 0.0 : pDvdVideoPicture->dts*1e-6, pDvdVideoPicture->pts == DVD_NOPTS_VALUE ? 0.0 : pDvdVideoPicture->pts*1e-6,
         pDvdVideoPicture->iFlags, buffer->omx_buffer->nFlags, pDvdVideoPicture->openMaxBuffer, pDvdVideoPicture->openMaxBuffer->omx_buffer, pDvdVideoPicture->openMaxBuffer->egl_image, pDvdVideoPicture->openMaxBuffer->texture_id);
 #endif
+    assert(!(buffer->omx_buffer->nFlags & (OMX_BUFFERFLAG_DECODEONLY | OMX_BUFFERFLAG_DROPPED)));
   }
   else
   {
@@ -953,10 +978,11 @@ OMX_ERRORTYPE COpenMaxVideo::DecoderFillBufferDone(
   COpenMaxVideoBuffer *buffer = (COpenMaxVideoBuffer*)pBuffer->pAppPrivate;
 
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s - %p (%p,%p) buffer_size(%u), pts:%.3f",
-    CLASSNAME, __func__, buffer, pBuffer, buffer->omx_buffer, pBuffer->nFilledLen, (double)FromOMXTime(buffer->omx_buffer->nTimeStamp)*1e-6);
+  CLog::Log(LOGDEBUG, "%s::%s - %p (%p,%p) buffer_size(%u), pts:%.3f flags:%x",
+    CLASSNAME, __func__, buffer, pBuffer, buffer->omx_buffer, pBuffer->nFilledLen, (double)FromOMXTime(buffer->omx_buffer->nTimeStamp)*1e-6, buffer->omx_buffer->nFlags);
   #endif
 
+  assert(!(buffer->omx_buffer->nFlags & (OMX_BUFFERFLAG_DECODEONLY | OMX_BUFFERFLAG_DROPPED)));
   // queue output omx buffer to ready list.
   pthread_mutex_lock(&m_omx_output_mutex);
   buffer->m_aspect_ratio = m_aspect_ratio;
@@ -1000,41 +1026,60 @@ OMX_ERRORTYPE COpenMaxVideo::FreeOMXInputBuffers(void)
   return(omx_err);
 }
 
-bool COpenMaxVideo::CallbackAllocOMXEGLTextures(void *userdata)
+bool COpenMaxVideo::CallbackAllocOMXEGLTextures(EGLDisplay egl_display, EGLContext egl_context, void *userdata)
 {
   COpenMaxVideo *omx = static_cast<COpenMaxVideo*>(userdata);
-  return omx->AllocOMXOutputEGLTextures() == OMX_ErrorNone;
+  return omx->AllocOMXOutputEGLTextures(egl_display, egl_context) == OMX_ErrorNone;
 }
 
-bool COpenMaxVideo::CallbackFreeOMXEGLTextures(void *userdata)
+bool COpenMaxVideo::CallbackFreeOMXEGLTextures(EGLDisplay egl_display, EGLContext egl_context, void *userdata)
 {
   COpenMaxVideo *omx = static_cast<COpenMaxVideo*>(userdata);
-  return omx->FreeOMXOutputEGLTextures() == OMX_ErrorNone;
+  return omx->FreeOMXOutputEGLTextures(egl_display, egl_context) == OMX_ErrorNone;
 }
 
 bool COpenMaxVideo::AllocOMXOutputBuffers(void)
 {
-  return g_OMXImage.SendMessage(CallbackAllocOMXEGLTextures, (void *)this);
+  pthread_mutex_lock(&m_omx_output_mutex);
+  for (size_t i = 0; i < m_egl_buffer_count; i++)
+  {
+    COpenMaxVideoBuffer *egl_buffer = new COpenMaxVideoBuffer(this);
+    egl_buffer->width  = m_decoded_width;
+    egl_buffer->height = m_decoded_height;
+    egl_buffer->index = i;
+    m_omx_output_buffers.push_back(egl_buffer);
+  }
+  bool ret = g_OMXImage.SendMessage(CallbackAllocOMXEGLTextures, (void *)this);
+  pthread_mutex_unlock(&m_omx_output_mutex);
+  return ret;
 }
 
 bool COpenMaxVideo::FreeOMXOutputBuffers(void)
 {
-  return g_OMXImage.SendMessage(CallbackFreeOMXEGLTextures, (void *)this);
+  pthread_mutex_lock(&m_omx_output_mutex);
+  bool ret = g_OMXImage.SendMessage(CallbackFreeOMXEGLTextures, (void *)this);
+
+  for (size_t i = 0; i < m_omx_output_buffers.size(); i++)
+  {
+    COpenMaxVideoBuffer *egl_buffer = m_omx_output_buffers[i];
+    delete egl_buffer;
+  }
+
+  m_omx_output_buffers.clear();
+  pthread_mutex_unlock(&m_omx_output_mutex);
+  return ret;
 }
 
-OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputEGLTextures(void)
+OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputEGLTextures(EGLDisplay egl_display, EGLContext egl_context)
 {
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
   EGLint attrib = EGL_NONE;
-  COpenMaxVideoBuffer *egl_buffer;
 
   glActiveTexture(GL_TEXTURE0);
 
   for (size_t i = 0; i < m_egl_buffer_count; i++)
   {
-    egl_buffer = new COpenMaxVideoBuffer(this);
-    egl_buffer->width  = m_decoded_width;
-    egl_buffer->height = m_decoded_height;
+    COpenMaxVideoBuffer *egl_buffer = m_omx_output_buffers[i];
 
     glGenTextures(1, &egl_buffer->texture_id);
     glBindTexture(GL_TEXTURE_2D, egl_buffer->texture_id);
@@ -1057,8 +1102,8 @@ OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputEGLTextures(void)
 
     // create EGLImage from texture
     egl_buffer->egl_image = eglCreateImageKHR(
-      m_egl_display,
-      m_egl_context,
+      egl_display,
+      egl_context,
       EGL_GL_TEXTURE_2D_KHR,
       (EGLClientBuffer)(egl_buffer->texture_id),
       &attrib);
@@ -1067,7 +1112,6 @@ OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputEGLTextures(void)
       CLog::Log(LOGERROR, "%s::%s - ERROR creating EglImage", CLASSNAME, __func__);
       return(OMX_ErrorUndefined);
     }
-    egl_buffer->index = i;
 
     // tell decoder output port that it will be using EGLImage
     omx_err = m_omx_egl_render.UseEGLImage(
@@ -1078,7 +1122,6 @@ OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputEGLTextures(void)
         CLASSNAME, __func__, omx_err);
       return(omx_err);
     }
-    m_omx_output_buffers.push_back(egl_buffer);
 
     CLog::Log(LOGDEBUG, "%s::%s - Texture %p Width %d Height %d",
       CLASSNAME, __func__, egl_buffer->egl_image, egl_buffer->width, egl_buffer->height);
@@ -1086,26 +1129,22 @@ OMX_ERRORTYPE COpenMaxVideo::AllocOMXOutputEGLTextures(void)
   return omx_err;
 }
 
-OMX_ERRORTYPE COpenMaxVideo::FreeOMXOutputEGLTextures(void)
+OMX_ERRORTYPE COpenMaxVideo::FreeOMXOutputEGLTextures(EGLDisplay egl_display, EGLContext egl_context)
 {
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-  COpenMaxVideoBuffer *egl_buffer;
 
   for (size_t i = 0; i < m_omx_output_buffers.size(); i++)
   {
-    egl_buffer = m_omx_output_buffers[i];
+    COpenMaxVideoBuffer *egl_buffer = m_omx_output_buffers[i];
     // tell decoder output port to stop using the EGLImage
     omx_err = m_omx_egl_render.FreeOutputBuffer(egl_buffer->omx_buffer);
     if (omx_err != OMX_ErrorNone)
       CLog::Log(LOGERROR, "%s::%s m_omx_egl_render.FreeOutputBuffer(%p) omx_err(0x%08x)", CLASSNAME, __func__, egl_buffer->omx_buffer, omx_err);
     // destroy egl_image
-    eglDestroyImageKHR(m_egl_display, egl_buffer->egl_image);
+    eglDestroyImageKHR(egl_display, egl_buffer->egl_image);
     // free texture
     glDeleteTextures(1, &egl_buffer->texture_id);
-    delete egl_buffer;
   }
-  m_omx_output_buffers.clear();
-
   return omx_err;
 }
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
index c8ad4d8..f234f6d 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
@@ -99,17 +99,13 @@ class COpenMaxVideo
   OMX_ERRORTYPE FreeOMXInputBuffers(void);
   bool AllocOMXOutputBuffers(void);
   bool FreeOMXOutputBuffers(void);
-  static bool CallbackAllocOMXEGLTextures(void*);
-  OMX_ERRORTYPE AllocOMXOutputEGLTextures(void);
-  static bool CallbackFreeOMXEGLTextures(void*);
-  OMX_ERRORTYPE FreeOMXOutputEGLTextures(void);
+  static bool CallbackAllocOMXEGLTextures(EGLDisplay egl_display, EGLContext egl_context, void*);
+  OMX_ERRORTYPE AllocOMXOutputEGLTextures(EGLDisplay egl_display, EGLContext egl_context);
+  static bool CallbackFreeOMXEGLTextures(EGLDisplay egl_display, EGLContext egl_context, void*);
+  OMX_ERRORTYPE FreeOMXOutputEGLTextures(EGLDisplay egl_display, EGLContext egl_context);
   OMX_ERRORTYPE StopDecoder(void);
   OMX_ERRORTYPE ReturnOpenMaxBuffer(COpenMaxVideoBuffer *buffer);
 
-  // EGL Resources
-  EGLDisplay        m_egl_display;
-  EGLContext        m_egl_context;
-
   // Video format
   bool              m_drop_state;
   int               m_decoded_width;
@@ -148,6 +144,8 @@ class COpenMaxVideo
   EDEINTERLACEMODE  m_deinterlace_request;
   bool              m_deinterlace_second_field;
 
+  bool              m_startframe;
+
   bool PortSettingsChanged();
   bool SendDecoderConfig(uint8_t *extradata, int extrasize);
   bool NaluFormatStartCodes(enum AVCodecID codec, uint8_t *extradata, int extrasize);
-- 
1.9.3


From b31370c5583dcee46d5fd5fae1abfcd1c88036a6 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 8 Mar 2014 15:36:06 +0000
Subject: [PATCH 29/99] [hifiberry] Hack: force it to be recognised as IEC958
 capable to enable passthrough options

---
 xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
index 8dee4bc..cc79e80 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
@@ -1296,6 +1296,10 @@ void CAESinkALSA::EnumerateDevice(AEDeviceInfoList &list, const std::string &dev
     if (snd_card_get_name(cardNr, &cardName) == 0)
       info.m_displayName = cardName;
 
+    // hack: hifiberry digi doesn't correctly report as iec958 device. Needs fixing in kernel driver
+    if (info.m_displayName == "snd_rpi_hifiberry_digi")
+      info.m_deviceType = AE_DEVTYPE_IEC958;
+
     if (info.m_deviceType == AE_DEVTYPE_HDMI && info.m_displayName.size() > 5 &&
         info.m_displayName.substr(info.m_displayName.size()-5) == " HDMI")
     {
-- 
1.9.3


From 4f93a32a7c009500cfaa33c4c1591047418c61d0 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 11 Mar 2014 18:50:23 +0000
Subject: [PATCH 30/99] [dvdplayer] Use inexact seeking like omxplayer

---
 xbmc/cores/dvdplayer/DVDPlayer.cpp | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index adbc312..dc0d6b2 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -1887,7 +1887,11 @@ void CDVDPlayer::CheckAutoSceneSkip()
     /*
      * Seeking is NOT flushed so any content up to the demux point is retained when playing forwards.
      */
+#ifdef TARGET_RASPBERRY_PI
+    m_messenger.Put(new CDVDMsgPlayerSeek((int)seek, true, true, true, false, true));
+#else
     m_messenger.Put(new CDVDMsgPlayerSeek((int)seek, true, false, true, false, true));
+#endif
     /*
      * Seek doesn't always work reliably. Last physical seek time is recorded to prevent looping
      * if there was an error with seeking and it landed somewhere unexpected, perhaps back in the
@@ -1905,7 +1909,11 @@ void CDVDPlayer::CheckAutoSceneSkip()
     /*
      * Seeking is NOT flushed so any content up to the demux point is retained when playing forwards.
      */
+#ifdef TARGET_RASPBERRY_PI
+    m_messenger.Put(new CDVDMsgPlayerSeek(cut.end + 1, true, false, true, false, true));
+#else
     m_messenger.Put(new CDVDMsgPlayerSeek(cut.end + 1, true, false, true, false, true));
+#endif
     /*
      * Each commercial break is only skipped once so poorly detected commercial breaks can be
      * manually re-entered. Start and end are recorded to prevent looping and to allow seeking back
@@ -3105,9 +3113,12 @@ void CDVDPlayer::UpdateClockMaster()
 void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate)
 {
   double startpts;
+#ifndef TARGET_RASPBERRY_PI
+  /* for now, ignore accurate flag as it discards keyframes and causes corrupt frames */
   if(accurate)
     startpts = pts;
   else
+#endif
     startpts = DVD_NOPTS_VALUE;
 
   /* call with demuxer pts */
-- 
1.9.3


From d5e9b2aa6486c6f15aae439bcdb74b54d114c3d5 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 7 Apr 2014 18:19:32 +0100
Subject: [PATCH 31/99] [rbp/omxplayer] When opening a stream don't try to
 update gui so often

---
 xbmc/dialogs/GUIDialogBusy.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/dialogs/GUIDialogBusy.cpp b/xbmc/dialogs/GUIDialogBusy.cpp
index e9ba7d3..0fdc3c2 100644
--- a/xbmc/dialogs/GUIDialogBusy.cpp
+++ b/xbmc/dialogs/GUIDialogBusy.cpp
@@ -64,7 +64,11 @@ bool CGUIDialogBusy::WaitOnEvent(CEvent &event, unsigned int displaytime /* = 10
     if (dialog)
     {
       dialog->Show();
+#ifdef TARGET_RASPBERRY_PI
+      while(!event.WaitMSec(100))
+#else
       while(!event.WaitMSec(1))
+#endif
       {
         g_windowManager.ProcessRenderLoop(false);
         if (allowCancel && dialog->IsCanceled())
-- 
1.9.3


From 543cb5fce2846f4822160189d792d09edff8fffa Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 7 Apr 2014 15:28:57 +0100
Subject: [PATCH 32/99] [omxcodec] Clamp video texture at edges to avoid image
 wrapping

---
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index 51f56aa..2929a37 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -1337,6 +1337,8 @@ void CLinuxRendererGLES::RenderOpenMax(int index, int field)
   GLint filter = m_scalingMethod == VS_SCALINGMETHOD_NEAREST ? GL_NEAREST : GL_LINEAR;
   glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, filter);
   glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, filter);
+  glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+  glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 
   g_Windowing.EnableGUIShader(SM_TEXTURE_RGBA);
 
-- 
1.9.3


From 3aaea5bd52ed3554771f6f14efbd8ddbebf6d845 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 30 Mar 2014 15:54:34 +0100
Subject: [PATCH 33/99] [omxplayer] Make the sharpness control act as a
 sharpness control.

This fixes scaling kernel as Mitchell Netravali, and varies sharpness over range B=[5/3,0] C=[-1/3,1/2]
---
 xbmc/cores/omxplayer/OMXPlayer.cpp | 338 +++++++++++++++++++++++++++++++++++++
 1 file changed, 338 insertions(+)

diff --git a/xbmc/cores/omxplayer/OMXPlayer.cpp b/xbmc/cores/omxplayer/OMXPlayer.cpp
index ab651b9..9fcfa23 100644
--- a/xbmc/cores/omxplayer/OMXPlayer.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayer.cpp
@@ -1042,6 +1042,334 @@ bool COMXPlayer::IsBetterStream(COMXCurrentStream& current, CDemuxStream* stream
   return false;
 }
 
+static void SetSharpness(float sharpness)
+{
+  const int16_t mitchells[][32] =
+  {
+      { // B=1.66667 C=-0.33333
+         0,  3,  8, 15, 24, 35, 49, 55, 70, 92,100,107,109,113,113,114,114,113,113,109,107,100, 92, 70, 55, 49, 35, 24, 15,  8,  3,  0,
+      },
+      { // B=1.64000 C=-0.32000
+         0,  3,  7, 14, 24, 34, 48, 54, 69, 91,100,107,111,114,116,116,116,116,114,111,107,100, 91, 69, 54, 48, 34, 24, 14,  7,  3,  0,
+      },
+      { // B=1.61333 C=-0.30667
+         0,  3,  7, 14, 23, 34, 47, 53, 68, 90, 99,107,112,115,118,118,118,118,115,112,107, 99, 90, 68, 53, 47, 34, 23, 14,  7,  3,  0,
+      },
+      { // B=1.58667 C=-0.29333
+         0,  2,  7, 14, 22, 33, 46, 52, 67, 89, 99,107,113,117,119,121,121,119,117,113,107, 99, 89, 67, 52, 46, 33, 22, 14,  7,  2,  0,
+      },
+      { // B=1.56000 C=-0.28000
+         0,  2,  7, 13, 22, 32, 45, 51, 66, 88, 98,107,114,119,121,123,123,121,119,114,107, 98, 88, 66, 51, 45, 32, 22, 13,  7,  2,  0,
+      },
+      { // B=1.53333 C=-0.26667
+         0,  2,  7, 12, 21, 31, 44, 50, 65, 87, 98,108,114,120,123,125,125,123,120,114,108, 98, 87, 65, 50, 44, 31, 21, 12,  7,  2,  0,
+      },
+      { // B=1.50667 C=-0.25333
+         0,  2,  6, 12, 20, 30, 43, 49, 64, 86, 98,108,116,122,125,127,127,125,122,116,108, 98, 86, 64, 49, 43, 30, 20, 12,  6,  2,  0,
+      },
+      { // B=1.48000 C=-0.24000
+         0,  2,  6, 12, 19, 29, 42, 47, 63, 85, 98,108,117,123,127,130,130,127,123,117,108, 98, 85, 63, 47, 42, 29, 19, 12,  6,  2,  0,
+      },
+      { // B=1.45333 C=-0.22667
+         0,  2,  6, 11, 19, 28, 41, 46, 62, 85, 97,108,118,125,129,132,132,129,125,118,108, 97, 85, 62, 46, 41, 28, 19, 11,  6,  2,  0,
+      },
+      { // B=1.42667 C=-0.21333
+         0,  2,  5, 11, 18, 28, 40, 45, 61, 84, 97,108,119,126,131,134,134,131,126,119,108, 97, 84, 61, 45, 40, 28, 18, 11,  5,  2,  0,
+      },
+      { // B=1.40000 C=-0.20000
+         0,  2,  5, 10, 18, 27, 39, 44, 60, 84, 96,109,119,127,134,136,136,134,127,119,109, 96, 84, 60, 44, 39, 27, 18, 10,  5,  2,  0,
+      },
+      { // B=1.37333 C=-0.18667
+         0,  1,  5, 10, 17, 26, 38, 43, 58, 82, 96,109,120,129,135,139,139,135,129,120,109, 96, 82, 58, 43, 38, 26, 17, 10,  5,  1,  0,
+      },
+      { // B=1.34667 C=-0.17333
+         0,  2,  4, 10, 16, 25, 37, 42, 57, 81, 96,109,121,131,137,141,141,137,131,121,109, 96, 81, 57, 42, 37, 25, 16, 10,  4,  2,  0,
+      },
+      { // B=1.32000 C=-0.16000
+         0,  1,  4,  9, 15, 24, 36, 41, 56, 81, 95,110,122,132,139,143,143,139,132,122,110, 95, 81, 56, 41, 36, 24, 15,  9,  4,  1,  0,
+      },
+      { // B=1.29333 C=-0.14667
+         0,  1,  4,  8, 15, 23, 35, 40, 55, 80, 95,110,123,133,141,146,146,141,133,123,110, 95, 80, 55, 40, 35, 23, 15,  8,  4,  1,  0,
+      },
+      { // B=1.26667 C=-0.13333
+         0,  1,  4,  8, 14, 22, 33, 38, 54, 79, 95,110,124,135,143,148,148,143,135,124,110, 95, 79, 54, 38, 33, 22, 14,  8,  4,  1,  0,
+      },
+      { // B=1.24000 C=-0.12000
+         0,  1,  4,  7, 14, 21, 33, 37, 53, 78, 94,110,125,136,145,150,150,145,136,125,110, 94, 78, 53, 37, 33, 21, 14,  7,  4,  1,  0,
+      },
+      { // B=1.21333 C=-0.10667
+         0,  1,  3,  7, 13, 20, 32, 36, 52, 77, 94,110,127,138,147,152,152,147,138,127,110, 94, 77, 52, 36, 32, 20, 13,  7,  3,  1,  0,
+      },
+      { // B=1.18667 C=-0.09333
+         0,  1,  3,  7, 12, 20, 30, 35, 51, 77, 93,111,125,140,149,155,155,149,140,125,111, 93, 77, 51, 35, 30, 20, 12,  7,  3,  1,  0,
+      },
+      { // B=1.16000 C=-0.08000
+         0,  1,  3,  6, 11, 19, 29, 34, 50, 76, 93,111,128,141,151,157,157,151,141,128,111, 93, 76, 50, 34, 29, 19, 11,  6,  3,  1,  0,
+      },
+      { // B=1.13333 C=-0.06667
+         0,  1,  3,  5, 11, 18, 28, 33, 49, 75, 93,111,129,143,153,159,159,153,143,129,111, 93, 75, 49, 33, 28, 18, 11,  5,  3,  1,  0,
+      },
+      { // B=1.10667 C=-0.05333
+         0,  1,  2,  5, 10, 17, 27, 32, 48, 74, 93,111,130,144,155,161,161,155,144,130,111, 93, 74, 48, 32, 27, 17, 10,  5,  2,  1,  0,
+      },
+      { // B=1.08000 C=-0.04000
+         0,  1,  2,  5,  9, 16, 26, 31, 46, 73, 92,112,130,145,157,164,164,157,145,130,112, 92, 73, 46, 31, 26, 16,  9,  5,  2,  1,  0,
+      },
+      { // B=1.05333 C=-0.02667
+         0,  0,  2,  4,  9, 15, 25, 29, 45, 72, 92,112,131,147,159,166,166,159,147,131,112, 92, 72, 45, 29, 25, 15,  9,  4,  2,  0,  0,
+      },
+      { // B=1.02667 C=-0.01333
+         0,  0,  1,  4,  8, 14, 24, 28, 44, 72, 92,112,132,148,161,168,168,161,148,132,112, 92, 72, 44, 28, 24, 14,  8,  4,  1,  0,  0,
+      },
+      { // B=1.00000 C=0.00000
+         0,  0,  1,  4,  7, 14, 23, 27, 43, 71, 91,112,133,150,163,170,170,163,150,133,112, 91, 71, 43, 27, 23, 14,  7,  4,  1,  0,  0,
+      },
+      { // B=0.97333 C=0.01333
+         0,  0,  1,  3,  7, 12, 22, 26, 42, 70, 91,113,133,152,165,173,173,165,152,133,113, 91, 70, 42, 26, 22, 12,  7,  3,  1,  0,  0,
+      },
+      { // B=0.94667 C=0.02667
+         0,  0,  1,  2,  6, 12, 21, 25, 41, 69, 90,113,135,153,167,175,175,167,153,135,113, 90, 69, 41, 25, 21, 12,  6,  2,  1,  0,  0,
+      },
+      { // B=0.92000 C=0.04000
+         0,  0,  0,  2,  5, 11, 20, 24, 40, 68, 90,113,136,154,169,177,177,169,154,136,113, 90, 68, 40, 24, 20, 11,  5,  2,  0,  0,  0,
+      },
+      { // B=0.89333 C=0.05333
+         0,  0,  0,  1,  5, 10, 19, 23, 39, 67, 90,114,136,156,171,179,179,171,156,136,114, 90, 67, 39, 23, 19, 10,  5,  1,  0,  0,  0,
+      },
+      { // B=0.86667 C=0.06667
+         0,  0,  0,  1,  4,  9, 18, 22, 38, 66, 89,114,137,157,173,182,182,173,157,137,114, 89, 66, 38, 22, 18,  9,  4,  1,  0,  0,  0,
+      },
+      { // B=0.84000 C=0.08000
+         0,  0, -1,  1,  3,  9, 17, 21, 37, 65, 89,114,138,159,175,184,184,175,159,138,114, 89, 65, 37, 21, 17,  9,  3,  1, -1,  0,  0,
+      },
+      { // B=0.81333 C=0.09333
+         0,  0, -1,  0,  3,  7, 16, 19, 36, 65, 89,114,139,160,177,186,186,177,160,139,114, 89, 65, 36, 19, 16,  7,  3,  0, -1,  0,  0,
+      },
+      { // B=0.78667 C=0.10667
+         0, -1, -1,  0,  2,  6, 15, 18, 35, 64, 88,115,139,162,179,188,188,179,162,139,115, 88, 64, 35, 18, 15,  6,  2,  0, -1, -1,  0,
+      },
+      { // B=0.76000 C=0.12000
+         0, -1, -1, -1,  1,  6, 14, 17, 33, 63, 88,115,141,163,181,191,191,181,163,141,115, 88, 63, 33, 17, 14,  6,  1, -1, -1, -1,  0,
+      },
+      { // B=0.73333 C=0.13333
+         0, -1, -1, -1,  0,  5, 13, 16, 32, 62, 87,115,142,165,183,193,193,183,165,142,115, 87, 62, 32, 16, 13,  5,  0, -1, -1, -1,  0,
+      },
+      { // B=0.70667 C=0.14667
+         0, -1, -1, -2,  0,  4, 12, 15, 31, 61, 87,115,143,166,185,195,195,185,166,143,115, 87, 61, 31, 15, 12,  4,  0, -2, -1, -1,  0,
+      },
+      { // B=0.68000 C=0.16000
+         0, -1, -2, -2, -1,  3, 11, 14, 30, 61, 87,116,142,168,187,197,197,187,168,142,116, 87, 61, 30, 14, 11,  3, -1, -2, -2, -1,  0,
+      },
+      { // B=0.65333 C=0.17333
+         0, -1, -2, -3, -1,  2, 10, 13, 29, 60, 86,116,144,169,189,200,200,189,169,144,116, 86, 60, 29, 13, 10,  2, -1, -3, -2, -1,  0,
+      },
+      { // B=0.62667 C=0.18667
+         0, -1, -3, -3, -2,  1,  9, 12, 28, 59, 86,116,145,171,191,202,202,191,171,145,116, 86, 59, 28, 12,  9,  1, -2, -3, -3, -1,  0,
+      },
+      { // B=0.60000 C=0.20000
+         0, -1, -3, -3, -3,  0,  8, 10, 27, 58, 86,116,146,172,193,204,204,193,172,146,116, 86, 58, 27, 10,  8,  0, -3, -3, -3, -1,  0,
+      },
+      { // B=0.57333 C=0.21333
+         0, -1, -3, -4, -3, -1,  7,  9, 26, 57, 86,116,147,174,194,207,207,194,174,147,116, 86, 57, 26,  9,  7, -1, -3, -4, -3, -1,  0,
+      },
+      { // B=0.54667 C=0.22667
+         0, -2, -3, -5, -4, -1,  5,  8, 25, 57, 85,117,148,176,196,209,209,196,176,148,117, 85, 57, 25,  8,  5, -1, -4, -5, -3, -2,  0,
+      },
+      { // B=0.52000 C=0.24000
+         0, -1, -4, -5, -5, -2,  4,  7, 24, 55, 85,117,149,177,199,211,211,199,177,149,117, 85, 55, 24,  7,  4, -2, -5, -5, -4, -1,  0,
+      },
+      { // B=0.49333 C=0.25333
+         0, -2, -4, -5, -6, -3,  3,  6, 23, 55, 84,117,150,178,200,214,214,200,178,150,117, 84, 55, 23,  6,  3, -3, -6, -5, -4, -2,  0,
+      },
+      { // B=0.46667 C=0.26667
+         0, -2, -4, -6, -6, -4,  2,  6, 22, 54, 84,118,150,180,202,216,216,202,180,150,118, 84, 54, 22,  6,  2, -4, -6, -6, -4, -2,  0,
+      },
+      { // B=0.44000 C=0.28000
+         0, -2, -4, -6, -7, -5,  2,  5, 21, 53, 83,118,150,181,205,218,218,205,181,150,118, 83, 53, 21,  5,  2, -5, -7, -6, -4, -2,  0,
+      },
+      { // B=0.41333 C=0.29333
+         0, -2, -4, -7, -7, -6,  0,  5, 20, 53, 83,118,152,183,207,220,220,207,183,152,118, 83, 53, 20,  5,  0, -6, -7, -7, -4, -2,  0,
+      },
+      { // B=0.38667 C=0.30667
+         0, -2, -5, -7, -8, -7, -1,  4, 19, 52, 83,118,153,185,208,223,223,208,185,153,118, 83, 52, 19,  4, -1, -7, -8, -7, -5, -2,  0,
+      },
+      { // B=0.36000 C=0.32000
+         0, -2, -5, -8, -8, -8, -2,  3, 19, 51, 83,118,155,186,210,225,225,210,186,155,118, 83, 51, 19,  3, -2, -8, -8, -8, -5, -2,  0,
+      },
+      { // B=0.33333 C=0.33333
+         0, -2, -6, -8,-10, -8, -3,  2, 18, 50, 82,119,155,187,213,227,227,213,187,155,119, 82, 50, 18,  2, -3, -8,-10, -8, -6, -2,  0,
+      },
+      { // B=0.32667 C=0.33667
+         0, -2, -6, -8,-10, -8, -3,  2, 18, 49, 82,119,155,188,213,228,228,213,188,155,119, 82, 49, 18,  2, -3, -8,-10, -8, -6, -2,  0,
+      },
+      { // B=0.32000 C=0.34000
+         0, -2, -6, -8,-10, -9, -3,  2, 18, 49, 82,119,155,188,214,228,228,214,188,155,119, 82, 49, 18,  2, -3, -9,-10, -8, -6, -2,  0,
+      },
+      { // B=0.31333 C=0.34333
+         0, -2, -6, -8,-10, -9, -4,  1, 18, 49, 82,119,155,188,214,229,229,214,188,155,119, 82, 49, 18,  1, -4, -9,-10, -8, -6, -2,  0,
+      },
+      { // B=0.30667 C=0.34667
+         0, -2, -6, -9,-10, -9, -4,  1, 18, 49, 82,119,156,189,214,229,229,214,189,156,119, 82, 49, 18,  1, -4, -9,-10, -9, -6, -2,  0,
+      },
+      { // B=0.30000 C=0.35000
+         0, -3, -5, -9,-10,-10, -4,  1, 18, 49, 82,119,156,189,215,230,230,215,189,156,119, 82, 49, 18,  1, -4,-10,-10, -9, -5, -3,  0,
+      },
+      { // B=0.29333 C=0.35333
+         0, -2, -6, -9,-10,-10, -4,  1, 17, 48, 82,119,156,190,215,231,231,215,190,156,119, 82, 48, 17,  1, -4,-10,-10, -9, -6, -2,  0,
+      },
+      { // B=0.28667 C=0.35667
+         0, -2, -6, -9,-11,-10, -5,  1, 17, 48, 82,119,157,190,216,231,231,216,190,157,119, 82, 48, 17,  1, -5,-10,-11, -9, -6, -2,  0,
+      },
+      { // B=0.28000 C=0.36000
+         0, -3, -6, -9,-11,-10, -5,  0, 17, 48, 82,119,157,190,217,231,231,217,190,157,119, 82, 48, 17,  0, -5,-10,-11, -9, -6, -3,  0,
+      },
+      { // B=0.27333 C=0.36333
+         0, -3, -6, -9,-11,-11, -5,  0, 17, 48, 82,119,157,191,217,232,232,217,191,157,119, 82, 48, 17,  0, -5,-11,-11, -9, -6, -3,  0,
+      },
+      { // B=0.26667 C=0.36667
+         0, -3, -6, -9,-11,-11, -5,  0, 17, 48, 81,119,157,191,217,233,233,217,191,157,119, 81, 48, 17,  0, -5,-11,-11, -9, -6, -3,  0,
+      },
+      { // B=0.26000 C=0.37000
+         0, -3, -6,-10,-11,-11, -5,  0, 16, 47, 81,120,156,191,218,233,233,218,191,156,120, 81, 47, 16,  0, -5,-11,-11,-10, -6, -3,  0,
+      },
+      { // B=0.25333 C=0.37333
+         0, -3, -6, -9,-12,-11, -6,  0, 16, 47, 81,119,158,192,218,234,234,218,192,158,119, 81, 47, 16,  0, -6,-11,-12, -9, -6, -3,  0,
+      },
+      { // B=0.24667 C=0.37667
+         0, -3, -6,-10,-12,-11, -6,  0, 16, 47, 81,120,157,192,219,234,234,219,192,157,120, 81, 47, 16,  0, -6,-11,-12,-10, -6, -3,  0,
+      },
+      { // B=0.24000 C=0.38000
+         0, -3, -6,-10,-12,-12, -6, -1, 16, 47, 81,120,158,193,219,235,235,219,193,158,120, 81, 47, 16, -1, -6,-12,-12,-10, -6, -3,  0,
+      },
+      { // B=0.23333 C=0.38333
+         0, -3, -6,-10,-12,-12, -6, -1, 16, 46, 81,120,158,193,220,236,236,220,193,158,120, 81, 46, 16, -1, -6,-12,-12,-10, -6, -3,  0,
+      },
+      { // B=0.22667 C=0.38667
+         0, -3, -6,-10,-12,-12, -7, -1, 15, 47, 80,120,158,194,220,236,236,220,194,158,120, 80, 47, 15, -1, -7,-12,-12,-10, -6, -3,  0,
+      },
+      { // B=0.22000 C=0.39000
+         0, -3, -6,-10,-13,-12, -7, -1, 15, 46, 80,120,159,194,221,237,237,221,194,159,120, 80, 46, 15, -1, -7,-12,-13,-10, -6, -3,  0,
+      },
+      { // B=0.21333 C=0.39333
+         0, -3, -6,-10,-13,-12, -8, -1, 15, 46, 80,120,159,194,221,237,237,221,194,159,120, 80, 46, 15, -1, -8,-12,-13,-10, -6, -3,  0,
+      },
+      { // B=0.20667 C=0.39667
+         0, -3, -7,-10,-13,-12, -8, -2, 15, 46, 80,120,159,194,222,238,238,222,194,159,120, 80, 46, 15, -2, -8,-12,-13,-10, -7, -3,  0,
+      },
+      { // B=0.20000 C=0.40000
+         0, -3, -7,-10,-13,-13, -8, -2, 15, 45, 81,120,159,195,222,238,238,222,195,159,120, 81, 45, 15, -2, -8,-13,-13,-10, -7, -3,  0,
+      },
+      { // B=0.19333 C=0.40333
+         0, -3, -7,-11,-13,-13, -8, -2, 15, 45, 81,120,160,195,223,239,239,223,195,160,120, 81, 45, 15, -2, -8,-13,-13,-11, -7, -3,  0,
+      },
+      { // B=0.18667 C=0.40667
+         0, -3, -7,-10,-14,-13, -9, -2, 14, 45, 80,120,160,196,223,240,240,223,196,160,120, 80, 45, 14, -2, -9,-13,-14,-10, -7, -3,  0,
+      },
+      { // B=0.18000 C=0.41000
+         0, -3, -7,-11,-13,-13, -9, -2, 14, 45, 80,120,160,196,224,240,240,224,196,160,120, 80, 45, 14, -2, -9,-13,-13,-11, -7, -3,  0,
+      },
+      { // B=0.17333 C=0.41333
+         0, -3, -7,-11,-13,-14, -9, -3, 14, 45, 80,120,160,196,225,240,240,225,196,160,120, 80, 45, 14, -3, -9,-14,-13,-11, -7, -3,  0,
+      },
+      { // B=0.16667 C=0.41667
+         0, -3, -7,-11,-14,-14, -9, -3, 14, 44, 80,120,161,197,225,241,241,225,197,161,120, 80, 44, 14, -3, -9,-14,-14,-11, -7, -3,  0,
+      },
+      { // B=0.16000 C=0.42000
+         0, -3, -7,-11,-14,-14,-10, -3, 14, 44, 80,120,161,197,225,242,242,225,197,161,120, 80, 44, 14, -3,-10,-14,-14,-11, -7, -3,  0,
+      },
+      { // B=0.15333 C=0.42333
+         0, -3, -7,-11,-14,-14,-10, -3, 13, 44, 80,120,161,197,226,242,242,226,197,161,120, 80, 44, 13, -3,-10,-14,-14,-11, -7, -3,  0,
+      },
+      { // B=0.14667 C=0.42667
+         0, -3, -7,-11,-15,-14,-10, -4, 14, 43, 80,120,163,198,226,243,243,226,198,163,120, 80, 43, 14, -4,-10,-14,-15,-11, -7, -3,  0,
+      },
+      { // B=0.14000 C=0.43000
+         0, -3, -7,-12,-14,-15,-10, -4, 14, 43, 80,120,163,198,227,243,243,227,198,163,120, 80, 43, 14, -4,-10,-15,-14,-12, -7, -3,  0,
+      },
+      { // B=0.13333 C=0.43333
+         0, -3, -7,-12,-14,-15,-11, -4, 13, 43, 79,121,161,199,227,244,244,227,199,161,121, 79, 43, 13, -4,-11,-15,-14,-12, -7, -3,  0,
+      },
+      { // B=0.12667 C=0.43667
+         0, -3, -7,-12,-14,-15,-11, -4, 13, 43, 79,120,163,199,228,245,245,228,199,163,120, 79, 43, 13, -4,-11,-15,-14,-12, -7, -3,  0,
+      },
+      { // B=0.12000 C=0.44000
+         0, -3, -7,-12,-15,-15,-12, -5, 13, 43, 79,121,162,199,228,245,245,228,199,162,121, 79, 43, 13, -5,-12,-15,-15,-12, -7, -3,  0,
+      },
+      { // B=0.11333 C=0.44333
+         0, -3, -7,-12,-15,-16,-11, -5, 13, 42, 79,121,162,200,229,246,246,229,200,162,121, 79, 42, 13, -5,-11,-16,-15,-12, -7, -3,  0,
+      },
+      { // B=0.10667 C=0.44667
+         0, -3, -8,-12,-15,-16,-12, -5, 13, 42, 79,121,162,200,229,246,246,229,200,162,121, 79, 42, 13, -5,-12,-16,-15,-12, -8, -3,  0,
+      },
+      { // B=0.10000 C=0.45000
+         0, -3, -8,-12,-16,-16,-12, -6, 13, 42, 79,121,163,200,230,247,247,230,200,163,121, 79, 42, 13, -6,-12,-16,-16,-12, -8, -3,  0,
+      },
+      { // B=0.09333 C=0.45333
+         0, -3, -8,-12,-16,-16,-13, -5, 12, 42, 79,121,163,201,230,248,248,230,201,163,121, 79, 42, 12, -5,-13,-16,-16,-12, -8, -3,  0,
+      },
+      { // B=0.08667 C=0.45667
+         0, -3, -8,-12,-16,-16,-13, -5, 12, 41, 79,121,163,201,231,248,248,231,201,163,121, 79, 41, 12, -5,-13,-16,-16,-12, -8, -3,  0,
+      },
+      { // B=0.08000 C=0.46000
+         0, -3, -8,-12,-16,-17,-13, -6, 12, 41, 79,121,163,201,232,248,248,232,201,163,121, 79, 41, 12, -6,-13,-17,-16,-12, -8, -3,  0,
+      },
+      { // B=0.07333 C=0.46333
+         0, -3, -8,-13,-16,-17,-13, -6, 12, 41, 79,121,164,202,232,249,249,232,202,164,121, 79, 41, 12, -6,-13,-17,-16,-13, -8, -3,  0,
+      },
+      { // B=0.06667 C=0.46667
+         0, -3, -8,-13,-16,-17,-14, -6, 11, 41, 79,121,164,202,233,249,249,233,202,164,121, 79, 41, 11, -6,-14,-17,-16,-13, -8, -3,  0,
+      },
+      { // B=0.06000 C=0.47000
+         0, -3, -8,-13,-16,-18,-14, -6, 11, 40, 79,121,164,203,233,250,250,233,203,164,121, 79, 40, 11, -6,-14,-18,-16,-13, -8, -3,  0,
+      },
+      { // B=0.05333 C=0.47333
+         0, -3, -8,-13,-17,-18,-14, -6, 11, 40, 79,121,165,203,233,251,251,233,203,165,121, 79, 40, 11, -6,-14,-18,-17,-13, -8, -3,  0,
+      },
+      { // B=0.04667 C=0.47667
+         0, -4, -8,-13,-17,-18,-14, -7, 11, 40, 79,121,166,203,234,251,251,234,203,166,121, 79, 40, 11, -7,-14,-18,-17,-13, -8, -4,  0,
+      },
+      { // B=0.04000 C=0.48000
+         0, -4, -8,-13,-17,-18,-14, -7, 11, 40, 78,121,166,204,234,251,251,234,204,166,121, 78, 40, 11, -7,-14,-18,-17,-13, -8, -4,  0,
+      },
+      { // B=0.03333 C=0.48333
+         0, -4, -8,-14,-17,-18,-15, -7, 11, 40, 78,122,164,204,235,252,252,235,204,164,122, 78, 40, 11, -7,-15,-18,-17,-14, -8, -4,  0,
+      },
+      { // B=0.02667 C=0.48667
+         0, -4, -8,-14,-17,-19,-15, -7, 10, 40, 78,122,164,205,235,253,253,235,205,164,122, 78, 40, 10, -7,-15,-19,-17,-14, -8, -4,  0,
+      },
+      { // B=0.02000 C=0.49000
+         0, -4, -8,-14,-17,-19,-15, -7, 10, 39, 78,122,164,205,236,253,253,236,205,164,122, 78, 39, 10, -7,-15,-19,-17,-14, -8, -4,  0,
+      },
+      { // B=0.01333 C=0.49333
+         0, -4, -8,-14,-18,-19,-16, -7,  9, 40, 78,122,165,205,236,254,254,236,205,165,122, 78, 40,  9, -7,-16,-19,-18,-14, -8, -4,  0,
+      },
+      { // B=0.00667 C=0.49667
+         0, -4, -9,-14,-18,-19,-15, -8, 10, 39, 78,122,166,206,236,254,254,236,206,166,122, 78, 39, 10, -8,-15,-19,-18,-14, -9, -4,  0,
+      },
+      { // B=0.00000 C=0.50000
+         0, -4, -8,-14,-18,-19,-16, -8,  9, 39, 77,122,166,206,237,255,255,237,206,166,122, 77, 39,  9, -8,-16,-19,-18,-14, -8, -4,  0,
+      },
+  };
+  int index = (sharpness + 1.0f) * 50.0f + 0.5f;
+  if (index >=0 && index <= 100)
+  {
+    const int16_t *coef = mitchells[index];
+
+    char command[33*12];
+    char response[33*12];
+    unsigned int len = sprintf(command, "scaling_kernel ");
+    for (int i=0; i < 32; i++) {
+       if (len + 12 < sizeof command)
+         len += sprintf(command+len, "%d ", coef[i]);
+    }
+    // no interpolate flag
+    if (len + 12 < sizeof command)
+      len += sprintf(command+len, " %d", 0);
+    //printf("%i: %s\n", index, command);
+    vc_gencmd(response, sizeof response, command);
+  }
+}
+
 void COMXPlayer::Process()
 {
   bool bOmxWaitVideo = false;
@@ -1174,6 +1502,8 @@ void COMXPlayer::Process()
     SetCaching(CACHESTATE_FLUSH);
 
   EDEINTERLACEMODE current_deinterlace = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+  float current_sharpness = CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness;
+  SetSharpness(current_sharpness);
 
   while (!m_bAbortRequest)
   {
@@ -1205,6 +1535,13 @@ void COMXPlayer::Process()
         current_deinterlace = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
       }
 
+      // if sharpness setting has changed, we should update it
+      if (current_sharpness != CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness)
+      {
+        current_sharpness = CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness;
+        SetSharpness(current_sharpness);
+      }
+
       m_video_fifo = (int)(100.0*(m_omxPlayerVideo.GetDecoderBufferSize()-m_omxPlayerVideo.GetDecoderFreeSpace())/m_omxPlayerVideo.GetDecoderBufferSize());
       m_audio_fifo = (int)(100.0*audio_fifo/m_omxPlayerAudio.GetCacheTotal());
 
@@ -4553,6 +4890,7 @@ void COMXPlayer::GetRenderFeatures(std::vector<int> &renderFeatures)
   renderFeatures.push_back(RENDERFEATURE_CROP);
   renderFeatures.push_back(RENDERFEATURE_PIXEL_RATIO);
   renderFeatures.push_back(RENDERFEATURE_ZOOM);
+  renderFeatures.push_back(RENDERFEATURE_SHARPNESS);
 }
 
 void COMXPlayer::GetDeinterlaceMethods(std::vector<int> &deinterlaceMethods)
-- 
1.9.3


From 0d430b13c0052b9409c6de656667000d1011feba Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 16 Apr 2014 21:18:06 +0100
Subject: [PATCH 34/99] [omxplayer] Don't propagate 3d flags based on supported
 3d modes

---
 xbmc/cores/omxplayer/OMXPlayerVideo.cpp | 29 ++++-------------------------
 1 file changed, 4 insertions(+), 25 deletions(-)

diff --git a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
index af439e7..77dad37 100644
--- a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
@@ -747,36 +747,15 @@ void OMXPlayerVideo::ResolutionUpdateCallBack(uint32_t width, uint32_t height, f
   unsigned flags = 0;
   ERenderFormat format = RENDER_FMT_BYPASS;
 
+  /* figure out steremode expected based on user settings and hints */
+  unsigned int stereo_flags = GetStereoModeFlags(GetStereoMode());
+
   if(m_bAllowFullscreen)
   {
     flags |= CONF_FLAGS_FULLSCREEN;
     m_bAllowFullscreen = false; // only allow on first configure
   }
-
-  flags |= GetStereoModeFlags(GetStereoMode());
-
-  if(flags & CONF_FLAGS_STEREO_MODE_SBS)
-  {
-    if(g_Windowing.Support3D(video_width, video_height, D3DPRESENTFLAG_MODE3DSBS))
-      CLog::Log(LOGNOTICE, "3DSBS movie found");
-    else
-    {
-      flags &= ~CONF_FLAGS_STEREO_MODE_MASK(~0);
-      CLog::Log(LOGNOTICE, "3DSBS movie found but not supported");
-    }
-  }
-  else if(flags & CONF_FLAGS_STEREO_MODE_TAB)
-  {
-    if(g_Windowing.Support3D(video_width, video_height, D3DPRESENTFLAG_MODE3DTB))
-      CLog::Log(LOGNOTICE, "3DTB movie found");
-    else
-    {
-      flags &= ~CONF_FLAGS_STEREO_MODE_MASK(~0);
-      CLog::Log(LOGNOTICE, "3DTB movie found but not supported");
-    }
-  }
-  else
-    CLog::Log(LOGNOTICE, "not a 3D movie");
+  flags |= stereo_flags;
 
   unsigned int iDisplayWidth  = width;
   unsigned int iDisplayHeight = height;
-- 
1.9.3


From 1e9ed1c6954c05d18da107fc8c500a0e685cb4b1 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 17 Apr 2014 13:00:52 +0100
Subject: [PATCH 35/99] [graphics] Don't set stereo mode based on resolution

The resolution change should follow stereo mode
---
 xbmc/guilib/GraphicContext.cpp | 22 ----------------------
 1 file changed, 22 deletions(-)

diff --git a/xbmc/guilib/GraphicContext.cpp b/xbmc/guilib/GraphicContext.cpp
index 5bffdf5..7e4fdd4 100644
--- a/xbmc/guilib/GraphicContext.cpp
+++ b/xbmc/guilib/GraphicContext.cpp
@@ -418,28 +418,6 @@ void CGraphicContext::SetVideoResolution(RESOLUTION res, bool forceUpdate)
   Lock();
 
   RESOLUTION_INFO info_org  = CDisplaySettings::Get().GetResolutionInfo(res);
-  RESOLUTION_INFO info_last = CDisplaySettings::Get().GetResolutionInfo(lastRes);
-
-  RENDER_STEREO_MODE stereo_mode = m_stereoMode;
-
-  // if the new mode is an actual stereo mode, switch to that
-  // if the old mode was an actual stereo mode, switch to no 3d mode
-  if (info_org.dwFlags & D3DPRESENTFLAG_MODE3DTB)
-    stereo_mode = RENDER_STEREO_MODE_SPLIT_HORIZONTAL;
-  else if (info_org.dwFlags & D3DPRESENTFLAG_MODE3DSBS)
-    stereo_mode = RENDER_STEREO_MODE_SPLIT_VERTICAL;
-  else if ((info_last.dwFlags & D3DPRESENTFLAG_MODE3DSBS) != 0
-        || (info_last.dwFlags & D3DPRESENTFLAG_MODE3DTB)  != 0)
-    stereo_mode = RENDER_STEREO_MODE_OFF;
-
-  if(stereo_mode != m_stereoMode)
-  {
-    m_stereoView     = RENDER_STEREO_VIEW_OFF;
-    m_stereoMode     = stereo_mode;
-    m_nextStereoMode = stereo_mode;
-    CSettings::Get().SetInt("videoscreen.stereoscopicmode", (int)m_stereoMode);
-  }
-
   RESOLUTION_INFO info_mod = GetResInfo(res);
 
   m_iScreenWidth  = info_mod.iWidth;
-- 
1.9.3


From 293fc1887aa64325e7cf8a6dc3a8c8444ddedcfe Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 17 Apr 2014 13:01:51 +0100
Subject: [PATCH 36/99] [graphics] Allow switching to a more suitable 3D
 resolution

---
 xbmc/guilib/GraphicContext.cpp | 41 ++++++++++++++++++++++++++++++++++++++++-
 xbmc/guilib/GraphicContext.h   |  1 +
 2 files changed, 41 insertions(+), 1 deletion(-)

diff --git a/xbmc/guilib/GraphicContext.cpp b/xbmc/guilib/GraphicContext.cpp
index 7e4fdd4..886b612 100644
--- a/xbmc/guilib/GraphicContext.cpp
+++ b/xbmc/guilib/GraphicContext.cpp
@@ -35,6 +35,7 @@
 #include "utils/JobManager.h"
 #include "video/VideoReferenceClock.h"
 #include "cores/IPlayer.h"
+#include <float.h>
 
 using namespace std;
 
@@ -459,6 +460,44 @@ RESOLUTION CGraphicContext::GetVideoResolution() const
   return m_Resolution;
 }
 
+RESOLUTION CGraphicContext::Get3DVideoResolution(RENDER_STEREO_MODE mode) const
+{
+  RESOLUTION best = m_Resolution;
+  RESOLUTION_INFO curr = CDisplaySettings::Get().GetResolutionInfo(best);
+
+  // Find closest refresh rate
+  for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
+  {
+    const RESOLUTION_INFO info = CDisplaySettings::Get().GetResolutionInfo((RESOLUTION)i);
+
+    //discard resolutions that are not the same width and height (and interlaced/3D flags)
+    //or have a too low refreshrate
+    if (info.iScreenWidth  != curr.iScreenWidth
+    ||  info.iScreenHeight != curr.iScreenHeight
+    ||  info.iScreen       != curr.iScreen
+    ||  (info.dwFlags & D3DPRESENTFLAG_INTERLACED) != (curr.dwFlags & D3DPRESENTFLAG_INTERLACED)
+    ||  fabs(info.fRefreshRate - curr.fRefreshRate) >= FLT_EPSILON)
+      continue;
+
+    if (mode == RENDER_STEREO_MODE_SPLIT_VERTICAL && info.dwFlags & D3DPRESENTFLAG_MODE3DSBS)
+    {
+      best = (RESOLUTION)i;
+      break;
+    }
+    else if (mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL && info.dwFlags & D3DPRESENTFLAG_MODE3DTB)
+    {
+      best = (RESOLUTION)i;
+      break;
+    }
+    else if ((mode == RENDER_STEREO_MODE_OFF || mode == RENDER_STEREO_MODE_MONO) && !(info.dwFlags & (D3DPRESENTFLAG_MODE3DSBS|D3DPRESENTFLAG_MODE3DTB)))
+    {
+      best = (RESOLUTION)i;
+      break;
+    }
+  }
+  return best;
+}
+
 void CGraphicContext::ResetOverscan(RESOLUTION_INFO &res)
 {
   res.Overscan.left = 0;
@@ -996,7 +1035,7 @@ void CGraphicContext::Flip(const CDirtyRegionList& dirty)
   if(m_stereoMode != m_nextStereoMode)
   {
     m_stereoMode = m_nextStereoMode;
-    SetVideoResolution(GetVideoResolution(), true);
+    SetVideoResolution(Get3DVideoResolution(m_stereoMode), true);
     g_windowManager.SendMessage(GUI_MSG_NOTIFY_ALL, 0, 0, GUI_MSG_RENDERER_RESET);
   }
 }
diff --git a/xbmc/guilib/GraphicContext.h b/xbmc/guilib/GraphicContext.h
index 0a27643..df55e92 100644
--- a/xbmc/guilib/GraphicContext.h
+++ b/xbmc/guilib/GraphicContext.h
@@ -108,6 +108,7 @@ class CGraphicContext : public CCriticalSection,
   bool IsValidResolution(RESOLUTION res);
   void SetVideoResolution(RESOLUTION res, bool forceUpdate = false);
   RESOLUTION GetVideoResolution() const;
+  RESOLUTION Get3DVideoResolution(RENDER_STEREO_MODE mode) const;
   void ResetOverscan(RESOLUTION res, OVERSCAN &overscan);
   void ResetOverscan(RESOLUTION_INFO &resinfo);
   void ResetScreenParameters(RESOLUTION res);
-- 
1.9.3


From 084fc70894c4da7fb38a67c7be84faa04570102e Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 17 Apr 2014 13:38:55 +0100
Subject: [PATCH 37/99] [3D] Support switching to 3D resolutions

Include matching 3D flags (SBS/TAB) in the score of a resolution to switch to, to enable switching to 3d modes.
Also remove the old code that treated 3D modes differently when assigning a score.
---
 xbmc/cores/VideoRenderers/BaseRenderer.cpp | 47 +++++++++++-------------------
 1 file changed, 17 insertions(+), 30 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.cpp b/xbmc/cores/VideoRenderers/BaseRenderer.cpp
index 83c3adb..8076e76 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.cpp
@@ -222,10 +222,14 @@ void CBaseRenderer::FindResolutionFromFpsMatch(float fps, float& weight)
 RESOLUTION CBaseRenderer::FindClosestResolution(float fps, float multiplier, RESOLUTION current, float& weight)
 {
   RESOLUTION_INFO curr = g_graphicsContext.GetResInfo(current);
+  RENDER_STEREO_MODE stereo_mode = g_graphicsContext.GetStereoMode();
 
   float fRefreshRate = fps;
 
-  float last_diff = fRefreshRate;
+  int c_weight = MathUtils::round_int(RefreshWeight(curr.fRefreshRate, fRefreshRate * multiplier) * 1000.0);
+  if (!(stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL) != !(curr.dwFlags & D3DPRESENTFLAG_MODE3DSBS) ||
+      !(stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL) != !(curr.dwFlags & D3DPRESENTFLAG_MODE3DTB))
+    c_weight += 1000;
 
   // Find closest refresh rate
   for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
@@ -241,40 +245,23 @@ RESOLUTION CBaseRenderer::FindClosestResolution(float fps, float multiplier, RES
     ||  info.fRefreshRate < (fRefreshRate * multiplier / 1.001) - 0.001)
       continue;
 
-    // For 3D choose the closest refresh rate 
-    if(CONF_FLAGS_STEREO_MODE_MASK(m_iFlags))
-    {
-      float diff = (info.fRefreshRate - fRefreshRate);
-      if(diff < 0)
-        diff *= -1.0f;
+    int i_weight = MathUtils::round_int(RefreshWeight(info.fRefreshRate, fRefreshRate * multiplier) * 1000.0);
 
-      if(diff < last_diff)
-      {
-        last_diff = diff;
-        current = (RESOLUTION)i;
-        curr = info;
-      }
-    }
-    else
-    {
-      int c_weight = MathUtils::round_int(RefreshWeight(curr.fRefreshRate, fRefreshRate * multiplier) * 1000.0);
-      int i_weight = MathUtils::round_int(RefreshWeight(info.fRefreshRate, fRefreshRate * multiplier) * 1000.0);
+    if (!(stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL) != !(info.dwFlags & D3DPRESENTFLAG_MODE3DSBS) ||
+        !(stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL) != !(info.dwFlags & D3DPRESENTFLAG_MODE3DTB))
+      i_weight += 1000;
 
-      // Closer the better, prefer higher refresh rate if the same
-      if ((i_weight <  c_weight)
-      ||  (i_weight == c_weight && info.fRefreshRate > curr.fRefreshRate))
-      {
-        current = (RESOLUTION)i;
-        curr    = info;
-      }
+    // Closer the better, prefer higher refresh rate if the same
+    if ((i_weight <  c_weight)
+    ||  (i_weight == c_weight && info.fRefreshRate > curr.fRefreshRate))
+    {
+      current  = (RESOLUTION)i;
+      curr     = info;
+      c_weight = i_weight;
     }
   }
 
-  // For 3D overwrite weight
-  if(CONF_FLAGS_STEREO_MODE_MASK(m_iFlags))
-    weight = 0;
-  else
-    weight = RefreshWeight(curr.fRefreshRate, fRefreshRate * multiplier);
+  weight = RefreshWeight(curr.fRefreshRate, fRefreshRate * multiplier);
 
   return current;
 }
-- 
1.9.3


From d4bde73fbf844088d448dcd067e656e12267c6e3 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 23 Apr 2014 00:05:07 +0100
Subject: [PATCH 38/99] [graphics] Make pixel ratio for 3d modes consistent

Note: Use the stored stereo flags from lists of resolutions.
Use current stereo mode for current resolution.
---
 xbmc/cores/VideoRenderers/BaseRenderer.cpp      | 10 ++++----
 xbmc/guilib/GraphicContext.cpp                  | 32 ++++++++++---------------
 xbmc/guilib/GraphicContext.h                    |  4 ++--
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp |  8 -------
 4 files changed, 19 insertions(+), 35 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.cpp b/xbmc/cores/VideoRenderers/BaseRenderer.cpp
index 8076e76..beda4e9 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.cpp
@@ -119,7 +119,7 @@ bool CBaseRenderer::FindResolutionFromOverride(float fps, float& weight, bool fa
 
     for (size_t j = (int)RES_DESKTOP; j < CDisplaySettings::Get().ResolutionInfoSize(); j++)
     {
-      RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)j);
+      RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)j, false);
 
       if (info.iScreenWidth  == curr.iScreenWidth
        && info.iScreenHeight == curr.iScreenHeight
@@ -179,7 +179,7 @@ void CBaseRenderer::FindResolutionFromFpsMatch(float fps, float& weight)
       //get the resolution with the refreshrate closest to 60 hertz
       for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
       {
-        RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i);
+        RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i, false);
 
         if (MathUtils::round_int(info.fRefreshRate) == 60
          && info.iScreenWidth  == curr.iScreenWidth
@@ -200,7 +200,7 @@ void CBaseRenderer::FindResolutionFromFpsMatch(float fps, float& weight)
         CLog::Log(LOGDEBUG, "60 hertz refreshrate not available, choosing highest");
         for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
         {
-          RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i);
+          RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i, false);
 
           if (info.fRefreshRate  >  curr.fRefreshRate
            && info.iScreenWidth  == curr.iScreenWidth
@@ -234,14 +234,14 @@ RESOLUTION CBaseRenderer::FindClosestResolution(float fps, float multiplier, RES
   // Find closest refresh rate
   for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
   {
-    const RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i);
+    const RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i, false);
 
     //discard resolutions that are not the same width and height (and interlaced/3D flags)
     //or have a too low refreshrate
     if (info.iScreenWidth  != curr.iScreenWidth
     ||  info.iScreenHeight != curr.iScreenHeight
     ||  info.iScreen       != curr.iScreen
-    ||  (info.dwFlags & D3DPRESENTFLAG_MODEMASK) != (curr.dwFlags & D3DPRESENTFLAG_MODEMASK)
+    ||  (info.dwFlags & D3DPRESENTFLAG_INTERLACED) != (curr.dwFlags & D3DPRESENTFLAG_INTERLACED)
     ||  info.fRefreshRate < (fRefreshRate * multiplier / 1.001) - 0.001)
       continue;
 
diff --git a/xbmc/guilib/GraphicContext.cpp b/xbmc/guilib/GraphicContext.cpp
index 886b612..40a6362 100644
--- a/xbmc/guilib/GraphicContext.cpp
+++ b/xbmc/guilib/GraphicContext.cpp
@@ -707,32 +707,26 @@ void CGraphicContext::ApplyStateBlock()
   g_Windowing.ApplyStateBlock();
 }
 
-const RESOLUTION_INFO CGraphicContext::GetResInfo(RESOLUTION res) const
+const RESOLUTION_INFO CGraphicContext::GetResInfo(RESOLUTION res, bool use_current_3d /*= true*/) const
 {
   RESOLUTION_INFO info = CDisplaySettings::Get().GetResolutionInfo(res);
 
-  if(m_stereoMode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+  if(use_current_3d ? m_stereoMode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL : (info.dwFlags & D3DPRESENTFLAG_MODE3DTB))
   {
-    if((info.dwFlags & D3DPRESENTFLAG_MODE3DTB) == 0)
-    {
-      info.fPixelRatio     /= 2;
-      info.iBlanking        = 0;
-      info.dwFlags         |= D3DPRESENTFLAG_MODE3DTB;
-    }
+    info.fPixelRatio     /= 2;
+    info.iBlanking        = 0;
+    info.dwFlags         |= D3DPRESENTFLAG_MODE3DTB;
     info.iHeight          = (info.iHeight         - info.iBlanking) / 2;
     info.Overscan.top    /= 2;
     info.Overscan.bottom  = (info.Overscan.bottom - info.iBlanking) / 2;
     info.iSubtitles       = (info.iSubtitles      - info.iBlanking) / 2;
   }
 
-  if(m_stereoMode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+  if(use_current_3d ? m_stereoMode == RENDER_STEREO_MODE_SPLIT_VERTICAL : (info.dwFlags & D3DPRESENTFLAG_MODE3DSBS))
   {
-    if((info.dwFlags & D3DPRESENTFLAG_MODE3DSBS) == 0)
-    {
-      info.fPixelRatio     *= 2;
-      info.iBlanking        = 0;
-      info.dwFlags         |= D3DPRESENTFLAG_MODE3DSBS;
-    }
+    info.fPixelRatio     *= 2;
+    info.iBlanking        = 0;
+    info.dwFlags         |= D3DPRESENTFLAG_MODE3DSBS;
     info.iWidth           = (info.iWidth         - info.iBlanking) / 2;
     info.Overscan.left   /= 2;
     info.Overscan.right   = (info.Overscan.right - info.iBlanking) / 2;
@@ -740,7 +734,7 @@ const RESOLUTION_INFO CGraphicContext::GetResInfo(RESOLUTION res) const
   return info;
 }
 
-void CGraphicContext::SetResInfo(RESOLUTION res, const RESOLUTION_INFO& info)
+void CGraphicContext::SetResInfo(RESOLUTION res, const RESOLUTION_INFO& info, bool use_current_3d /*= true*/)
 {
   RESOLUTION_INFO& curr = CDisplaySettings::Get().GetResolutionInfo(res);
   curr.Overscan   = info.Overscan;
@@ -750,16 +744,14 @@ void CGraphicContext::SetResInfo(RESOLUTION res, const RESOLUTION_INFO& info)
   if(info.dwFlags & D3DPRESENTFLAG_MODE3DSBS)
   {
     curr.Overscan.right  = info.Overscan.right  * 2 + info.iBlanking;
-    if((curr.dwFlags & D3DPRESENTFLAG_MODE3DSBS) == 0)
-      curr.fPixelRatio  /= 2.0;
+    curr.fPixelRatio  /= 2.0;
   }
 
   if(info.dwFlags & D3DPRESENTFLAG_MODE3DTB)
   {
     curr.Overscan.bottom = info.Overscan.bottom * 2 + info.iBlanking;
     curr.iSubtitles      = info.iSubtitles      * 2 + info.iBlanking;
-    if((curr.dwFlags & D3DPRESENTFLAG_MODE3DTB) == 0)
-      curr.fPixelRatio  *= 2.0;
+    curr.fPixelRatio  *= 2.0;
   }
 }
 
diff --git a/xbmc/guilib/GraphicContext.h b/xbmc/guilib/GraphicContext.h
index df55e92..c77f2ff 100644
--- a/xbmc/guilib/GraphicContext.h
+++ b/xbmc/guilib/GraphicContext.h
@@ -124,8 +124,8 @@ class CGraphicContext : public CCriticalSection,
   {
     return GetResInfo(m_Resolution);
   }
-  const RESOLUTION_INFO GetResInfo(RESOLUTION res) const;
-  void SetResInfo(RESOLUTION res, const RESOLUTION_INFO& info);
+  const RESOLUTION_INFO GetResInfo(RESOLUTION res, bool use_current_3d = true) const;
+  void SetResInfo(RESOLUTION res, const RESOLUTION_INFO& info, bool use_current_3d = true);
 
   /* \brief Get UI scaling information from a given resolution to the screen resolution.
    Takes account of overscan and UI zooming.
diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index 90b57e1..5b26b20 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -448,15 +448,9 @@ bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &r
       m_desktopRes.fPixelRatio  = get_display_aspect_ratio((HDMI_ASPECT_T)tv_state.display.hdmi.display_options.aspect) / ((float)m_desktopRes.iScreenWidth / (float)m_desktopRes.iScreenHeight);
       // Also add 3D flags
       if (tv_state.display.hdmi.format_3d == HDMI_3D_FORMAT_SBS_HALF)
-      {
         m_desktopRes.dwFlags |= D3DPRESENTFLAG_MODE3DSBS;
-        m_desktopRes.fPixelRatio *= 2.0;
-      }
       else if (tv_state.display.hdmi.format_3d == HDMI_3D_FORMAT_TB_HALF)
-      {
         m_desktopRes.dwFlags |= D3DPRESENTFLAG_MODE3DTB;
-        m_desktopRes.fPixelRatio *= 0.5;
-      }
       HDMI_PROPERTY_PARAM_T property;
       property.property = HDMI_PROPERTY_PIXEL_CLOCK_TYPE;
       vc_tv_hdmi_get_property(&property);
@@ -602,7 +596,6 @@ void CEGLNativeTypeRaspberryPI::GetSupportedModes(HDMI_RES_GROUP_T group, std::v
         RESOLUTION_INFO res2 = res;
         res2.dwFlags |= D3DPRESENTFLAG_MODE3DSBS;
         res2.fPixelRatio    = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)res2.iScreenWidth / (float)res2.iScreenHeight);
-        res2.fPixelRatio   *= 2.0f;
         CLog::Log(LOGDEBUG, "EGL mode %d: %s (%.2f)\n", i, res2.strMode.c_str(), res2.fPixelRatio);
 
         res2.iSubtitles    = (int)(0.965 * res2.iHeight);
@@ -619,7 +612,6 @@ void CEGLNativeTypeRaspberryPI::GetSupportedModes(HDMI_RES_GROUP_T group, std::v
         RESOLUTION_INFO res2 = res;
         res2.dwFlags |= D3DPRESENTFLAG_MODE3DTB;
         res2.fPixelRatio    = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)res2.iScreenWidth / (float)res2.iScreenHeight);
-        res2.fPixelRatio   *= 0.5f;
         CLog::Log(LOGDEBUG, "EGL mode %d: %s (%.2f)\n", i, res2.strMode.c_str(), res2.fPixelRatio);
 
         res2.iSubtitles    = (int)(0.965 * res2.iHeight);
-- 
1.9.3


From e75402b7fdbdc4c7037f4fdfd542bba048501350 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 23 Apr 2014 21:07:51 +0100
Subject: [PATCH 39/99] [PiSink] More attempts to reduce underrun audio
 glitches with multichannl and high samplerate

---
 xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp | 78 ++++++++++++-------------------
 1 file changed, 30 insertions(+), 48 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
index 19a9411..0a09275 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
@@ -186,7 +186,7 @@ bool CAESinkPi::Initialize(AEAudioFormat &format, std::string &device)
   unsigned int sample_size = CAEUtil::DataFormatToBits(format.m_dataFormat) >> 3;
   format.m_frameSize     = sample_size * channels;
   format.m_sampleRate    = std::max(8000U, std::min(192000U, format.m_sampleRate));
-  format.m_frames        = format.m_sampleRate * AUDIO_PLAYBUFFER;
+  format.m_frames        = format.m_sampleRate * AUDIO_PLAYBUFFER / NUM_OMX_BUFFERS;
   format.m_frameSamples  = format.m_frames * channels;
 
   SetAudioProps(m_passthrough, GetChannelMap(format, m_passthrough));
@@ -232,7 +232,7 @@ bool CAESinkPi::Initialize(AEAudioFormat &format, std::string &device)
     CLog::Log(LOGERROR, "%s:%s - error get OMX_IndexParamPortDefinition (input) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
 
   port_param.nBufferCountActual = std::max((unsigned int)port_param.nBufferCountMin, (unsigned int)NUM_OMX_BUFFERS);
-  port_param.nBufferSize = m_format.m_frameSize * m_format.m_frames / port_param.nBufferCountActual;
+  port_param.nBufferSize = m_format.m_frameSize * m_format.m_frames;
 
   omx_err = m_omx_render.SetParameter(OMX_IndexParamPortDefinition, &port_param);
   if (omx_err != OMX_ErrorNone)
@@ -306,61 +306,43 @@ double CAESinkPi::GetCacheTotal()
 
 unsigned int CAESinkPi::AddPackets(uint8_t **data, unsigned int frames, unsigned int offset)
 {
-  unsigned int sent = 0;
   uint8_t *buffer = data[0]+offset*m_format.m_frameSize;
 
-  if (!m_Initialized)
+  if (!m_Initialized || !frames)
     return frames;
 
   OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
   OMX_BUFFERHEADERTYPE *omx_buffer = NULL;
-  while (sent < frames)
+
+  AEDelayStatus status;
+  GetDelay(status);
+  double delay = status.GetDelay();
+  if (delay <= 0.0 && m_submitted)
+    CLog::Log(LOGNOTICE, "%s:%s Underrun (delay:%.2f frames:%d)", CLASSNAME, __func__, delay, frames);
+
+  omx_buffer = m_omx_render.GetInputBuffer(1000);
+  if (omx_buffer == NULL)
   {
-    AEDelayStatus status;
-    GetDelay(status);
-    double delay = status.GetDelay();
-    double ideal_submission_time = AUDIO_PLAYBUFFER - delay;
-    // ideal amount of audio we'd like submit (to make delay match AUDIO_PLAYBUFFER)
-    int timeout = 1000;
-    int ideal_submission_samples = ideal_submission_time / (m_sinkbuffer_sec_per_byte * m_format.m_frameSize);
-    // if we are almost full then sleep (to avoid repeatedly sending a few samples)
-    bool too_laggy = ideal_submission_time < 0.25 * AUDIO_PLAYBUFFER;
-    int sleeptime = (int)(AUDIO_PLAYBUFFER * 0.25 * 1000.0);
-    if (too_laggy)
-    {
-      Sleep(sleeptime);
-      continue;
-    }
-    omx_buffer = m_omx_render.GetInputBuffer(timeout);
-    if (omx_buffer == NULL)
-    {
-      CLog::Log(LOGERROR, "COMXAudio::Decode timeout");
-      break;
-    }
-
-    unsigned int space = omx_buffer->nAllocLen / m_format.m_frameSize;
-    unsigned int samples = std::min(std::min(space, (unsigned int)ideal_submission_samples), frames - sent);
-
-    omx_buffer->nFilledLen = samples * m_format.m_frameSize;
-    omx_buffer->nTimeStamp = ToOMXTime(0);
-    omx_buffer->nFlags = 0;
-    memcpy(omx_buffer->pBuffer, (uint8_t *)buffer + sent * m_format.m_frameSize, omx_buffer->nFilledLen);
-
-    sent += samples;
-
-    if (sent == frames)
-      omx_buffer->nFlags |= OMX_BUFFERFLAG_ENDOFFRAME;
-
-    if (delay <= 0.0 && m_submitted)
-      CLog::Log(LOGNOTICE, "%s:%s Underrun (delay:%.2f frames:%d)", CLASSNAME, __func__, delay, frames);
-
-    omx_err = m_omx_render.EmptyThisBuffer(omx_buffer);
-    if (omx_err != OMX_ErrorNone)
-      CLog::Log(LOGERROR, "%s:%s frames=%d err=%x", CLASSNAME, __func__, frames, omx_err);
-    m_submitted++;
+    CLog::Log(LOGERROR, "CAESinkPi::AddPackets timeout");
+    return 0;
   }
 
-  return sent;
+  omx_buffer->nFilledLen = frames * m_format.m_frameSize;
+  // must be true
+  assert(omx_buffer->nFilledLen <= omx_buffer->nAllocLen);
+  omx_buffer->nTimeStamp = ToOMXTime(0);
+  omx_buffer->nFlags = OMX_BUFFERFLAG_ENDOFFRAME;
+  memcpy(omx_buffer->pBuffer, buffer, omx_buffer->nFilledLen);
+
+  omx_err = m_omx_render.EmptyThisBuffer(omx_buffer);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s frames=%d err=%x", CLASSNAME, __func__, frames, omx_err);
+  m_submitted++;
+  GetDelay(status);
+  delay = status.GetDelay();
+  if (delay > AUDIO_PLAYBUFFER)
+    Sleep((int)(1000.0f * (delay - AUDIO_PLAYBUFFER)));
+  return frames;
 }
 
 void CAESinkPi::Drain()
-- 
1.9.3


From ec1b483946a1d269ba36933b62aa8e61318d987c Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 22 Apr 2014 12:23:23 +0100
Subject: [PATCH 40/99] [omxplayer] Make dvdplayer the default for dvd images

---
 xbmc/cores/omxplayer/omxplayer_advancedsettings.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/cores/omxplayer/omxplayer_advancedsettings.xml b/xbmc/cores/omxplayer/omxplayer_advancedsettings.xml
index 77c6a15..51c0daf 100644
--- a/xbmc/cores/omxplayer/omxplayer_advancedsettings.xml
+++ b/xbmc/cores/omxplayer/omxplayer_advancedsettings.xml
@@ -2,6 +2,6 @@
 <advancedsettings>
   <video>
     <defaultplayer>omxplayer</defaultplayer>
-    <defaultdvdplayer>omxplayer</defaultdvdplayer>
+    <defaultdvdplayer>dvdplayer</defaultdvdplayer>
   </video>
 </advancedsettings>
-- 
1.9.3


From 8b8c3a1f2fb66b2b849c75492d117513106aaa9c Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 26 Apr 2014 17:27:52 +0100
Subject: [PATCH 41/99] [cec] Don't suspend pi on tv switch off - it can't wake
 up

---
 system/peripherals.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/system/peripherals.xml b/system/peripherals.xml
index a906628..9b5271a 100644
--- a/system/peripherals.xml
+++ b/system/peripherals.xml
@@ -16,7 +16,7 @@
     <setting key="send_inactive_source" type="bool" value="1" label="36025" order="5" />
     <setting key="cec_standby_screensaver" type="bool" value="0" label="36009" order="6" />
     <setting key="cec_wake_screensaver" type="bool" value="1" label="36010" order="7" />
-    <setting key="standby_pc_on_tv_standby" type="enum" value="13011" label="36029" order="8" lvalues="36028|13005|13011" />
+    <setting key="standby_pc_on_tv_standby" type="enum" value="36028" label="36029" order="8" lvalues="36028|13005|13011" />
     <setting key="standby_tv_on_pc_standby" type="bool" value="1" label="36026" order="9" />
     <setting key="use_tv_menu_language" type="bool" value="1" label="36018" order="10" />
     <setting key="pause_playback_on_deactivate" type="bool" value="1" label="36033" order="11" />
-- 
1.9.3


From c5b85f1ce7154626cff40645f813e77e2b547fab Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 27 Jun 2013 01:25:57 +0100
Subject: [PATCH 43/99] [rbp/omxplayer] Do we need discontinuity handling?

So far I've not seen what this is needed for and it does cause problems for some files.
---
 xbmc/cores/omxplayer/OMXPlayer.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/xbmc/cores/omxplayer/OMXPlayer.cpp b/xbmc/cores/omxplayer/OMXPlayer.cpp
index 9fcfa23..030d7b6 100644
--- a/xbmc/cores/omxplayer/OMXPlayer.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayer.cpp
@@ -2382,6 +2382,7 @@ static void UpdateLimits(double& minimum, double& maximum, double dts)
 
 void COMXPlayer::CheckContinuity(COMXCurrentStream& current, DemuxPacket* pPacket)
 {
+return;
   if (m_playSpeed < DVD_PLAYSPEED_PAUSE)
     return;
 
-- 
1.9.3


From 7cfce548f1e59cbace180692e4dec5f19214801e Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 24 Oct 2013 00:53:26 +0100
Subject: [PATCH 44/99] [rbp/omxplayer] Avoid marking non-monotonic timestamps
 as unknown

Following a single spurious timestamp that is in the future,
all subsequent timestamps will be marked unknown causing out of sync.
---
 xbmc/cores/omxplayer/OMXAudio.cpp | 16 ++--------------
 1 file changed, 2 insertions(+), 14 deletions(-)

diff --git a/xbmc/cores/omxplayer/OMXAudio.cpp b/xbmc/cores/omxplayer/OMXAudio.cpp
index 77731a9..5f9d028 100644
--- a/xbmc/cores/omxplayer/OMXAudio.cpp
+++ b/xbmc/cores/omxplayer/OMXAudio.cpp
@@ -1210,22 +1210,10 @@ unsigned int COMXAudio::AddPackets(const void* data, unsigned int len, double dt
     }
     else
     {
-      if(pts == DVD_NOPTS_VALUE)
-      {
+      if(pts == DVD_NOPTS_VALUE || pts == m_last_pts)
         omx_buffer->nFlags = OMX_BUFFERFLAG_TIME_UNKNOWN;
+      else
         m_last_pts = pts;
-      }
-      else if (m_last_pts != pts)
-      {
-        if(pts > m_last_pts)
-          m_last_pts = pts;
-        else
-          omx_buffer->nFlags = OMX_BUFFERFLAG_TIME_UNKNOWN;;
-      }
-      else if (m_last_pts == pts)
-      {
-        omx_buffer->nFlags = OMX_BUFFERFLAG_TIME_UNKNOWN;
-      }
     }
 
     omx_buffer->nTimeStamp = ToOMXTime(val);
-- 
1.9.3



From a503852a52721d5cc0dac3a4f5dffd4886087294 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 13 Dec 2013 16:25:23 +0000
Subject: [PATCH 46/99] Add time taken to resample to log

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp    | 7 +++++++
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.h | 2 +-
 2 files changed, 8 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index d6a18f5..65a0756 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -2647,7 +2647,14 @@ void CActiveAE::ResampleSounds()
   {
     if (!(*it)->IsConverted())
     {
+  struct timespec now;
+  clock_gettime(CLOCK_MONOTONIC, &now);
+  uint64_t  Start = ((int64_t)now.tv_sec * 1000000000L) + now.tv_nsec;
+
       ResampleSound(*it);
+  clock_gettime(CLOCK_MONOTONIC, &now);
+  uint64_t  End = ((int64_t)now.tv_sec * 1000000000L) + now.tv_nsec;
+  CLog::Log(LOGNOTICE, "ActiveAE::%s - resample %s took %.0fms", __FUNCTION__, (*it)->m_filename.c_str(), (End-Start)*1e-6);
       // only do one sound, then yield to main loop
       break;
     }
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.h
index 01aafe3..5ab83a2 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.h
@@ -57,8 +57,8 @@ class CActiveAESound : public IAESound
   static int Read(void *h, uint8_t* buf, int size);
   static int64_t Seek(void *h, int64_t pos, int whence);
 
-protected:
   std::string m_filename;
+protected:
   XFILE::CFile *m_pFile;
   bool m_isSeekPosible;
   int m_fileSize;
-- 
1.9.3


From 789d5b5fa3f90d4a0b477cf8cba81473734107d1 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 14 Dec 2013 16:55:05 +0000
Subject: [PATCH 47/99] logging: Add microsecond timer to log messages

---
 xbmc/utils/log.cpp | 12 +++++++++---
 1 file changed, 9 insertions(+), 3 deletions(-)

diff --git a/xbmc/utils/log.cpp b/xbmc/utils/log.cpp
index dd6ef26..8edf2fd 100644
--- a/xbmc/utils/log.cpp
+++ b/xbmc/utils/log.cpp
@@ -32,6 +32,7 @@
 #elif defined(TARGET_WINDOWS)
 #include "win32/WIN32Util.h"
 #endif
+#include "utils/TimeUtils.cpp"
 
 #define critSec XBMC_GLOBAL_USE(CLog::CLogGlobals).critSec
 #define m_file XBMC_GLOBAL_USE(CLog::CLogGlobals).m_file
@@ -64,7 +65,7 @@ void CLog::Close()
 
 void CLog::Log(int loglevel, const char *format, ... )
 {
-  static const char* prefixFormat = "%02.2d:%02.2d:%02.2d T:%" PRIu64" %7s: ";
+  static const char* prefixFormat = "%02.2d:%02.2d:%02.2d %10.6f T:%" PRIu64" %7s: ";
   CSingleLock waitLock(critSec);
   int extras = (loglevel >> LOGMASKBIT) << LOGMASKBIT;
   loglevel = loglevel & LOGMASK;
@@ -90,6 +91,11 @@ void CLog::Log(int loglevel, const char *format, ... )
     strData = StringUtils::FormatV(format,va);
     va_end(va);
 
+
+  struct timespec now;
+  clock_gettime(CLOCK_MONOTONIC, &now);
+  float Now = now.tv_sec + now.tv_nsec * 1e-9;
+
     if (m_repeatLogLevel == loglevel && m_repeatLine == strData)
     {
       m_repeatCount++;
@@ -100,7 +106,7 @@ void CLog::Log(int loglevel, const char *format, ... )
       strPrefix = StringUtils::Format(prefixFormat,
                                       time.wHour,
                                       time.wMinute,
-                                      time.wSecond,
+                                      time.wSecond, Now,
                                       (uint64_t)CThread::GetCurrentThreadId(),
                                       levelNames[m_repeatLogLevel]);
 
@@ -129,7 +135,7 @@ void CLog::Log(int loglevel, const char *format, ... )
     strPrefix = StringUtils::Format(prefixFormat,
                                     time.wHour,
                                     time.wMinute,
-                                    time.wSecond,
+                                    time.wSecond, Now,
                                     (uint64_t)CThread::GetCurrentThreadId(),
                                     levelNames[loglevel]);
 
-- 
1.9.3


From 6f03e6732cf7a560dd342ead48ea81363817f99d Mon Sep 17 00:00:00 2001
From: Jonathan Marshall <jmarshall@xbmc.org>
Date: Sat, 2 Nov 2013 23:49:17 +1300
Subject: [PATCH 48/99] adds GetTvShowSeasons

---
 xbmc/video/VideoDatabase.cpp | 30 ++++++++++++++++++++++++------
 xbmc/video/VideoDatabase.h   |  1 +
 2 files changed, 25 insertions(+), 6 deletions(-)

diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index 55036e0..8ef5311 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -4075,7 +4075,7 @@ bool CVideoDatabase::RemoveArtForItem(int mediaId, const MediaType &mediaType, c
   return result;
 }
 
-bool CVideoDatabase::GetTvShowSeasonArt(int showId, map<int, map<string, string> > &seasonArt)
+bool CVideoDatabase::GetTvShowSeasons(int showId, map<int, int> &seasons)
 {
   try
   {
@@ -4086,19 +4086,37 @@ bool CVideoDatabase::GetTvShowSeasonArt(int showId, map<int, map<string, string>
     CStdString sql = PrepareSQL("select idSeason,season from seasons where idShow=%i", showId);
     m_pDS2->query(sql.c_str());
 
-    vector< pair<int, int> > seasons;
+    seasons.clear();
     while (!m_pDS2->eof())
     {
-      seasons.push_back(make_pair(m_pDS2->fv(0).get_asInt(), m_pDS2->fv(1).get_asInt()));
+      seasons.insert(make_pair(m_pDS2->fv(1).get_asInt(), m_pDS2->fv(0).get_asInt()));
       m_pDS2->next();
     }
     m_pDS2->close();
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "%s(%d) failed", __FUNCTION__, showId);
+  }
+  return false;
+}
+
+bool CVideoDatabase::GetTvShowSeasonArt(int showId, map<int, map<string, string> > &seasonArt)
+{
+  try
+  {
+    if (NULL == m_pDB.get()) return false;
+    if (NULL == m_pDS2.get()) return false; // using dataset 2 as we're likely called in loops on dataset 1
+
+    map<int, int> seasons;
+    GetTvShowSeasons(showId, seasons);
 
-    for (vector< pair<int,int> >::const_iterator i = seasons.begin(); i != seasons.end(); ++i)
+    for (map<int, int>::const_iterator i = seasons.begin(); i != seasons.end(); ++i)
     {
       map<string, string> art;
-      GetArtForItem(i->first, MediaTypeSeason, art);
-      seasonArt.insert(make_pair(i->second,art));
+      GetArtForItem(i->second, MediaTypeSeason, art);
+      seasonArt.insert(make_pair(i->first,art));
     }
     return true;
   }
diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index 492eebb..f6026c2 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -744,6 +744,7 @@ class CVideoDatabase : public CDatabase
   std::string GetArtForItem(int mediaId, const MediaType &mediaType, const std::string &artType);
   bool RemoveArtForItem(int mediaId, const MediaType &mediaType, const std::string &artType);
   bool RemoveArtForItem(int mediaId, const MediaType &mediaType, const std::set<std::string> &artTypes);
+  bool GetTvShowSeasons(int showId, std::map<int, int> &seasons);
   bool GetTvShowSeasonArt(int mediaId, std::map<int, std::map<std::string, std::string> > &seasonArt);
   bool GetArtTypes(const MediaType &mediaType, std::vector<std::string> &artTypes);
 
-- 
1.9.3


From 0daa19069981aa0fa60cc03cad74465b120ca152 Mon Sep 17 00:00:00 2001
From: Jonathan Marshall <jmarshall@xbmc.org>
Date: Sat, 2 Nov 2013 23:50:10 +1300
Subject: [PATCH 49/99] move AddSeason() public.

---
 xbmc/video/VideoDatabase.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index f6026c2..a7acea3 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -755,6 +755,7 @@ class CVideoDatabase : public CDatabase
 
   virtual bool GetFilter(CDbUrl &videoUrl, Filter &filter, SortDescription &sorting);
 
+  int AddSeason(int showID, int season);
   int AddSet(const CStdString& strSet);
   void ClearMovieSet(int idMovie);
   void SetMovieSet(int idMovie, int idSet);
@@ -785,7 +786,6 @@ class CVideoDatabase : public CDatabase
 
   int AddTvShow();
   int AddMusicVideo(const CStdString& strFilenameAndPath);
-  int AddSeason(int showID, int season);
 
   /*! \brief Adds a path to the tvshow link table.
    \param idShow the id of the show.
-- 
1.9.3


From 295a279646f63c880570a6edd282e29b099f1c95 Mon Sep 17 00:00:00 2001
From: Jonathan Marshall <jmarshall@xbmc.org>
Date: Sat, 2 Nov 2013 23:48:24 +1300
Subject: [PATCH 50/99] adds GetArt function to (video) scraper, allowing art
 to be fetched given the video identifier.

---
 xbmc/addons/Scraper.cpp            | 38 ++++++++++++++++++++++++++++++++++++++
 xbmc/addons/Scraper.h              |  3 +++
 xbmc/video/VideoInfoDownloader.cpp |  5 +++++
 xbmc/video/VideoInfoDownloader.h   |  7 +++++++
 4 files changed, 53 insertions(+)

diff --git a/xbmc/addons/Scraper.cpp b/xbmc/addons/Scraper.cpp
index 225220b..4f93865 100644
--- a/xbmc/addons/Scraper.cpp
+++ b/xbmc/addons/Scraper.cpp
@@ -925,6 +925,44 @@ EPISODELIST CScraper::GetEpisodeList(XFILE::CCurlFile &fcurl, const CScraperUrl
   return vcep;
 }
 
+// takes URL; returns true and populates art XML details on success, false otherwise
+bool CScraper::GetArt(XFILE::CCurlFile &fcurl, const std::string &id, CVideoInfoTag &video)
+{
+  CLog::Log(LOGDEBUG, "%s: Reading art for '%s' using %s scraper "
+            "(file: '%s', content: '%s', version: '%s')", __FUNCTION__, id.c_str(), Name().c_str(), Path().c_str(),
+            ADDON::TranslateContent(Content()).c_str(), Version().asString().c_str());
+
+  video.Reset();
+  vector<string> vcsIn;
+  CScraperUrl scurl;
+  vcsIn.push_back(id);
+  vector<string> vcsOut = RunNoThrow("GetArt", scurl, fcurl, &vcsIn);
+
+  // parse XML output
+  bool fRet(false);
+  for (vector<string>::const_iterator i = vcsOut.begin(); i != vcsOut.end(); ++i)
+  {
+    CXBMCTinyXML doc;
+    doc.Parse(*i, TIXML_ENCODING_UTF8);
+    if (!doc.RootElement())
+    {
+      CLog::Log(LOGERROR, "%s: Unable to parse XML", __FUNCTION__);
+      continue;
+    }
+
+    TiXmlHandle xhDoc(&doc);
+    TiXmlElement *pxeDetails = xhDoc.FirstChild("details").Element();
+    if (!pxeDetails)
+    {
+      CLog::Log(LOGERROR, "%s: Invalid XML file (want <details>)", __FUNCTION__);
+      continue;
+    }
+    video.Load(pxeDetails, true/*fChain*/);
+    fRet = true;  // but don't exit in case of chaining
+  }
+  return fRet;
+}
+
 // takes URL; returns true and populates video details on success, false otherwise
 bool CScraper::GetVideoDetails(XFILE::CCurlFile &fcurl, const CScraperUrl &scurl,
   bool fMovie/*else episode*/, CVideoInfoTag &video)
diff --git a/xbmc/addons/Scraper.h b/xbmc/addons/Scraper.h
index c7274f2..5df5296 100644
--- a/xbmc/addons/Scraper.h
+++ b/xbmc/addons/Scraper.h
@@ -18,6 +18,8 @@
  *  <http://www.gnu.org/licenses/>.
  *
  */
+
+#include <string>
 #include "addons/Addon.h"
 #include "XBDateTime.h"
 #include "utils/ScraperUrl.h"
@@ -146,6 +148,7 @@ class CScraper : public CAddon
     CAlbum &album);
   bool GetArtistDetails(XFILE::CCurlFile &fcurl, const CScraperUrl &scurl,
     const std::string &sSearch, CArtist &artist);
+  bool GetArt(XFILE::CCurlFile &fcurl, const std::string &id, CVideoInfoTag &video);
 
 private:
   CScraper(const CScraper &rhs);
diff --git a/xbmc/video/VideoInfoDownloader.cpp b/xbmc/video/VideoInfoDownloader.cpp
index f33ac8a..5d84734 100644
--- a/xbmc/video/VideoInfoDownloader.cpp
+++ b/xbmc/video/VideoInfoDownloader.cpp
@@ -191,6 +191,11 @@ bool CVideoInfoDownloader::GetDetails(const CScraperUrl &url,
     return m_info->GetVideoDetails(*m_http, url, true/*fMovie*/, movieDetails);
 }
 
+bool CVideoInfoDownloader::GetArt(const std::string &id, CVideoInfoTag &details)
+{
+  return m_info->GetArt(*m_http, id, details);
+}
+
 bool CVideoInfoDownloader::GetEpisodeDetails(const CScraperUrl &url,
                                              CVideoInfoTag &movieDetails,
                                              CGUIDialogProgress *pProgress /* = NULL */)
diff --git a/xbmc/video/VideoInfoDownloader.h b/xbmc/video/VideoInfoDownloader.h
index 22ac229..75bc341 100644
--- a/xbmc/video/VideoInfoDownloader.h
+++ b/xbmc/video/VideoInfoDownloader.h
@@ -59,6 +59,13 @@ class CVideoInfoDownloader : public CThread
 
   static void ShowErrorDialog(const ADDON::CScraperError &sce);
 
+  /*! \brief Grab art URLs for an item with the scraper
+   \param id the unique identifier used by the scraper to describe the item.
+   \param details [out] the video info tag structure to fill with art.
+   \return true on success, false on failure.
+   */
+  bool GetArt(const std::string &id, CVideoInfoTag &details);
+
 protected:
   enum LOOKUP_STATE { DO_NOTHING = 0,
                       FIND_MOVIE = 1,
-- 
1.9.3


From 36c7b7aee6007665a45667839c0857a69f4c23dd Mon Sep 17 00:00:00 2001
From: Jonathan Marshall <jmarshall@xbmc.org>
Date: Sat, 2 Nov 2013 23:53:14 +1300
Subject: [PATCH 51/99] refresh season art if a new season is found that isn't
 recorded in the database yet. Fixes #14339

---
 xbmc/video/VideoInfoScanner.cpp | 33 ++++++++++++++++++++++++++++++++-
 xbmc/video/VideoInfoScanner.h   |  2 ++
 2 files changed, 34 insertions(+), 1 deletion(-)

diff --git a/xbmc/video/VideoInfoScanner.cpp b/xbmc/video/VideoInfoScanner.cpp
index 04e578b..b86746a 100644
--- a/xbmc/video/VideoInfoScanner.cpp
+++ b/xbmc/video/VideoInfoScanner.cpp
@@ -1360,6 +1360,10 @@ namespace VIDEO
       pDlgProgress->Progress();
     }
 
+    bool updateSeasons = false;
+    map<int, int> seasons;
+    m_database.GetTvShowSeasons(showInfo.m_iDbId, seasons);
+
     EPISODELIST episodes;
     bool hasEpisodeGuide = false;
 
@@ -1408,6 +1412,8 @@ namespace VIDEO
         }
         if (AddVideo(&item, CONTENT_TVSHOWS, file->isFolder, true, &showInfo) < 0)
           return INFO_ERROR;
+        if (seasons.find(item.GetVideoInfoTag()->m_iSeason) == seasons.end())
+          updateSeasons = true;
         continue;
       }
 
@@ -1537,6 +1543,8 @@ namespace VIDEO
           
         if (AddVideo(&item, CONTENT_TVSHOWS, file->isFolder, useLocal, &showInfo) < 0)
           return INFO_ERROR;
+        if (seasons.find(item.GetVideoInfoTag()->m_iSeason) == seasons.end())
+          updateSeasons = true;
       }
       else
       {
@@ -1545,9 +1553,27 @@ namespace VIDEO
                   file->cDate.GetAsLocalizedDate().c_str(), file->strTitle.c_str());
       }
     }
+    if (updateSeasons)
+      UpdateSeasons(showInfo, scraper, useLocal);
     return INFO_ADDED;
   }
 
+  void CVideoInfoScanner::UpdateSeasons(const CVideoInfoTag &showInfo, const ADDON::ScraperPtr &scraper, bool useLocal)
+  {
+    map<int, map<string, string> > seasonArt;
+    m_database.GetTvShowSeasonArt(showInfo.m_iDbId, seasonArt);
+    CVideoInfoTag details;
+    CVideoInfoDownloader loader(scraper);
+    loader.GetArt(showInfo.m_strIMDBNumber, details);
+    details.m_strPath = showInfo.m_strPath;
+    GetSeasonThumbs(details, seasonArt, CVideoThumbLoader::GetArtTypes("season"), useLocal);
+    for (map<int, map<string, string> >::iterator i = seasonArt.begin(); i != seasonArt.end(); ++i)
+    {
+      int seasonID = m_database.AddSeason(showInfo.m_iDbId, i->first);
+      m_database.SetArtForItem(seasonID, "season", i->second);
+    }
+  }
+
   CStdString CVideoInfoScanner::GetnfoFile(CFileItem *item, bool bGrabAny) const
   {
     CStdString nfoFile;
@@ -1812,6 +1838,11 @@ namespace VIDEO
     }
     for (int season = -1; season <= maxSeasons; season++)
     {
+      // skip if we already have some art
+      map<int, map<string, string> >::const_iterator i = seasonArt.find(season);
+      if (i != seasonArt.end() && !i->second.empty())
+        continue;
+
       map<string, string> art;
       if (useLocal)
       {
@@ -1865,7 +1896,7 @@ namespace VIDEO
           art.insert(make_pair(artTypes.front(), image));
       }
 
-      seasonArt.insert(make_pair(season, art));
+      seasonArt[season] = art;
     }
   }
 
diff --git a/xbmc/video/VideoInfoScanner.h b/xbmc/video/VideoInfoScanner.h
index 7da1bf2..c764e20 100644
--- a/xbmc/video/VideoInfoScanner.h
+++ b/xbmc/video/VideoInfoScanner.h
@@ -230,6 +230,8 @@ namespace VIDEO
      */
     INFO_RET OnProcessSeriesFolder(EPISODELIST& files, const ADDON::ScraperPtr &scraper, bool useLocal, const CVideoInfoTag& showInfo, CGUIDialogProgress* pDlgProgress = NULL);
 
+    void UpdateSeasons(const CVideoInfoTag &showInfo, const ADDON::ScraperPtr &scraper, bool useLocal);
+
     bool EnumerateSeriesFolder(CFileItem* item, EPISODELIST& episodeList);
     bool ProcessItemByVideoInfoTag(const CFileItem *item, EPISODELIST &episodeList);
 
-- 
1.9.3


From 7023dcb9c045af7916b7ddf11cab9ff5f11d262c Mon Sep 17 00:00:00 2001
From: Jonathan Marshall <jmarshall@xbmc.org>
Date: Sat, 2 Nov 2013 23:53:34 +1300
Subject: [PATCH 52/99] REMOVEME: updated thetvdb.com scraper to support art
 updates

---
 addons/metadata.tvdb.com/tvdb.xml | 59 +++++++++++++++++++++++++--------------
 1 file changed, 38 insertions(+), 21 deletions(-)

diff --git a/addons/metadata.tvdb.com/tvdb.xml b/addons/metadata.tvdb.com/tvdb.xml
index 39e604d..60a0e96 100644
--- a/addons/metadata.tvdb.com/tvdb.xml
+++ b/addons/metadata.tvdb.com/tvdb.xml
@@ -99,57 +99,74 @@
 			<RegExp input="$$5" output="&lt;actor&gt;&lt;name&gt;\2&lt;/name&gt;&lt;role&gt;\3&lt;/role&gt;&lt;/actor&gt;" dest="4+">
 				<expression repeat="yes" noclean="1,2,3">&lt;Actor&gt;.*?&lt;Image&gt;([^&lt;]*)&lt;/Image&gt;.*?&lt;Name&gt;([^&lt;]*)&lt;/Name&gt;.*?&lt;Role&gt;([^&lt;]*)</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$2" output="&lt;chain function=&quot;GetArt&quot;&gt;\1&lt;/chain&gt;" dest="4+">
+				<expression/>
+			</RegExp>
+			<RegExp input="$$3" output="\1" dest="6">
+				<expression>.*/(.*).zip</expression>
+			</RegExp>
+			<RegExp input="$$3" output="&lt;episodeguide&gt;&lt;url cache=&quot;$$2-$$6.xml&quot;&gt;\1&lt;/url&gt;&lt;/episodeguide&gt;" dest="4+">
+				<expression/>
+			</RegExp>
+			<expression noclean="1"/>
+		</RegExp>
+	</GetDetails>
+
+	<GetArt dest="3">
+		<RegExp input="$$4" output="&lt;details&gt;\1&lt;/details&gt;" dest="3">
+			<RegExp input="$$1" output="&lt;url function=&quot;ParseArt&quot; cache=&quot;\1-banners.xml&quot;&gt;http://thetvdb.com/api/1D62F2F90030C444/series/\1/banners.xml&lt;/url&gt;" dest="4">
+				<expression/>
+			</RegExp>
+			<expression noclean="1"/>
+		</RegExp>
+	</GetArt>
+	<ParseArt dest="3">
+		<RegExp input="$$4" output="&lt;details&gt;\1&lt;/details&gt;" dest="3">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;series&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;graphical&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;$INFO[language]&lt;/Language&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;series&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;graphical&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;((?!$INFO[language])[a-z])*&lt;/Language&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;series&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;text&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;$INFO[language]&lt;/Language&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;series&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;text&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;((?!$INFO[language])[a-z])*&lt;/Language&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;banner&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;series&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;blank&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;&lt;/Language&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;poster&quot; type=&quot;season&quot; season=&quot;\2&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;poster&quot; type=&quot;season&quot; season=&quot;\2&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;season&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;season&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;$INFO[language]&lt;/Language&gt;[^&lt;]*[^S]*Season&gt;([0-9]+)&lt;/Season&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;poster&quot; type=&quot;season&quot; season=&quot;\3&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;poster&quot; type=&quot;season&quot; season=&quot;\3&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;season&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;season&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;((?!$INFO[language])[a-z])*&lt;/Language&gt;[^&lt;]*[^S]*Season&gt;([0-9]+)&lt;/Season&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;banner&quot; type=&quot;season&quot; season=&quot;\2&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;banner&quot; type=&quot;season&quot; season=&quot;\2&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;season&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;seasonwide&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;$INFO[language]&lt;/Language&gt;[^&lt;]*[^S]*Season&gt;([0-9]+)&lt;/Season&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;banner&quot; type=&quot;season&quot; season=&quot;\3&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;banner&quot; type=&quot;season&quot; season=&quot;\3&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;season&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;seasonwide&lt;/BannerType2&gt;[^&lt;]*&lt;Language&gt;((?!$INFO[language])[a-z])*&lt;/Language&gt;[^&lt;]*[^S]*Season&gt;([0-9]+)&lt;/Season&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;poster&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;poster&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;poster&lt;/BannerType&gt;</expression>
 			</RegExp>
-			<RegExp input="$$5" output="&lt;thumb aspect=&quot;poster&quot; type=&quot;season&quot; season=&quot;-1&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
+			<RegExp input="$$1" output="&lt;thumb aspect=&quot;poster&quot; type=&quot;season&quot; season=&quot;-1&quot;&gt;http://thetvdb.com/banners/\1&lt;/thumb&gt;" dest="4+">
 				<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;poster&lt;/BannerType&gt;</expression>
 			</RegExp>
-			<RegExp conditional="fanart" input="$$7" output="&lt;fanart url=&quot;http://thetvdb.com/banners/&quot;&gt;\1&lt;/fanart&gt;" dest="4+">
-				<RegExp input="$$5" output="&lt;thumb dim=&quot;\2&quot; colors=&quot;\3&quot; preview=&quot;_cache/\1&quot;&gt;\1&lt;/thumb&gt;" dest="7+">
+			<RegExp conditional="fanart" input="$$5" output="&lt;fanart url=&quot;http://thetvdb.com/banners/&quot;&gt;\1&lt;/fanart&gt;" dest="4+">
+				<RegExp input="$$1" output="&lt;thumb dim=&quot;\2&quot; colors=&quot;\3&quot; preview=&quot;_cache/\1&quot;&gt;\1&lt;/thumb&gt;" dest="5">
 					<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;fanart&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;([^&lt;]*)&lt;/BannerType2&gt;[^&lt;]*&lt;Colors&gt;([^&lt;]*)&lt;/Colors&gt;[^&lt;]*&lt;Language&gt;$INFO[language]&lt;/Language&gt;</expression>
 				</RegExp>
-				<RegExp input="$$5" output="&lt;thumb dim=&quot;\2&quot; colors=&quot;\3&quot; preview=&quot;_cache/\1&quot;&gt;\1&lt;/thumb&gt;" dest="7+">
+				<RegExp input="$$1" output="&lt;thumb dim=&quot;\2&quot; colors=&quot;\3&quot; preview=&quot;_cache/\1&quot;&gt;\1&lt;/thumb&gt;" dest="5+">
 					<expression repeat="yes">&lt;BannerPath&gt;([^&lt;]*)&lt;/BannerPath&gt;[^&lt;]*&lt;BannerType&gt;fanart&lt;/BannerType&gt;[^&lt;]*&lt;BannerType2&gt;([^&lt;]*)&lt;/BannerType2&gt;[^&lt;]*&lt;Colors&gt;([^&lt;]*)&lt;/Colors&gt;[^&lt;]*&lt;Language&gt;((?!$INFO[language])[a-z])*&lt;/Language&gt;</expression>
 				</RegExp>
 				<expression noclean="1"/>
 			</RegExp>
-			<RegExp input="$$3" output="\1" dest="6">
-				<expression>.*/(.*).zip</expression>
-			</RegExp>
-			<RegExp input="$$3" output="&lt;episodeguide&gt;&lt;url cache=&quot;$$2-$$6.xml&quot;&gt;\1&lt;/url&gt;&lt;/episodeguide&gt;" dest="4+">
-				<expression/>
-			</RegExp>
 			<expression noclean="1"/>
 		</RegExp>
-	</GetDetails>
+	</ParseArt>
 
 	<!-- input:	$1=html !-->
 	<!-- input:	$2=series url !-->
-- 
1.9.3


From 9a8011041d2b0b17aac4b23155136daaeb4a684b Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 22 Mar 2014 16:40:01 +0000
Subject: [PATCH 53/99] Enable PYTHONOPTIMIZE for Pi

---
 xbmc/interfaces/python/XBPython.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/interfaces/python/XBPython.cpp b/xbmc/interfaces/python/XBPython.cpp
index 099c042..95caaa0 100644
--- a/xbmc/interfaces/python/XBPython.cpp
+++ b/xbmc/interfaces/python/XBPython.cpp
@@ -462,6 +462,10 @@ bool XBPython::InitializeEngine()
       }
 #endif
 
+// Lets enable for Pi
+#if defined(TARGET_RASPBERRY_PI)
+   setenv("PYTHONOPTIMIZE", "1", 1);
+#endif
 
 // Darwin packs .pyo files, we need PYTHONOPTIMIZE on in order to load them.
 #if defined(TARGET_DARWIN)
-- 
1.9.3


From 8c41eb9ed90a3959021d8f9e5da5f88f873f3ab4 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 28 Apr 2014 18:07:45 +0100
Subject: [PATCH 54/99] [rpi] Make ActiveAE thread higher priority to make
 audio underrun less likely

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index 65a0756..c022b5c 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -2168,6 +2168,12 @@ void CActiveAE::LoadSettings()
 bool CActiveAE::Initialize()
 {
   Create();
+
+#ifdef TARGET_RASPBERRY_PI
+  /* audio normally won't consume full cpu, so let it have prio */
+  SetPriority(GetPriority()+1);
+#endif
+
   Message *reply;
   if (m_controlPort.SendOutMessageSync(CActiveAEControlProtocol::INIT,
                                                  &reply,
-- 
1.9.3


From ce6b738cc6adcb7c1ad3afdb424e2bb9030c36a4 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 11 May 2014 16:13:45 +0100
Subject: [PATCH 57/99] [rbp] Add config.txt settings to log file

---
 xbmc/linux/RBP.cpp | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index 49dcbb8..9a5e9cb 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -79,11 +79,17 @@ bool CRBP::Initialize()
 
 void CRBP::LogFirmwareVerison()
 {
-  char  response[160];
+  char  response[1024];
   m_DllBcmHost->vc_gencmd(response, sizeof response, "version");
   response[sizeof(response) - 1] = '\0';
   CLog::Log(LOGNOTICE, "Raspberry PI firmware version: %s", response);
   CLog::Log(LOGNOTICE, "ARM mem: %dMB GPU mem: %dMB MPG2:%d WVC1:%d", m_arm_mem, m_gpu_mem, m_codec_mpg2_enabled, m_codec_wvc1_enabled);
+  m_DllBcmHost->vc_gencmd(response, sizeof response, "get_config int");
+  response[sizeof(response) - 1] = '\0';
+  CLog::Log(LOGNOTICE, "Config:\n%s", response);
+  m_DllBcmHost->vc_gencmd(response, sizeof response, "get_config str");
+  response[sizeof(response) - 1] = '\0';
+  CLog::Log(LOGNOTICE, "Config:\n%s", response);
 }
 
 void CRBP::GetDisplaySize(int &width, int &height)
-- 
1.9.3


From 7d9bf62df3890f417e124d7c9acb913a47a937b1 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 12 May 2014 23:06:43 +0100
Subject: [PATCH 58/99] [omxcodec] Updates to work better with dropping and
 lateness detection

---
 .../DVDCodecs/Video/DVDVideoCodecOpenMax.cpp       |  5 ++
 .../DVDCodecs/Video/DVDVideoCodecOpenMax.h         |  1 +
 .../dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp     | 97 +++++++++++++++++-----
 .../cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h |  9 +-
 4 files changed, 86 insertions(+), 26 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
index ef10555..8323497 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
@@ -91,4 +91,9 @@ bool CDVDVideoCodecOpenMax::ClearPicture(DVDVideoPicture* pDvdVideoPicture)
   return m_omx_decoder->ClearPicture(pDvdVideoPicture);
 }
 
+bool CDVDVideoCodecOpenMax::GetCodecStats(double &pts, int &droppedPics)
+{
+  return m_omx_decoder->GetCodecStats(pts, droppedPics);
+}
+
 #endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
index b7c0c1b..4f243df 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
@@ -41,6 +41,7 @@ class CDVDVideoCodecOpenMax : public CDVDVideoCodec
   virtual unsigned GetAllowedReferences();
   virtual void SetDropState(bool bDrop);
   virtual const char* GetName(void);
+  virtual bool GetCodecStats(double &pts, int &droppedPics);
   
 protected:
   OpenMaxVideoPtr m_omx_decoder;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
index 71d19af..612ae21 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
@@ -37,6 +37,7 @@
 #include "ApplicationMessenger.h"
 #include "Application.h"
 #include "threads/Atomics.h"
+#include "guilib/GUIWindowManager.h"
 
 #include <IL/OMX_Core.h>
 #include <IL/OMX_Component.h>
@@ -57,6 +58,7 @@
 
 #define OMX_BUFFERFLAG_PTS_INVALID (1<<28)
 #define OMX_BUFFERFLAG_DROPPED     (1<<29)
+#define OMX_BUFFERFLAG_FIRST_FIELD (1<<30)
 
 COpenMaxVideoBuffer::COpenMaxVideoBuffer(COpenMaxVideo *omv)
     : m_omv(omv), m_refs(0)
@@ -139,8 +141,11 @@ COpenMaxVideo::COpenMaxVideo()
 
   m_deinterlace = false;
   m_deinterlace_request = VS_DEINTERLACEMODE_OFF;
-  m_deinterlace_second_field = false;
   m_startframe = false;
+  m_decoderPts = DVD_NOPTS_VALUE;
+  m_droppedPics = 0;
+  m_decode_frame_number = 1;
+  m_skipDeinterlaceFields = false;
 }
 
 COpenMaxVideo::~COpenMaxVideo()
@@ -369,7 +374,10 @@ void COpenMaxVideo::Dispose()
   m_finished = true;
   pthread_mutex_unlock(&m_omx_output_mutex);
   if (done)
+  {
+    assert(m_dts_queue.empty());
     m_myself.reset();
+  }
 }
 
 void COpenMaxVideo::SetDropState(bool bDrop)
@@ -730,6 +738,7 @@ int COpenMaxVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
       omx_buffer->nFilledLen = (demuxer_bytes > omx_buffer->nAllocLen) ? omx_buffer->nAllocLen : demuxer_bytes;
       omx_buffer->nTimeStamp = ToOMXTime((uint64_t)(pts == DVD_NOPTS_VALUE) ? 0 : pts);
       omx_buffer->pAppPrivate = omx_buffer;
+      omx_buffer->pMarkData = (OMX_PTR)m_decode_frame_number;
       memcpy(omx_buffer->pBuffer, demuxer_content, omx_buffer->nFilledLen);
 
       demuxer_bytes -= omx_buffer->nFilledLen;
@@ -742,12 +751,18 @@ int COpenMaxVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
         omx_buffer->nFlags |= OMX_BUFFERFLAG_TIME_UNKNOWN;
       if (pts == DVD_NOPTS_VALUE) // hijack an omx flag to indicate there wasn't a real timestamp - it will be returned with the picture (but otherwise ignored)
         omx_buffer->nFlags |= OMX_BUFFERFLAG_PTS_INVALID;
-      if (m_drop_state) // hijack an omx flag to signal this frame to be dropped - it will be returned with the picture (but otherwise ignored)
+      if (m_drop_state)
+      {
+        // hijack an omx flag to signal this frame to be dropped - it will be returned with the picture (but otherwise ignored)
         omx_buffer->nFlags |= OMX_BUFFERFLAG_DECODEONLY | OMX_BUFFERFLAG_DROPPED;
+        m_droppedPics += m_deinterlace ? 2:1;
+      }
+      // always set this flag on input. It won't be set on second field of interlaced video.
+      omx_buffer->nFlags |= OMX_BUFFERFLAG_FIRST_FIELD;
 
 #if defined(OMX_DEBUG_VERBOSE)
-      CLog::Log(LOGDEBUG, "%s::%s - %-6d dts:%.3f pts:%.3f flags:%x",
-        CLASSNAME, __func__, omx_buffer->nFilledLen, dts == DVD_NOPTS_VALUE ? 0.0 : dts*1e-6, pts == DVD_NOPTS_VALUE ? 0.0 : pts*1e-6, omx_buffer->nFlags);
+      CLog::Log(LOGDEBUG, "%s::%s - %-6d dts:%.3f pts:%.3f flags:%x frame:%d",
+        CLASSNAME, __func__, omx_buffer->nFilledLen, dts == DVD_NOPTS_VALUE ? 0.0 : dts*1e-6, pts == DVD_NOPTS_VALUE ? 0.0 : pts*1e-6, omx_buffer->nFlags, (int)omx_buffer->pMarkData);
 #endif
 
       omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
@@ -758,13 +773,16 @@ int COpenMaxVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
       }
       if (demuxer_bytes == 0)
       {
+        m_decode_frame_number++;
         m_startframe = true;
 #ifdef DTS_QUEUE
         if (!m_drop_state)
         {
           // only push if we are successful with feeding OMX_EmptyThisBuffer
+          pthread_mutex_lock(&m_omx_output_mutex);
           m_dts_queue.push(dts);
           assert(m_dts_queue.size() < 32);
+          pthread_mutex_unlock(&m_omx_output_mutex);
         }
 #endif
         if (buffer_to_free)
@@ -840,13 +858,18 @@ void COpenMaxVideo::Reset(void)
   SetDropState(true);
   SetDropState(false);
 #ifdef DTS_QUEUE
+  pthread_mutex_lock(&m_omx_output_mutex);
   while (!m_dts_queue.empty())
     m_dts_queue.pop();
+  pthread_mutex_unlock(&m_omx_output_mutex);
 #endif
 
   while (!m_demux_queue.empty())
     m_demux_queue.pop();
   m_startframe = false;
+  m_decoderPts = DVD_NOPTS_VALUE;
+  m_droppedPics = 0;
+  m_decode_frame_number = 1;
 }
 
 
@@ -928,26 +951,17 @@ bool COpenMaxVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
       }
     }
 
-#ifdef DTS_QUEUE
-    if (!m_deinterlace_second_field)
-    {
-      assert(!m_dts_queue.empty());
-      pDvdVideoPicture->dts = m_dts_queue.front();
-      m_dts_queue.pop();
-    }
-    if (m_deinterlace)
-      m_deinterlace_second_field = !m_deinterlace_second_field;
-#endif
     // nTimeStamp is in microseconds
+    pDvdVideoPicture->dts = buffer->dts;
     pDvdVideoPicture->pts = FromOMXTime(buffer->omx_buffer->nTimeStamp);
     pDvdVideoPicture->openMaxBuffer->Acquire();
     pDvdVideoPicture->iFlags  = DVP_FLAG_ALLOCATED;
     if (buffer->omx_buffer->nFlags & OMX_BUFFERFLAG_PTS_INVALID)
       pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
 #if defined(OMX_DEBUG_VERBOSE)
-    CLog::Log(LOGINFO, "%s::%s dts:%.3f pts:%.3f flags:%x:%x openMaxBuffer:%p omx_buffer:%p egl_image:%p texture_id:%x", CLASSNAME, __func__,
+    CLog::Log(LOGINFO, "%s::%s dts:%.3f pts:%.3f flags:%x:%x frame:%d openMaxBuffer:%p omx_buffer:%p egl_image:%p texture_id:%x", CLASSNAME, __func__,
         pDvdVideoPicture->dts == DVD_NOPTS_VALUE ? 0.0 : pDvdVideoPicture->dts*1e-6, pDvdVideoPicture->pts == DVD_NOPTS_VALUE ? 0.0 : pDvdVideoPicture->pts*1e-6,
-        pDvdVideoPicture->iFlags, buffer->omx_buffer->nFlags, pDvdVideoPicture->openMaxBuffer, pDvdVideoPicture->openMaxBuffer->omx_buffer, pDvdVideoPicture->openMaxBuffer->egl_image, pDvdVideoPicture->openMaxBuffer->texture_id);
+        pDvdVideoPicture->iFlags, buffer->omx_buffer->nFlags, (int)buffer->omx_buffer->pMarkData, pDvdVideoPicture->openMaxBuffer, pDvdVideoPicture->openMaxBuffer->omx_buffer, pDvdVideoPicture->openMaxBuffer->egl_image, pDvdVideoPicture->openMaxBuffer->texture_id);
 #endif
     assert(!(buffer->omx_buffer->nFlags & (OMX_BUFFERFLAG_DECODEONLY | OMX_BUFFERFLAG_DROPPED)));
   }
@@ -956,6 +970,12 @@ bool COpenMaxVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
     CLog::Log(LOGERROR, "%s::%s - called but m_omx_output_ready is empty", CLASSNAME, __func__);
     return false;
   }
+
+  if (pDvdVideoPicture->pts != DVD_NOPTS_VALUE)
+    m_decoderPts = pDvdVideoPicture->pts;
+  else
+    m_decoderPts = pDvdVideoPicture->dts; // xxx is DVD_NOPTS_VALUE better?
+
   return true;
 }
 
@@ -970,25 +990,56 @@ bool COpenMaxVideo::ClearPicture(DVDVideoPicture* pDvdVideoPicture)
   return true;
 }
 
+bool COpenMaxVideo::GetCodecStats(double &pts, int &droppedPics)
+{
+  pts = m_decoderPts;
+  droppedPics = m_droppedPics;
+  m_droppedPics = 0;
+#if defined(OMX_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s - pts:%.0f droppedPics:%d", CLASSNAME, __func__, pts, droppedPics);
+#endif
+  return true;
+}
+
   // DecoderFillBufferDone -- OpenMax output buffer has been filled
 OMX_ERRORTYPE COpenMaxVideo::DecoderFillBufferDone(
   OMX_HANDLETYPE hComponent,
   OMX_BUFFERHEADERTYPE* pBuffer)
 {
   COpenMaxVideoBuffer *buffer = (COpenMaxVideoBuffer*)pBuffer->pAppPrivate;
+  bool skipDeinterlaceFields = m_skipDeinterlaceFields || g_windowManager.HasDialogOnScreen();
 
   #if defined(OMX_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s - %p (%p,%p) buffer_size(%u), pts:%.3f flags:%x",
-    CLASSNAME, __func__, buffer, pBuffer, buffer->omx_buffer, pBuffer->nFilledLen, (double)FromOMXTime(buffer->omx_buffer->nTimeStamp)*1e-6, buffer->omx_buffer->nFlags);
+  CLog::Log(LOGDEBUG, "%s::%s - %p (%p,%p) buffer_size(%u), pts:%.3f flags:%x frame:%d win:%x",
+    CLASSNAME, __func__, buffer, pBuffer, buffer->omx_buffer, pBuffer->nFilledLen, (double)FromOMXTime(buffer->omx_buffer->nTimeStamp)*1e-6, buffer->omx_buffer->nFlags, (int)buffer->omx_buffer->pMarkData, skipDeinterlaceFields);
   #endif
 
   assert(!(buffer->omx_buffer->nFlags & (OMX_BUFFERFLAG_DECODEONLY | OMX_BUFFERFLAG_DROPPED)));
-  // queue output omx buffer to ready list.
-  pthread_mutex_lock(&m_omx_output_mutex);
-  buffer->m_aspect_ratio = m_aspect_ratio;
-  m_omx_output_ready.push(buffer);
-  pthread_mutex_unlock(&m_omx_output_mutex);
 
+
+  // flags have OMX_BUFFERFLAG_FIRST_FIELD set if this is a direct result of a submitted frame,
+  // clear for second field of deinterlaced frame. They are zero when frame is returned due to a flush.
+#ifdef DTS_QUEUE
+  if ((!m_deinterlace || (buffer->omx_buffer->nFlags & OMX_BUFFERFLAG_FIRST_FIELD)) && buffer->omx_buffer->nFlags)
+  {
+    pthread_mutex_lock(&m_omx_output_mutex);
+    assert(!m_dts_queue.empty());
+    buffer->dts = m_dts_queue.front();
+    m_dts_queue.pop();
+    pthread_mutex_unlock(&m_omx_output_mutex);
+  }
+#endif
+  if (m_drop_state || (m_deinterlace && skipDeinterlaceFields && !(buffer->omx_buffer->nFlags & OMX_BUFFERFLAG_FIRST_FIELD)))
+  {
+    ReturnOpenMaxBuffer(buffer);
+  }
+  else
+  {
+    buffer->m_aspect_ratio = m_aspect_ratio;
+    pthread_mutex_lock(&m_omx_output_mutex);
+    m_omx_output_ready.push(buffer);
+    pthread_mutex_unlock(&m_omx_output_mutex);
+  }
   return OMX_ErrorNone;
 }
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
index f234f6d..adf53b5 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.h
@@ -57,6 +57,7 @@ class COpenMaxVideoBuffer
   int height;
   float m_aspect_ratio;
   int index;
+  double dts;
 
   // used for egl based rendering if active
   EGLImageKHR egl_image;
@@ -87,6 +88,7 @@ class COpenMaxVideo
   virtual unsigned GetAllowedReferences() { return 2; }
   virtual void SetDropState(bool bDrop);
   virtual const char* GetName(void) { return (const char*)m_pFormatName; }
+  virtual bool GetCodecStats(double &pts, int &droppedPics);
 
   // OpenMax decoder callback routines.
   OMX_ERRORTYPE DecoderFillBufferDone(OMX_HANDLETYPE hComponent, OMX_BUFFERHEADERTYPE* pBuffer);
@@ -142,10 +144,11 @@ class COpenMaxVideo
 
   bool              m_deinterlace;
   EDEINTERLACEMODE  m_deinterlace_request;
-  bool              m_deinterlace_second_field;
-
   bool              m_startframe;
-
+  unsigned int      m_decode_frame_number;
+  double            m_decoderPts;
+  unsigned int      m_droppedPics;
+  bool              m_skipDeinterlaceFields;
   bool PortSettingsChanged();
   bool SendDecoderConfig(uint8_t *extradata, int extrasize);
   bool NaluFormatStartCodes(enum AVCodecID codec, uint8_t *extradata, int extrasize);
-- 
1.9.3


From 89a8ef38736a9bc529fd1bbad6c9bd5919a4992f Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 11 Apr 2014 16:12:27 +0100
Subject: [PATCH 59/99] [omxplayer] Add ability to log more timestamp info in
 extra debug settings

---
 language/English/strings.po             |  5 ++++
 xbmc/commons/ilog.h                     |  1 +
 xbmc/cores/omxplayer/OMXPlayer.cpp      | 52 ++++++++++++++++-----------------
 xbmc/cores/omxplayer/OMXPlayerAudio.cpp |  8 ++---
 xbmc/cores/omxplayer/OMXPlayerVideo.cpp |  9 +++---
 xbmc/settings/AdvancedSettings.cpp      |  3 ++
 6 files changed, 44 insertions(+), 34 deletions(-)

diff --git a/language/English/strings.po b/language/English/strings.po
index d56f687..86da213 100755
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -2879,6 +2879,11 @@ msgctxt "#679"
 msgid "Verbose logging for CEC library"
 msgstr ""
 
+#: xbmc/settings/AdvancedSettings.cpp
+msgctxt "#697"
+msgid "Verbose logging for OMXPLAYER"
+msgstr ""
+
 #empty strings from id 680 to 699
 
 msgctxt "#700"
diff --git a/xbmc/commons/ilog.h b/xbmc/commons/ilog.h
index 4bf5d83..3fb7cc3 100644
--- a/xbmc/commons/ilog.h
+++ b/xbmc/commons/ilog.h
@@ -53,6 +53,7 @@
 #define LOGAIRTUNES (1 << (LOGMASKBIT + 8))
 #define LOGUPNP     (1 << (LOGMASKBIT + 9))
 #define LOGCEC      (1 << (LOGMASKBIT + 10))
+#define LOGOMXPLAYER  (1 << (LOGMASKBIT+11))
 
 #ifdef __GNUC__
 #define ATTRIB_LOG_FORMAT __attribute__((format(printf,3,4)))
diff --git a/xbmc/cores/omxplayer/OMXPlayer.cpp b/xbmc/cores/omxplayer/OMXPlayer.cpp
index 030d7b6..658b0a6 100644
--- a/xbmc/cores/omxplayer/OMXPlayer.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayer.cpp
@@ -1545,27 +1545,28 @@ void COMXPlayer::Process()
       m_video_fifo = (int)(100.0*(m_omxPlayerVideo.GetDecoderBufferSize()-m_omxPlayerVideo.GetDecoderFreeSpace())/m_omxPlayerVideo.GetDecoderBufferSize());
       m_audio_fifo = (int)(100.0*audio_fifo/m_omxPlayerAudio.GetCacheTotal());
 
-      #ifdef _DEBUG
-      static unsigned count;
-      if ((count++ & 7) == 0)
+      if (g_advancedSettings.CanLogComponent(LOGOMXPLAYER))
       {
-        char response[80];
-        if (m_omxPlayerVideo.GetDecoderBufferSize() && m_omxPlayerAudio.GetCacheTotal())
-          vc_gencmd(response, sizeof response, "render_bar 4 video_fifo %d %d %d %d",
-              m_video_fifo,
-              (int)(100.0*video_fifo/m_omxPlayerAudio.GetCacheTotal()),
-              0, 100);
-        if (m_omxPlayerAudio.GetCacheTotal())
-          vc_gencmd(response, sizeof response, "render_bar 5 audio_fifo %d %d %d %d",
-              m_audio_fifo,
-              (int)(100.0*m_omxPlayerAudio.GetDelay()/m_omxPlayerAudio.GetCacheTotal()),
-              0, 100);
-        vc_gencmd(response, sizeof response, "render_bar 6 video_queue %d %d %d %d",
-              m_omxPlayerVideo.GetLevel(), 0, 0, 100);
-        vc_gencmd(response, sizeof response, "render_bar 7 audio_queue %d %d %d %d",
-              m_omxPlayerAudio.GetLevel(), 0, 0, 100);
+        static unsigned count;
+        if ((count++ & 7) == 0)
+        {
+          char response[80];
+          if (m_omxPlayerVideo.GetDecoderBufferSize() && m_omxPlayerAudio.GetCacheTotal())
+            vc_gencmd(response, sizeof response, "render_bar 4 video_fifo %d %d %d %d",
+                m_video_fifo,
+                (int)(100.0*video_fifo/m_omxPlayerAudio.GetCacheTotal()),
+                0, 100);
+          if (m_omxPlayerAudio.GetCacheTotal())
+            vc_gencmd(response, sizeof response, "render_bar 5 audio_fifo %d %d %d %d",
+                m_audio_fifo,
+                (int)(100.0*m_omxPlayerAudio.GetDelay()/m_omxPlayerAudio.GetCacheTotal()),
+                0, 100);
+          vc_gencmd(response, sizeof response, "render_bar 6 video_queue %d %d %d %d",
+                m_omxPlayerVideo.GetLevel(), 0, 0, 100);
+          vc_gencmd(response, sizeof response, "render_bar 7 audio_queue %d %d %d %d",
+                m_omxPlayerAudio.GetLevel(), 0, 0, 100);
+        }
       }
-      #endif
       if (audio_pts != DVD_NOPTS_VALUE)
       {
         audio_fifo_low = m_HasAudio && audio_fifo < threshold;
@@ -1581,13 +1582,12 @@ void COMXPlayer::Process()
       if (!m_HasVideo && m_HasAudio)
         video_fifo_high = true;
 
-      #ifdef _DEBUG
-      CLog::Log(LOGDEBUG, "%s - M:%.6f-%.6f (A:%.6f V:%.6f) PEF:%d%d%d S:%.2f A:%.2f V:%.2f/T:%.2f (A:%d%d V:%d%d) A:%d%% V:%d%% (%.2f,%.2f)", __FUNCTION__,
-        m_stamp*1e-6, m_av_clock.OMXClockAdjustment()*1e-6, audio_pts*1e-6, video_pts*1e-6, m_av_clock.OMXIsPaused(), bOmxSentEOFs, not_accepts_data, m_playSpeed * (1.0f/DVD_PLAYSPEED_NORMAL),
-        audio_pts == DVD_NOPTS_VALUE ? 0.0:audio_fifo, video_pts == DVD_NOPTS_VALUE ? 0.0:video_fifo, m_threshold,
-        audio_fifo_low, audio_fifo_high, video_fifo_low, video_fifo_high,
-        m_omxPlayerAudio.GetLevel(), m_omxPlayerVideo.GetLevel(), m_omxPlayerAudio.GetDelay(), (float)m_omxPlayerAudio.GetCacheTotal());
-      #endif
+      if (g_advancedSettings.CanLogComponent(LOGOMXPLAYER))
+        CLog::Log(LOGDEBUG, "%s - M:%.6f-%.6f (A:%.6f V:%.6f) PEF:%d%d%d S:%.2f A:%.2f V:%.2f/T:%.2f (A:%d%d V:%d%d) A:%d%% V:%d%% (%.2f,%.2f)", __FUNCTION__,
+          m_stamp*1e-6, m_av_clock.OMXClockAdjustment()*1e-6, audio_pts*1e-6, video_pts*1e-6, m_av_clock.OMXIsPaused(), bOmxSentEOFs, not_accepts_data, m_playSpeed * (1.0f/DVD_PLAYSPEED_NORMAL),
+          audio_pts == DVD_NOPTS_VALUE ? 0.0:audio_fifo, video_pts == DVD_NOPTS_VALUE ? 0.0:video_fifo, m_threshold,
+          audio_fifo_low, audio_fifo_high, video_fifo_low, video_fifo_high,
+          m_omxPlayerAudio.GetLevel(), m_omxPlayerVideo.GetLevel(), m_omxPlayerAudio.GetDelay(), (float)m_omxPlayerAudio.GetCacheTotal());
 
       if (TP(m_playSpeed))
       {
diff --git a/xbmc/cores/omxplayer/OMXPlayerAudio.cpp b/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
index 4ed8d17..a4a491e 100644
--- a/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
@@ -366,10 +366,10 @@ void OMXPlayerAudio::Process()
       DemuxPacket* pPacket = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacket();
       bool bPacketDrop     = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacketDrop();
 
-      #ifdef _DEBUG
-      CLog::Log(LOGINFO, "Audio: dts:%.0f pts:%.0f size:%d (s:%d f:%d d:%d l:%d) s:%d %d/%d late:%d,%d", pPacket->dts, pPacket->pts,
-           (int)pPacket->iSize, m_started, m_flush, bPacketDrop, m_stalled, m_speed, 0, 0, (int)m_omxAudio.GetAudioRenderingLatency(), (int)m_hints_current.samplerate);
-      #endif
+      if (g_advancedSettings.CanLogComponent(LOGOMXPLAYER))
+        CLog::Log(LOGINFO, "Audio: dts:%.0f pts:%.0f size:%d (s:%d f:%d d:%d l:%d) s:%d %d/%d late:%d,%d", pPacket->dts, pPacket->pts,
+             (int)pPacket->iSize, m_started, m_flush, bPacketDrop, m_stalled, m_speed, 0, 0, (int)m_omxAudio.GetAudioRenderingLatency(), (int)m_hints_current.samplerate);
+
       if(Decode(pPacket, m_speed > DVD_PLAYSPEED_NORMAL || m_speed < 0 || bPacketDrop))
       {
         // we are not running until something is cached in output device
diff --git a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
index 77dad37..605ea80 100644
--- a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
@@ -42,6 +42,7 @@
 #include "DVDOverlayRenderer.h"
 #include "settings/DisplaySettings.h"
 #include "settings/Settings.h"
+#include "settings/AdvancedSettings.h"
 #include "settings/MediaSettings.h"
 #include "cores/VideoRenderers/RenderFormats.h"
 #include "cores/VideoRenderers/RenderFlags.h"
@@ -452,10 +453,10 @@ void OMXPlayerVideo::Process()
       DemuxPacket* pPacket = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacket();
       bool bPacketDrop     = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacketDrop();
 
-      #ifdef _DEBUG
-      CLog::Log(LOGINFO, "Video: dts:%.0f pts:%.0f size:%d (s:%d f:%d d:%d l:%d) s:%d %d/%d late:%d\n", pPacket->dts, pPacket->pts, 
-          (int)pPacket->iSize, m_started, m_flush, bPacketDrop, m_stalled, m_speed, 0, 0, 0);
-      #endif
+      if (g_advancedSettings.CanLogComponent(LOGOMXPLAYER))
+        CLog::Log(LOGINFO, "Video: dts:%.0f pts:%.0f size:%d (s:%d f:%d d:%d l:%d) s:%d %d/%d late:%d\n", pPacket->dts, pPacket->pts,
+            (int)pPacket->iSize, m_started, m_flush, bPacketDrop, m_stalled, m_speed, 0, 0, 0);
+
       if (m_messageQueue.GetDataSize() == 0
       ||  m_speed < 0)
       {
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index e41a935..90222f4 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -1386,6 +1386,9 @@ void CAdvancedSettings::SettingOptionsLoggingComponentsFiller(const CSetting *se
 #ifdef HAVE_LIBCEC
   list.push_back(std::make_pair(g_localizeStrings.Get(679), LOGCEC));
 #endif
+#ifdef TARGET_RASPBERRY_PI
+  list.push_back(std::make_pair(g_localizeStrings.Get(697), LOGOMXPLAYER));
+#endif
 }
 
 void CAdvancedSettings::setExtraLogLevel(const std::vector<CVariant> &components)
-- 
1.9.3


From 456412b4f28b491891c35c4ffee6e8863588a878 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 7 Apr 2014 23:13:55 +0100
Subject: [PATCH 60/99] [omxplayer] Add ability to dump out audio/video data
 for later debugging

---
 language/English/strings.po        | 10 ++++++++
 xbmc/commons/ilog.h                |  2 ++
 xbmc/cores/omxplayer/OMXAudio.cpp  | 49 ++++++++++++++++++++++++++++++++++++++
 xbmc/cores/omxplayer/OMXVideo.cpp  | 47 ++++++++++++++++++++++++++++++++++++
 xbmc/settings/AdvancedSettings.cpp |  4 ++++
 5 files changed, 112 insertions(+)

diff --git a/language/English/strings.po b/language/English/strings.po
index 86da213..3704baa 100755
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -2884,6 +2884,16 @@ msgctxt "#697"
 msgid "Verbose logging for OMXPLAYER"
 msgstr ""
 
+#: xbmc/settings/AdvancedSettings.cpp
+msgctxt "#698"
+msgid "Dump video frames to debug file"
+msgstr ""
+
+#: xbmc/settings/AdvancedSettings.cpp
+msgctxt "#699"
+msgid "Dump audio frames to debug file"
+msgstr ""
+
 #empty strings from id 680 to 699
 
 msgctxt "#700"
diff --git a/xbmc/commons/ilog.h b/xbmc/commons/ilog.h
index 3fb7cc3..4d722a0 100644
--- a/xbmc/commons/ilog.h
+++ b/xbmc/commons/ilog.h
@@ -54,6 +54,8 @@
 #define LOGUPNP     (1 << (LOGMASKBIT + 9))
 #define LOGCEC      (1 << (LOGMASKBIT + 10))
 #define LOGOMXPLAYER  (1 << (LOGMASKBIT+11))
+#define LOGDUMPVIDEO  (1 << (LOGMASKBIT+12))
+#define LOGDUMPAUDIO  (1 << (LOGMASKBIT+13))
 
 #ifdef __GNUC__
 #define ATTRIB_LOG_FORMAT __attribute__((format(printf,3,4)))
diff --git a/xbmc/cores/omxplayer/OMXAudio.cpp b/xbmc/cores/omxplayer/OMXAudio.cpp
index 5f9d028..1bcc53e0 100644
--- a/xbmc/cores/omxplayer/OMXAudio.cpp
+++ b/xbmc/cores/omxplayer/OMXAudio.cpp
@@ -59,6 +59,49 @@ static const uint16_t AC3FSCod   [] = {48000, 44100, 32000, 0};
 
 static const uint16_t DTSFSCod   [] = {0, 8000, 16000, 32000, 0, 0, 11025, 22050, 44100, 0, 0, 12000, 24000, 48000, 0, 0};
 
+//#define DEBUG_PLAYBACK
+static void dump_omx_buffer(OMX_BUFFERHEADERTYPE *omx_buffer)
+{
+  if (!(g_advancedSettings.CanLogComponent(LOGDUMPAUDIO)))
+    return;
+  static FILE *fp;
+  if (!omx_buffer)
+  {
+    if (fp)
+    {
+      fclose(fp);
+      fp = NULL;
+    }
+    return;
+  }
+  if (!fp)
+  {
+    char filename[1024];
+    strcpy(filename, g_advancedSettings.m_logFolder.c_str());
+    strcat(filename, "audio.dat");
+#ifdef DEBUG_PLAYBACK
+    fp = fopen(filename, "rb");
+#else
+    fp = fopen(filename, "wb");
+#endif
+    }
+  if (fp)
+  {
+#ifdef DEBUG_PLAYBACK
+    OMX_BUFFERHEADERTYPE omx = {0};
+    int s = fread(&omx, sizeof omx, 1, fp);
+    omx_buffer->nFilledLen = omx.nFilledLen;
+    omx_buffer->nFlags = omx.nFlags;
+    omx_buffer->nTimeStamp = omx.nTimeStamp;
+    if (s==1)
+      fread(omx_buffer->pBuffer, omx_buffer->nFilledLen, 1, fp);
+#else
+    if (fwrite(omx_buffer, sizeof *omx_buffer, 1, fp) == 1)
+      fwrite(omx_buffer->pBuffer, omx_buffer->nFilledLen, 1, fp);
+#endif
+  }
+}
+
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
@@ -866,6 +909,7 @@ bool COMXAudio::Initialize(AEAudioFormat format, OMXClock *clock, CDVDStreamInfo
     memcpy((unsigned char *)omx_buffer->pBuffer, &m_wave_header, omx_buffer->nFilledLen);
     omx_buffer->nFlags = OMX_BUFFERFLAG_CODECCONFIG | OMX_BUFFERFLAG_ENDOFFRAME;
 
+    dump_omx_buffer(omx_buffer);
     omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
     if (omx_err != OMX_ErrorNone)
     {
@@ -898,6 +942,7 @@ bool COMXAudio::Initialize(AEAudioFormat format, OMXClock *clock, CDVDStreamInfo
       memcpy((unsigned char *)omx_buffer->pBuffer, m_extradata, omx_buffer->nFilledLen);
       omx_buffer->nFlags = OMX_BUFFERFLAG_CODECCONFIG | OMX_BUFFERFLAG_ENDOFFRAME;
   
+      dump_omx_buffer(omx_buffer);
       omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
       if (omx_err != OMX_ErrorNone)
       {
@@ -934,6 +979,8 @@ bool COMXAudio::Deinitialize()
 {
   CSingleLock lock (m_critSection);
 
+  dump_omx_buffer(NULL);
+
   if ( m_omx_tunnel_clock_analog.IsInitialized() )
     m_omx_tunnel_clock_analog.Deestablish();
   if ( m_omx_tunnel_clock_hdmi.IsInitialized() )
@@ -1226,6 +1273,7 @@ unsigned int COMXAudio::AddPackets(const void* data, unsigned int len, double dt
     int nRetry = 0;
     while(true)
     {
+      dump_omx_buffer(omx_buffer);
       omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
       if (omx_err == OMX_ErrorNone)
       {
@@ -1492,6 +1540,7 @@ void COMXAudio::SubmitEOS()
 
   omx_buffer->nFlags = OMX_BUFFERFLAG_ENDOFFRAME | OMX_BUFFERFLAG_EOS | OMX_BUFFERFLAG_TIME_UNKNOWN;
 
+  dump_omx_buffer(omx_buffer);
   omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
   if (omx_err != OMX_ErrorNone)
   {
diff --git a/xbmc/cores/omxplayer/OMXVideo.cpp b/xbmc/cores/omxplayer/OMXVideo.cpp
index 820ea44..6639804 100644
--- a/xbmc/cores/omxplayer/OMXVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXVideo.cpp
@@ -63,6 +63,49 @@
 
 #define MAX_TEXT_LENGTH 1024
 
+//#define DEBUG_PLAYBACK
+static void dump_omx_buffer(OMX_BUFFERHEADERTYPE *omx_buffer)
+{
+  if (!(g_advancedSettings.CanLogComponent(LOGDUMPVIDEO)))
+    return;
+  static FILE *fp;
+  if (!omx_buffer)
+  {
+    if (fp)
+    {
+      fclose(fp);
+      fp = NULL;
+    }
+    return;
+  }
+  if (!fp)
+  {
+    char filename[1024];
+    strcpy(filename, g_advancedSettings.m_logFolder.c_str());
+    strcat(filename, "video.dat");
+#ifdef DEBUG_PLAYBACK
+    fp = fopen(filename, "rb");
+#else
+    fp = fopen(filename, "wb");
+#endif
+    }
+  if (fp)
+  {
+#ifdef DEBUG_PLAYBACK
+    OMX_BUFFERHEADERTYPE omx = {0};
+    int s = fread(&omx, sizeof omx, 1, fp);
+    omx_buffer->nFilledLen = omx.nFilledLen;
+    omx_buffer->nFlags = omx.nFlags;
+    omx_buffer->nTimeStamp = omx.nTimeStamp;
+    if (s==1)
+      fread(omx_buffer->pBuffer, omx_buffer->nFilledLen, 1, fp);
+#else
+    if (fwrite(omx_buffer, sizeof *omx_buffer, 1, fp) == 1)
+      fwrite(omx_buffer->pBuffer, omx_buffer->nFilledLen, 1, fp);
+#endif
+  }
+}
+
 COMXVideo::COMXVideo() : m_video_codec_name("")
 {
   m_is_open           = false;
@@ -118,6 +161,7 @@ bool COMXVideo::SendDecoderConfig()
     memcpy((unsigned char *)omx_buffer->pBuffer, m_extradata, omx_buffer->nFilledLen);
     omx_buffer->nFlags = OMX_BUFFERFLAG_CODECCONFIG | OMX_BUFFERFLAG_ENDOFFRAME;
   
+    dump_omx_buffer(omx_buffer);
     omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
     if (omx_err != OMX_ErrorNone)
     {
@@ -687,6 +731,7 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, EDEINTERLACEMODE de
 void COMXVideo::Close()
 {
   CSingleLock lock (m_critSection);
+  dump_omx_buffer(NULL);
   m_omx_tunnel_clock.Deestablish();
   m_omx_tunnel_decoder.Deestablish();
   if(m_deinterlace)
@@ -781,6 +826,7 @@ int COMXVideo::Decode(uint8_t *pData, int iSize, double pts)
       int nRetry = 0;
       while(true)
       {
+        dump_omx_buffer(omx_buffer);
         omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
         if (omx_err == OMX_ErrorNone)
         {
@@ -910,6 +956,7 @@ void COMXVideo::SubmitEOS()
 
   omx_buffer->nFlags = OMX_BUFFERFLAG_ENDOFFRAME | OMX_BUFFERFLAG_EOS | OMX_BUFFERFLAG_TIME_UNKNOWN;
   
+  dump_omx_buffer(omx_buffer);
   omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
   if (omx_err != OMX_ErrorNone)
   {
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 90222f4..1175eb1 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -1389,6 +1389,10 @@ void CAdvancedSettings::SettingOptionsLoggingComponentsFiller(const CSetting *se
 #ifdef TARGET_RASPBERRY_PI
   list.push_back(std::make_pair(g_localizeStrings.Get(697), LOGOMXPLAYER));
 #endif
+#ifdef TARGET_RASPBERRY_PI
+  list.push_back(std::make_pair(g_localizeStrings.Get(698), LOGDUMPVIDEO));
+  list.push_back(std::make_pair(g_localizeStrings.Get(699), LOGDUMPAUDIO));
+#endif
 }
 
 void CAdvancedSettings::setExtraLogLevel(const std::vector<CVariant> &components)
-- 
1.9.3


From 9172ae4fef35d1990b2f8014cd8dd2fcf7434bfa Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 28 May 2014 18:30:51 +0100
Subject: [PATCH 61/99] [omxcodec] Reduce GPU memory use by 2 video frames

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
index 612ae21..494fdf5 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
@@ -308,6 +308,20 @@ bool COpenMaxVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, OpenM
     return false;
   }
 
+  {
+    // as we aren't tunnelled to display, we can save memory by setting extrabuffers to 0
+    OMX_PARAM_U32TYPE extra_buffers;
+    OMX_INIT_STRUCTURE(extra_buffers);
+    extra_buffers.nU32 = 0;
+
+    omx_err = m_omx_decoder.SetParameter(OMX_IndexParamBrcmExtraBuffers, &extra_buffers);
+    if(omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "COMXVideo::Open error OMX_IndexParamBrcmExtraBuffers omx_err(0x%08x)\n", omx_err);
+      return false;
+    }
+  }
+
   // request portsettingschanged on aspect ratio change
   OMX_CONFIG_REQUESTCALLBACKTYPE notifications;
   OMX_INIT_STRUCTURE(notifications);
-- 
1.9.3


From 90e783513b7b242155d18eda21b72540338a5986 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 30 May 2014 14:15:10 +0100
Subject: [PATCH 62/99] [pi] Fix for logged resolutions

---
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp | 15 +++++----------
 1 file changed, 5 insertions(+), 10 deletions(-)

diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index 5b26b20..a3edf0e 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -483,10 +483,8 @@ bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &r
 
   if(resolutions.size() == 0)
   {
-    RESOLUTION_INFO res;
-    CLog::Log(LOGDEBUG, "EGL probe resolution %s:%x\n", m_desktopRes.strMode.c_str(), m_desktopRes.dwFlags);
-
     AddUniqueResolution(m_desktopRes, resolutions);
+    CLog::Log(LOGDEBUG, "EGL probe resolution %s:%x\n", m_desktopRes.strMode.c_str(), m_desktopRes.dwFlags);
   }
 
   if(resolutions.size() < 2)
@@ -576,13 +574,12 @@ void CEGLNativeTypeRaspberryPI::GetSupportedModes(HDMI_RES_GROUP_T group, std::v
       res.iScreenWidth  = tv->width;
       res.iScreenHeight = tv->height;
       res.fPixelRatio   = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)res.iScreenWidth / (float)res.iScreenHeight);
+      res.iSubtitles    = (int)(0.965 * res.iHeight);
 
+      AddUniqueResolution(res, resolutions);
       CLog::Log(LOGDEBUG, "EGL mode %d: %s (%.2f) %s%s:%x\n", i, res.strMode.c_str(), res.fPixelRatio,
           tv->native ? "N" : "", tv->scan_mode ? "I" : "", tv->code);
 
-      res.iSubtitles    = (int)(0.965 * res.iHeight);
-
-      AddUniqueResolution(res, resolutions);
       if (tv->frame_rate == 24 || tv->frame_rate == 30 || tv->frame_rate == 60)
       {
         RESOLUTION_INFO res2 = res;
@@ -596,11 +593,10 @@ void CEGLNativeTypeRaspberryPI::GetSupportedModes(HDMI_RES_GROUP_T group, std::v
         RESOLUTION_INFO res2 = res;
         res2.dwFlags |= D3DPRESENTFLAG_MODE3DSBS;
         res2.fPixelRatio    = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)res2.iScreenWidth / (float)res2.iScreenHeight);
-        CLog::Log(LOGDEBUG, "EGL mode %d: %s (%.2f)\n", i, res2.strMode.c_str(), res2.fPixelRatio);
-
         res2.iSubtitles    = (int)(0.965 * res2.iHeight);
 
         AddUniqueResolution(res2, resolutions);
+        CLog::Log(LOGDEBUG, "EGL mode %d: %s (%.2f)\n", i, res2.strMode.c_str(), res2.fPixelRatio);
         if (tv->frame_rate == 24 || tv->frame_rate == 30 || tv->frame_rate == 60)
         {
           res2.fRefreshRate  = (float)tv->frame_rate * (1000.0f/1001.0f);
@@ -612,11 +608,10 @@ void CEGLNativeTypeRaspberryPI::GetSupportedModes(HDMI_RES_GROUP_T group, std::v
         RESOLUTION_INFO res2 = res;
         res2.dwFlags |= D3DPRESENTFLAG_MODE3DTB;
         res2.fPixelRatio    = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)res2.iScreenWidth / (float)res2.iScreenHeight);
-        CLog::Log(LOGDEBUG, "EGL mode %d: %s (%.2f)\n", i, res2.strMode.c_str(), res2.fPixelRatio);
-
         res2.iSubtitles    = (int)(0.965 * res2.iHeight);
 
         AddUniqueResolution(res2, resolutions);
+        CLog::Log(LOGDEBUG, "EGL mode %d: %s (%.2f)\n", i, res2.strMode.c_str(), res2.fPixelRatio);
         if (tv->frame_rate == 24 || tv->frame_rate == 30 || tv->frame_rate == 60)
         {
           res2.fRefreshRate  = (float)tv->frame_rate * (1000.0f/1001.0f);
-- 
1.9.3


From 2ad66067f303d68a976ec56ed2f5be41a3479f72 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 30 May 2014 14:58:43 +0100
Subject: [PATCH 63/99] [settings] Experiment: Report DESKTOP resolution in
 video settings

---
 xbmc/settings/DisplaySettings.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/settings/DisplaySettings.cpp b/xbmc/settings/DisplaySettings.cpp
index bb31f15..eae549b 100644
--- a/xbmc/settings/DisplaySettings.cpp
+++ b/xbmc/settings/DisplaySettings.cpp
@@ -650,6 +650,9 @@ void CDisplaySettings::SettingOptionsResolutionsFiller(const CSetting *setting,
     vector<RESOLUTION_WHR> resolutions = g_Windowing.ScreenResolutions(info.iScreen, info.fRefreshRate);
     for (vector<RESOLUTION_WHR>::const_iterator resolution = resolutions.begin(); resolution != resolutions.end(); ++resolution)
     {
+if (resolution->ResInfo_Index == RES_DESKTOP)
+      list.push_back(make_pair(StringUtils::Format("DESKTOP"), resolution->ResInfo_Index));
+else
       list.push_back(make_pair(
         StringUtils::Format("%dx%d%s", resolution->width, resolution->height,
                             ModeFlagsToString(resolution->flags, false).c_str()),
-- 
1.9.3


From 042314a5a8336b7a4ff6789ce719ba3edb30bfee Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 7 Jun 2014 16:55:41 +0100
Subject: [PATCH 64/99] [omx] Remove logging for texture jobs

This causes a lot of log spam which hasn't proved useful so far.
---
 xbmc/cores/omxplayer/OMXImage.cpp | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/xbmc/cores/omxplayer/OMXImage.cpp b/xbmc/cores/omxplayer/OMXImage.cpp
index 5889365..d2f6b21 100644
--- a/xbmc/cores/omxplayer/OMXImage.cpp
+++ b/xbmc/cores/omxplayer/OMXImage.cpp
@@ -213,13 +213,11 @@ bool COMXImage::SendMessage(bool (*callback)(EGLDisplay egl_display, EGLContext
   mess.sync.Reset();
   {
     CSingleLock lock(m_texqueue_lock);
-    CLog::Log(LOGDEBUG, "%s: texture job: %p:%p", __func__, &mess, mess.callback);
     m_texqueue.push(&mess);
     m_texqueue_cond.notifyAll();
   }
   // wait for function to have finished (in texture thread)
   mess.sync.Wait();
-  CLog::Log(LOGDEBUG, "%s: texture job done: %p:%p = %d", __func__, &mess, mess.callback, mess.result);
   // need to ensure texture thread has returned from mess.sync.Set() before we exit and free tex
   CSingleLock lock(m_texqueue_lock);
   return mess.result;
@@ -432,15 +430,12 @@ void COMXImage::Process()
       struct callbackinfo *mess = m_texqueue.front();
       m_texqueue.pop();
       lock.Leave();
-      CLog::Log(LOGDEBUG, "%s: texture job: %p:%p:%p", __func__, mess, mess->callback, mess->cookie);
 
       mess->result = mess->callback(g_Windowing.GetEGLDisplay(), GetEGLContext(), mess->cookie);
-      CLog::Log(LOGDEBUG, "%s: texture job about to Set: %p:%p:%p", __func__, mess, mess->callback, mess->cookie);
       {
         CSingleLock lock(m_texqueue_lock);
         mess->sync.Set();
       }
-      CLog::Log(LOGDEBUG, "%s: texture job: %p done", __func__, mess);
     }
   }
 }
-- 
1.9.3


From c5d28ec1360f5507090deb8a01685dbc2e788b1b Mon Sep 17 00:00:00 2001
From: Matthias Kortstiege <vdrfan@xbmc.org>
Date: Sun, 1 Jun 2014 18:47:20 +0200
Subject: [PATCH 65/99] changed: avoid useless filesytem io while searching for
 subtitles

---
 xbmc/Util.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/xbmc/Util.cpp b/xbmc/Util.cpp
index 20083fd..0d23820 100644
--- a/xbmc/Util.cpp
+++ b/xbmc/Util.cpp
@@ -1982,7 +1982,7 @@ void CUtil::ScanForExternalSubtitles(const std::string& strMovie, std::vector<st
     {
       CFileItemList items;
       
-      CDirectory::GetDirectory(strLookInPaths[step], items, g_advancedSettings.m_subtitlesExtensions, DIR_FLAG_NO_FILE_DIRS);
+      CDirectory::GetDirectory(strLookInPaths[step], items, g_advancedSettings.m_subtitlesExtensions, DIR_FLAG_NO_FILE_DIRS | DIR_FLAG_NO_FILE_INFO);
       
       for (int j = 0; j < items.Size(); j++)
       {
@@ -2062,7 +2062,7 @@ int CUtil::ScanArchiveForSubtitles( const std::string& strArchivePath, const std
   {
    CURL pathToUrl(strArchivePath);
    CURL zipURL = URIUtils::CreateArchivePath("zip", pathToUrl, "");
-   if (!CDirectory::GetDirectory(zipURL, ItemList, "", DIR_FLAG_NO_FILE_DIRS))
+   if (!CDirectory::GetDirectory(zipURL, ItemList, "", DIR_FLAG_NO_FILE_DIRS | DIR_FLAG_NO_FILE_INFO))
     return false;
   }
   else
-- 
1.9.3


From c54f3c74449a531ac68cd588d14ef9ca9f6db382 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 4 Jun 2014 19:10:27 +0100
Subject: [PATCH 66/99] [pisink] Support planar formats

---
 xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp | 35 ++++++++++++++++++++++++++-----
 1 file changed, 30 insertions(+), 5 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
index 0a09275..5a45653 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
@@ -180,7 +180,9 @@ bool CAESinkPi::Initialize(AEAudioFormat &format, std::string &device)
     format.m_channelLayout = AE_CH_LAYOUT_2_0;
 
   // setup for a 50ms sink feed from SoftAE
-  if (format.m_dataFormat != AE_FMT_FLOAT && format.m_dataFormat != AE_FMT_S32LE)
+  if (format.m_dataFormat != AE_FMT_FLOATP && format.m_dataFormat != AE_FMT_FLOAT &&
+      format.m_dataFormat != AE_FMT_S32NE && format.m_dataFormat != AE_FMT_S32NEP && format.m_dataFormat != AE_FMT_S32LE &&
+      format.m_dataFormat != AE_FMT_S16NE && format.m_dataFormat != AE_FMT_S16NEP && format.m_dataFormat != AE_FMT_S16LE)
     format.m_dataFormat = AE_FMT_S16LE;
   unsigned int channels    = format.m_channelLayout.Count();
   unsigned int sample_size = CAEUtil::DataFormatToBits(format.m_dataFormat) >> 3;
@@ -210,7 +212,13 @@ bool CAESinkPi::Initialize(AEAudioFormat &format, std::string &device)
   m_pcm_input.eEndian               = OMX_EndianLittle;
   m_pcm_input.bInterleaved          = OMX_TRUE;
   m_pcm_input.nBitPerSample         = sample_size * 8;
-  m_pcm_input.ePCMMode              = m_format.m_dataFormat == AE_FMT_FLOAT ? (OMX_AUDIO_PCMMODETYPE)0x8000 : OMX_AUDIO_PCMModeLinear;
+  // 0x8000 = float, 0x10000 = planar
+  uint32_t flags = 0;
+  if (m_format.m_dataFormat == AE_FMT_FLOAT || m_format.m_dataFormat == AE_FMT_FLOATP)
+   flags |= 0x8000;
+  if (AE_IS_PLANAR(m_format.m_dataFormat))
+   flags |= 0x10000;
+  m_pcm_input.ePCMMode              = flags == 0 ? OMX_AUDIO_PCMModeLinear : (OMX_AUDIO_PCMMODETYPE)flags;
   m_pcm_input.nChannels             = channels;
   m_pcm_input.nSamplingRate         = m_format.m_sampleRate;
 
@@ -306,14 +314,18 @@ double CAESinkPi::GetCacheTotal()
 
 unsigned int CAESinkPi::AddPackets(uint8_t **data, unsigned int frames, unsigned int offset)
 {
-  uint8_t *buffer = data[0]+offset*m_format.m_frameSize;
-
   if (!m_Initialized || !frames)
     return frames;
 
   OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
   OMX_BUFFERHEADERTYPE *omx_buffer = NULL;
 
+  unsigned int channels    = m_format.m_channelLayout.Count();
+  unsigned int sample_size = CAEUtil::DataFormatToBits(m_format.m_dataFormat) >> 3;
+  const int planes = AE_IS_PLANAR(m_format.m_dataFormat) ? channels : 1;
+  const int chans  = AE_IS_PLANAR(m_format.m_dataFormat) ? 1 : channels;
+  const int pitch  = chans * sample_size;
+
   AEDelayStatus status;
   GetDelay(status);
   double delay = status.GetDelay();
@@ -332,8 +344,13 @@ unsigned int CAESinkPi::AddPackets(uint8_t **data, unsigned int frames, unsigned
   assert(omx_buffer->nFilledLen <= omx_buffer->nAllocLen);
   omx_buffer->nTimeStamp = ToOMXTime(0);
   omx_buffer->nFlags = OMX_BUFFERFLAG_ENDOFFRAME;
-  memcpy(omx_buffer->pBuffer, buffer, omx_buffer->nFilledLen);
 
+  if (omx_buffer->nFilledLen)
+  {
+    int planesize = omx_buffer->nFilledLen / planes;
+    for (int i=0; i < planes; i++)
+      memcpy((uint8_t *)omx_buffer->pBuffer + i * planesize, data[i] + offset * pitch, planesize);
+  }
   omx_err = m_omx_render.EmptyThisBuffer(omx_buffer);
   if (omx_err != OMX_ErrorNone)
     CLog::Log(LOGERROR, "%s:%s frames=%d err=%x", CLASSNAME, __func__, frames, omx_err);
@@ -370,8 +387,13 @@ void CAESinkPi::EnumerateDevicesEx(AEDeviceInfoList &list, bool force)
   for (unsigned int i=0; i<sizeof PassthroughSampleRates/sizeof *PassthroughSampleRates; i++)
     m_info.m_sampleRates.push_back(PassthroughSampleRates[i]);
   m_info.m_dataFormats.push_back(AE_FMT_FLOAT);
+  m_info.m_dataFormats.push_back(AE_FMT_S32NE);
+  m_info.m_dataFormats.push_back(AE_FMT_S16NE);
   m_info.m_dataFormats.push_back(AE_FMT_S32LE);
   m_info.m_dataFormats.push_back(AE_FMT_S16LE);
+  m_info.m_dataFormats.push_back(AE_FMT_FLOATP);
+  m_info.m_dataFormats.push_back(AE_FMT_S32NEP);
+  m_info.m_dataFormats.push_back(AE_FMT_S16NEP);
   m_info.m_dataFormats.push_back(AE_FMT_AC3);
   m_info.m_dataFormats.push_back(AE_FMT_DTS);
   m_info.m_dataFormats.push_back(AE_FMT_EAC3);
@@ -392,6 +414,9 @@ void CAESinkPi::EnumerateDevicesEx(AEDeviceInfoList &list, bool force)
   m_info.m_dataFormats.push_back(AE_FMT_FLOAT);
   m_info.m_dataFormats.push_back(AE_FMT_S32LE);
   m_info.m_dataFormats.push_back(AE_FMT_S16LE);
+  m_info.m_dataFormats.push_back(AE_FMT_FLOATP);
+  m_info.m_dataFormats.push_back(AE_FMT_S32NEP);
+  m_info.m_dataFormats.push_back(AE_FMT_S16NEP);
 
   list.push_back(m_info);
 }
-- 
1.9.3


From 0b99849f497bf1ee698522018347cdce4c656bdd Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 30 Dec 2013 12:02:14 +0000
Subject: [PATCH 67/99] [rbp] Hardware accelerated resampling

This replaces the format conversion, up/down mixing and resampling code from ActiveAE with a GPU accelerated version.
Should significantly reduce CPU when using paplayer or dvdplayer.

Requires updated firmware
---
 .../Engines/ActiveAE/ActiveAEResample.cpp          |   5 +
 .../Engines/ActiveAE/ActiveAEResample.h            |   8 +
 .../Engines/ActiveAE/ActiveAEResamplePi.cpp        | 601 +++++++++++++++++++++
 .../Engines/ActiveAE/ActiveAEResamplePi.h          |  62 +++
 xbmc/cores/AudioEngine/Makefile.in                 |   1 +
 xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp          |  14 +-
 xbmc/linux/OMXCore.cpp                             |   4 +-
 7 files changed, 686 insertions(+), 9 deletions(-)
 create mode 100644 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
 create mode 100644 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.h

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp
index 03946c3..5feeefb 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp
@@ -18,6 +18,10 @@
  *
  */
 
+#include "system.h"
+
+#if !defined(TARGET_RASPBERRY_PI)
+
 #include "ActiveAEResample.h"
 #include "utils/log.h"
 
@@ -360,3 +364,4 @@ int CActiveAEResample::GetAVChannelIndex(enum AEChannel aechannel, uint64_t layo
 {
   return av_get_channel_layout_channel_index(layout, GetAVChannel(aechannel));
 }
+#endif
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h
index a471e02..5d37cc7 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h
@@ -19,6 +19,8 @@
  *
  */
 
+#include "system.h"
+
 #include "cores/AudioEngine/Utils/AEChannelInfo.h"
 #include "cores/AudioEngine/Utils/AEAudioFormat.h"
 #include "cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h"
@@ -29,6 +31,10 @@ extern "C" {
 #include "libswresample/swresample.h"
 }
 
+#if defined(TARGET_RASPBERRY_PI)
+#include "ActiveAEResamplePi.h"
+#else
+
 namespace ActiveAE
 {
 
@@ -63,3 +69,5 @@ class CActiveAEResample
 };
 
 }
+
+#endif
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
new file mode 100644
index 0000000..9a1e549
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
@@ -0,0 +1,601 @@
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+
+#if defined(TARGET_RASPBERRY_PI)
+
+#include "ActiveAEResample.h"
+#include "linux/RBP.h"
+#include "settings/Settings.h"
+#include "utils/log.h"
+
+extern "C" {
+#include "libavutil/channel_layout.h"
+#include "libavutil/opt.h"
+#include "libswresample/swresample.h"
+}
+
+//#define DEBUG_VERBOSE
+
+#define CLASSNAME "CActiveAEResamplePi"
+
+#define BUFFERSIZE (32*1024*2*8)
+
+//#define BENCHMARKING
+#ifdef BENCHMARKING
+#define LOGTIMEINIT(f) \
+  struct timespec now; \
+  uint64_t  Start, End; \
+  clock_gettime(CLOCK_MONOTONIC, &now); \
+  Start = ((int64_t)now.tv_sec * 1000000000L) + now.tv_nsec; \
+  const char *_filename = f;
+
+#define LOGTIME(n) \
+  clock_gettime(CLOCK_MONOTONIC, &now); \
+  End = ((int64_t)now.tv_sec * 1000000000L) + now.tv_nsec; \
+  CLog::Log(LOGNOTICE, "ActiveAE::%s %d - resample %s took %.0fms", __FUNCTION__, n, _filename, (End-Start)*1e-6); \
+  Start=End;
+#else
+#define LOGTIMEINIT(f)
+#define LOGTIME(n)
+#endif
+
+using namespace ActiveAE;
+
+CActiveAEResample::CActiveAEResample()
+{
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+
+  m_Initialized = false;
+  m_last_src_fmt = AV_SAMPLE_FMT_NONE;
+  m_last_dst_fmt = AV_SAMPLE_FMT_NONE;
+  m_last_src_channels = 0;
+  m_last_dst_channels = 0;
+}
+
+CActiveAEResample::~CActiveAEResample()
+{
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+  DeInit();
+}
+
+void CActiveAEResample::DeInit()
+{
+  CLog::Log(LOGDEBUG, "%s:%s", CLASSNAME, __func__);
+  if (m_Initialized)
+  {
+    m_omx_mixer.FlushAll();
+    m_omx_mixer.Deinitialize();
+    m_Initialized = false;
+  }
+}
+
+bool CActiveAEResample::Init(uint64_t dst_chan_layout, int dst_channels, int dst_rate, AVSampleFormat dst_fmt, int dst_bits, int dst_dither, uint64_t src_chan_layout, int src_channels, int src_rate, AVSampleFormat src_fmt, int src_bits, int src_dither, bool upmix, bool normalize, CAEChannelInfo *remapLayout, AEQuality quality)
+{
+  LOGTIMEINIT("x");
+
+  CLog::Log(LOGINFO, "%s::%s remap:%p chan:%d->%d rate:%d->%d format:%d->%d bits:%d->%d norm:%d upmix:%d", CLASSNAME, __func__, remapLayout, src_channels, dst_channels, src_rate, dst_rate, src_fmt, dst_fmt, src_bits, dst_bits, normalize, upmix);
+
+  if (src_bits == 0)
+  {
+    if (src_fmt == AV_SAMPLE_FMT_U8) src_bits = 8;
+    else if (src_fmt == AV_SAMPLE_FMT_S16) src_bits = 16;
+    else if (src_fmt == AV_SAMPLE_FMT_S32) src_bits = 32;
+    else if (src_fmt == AV_SAMPLE_FMT_FLT) src_bits = 32;
+  }
+  assert(src_bits && dst_bits);
+
+  m_dst_chan_layout = dst_chan_layout;
+  m_dst_channels = dst_channels;
+  m_dst_rate = dst_rate;
+  m_dst_fmt = dst_fmt;
+  m_dst_bits = dst_bits;
+  m_src_chan_layout = src_chan_layout;
+  m_src_channels = src_channels;
+  m_src_rate = src_rate;
+  m_src_fmt = src_fmt;
+  m_src_bits = src_bits;
+
+  if (m_dst_chan_layout == 0)
+    m_dst_chan_layout = av_get_default_channel_layout(m_dst_channels);
+  if (m_src_chan_layout == 0)
+    m_src_chan_layout = av_get_default_channel_layout(m_src_channels);
+
+  OMX_CONFIG_BRCMAUDIODOWNMIXCOEFFICIENTS8x8 mix;
+  OMX_INIT_STRUCTURE(mix);
+
+  assert(sizeof(mix.coeff)/sizeof(mix.coeff[0]) == 64);
+
+  LOGTIME(1);
+// this code is just uses ffmpeg to produce the 8x8 mixing matrix
+{
+  // dummy sample rate and format, as we only care about channel mapping
+  SwrContext *m_pContext = swr_alloc_set_opts(NULL, m_dst_chan_layout, AV_SAMPLE_FMT_FLT, 48000,
+                                                        m_src_chan_layout, AV_SAMPLE_FMT_FLT, 48000, 0, NULL);
+  if (!m_pContext)
+  {
+    CLog::Log(LOGERROR, "CActiveAEResample::Init - create context failed");
+    return false;
+  }
+  // tell resampler to clamp float values
+  // not required for sink stage (remapLayout == true)
+  if (!remapLayout && normalize)
+  {
+     av_opt_set_double(m_pContext, "rematrix_maxval", 1.0, 0);
+  }
+
+  if (remapLayout)
+  {
+    // one-to-one mapping of channels
+    // remapLayout is the layout of the sink, if the channel is in our src layout
+    // the channel is mapped by setting coef 1.0
+    double m_rematrix[AE_CH_MAX][AE_CH_MAX];
+    memset(m_rematrix, 0, sizeof(m_rematrix));
+    m_dst_chan_layout = 0;
+    for (unsigned int out=0; out<remapLayout->Count(); out++)
+    {
+      m_dst_chan_layout += (uint64_t) (1 << out);
+      int idx = GetAVChannelIndex((*remapLayout)[out], m_src_chan_layout);
+      if (idx >= 0)
+      {
+        m_rematrix[out][idx] = 1.0;
+      }
+    }
+
+    av_opt_set_int(m_pContext, "out_channel_count", m_dst_channels, 0);
+    av_opt_set_int(m_pContext, "out_channel_layout", m_dst_chan_layout, 0);
+
+    if (swr_set_matrix(m_pContext, (const double*)m_rematrix, AE_CH_MAX) < 0)
+    {
+      CLog::Log(LOGERROR, "CActiveAEResample::Init - setting channel matrix failed");
+      return false;
+    }
+  }
+  // stereo upmix
+  else if (upmix && m_src_channels == 2 && m_dst_channels > 2)
+  {
+    double m_rematrix[AE_CH_MAX][AE_CH_MAX];
+    memset(m_rematrix, 0, sizeof(m_rematrix));
+    for (int out=0; out<m_dst_channels; out++)
+    {
+      uint64_t out_chan = av_channel_layout_extract_channel(m_dst_chan_layout, out);
+      switch(out_chan)
+      {
+        case AV_CH_FRONT_LEFT:
+        case AV_CH_BACK_LEFT:
+        case AV_CH_SIDE_LEFT:
+          m_rematrix[out][0] = 1.0;
+          break;
+        case AV_CH_FRONT_RIGHT:
+        case AV_CH_BACK_RIGHT:
+        case AV_CH_SIDE_RIGHT:
+          m_rematrix[out][1] = 1.0;
+          break;
+        case AV_CH_FRONT_CENTER:
+          m_rematrix[out][0] = 0.5;
+          m_rematrix[out][1] = 0.5;
+          break;
+        case AV_CH_LOW_FREQUENCY:
+          m_rematrix[out][0] = 0.5;
+          m_rematrix[out][1] = 0.5;
+          break;
+        default:
+          break;
+      }
+    }
+
+    if (swr_set_matrix(m_pContext, (const double*)m_rematrix, AE_CH_MAX) < 0)
+    {
+      CLog::Log(LOGERROR, "CActiveAEResample::Init - setting channel matrix failed");
+      return false;
+    }
+  }
+
+  if (swr_init(m_pContext) < 0)
+  {
+    CLog::Log(LOGERROR, "CActiveAEResample::Init - init resampler failed");
+    return false;
+  }
+
+  const int samples = 8;
+  uint8_t *output, *input;
+  av_samples_alloc(&output, NULL, m_dst_channels, samples, AV_SAMPLE_FMT_FLT, 1);
+  av_samples_alloc(&input , NULL, m_src_channels, samples, AV_SAMPLE_FMT_FLT, 1);
+
+  // Produce "identity" samples
+  float *f = (float *)input;
+  for (int j=0; j < samples; j++)
+    for (int i=0; i < m_src_channels; i++)
+      *f++ = i == j ? 1.0f : 0.0f;
+
+  int ret = swr_convert(m_pContext, &output, samples, (const uint8_t **)&input, samples);
+  if (ret < 0)
+    CLog::Log(LOGERROR, "CActiveAEResample::Resample - resample failed");
+
+  f = (float *)output;
+  for (int j=0; j < samples; j++)
+    for (int i=0; i < m_dst_channels; i++)
+      mix.coeff[8*i+j] = *f++ * (1<<16);
+
+  for (int j=0; j < 8; j++)
+  {
+    char s[128] = {}, *t=s;
+    for (int i=0; i < 8; i++)
+      t += sprintf(t, "% 6.2f ", mix.coeff[j*8+i] * (1.0/0x10000));
+    CLog::Log(LOGINFO, "%s::%s  %s", CLASSNAME, __func__, s);
+  }
+  av_freep(&input);
+  av_freep(&output);
+  swr_free(&m_pContext);
+}
+  LOGTIME(2);
+
+  // This may be called before Application calls g_RBP.Initialise, so call it here too
+  g_RBP.Initialize();
+
+  OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
+
+  if (!m_omx_mixer.Initialize("OMX.broadcom.audio_mixer", OMX_IndexParamAudioInit))
+    CLog::Log(LOGERROR, "%s::%s - m_omx_mixer.Initialize omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  LOGTIME(3);
+
+  OMX_INIT_STRUCTURE(m_pcm_input);
+  m_pcm_input.nPortIndex            = m_omx_mixer.GetInputPort();
+  m_pcm_input.eNumData              = OMX_NumericalDataSigned;
+  m_pcm_input.eEndian               = OMX_EndianLittle;
+  m_pcm_input.bInterleaved          = OMX_TRUE;
+  m_pcm_input.nBitPerSample         = m_src_bits;
+  m_pcm_input.ePCMMode              = m_src_fmt == AV_SAMPLE_FMT_FLT ? (OMX_AUDIO_PCMMODETYPE)0x8000 : OMX_AUDIO_PCMModeLinear;
+  m_pcm_input.nChannels             = src_channels;
+  m_pcm_input.nSamplingRate         = src_rate;
+
+  omx_err = m_omx_mixer.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_input);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s::%s - error m_omx_mixer in SetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  OMX_INIT_STRUCTURE(m_pcm_output);
+  m_pcm_output.nPortIndex            = m_omx_mixer.GetOutputPort();
+  m_pcm_output.eNumData              = OMX_NumericalDataSigned;
+  m_pcm_output.eEndian               = OMX_EndianLittle;
+  m_pcm_output.bInterleaved          = OMX_TRUE;
+  m_pcm_output.nBitPerSample         = m_dst_bits;
+  m_pcm_output.ePCMMode              = m_dst_fmt == AV_SAMPLE_FMT_FLT ? (OMX_AUDIO_PCMMODETYPE)0x8000 : OMX_AUDIO_PCMModeLinear;
+  m_pcm_output.nChannels             = dst_channels;
+  m_pcm_output.nSamplingRate         = dst_rate;
+
+  omx_err = m_omx_mixer.SetParameter(OMX_IndexParamAudioPcm, &m_pcm_output);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s::%s - error m_omx_mixer out SetParameter omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  LOGTIME(4);
+
+  mix.nPortIndex = m_omx_mixer.GetInputPort();
+  omx_err = m_omx_mixer.SetConfig(OMX_IndexConfigBrcmAudioDownmixCoefficients8x8, &mix);
+  if (omx_err != OMX_ErrorNone)
+  {
+    CLog::Log(LOGERROR, "%s::%s - error setting mixer OMX_IndexConfigBrcmAudioDownmixCoefficients, error 0x%08x\n",
+              CLASSNAME, __func__, omx_err);
+    return false;
+  }
+
+  // set up the number/size of buffers for decoder input
+  OMX_PARAM_PORTDEFINITIONTYPE port_param;
+  OMX_INIT_STRUCTURE(port_param);
+  port_param.nPortIndex = m_omx_mixer.GetInputPort();
+
+  omx_err = m_omx_mixer.GetParameter(OMX_IndexParamPortDefinition, &port_param);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - error get OMX_IndexParamPortDefinition (input) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  port_param.nBufferCountActual = std::max((unsigned int)port_param.nBufferCountMin, (unsigned int)1);
+  port_param.nBufferSize = BUFFERSIZE;
+
+  omx_err = m_omx_mixer.SetParameter(OMX_IndexParamPortDefinition, &port_param);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - error set OMX_IndexParamPortDefinition (input) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  LOGTIME(5);
+
+  omx_err = m_omx_mixer.AllocInputBuffers();
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - Error alloc buffers 0x%08x", CLASSNAME, __func__, omx_err);
+
+  LOGTIME(6);
+
+  // set up the number/size of buffers for decoder output
+  OMX_INIT_STRUCTURE(port_param);
+  port_param.nPortIndex = m_omx_mixer.GetOutputPort();
+
+  omx_err = m_omx_mixer.GetParameter(OMX_IndexParamPortDefinition, &port_param);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - error get OMX_IndexParamPortDefinition (input) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  port_param.nBufferCountActual = std::max((unsigned int)port_param.nBufferCountMin, (unsigned int)1);
+  port_param.nBufferSize = BUFFERSIZE;
+
+  omx_err = m_omx_mixer.SetParameter(OMX_IndexParamPortDefinition, &port_param);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - error set OMX_IndexParamPortDefinition (input) omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  LOGTIME(7);
+
+  omx_err = m_omx_mixer.AllocOutputBuffers();
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - Error alloc buffers 0x%08x", CLASSNAME, __func__, omx_err);
+
+  LOGTIME(8);
+
+  omx_err = m_omx_mixer.SetStateForComponent(OMX_StateExecuting);
+  if (omx_err != OMX_ErrorNone)
+    CLog::Log(LOGERROR, "%s:%s - m_omx_mixer OMX_StateExecuting omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+
+  LOGTIME(9);
+
+  m_Initialized = true;
+
+  return true;
+}
+
+int CActiveAEResample::Resample(uint8_t **dst_buffer, int dst_samples, uint8_t **src_buffer, int src_samples, double ratio)
+{
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s samples:%d->%d (%.2f)", CLASSNAME, __func__, src_samples, dst_samples, ratio);
+  #endif
+  if (!m_Initialized)
+    return 0;
+  OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
+
+  const int s_pitch = m_pcm_input.nChannels * m_src_bits >> 3;
+  const int d_pitch = m_pcm_output.nChannels * m_dst_bits >> 3;
+  int sent = 0;
+  int received = 0;
+  while (sent < src_samples)
+  {
+    OMX_BUFFERHEADERTYPE *omx_buffer = NULL;
+    OMX_BUFFERHEADERTYPE *m_encoded_buffer = NULL;
+
+    omx_buffer = m_omx_mixer.GetInputBuffer(1000);
+    if (omx_buffer == NULL)
+      return false;
+
+    const int max_src_samples = BUFFERSIZE / s_pitch;
+    const int max_dst_samples = (long long)(BUFFERSIZE/d_pitch) * m_src_rate / (m_dst_rate + m_src_rate-1);
+    int send = std::min(std::min(max_dst_samples, max_src_samples), src_samples - sent);
+
+    omx_buffer->nOffset = 0;
+    omx_buffer->nFlags = OMX_BUFFERFLAG_EOS;
+    omx_buffer->nFilledLen = send * s_pitch;
+
+    assert(omx_buffer->nFilledLen > 0 && omx_buffer->nFilledLen <= omx_buffer->nAllocLen);
+
+    if (omx_buffer->nFilledLen)
+    {
+      memcpy(omx_buffer->pBuffer, src_buffer[0] + sent * s_pitch, omx_buffer->nFilledLen);
+      sent += send;
+    }
+
+    omx_err = m_omx_mixer.EmptyThisBuffer(omx_buffer);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s OMX_EmptyThisBuffer() failed with result(0x%x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+
+    m_encoded_buffer = m_omx_mixer.GetOutputBuffer();
+
+    if (!m_encoded_buffer)
+    {
+      CLog::Log(LOGERROR, "%s::%s no output buffer", CLASSNAME, __func__);
+      return false;
+    }
+
+    omx_err = m_omx_mixer.FillThisBuffer(m_encoded_buffer);
+    if (omx_err != OMX_ErrorNone)
+      return false;
+
+    omx_err = m_omx_mixer.WaitForOutputDone(1000);
+    if (omx_err != OMX_ErrorNone)
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_mixer.WaitForOutputDone result(0x%x)", CLASSNAME, __func__, omx_err);
+      return false;
+    }
+    assert(m_encoded_buffer->nFilledLen > 0 && m_encoded_buffer->nFilledLen <= m_encoded_buffer->nAllocLen);
+
+    if (m_omx_mixer.BadState())
+    {
+      CLog::Log(LOGERROR, "%s::%s m_omx_mixer.BadState", CLASSNAME, __func__);
+      return false;
+    }
+
+    if (m_encoded_buffer->nFilledLen)
+    {
+      memcpy(dst_buffer[0] + received * d_pitch, m_encoded_buffer->pBuffer, m_encoded_buffer->nFilledLen);
+      received += m_encoded_buffer->nFilledLen / d_pitch;
+    }
+  }
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s format:%d->%d rate:%d->%d chan:%d->%d samples %d->%d (%f) %d =%d", CLASSNAME, __func__,
+    (int)m_src_fmt, (int)m_dst_fmt, m_src_rate, m_dst_rate, m_src_channels, m_dst_channels, src_samples, dst_samples, ratio, m_Initialized, received);
+  #endif
+  return received;
+}
+
+int64_t CActiveAEResample::GetDelay(int64_t base)
+{
+  int ret = 0;
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s = %d", CLASSNAME, __func__, ret);
+  #endif
+  return ret;
+}
+
+int CActiveAEResample::GetBufferedSamples()
+{
+  int ret = 0;
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s = %d", CLASSNAME, __func__, ret);
+  #endif
+  return ret;
+}
+
+int CActiveAEResample::CalcDstSampleCount(int src_samples, int dst_rate, int src_rate)
+{
+  int ret = ((long long)src_samples * dst_rate + src_rate-1) / src_rate;
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s = %d", CLASSNAME, __func__, ret);
+  #endif
+  return ret;
+}
+
+int CActiveAEResample::GetSrcBufferSize(int samples)
+{
+  int ret = 0;
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s = %d", CLASSNAME, __func__, ret);
+  #endif
+  return ret;
+}
+
+int CActiveAEResample::GetDstBufferSize(int samples)
+{
+  int ret = CalcDstSampleCount(samples, m_dst_rate, m_src_rate);
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s = %d", CLASSNAME, __func__, ret);
+  #endif
+  return ret;
+}
+
+uint64_t CActiveAEResample::GetAVChannelLayout(CAEChannelInfo &info)
+{
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+  #endif
+  uint64_t channelLayout = 0;
+  if (info.HasChannel(AE_CH_FL))   channelLayout |= AV_CH_FRONT_LEFT;
+  if (info.HasChannel(AE_CH_FR))   channelLayout |= AV_CH_FRONT_RIGHT;
+  if (info.HasChannel(AE_CH_FC))   channelLayout |= AV_CH_FRONT_CENTER;
+  if (info.HasChannel(AE_CH_LFE))  channelLayout |= AV_CH_LOW_FREQUENCY;
+  if (info.HasChannel(AE_CH_BL))   channelLayout |= AV_CH_BACK_LEFT;
+  if (info.HasChannel(AE_CH_BR))   channelLayout |= AV_CH_BACK_RIGHT;
+  if (info.HasChannel(AE_CH_FLOC)) channelLayout |= AV_CH_FRONT_LEFT_OF_CENTER;
+  if (info.HasChannel(AE_CH_FROC)) channelLayout |= AV_CH_FRONT_RIGHT_OF_CENTER;
+  if (info.HasChannel(AE_CH_BC))   channelLayout |= AV_CH_BACK_CENTER;
+  if (info.HasChannel(AE_CH_SL))   channelLayout |= AV_CH_SIDE_LEFT;
+  if (info.HasChannel(AE_CH_SR))   channelLayout |= AV_CH_SIDE_RIGHT;
+  if (info.HasChannel(AE_CH_TC))   channelLayout |= AV_CH_TOP_CENTER;
+  if (info.HasChannel(AE_CH_TFL))  channelLayout |= AV_CH_TOP_FRONT_LEFT;
+  if (info.HasChannel(AE_CH_TFC))  channelLayout |= AV_CH_TOP_FRONT_CENTER;
+  if (info.HasChannel(AE_CH_TFR))  channelLayout |= AV_CH_TOP_FRONT_RIGHT;
+  if (info.HasChannel(AE_CH_TBL))   channelLayout |= AV_CH_TOP_BACK_LEFT;
+  if (info.HasChannel(AE_CH_TBC))   channelLayout |= AV_CH_TOP_BACK_CENTER;
+  if (info.HasChannel(AE_CH_TBR))   channelLayout |= AV_CH_TOP_BACK_RIGHT;
+
+  return channelLayout;
+}
+
+AVSampleFormat CActiveAEResample::GetAVSampleFormat(AEDataFormat format)
+{
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+  #endif
+  if      (format == AE_FMT_U8)     return AV_SAMPLE_FMT_U8;
+  else if (format == AE_FMT_S16NE)  return AV_SAMPLE_FMT_S16;
+  else if (format == AE_FMT_S32NE)  return AV_SAMPLE_FMT_S32;
+  else if (format == AE_FMT_S24NE4) return AV_SAMPLE_FMT_S32;
+  else if (format == AE_FMT_FLOAT)  return AV_SAMPLE_FMT_FLT;
+  else if (format == AE_FMT_DOUBLE) return AV_SAMPLE_FMT_DBL;
+
+  else if (format == AE_FMT_U8P)     return AV_SAMPLE_FMT_U8P;
+  else if (format == AE_FMT_S16NEP)  return AV_SAMPLE_FMT_S16P;
+  else if (format == AE_FMT_S32NEP)  return AV_SAMPLE_FMT_S32P;
+  else if (format == AE_FMT_S24NE4P) return AV_SAMPLE_FMT_S32P;
+  else if (format == AE_FMT_FLOATP)  return AV_SAMPLE_FMT_FLTP;
+  else if (format == AE_FMT_DOUBLEP) return AV_SAMPLE_FMT_DBLP;
+
+  if (AE_IS_PLANAR(format))
+    return AV_SAMPLE_FMT_FLTP;
+  else
+    return AV_SAMPLE_FMT_FLT;
+}
+
+AEDataFormat CActiveAEResample::GetAESampleFormat(AVSampleFormat format, int bits)
+{
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+  #endif
+  if      (format == AV_SAMPLE_FMT_U8)   return AE_FMT_U8;
+  else if (format == AV_SAMPLE_FMT_S16)  return AE_FMT_S16NE;
+  else if (format == AV_SAMPLE_FMT_S32 && bits == 32)  return AE_FMT_S32NE;
+  else if (format == AV_SAMPLE_FMT_S32 && bits == 24)  return AE_FMT_S24NE4;
+  else if (format == AV_SAMPLE_FMT_FLT)  return AE_FMT_FLOAT;
+  else if (format == AV_SAMPLE_FMT_DBL)  return AE_FMT_DOUBLE;
+
+  else if (format == AV_SAMPLE_FMT_U8P)   return AE_FMT_U8P;
+  else if (format == AV_SAMPLE_FMT_S16P)  return AE_FMT_S16NEP;
+  else if (format == AV_SAMPLE_FMT_S32P && bits == 32)  return AE_FMT_S32NEP;
+  else if (format == AV_SAMPLE_FMT_S32P && bits == 24)  return AE_FMT_S24NE4P;
+  else if (format == AV_SAMPLE_FMT_FLTP)  return AE_FMT_FLOATP;
+  else if (format == AV_SAMPLE_FMT_DBLP)  return AE_FMT_DOUBLEP;
+
+  CLog::Log(LOGERROR, "CActiveAEResample::GetAESampleFormat - format not supported");
+  return AE_FMT_INVALID;
+}
+
+uint64_t CActiveAEResample::GetAVChannel(enum AEChannel aechannel)
+{
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+  #endif
+  switch (aechannel)
+  {
+  case AE_CH_FL:   return AV_CH_FRONT_LEFT;
+  case AE_CH_FR:   return AV_CH_FRONT_RIGHT;
+  case AE_CH_FC:   return AV_CH_FRONT_CENTER;
+  case AE_CH_LFE:  return AV_CH_LOW_FREQUENCY;
+  case AE_CH_BL:   return AV_CH_BACK_LEFT;
+  case AE_CH_BR:   return AV_CH_BACK_RIGHT;
+  case AE_CH_FLOC: return AV_CH_FRONT_LEFT_OF_CENTER;
+  case AE_CH_FROC: return AV_CH_FRONT_RIGHT_OF_CENTER;
+  case AE_CH_BC:   return AV_CH_BACK_CENTER;
+  case AE_CH_SL:   return AV_CH_SIDE_LEFT;
+  case AE_CH_SR:   return AV_CH_SIDE_RIGHT;
+  case AE_CH_TC:   return AV_CH_TOP_CENTER;
+  case AE_CH_TFL:  return AV_CH_TOP_FRONT_LEFT;
+  case AE_CH_TFC:  return AV_CH_TOP_FRONT_CENTER;
+  case AE_CH_TFR:  return AV_CH_TOP_FRONT_RIGHT;
+  case AE_CH_TBL:  return AV_CH_TOP_BACK_LEFT;
+  case AE_CH_TBC:  return AV_CH_TOP_BACK_CENTER;
+  case AE_CH_TBR:  return AV_CH_TOP_BACK_RIGHT;
+  default:
+    return 0;
+  }
+}
+
+int CActiveAEResample::GetAVChannelIndex(enum AEChannel aechannel, uint64_t layout)
+{
+  #ifdef DEBUG_VERBOSE
+  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
+  #endif
+  return av_get_channel_layout_channel_index(layout, GetAVChannel(aechannel));
+}
+
+#endif
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.h
new file mode 100644
index 0000000..47a9e08
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.h
@@ -0,0 +1,62 @@
+#pragma once
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "linux/OMXCore.h"
+
+namespace ActiveAE
+{
+
+class CActiveAEResample
+{
+public:
+  CActiveAEResample();
+  virtual ~CActiveAEResample();
+  bool Init(uint64_t dst_chan_layout, int dst_channels, int dst_rate, AVSampleFormat dst_fmt, int dst_bits, int dst_dither, uint64_t src_chan_layout, int src_channels, int src_rate, AVSampleFormat src_fmt, int src_bits, int src_dither, bool upmix, bool normalize, CAEChannelInfo *remapLayout, AEQuality quality);
+  int Resample(uint8_t **dst_buffer, int dst_samples, uint8_t **src_buffer, int src_samples, double ratio);
+  int64_t GetDelay(int64_t base);
+  int GetBufferedSamples();
+  int CalcDstSampleCount(int src_samples, int dst_rate, int src_rate);
+  int GetSrcBufferSize(int samples);
+  int GetDstBufferSize(int samples);
+  static uint64_t GetAVChannelLayout(CAEChannelInfo &info);
+//  static CAEChannelInfo GetAEChannelLayout(uint64_t layout);
+  static AVSampleFormat GetAVSampleFormat(AEDataFormat format);
+  static AEDataFormat GetAESampleFormat(AVSampleFormat format, int bits);
+  static uint64_t GetAVChannel(enum AEChannel aechannel);
+  int GetAVChannelIndex(enum AEChannel aechannel, uint64_t layout);
+
+protected:
+  void DeInit();
+  uint64_t m_src_chan_layout, m_dst_chan_layout;
+  int m_src_rate, m_dst_rate;
+  int m_src_channels, m_dst_channels;
+  AVSampleFormat m_src_fmt, m_dst_fmt;
+  int m_src_bits, m_dst_bits;
+
+  OMX_AUDIO_PARAM_PCMMODETYPE m_pcm_input;
+  OMX_AUDIO_PARAM_PCMMODETYPE m_pcm_output;
+  COMXCoreComponent    m_omx_mixer;
+  bool                 m_Initialized;
+  AVSampleFormat m_last_src_fmt, m_last_dst_fmt;
+  int m_last_src_channels, m_last_dst_channels;
+};
+
+}
diff --git a/xbmc/cores/AudioEngine/Makefile.in b/xbmc/cores/AudioEngine/Makefile.in
index 581249e..20c05bb 100644
--- a/xbmc/cores/AudioEngine/Makefile.in
+++ b/xbmc/cores/AudioEngine/Makefile.in
@@ -31,6 +31,7 @@ SRCS += Engines/ActiveAE/ActiveAESink.cpp
 SRCS += Engines/ActiveAE/ActiveAEStream.cpp
 SRCS += Engines/ActiveAE/ActiveAESound.cpp
 SRCS += Engines/ActiveAE/ActiveAEResample.cpp
+SRCS += Engines/ActiveAE/ActiveAEResamplePi.cpp
 SRCS += Engines/ActiveAE/ActiveAEBuffer.cpp
 
 ifeq (@USE_ANDROID@,1)
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
index 5a45653..2733054 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
@@ -78,9 +78,9 @@ static void SetAudioProps(bool stream_channels, uint32_t channel_map)
   CLog::Log(LOGDEBUG, "%s:%s hdmi_stream_channels %d hdmi_channel_map %08x", CLASSNAME, __func__, stream_channels, channel_map);
 }
 
-static uint32_t GetChannelMap(AEAudioFormat &format, bool passthrough)
+static uint32_t GetChannelMap(const CAEChannelInfo &channelLayout, bool passthrough)
 {
-  unsigned int channels = format.m_channelLayout.Count();
+  unsigned int channels = channelLayout.Count();
   uint32_t channel_map = 0;
   if (passthrough)
     return 0;
@@ -119,12 +119,12 @@ static uint32_t GetChannelMap(AEAudioFormat &format, bool passthrough)
   // According to CEA-861-D only RL and RR are known. In case of a format having SL and SR channels
   // but no BR BL channels, we use the wide map in order to open only the num of channels really
   // needed.
-  if (format.m_channelLayout.HasChannel(AE_CH_BL) && !format.m_channelLayout.HasChannel(AE_CH_SL))
+  if (channelLayout.HasChannel(AE_CH_BL) && !channelLayout.HasChannel(AE_CH_SL))
     map = map_back;
 
   for (unsigned int i = 0; i < channels; ++i)
   {
-    AEChannel c = format.m_channelLayout[i];
+    AEChannel c = channelLayout[i];
     unsigned int chan = 0;
     if ((unsigned int)c < sizeof map_normal / sizeof *map_normal)
       chan = map[(unsigned int)c];
@@ -155,9 +155,9 @@ static uint32_t GetChannelMap(AEAudioFormat &format, bool passthrough)
     0xff, // 7
     0x13, // 7.1
   };
-  uint8_t cea = format.m_channelLayout.HasChannel(AE_CH_LFE) ? cea_map_lfe[channels] : cea_map[channels];
+  uint8_t cea = channelLayout.HasChannel(AE_CH_LFE) ? cea_map_lfe[channels] : cea_map[channels];
   if (cea == 0xff)
-    CLog::Log(LOGERROR, "%s::%s - Unexpected CEA mapping %d,%d", CLASSNAME, __func__, format.m_channelLayout.HasChannel(AE_CH_LFE), channels);
+    CLog::Log(LOGERROR, "%s::%s - Unexpected CEA mapping %d,%d", CLASSNAME, __func__, channelLayout.HasChannel(AE_CH_LFE), channels);
 
   channel_map |= cea << 24;
 
@@ -191,7 +191,7 @@ bool CAESinkPi::Initialize(AEAudioFormat &format, std::string &device)
   format.m_frames        = format.m_sampleRate * AUDIO_PLAYBUFFER / NUM_OMX_BUFFERS;
   format.m_frameSamples  = format.m_frames * channels;
 
-  SetAudioProps(m_passthrough, GetChannelMap(format, m_passthrough));
+  SetAudioProps(m_passthrough, GetChannelMap(format.m_channelLayout, m_passthrough));
 
   m_format = format;
   m_sinkbuffer_sec_per_byte = 1.0 / (double)(m_format.m_frameSize * m_format.m_sampleRate);
diff --git a/xbmc/linux/OMXCore.cpp b/xbmc/linux/OMXCore.cpp
index 99e407a..8d3c86a 100644
--- a/xbmc/linux/OMXCore.cpp
+++ b/xbmc/linux/OMXCore.cpp
@@ -448,7 +448,7 @@ void COMXCoreComponent::FlushAll()
 
 void COMXCoreComponent::FlushInput()
 {
-  if(!m_handle)
+  if(!m_handle || m_resource_error)
     return;
 
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
@@ -470,7 +470,7 @@ void COMXCoreComponent::FlushInput()
 
 void COMXCoreComponent::FlushOutput()
 {
-  if(!m_handle)
+  if(!m_handle || m_resource_error)
     return;
 
   OMX_ERRORTYPE omx_err = OMX_ErrorNone;
-- 
1.9.3


From 566bb44404b43245776fa0c97f6d4036dddb3ab4 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 1 Jun 2014 12:15:17 +0100
Subject: [PATCH 68/99] [resamplepi] Support planar formats

---
 .../Engines/ActiveAE/ActiveAEResamplePi.cpp        | 101 ++++++++++++---------
 1 file changed, 59 insertions(+), 42 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
index 9a1e549..1604030 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
@@ -88,20 +88,36 @@ void CActiveAEResample::DeInit()
   }
 }
 
+static int format_to_bits(AVSampleFormat fmt)
+{
+  switch (fmt)
+  {
+  case AV_SAMPLE_FMT_U8:
+  case AV_SAMPLE_FMT_U8P:
+    return 8;
+  case AV_SAMPLE_FMT_S16:
+  case AV_SAMPLE_FMT_S16P:
+    return 16;
+  case AV_SAMPLE_FMT_S32:
+  case AV_SAMPLE_FMT_S32P:
+  case AV_SAMPLE_FMT_FLT:
+  case AV_SAMPLE_FMT_FLTP:
+    return 32;
+  default:
+    assert(0);
+  }
+  return 0;
+}
+
 bool CActiveAEResample::Init(uint64_t dst_chan_layout, int dst_channels, int dst_rate, AVSampleFormat dst_fmt, int dst_bits, int dst_dither, uint64_t src_chan_layout, int src_channels, int src_rate, AVSampleFormat src_fmt, int src_bits, int src_dither, bool upmix, bool normalize, CAEChannelInfo *remapLayout, AEQuality quality)
 {
   LOGTIMEINIT("x");
 
   CLog::Log(LOGINFO, "%s::%s remap:%p chan:%d->%d rate:%d->%d format:%d->%d bits:%d->%d norm:%d upmix:%d", CLASSNAME, __func__, remapLayout, src_channels, dst_channels, src_rate, dst_rate, src_fmt, dst_fmt, src_bits, dst_bits, normalize, upmix);
 
-  if (src_bits == 0)
-  {
-    if (src_fmt == AV_SAMPLE_FMT_U8) src_bits = 8;
-    else if (src_fmt == AV_SAMPLE_FMT_S16) src_bits = 16;
-    else if (src_fmt == AV_SAMPLE_FMT_S32) src_bits = 32;
-    else if (src_fmt == AV_SAMPLE_FMT_FLT) src_bits = 32;
-  }
-  assert(src_bits && dst_bits);
+  // replace passed in number of bits with correct ones
+  src_bits = format_to_bits(src_fmt);
+  dst_bits = format_to_bits(dst_fmt);
 
   m_dst_chan_layout = dst_chan_layout;
   m_dst_channels = dst_channels;
@@ -139,7 +155,7 @@ bool CActiveAEResample::Init(uint64_t dst_chan_layout, int dst_channels, int dst
   // not required for sink stage (remapLayout == true)
   if (!remapLayout && normalize)
   {
-     av_opt_set_double(m_pContext, "rematrix_maxval", 1.0, 0);
+    av_opt_set_double(m_pContext, "rematrix_maxval", 1.0, 0);
   }
 
   if (remapLayout)
@@ -264,7 +280,13 @@ bool CActiveAEResample::Init(uint64_t dst_chan_layout, int dst_channels, int dst
   m_pcm_input.eEndian               = OMX_EndianLittle;
   m_pcm_input.bInterleaved          = OMX_TRUE;
   m_pcm_input.nBitPerSample         = m_src_bits;
-  m_pcm_input.ePCMMode              = m_src_fmt == AV_SAMPLE_FMT_FLT ? (OMX_AUDIO_PCMMODETYPE)0x8000 : OMX_AUDIO_PCMModeLinear;
+  // 0x8000 = float, 0x10000 = planar
+  uint32_t flags = 0;
+  if (m_src_fmt == AV_SAMPLE_FMT_FLT || m_src_fmt == AV_SAMPLE_FMT_FLTP)
+   flags |= 0x8000;
+  if (m_src_fmt >= AV_SAMPLE_FMT_U8P)
+   flags |= 0x10000;
+  m_pcm_input.ePCMMode              = flags == 0 ? OMX_AUDIO_PCMModeLinear : (OMX_AUDIO_PCMMODETYPE)flags;
   m_pcm_input.nChannels             = src_channels;
   m_pcm_input.nSamplingRate         = src_rate;
 
@@ -278,7 +300,12 @@ bool CActiveAEResample::Init(uint64_t dst_chan_layout, int dst_channels, int dst
   m_pcm_output.eEndian               = OMX_EndianLittle;
   m_pcm_output.bInterleaved          = OMX_TRUE;
   m_pcm_output.nBitPerSample         = m_dst_bits;
-  m_pcm_output.ePCMMode              = m_dst_fmt == AV_SAMPLE_FMT_FLT ? (OMX_AUDIO_PCMMODETYPE)0x8000 : OMX_AUDIO_PCMModeLinear;
+  flags = 0;
+  if (m_dst_fmt == AV_SAMPLE_FMT_FLT || m_dst_fmt == AV_SAMPLE_FMT_FLTP)
+   flags |= 0x8000;
+  if (m_dst_fmt >= AV_SAMPLE_FMT_U8P)
+   flags |= 0x10000;
+  m_pcm_output.ePCMMode              = flags == 0 ? OMX_AUDIO_PCMModeLinear : (OMX_AUDIO_PCMMODETYPE)flags;
   m_pcm_output.nChannels             = dst_channels;
   m_pcm_output.nSamplingRate         = dst_rate;
 
@@ -364,8 +391,13 @@ int CActiveAEResample::Resample(uint8_t **dst_buffer, int dst_samples, uint8_t *
     return 0;
   OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
 
-  const int s_pitch = m_pcm_input.nChannels * m_src_bits >> 3;
-  const int d_pitch = m_pcm_output.nChannels * m_dst_bits >> 3;
+  const int s_planes = m_src_fmt >= AV_SAMPLE_FMT_U8P ? m_src_channels : 1;
+  const int d_planes = m_dst_fmt >= AV_SAMPLE_FMT_U8P ? m_dst_channels : 1;
+  const int s_chans  = m_src_fmt >= AV_SAMPLE_FMT_U8P ? 1 : m_src_channels;
+  const int d_chans  = m_dst_fmt >= AV_SAMPLE_FMT_U8P ? 1 : m_dst_channels;
+  const int s_pitch = s_chans * m_src_bits >> 3;
+  const int d_pitch = d_chans * m_dst_bits >> 3;
+
   int sent = 0;
   int received = 0;
   while (sent < src_samples)
@@ -377,19 +409,23 @@ int CActiveAEResample::Resample(uint8_t **dst_buffer, int dst_samples, uint8_t *
     if (omx_buffer == NULL)
       return false;
 
-    const int max_src_samples = BUFFERSIZE / s_pitch;
-    const int max_dst_samples = (long long)(BUFFERSIZE/d_pitch) * m_src_rate / (m_dst_rate + m_src_rate-1);
+    const int s_samplesize = m_src_channels * m_src_bits >> 3;
+    const int d_samplesize = m_dst_channels * m_dst_bits >> 3;
+    const int max_src_samples = BUFFERSIZE / s_samplesize;
+    const int max_dst_samples = (long long)(BUFFERSIZE / d_samplesize) * m_src_rate / (m_dst_rate + m_src_rate-1);
     int send = std::min(std::min(max_dst_samples, max_src_samples), src_samples - sent);
 
     omx_buffer->nOffset = 0;
     omx_buffer->nFlags = OMX_BUFFERFLAG_EOS;
-    omx_buffer->nFilledLen = send * s_pitch;
+    omx_buffer->nFilledLen = send * s_samplesize;
 
     assert(omx_buffer->nFilledLen > 0 && omx_buffer->nFilledLen <= omx_buffer->nAllocLen);
 
     if (omx_buffer->nFilledLen)
     {
-      memcpy(omx_buffer->pBuffer, src_buffer[0] + sent * s_pitch, omx_buffer->nFilledLen);
+      int planesize = omx_buffer->nFilledLen / s_planes;
+      for (int i=0; i < s_planes; i++)
+        memcpy((uint8_t *)omx_buffer->pBuffer + i * planesize, src_buffer[i] + sent * s_pitch, planesize);
       sent += send;
     }
 
@@ -428,8 +464,10 @@ int CActiveAEResample::Resample(uint8_t **dst_buffer, int dst_samples, uint8_t *
 
     if (m_encoded_buffer->nFilledLen)
     {
-      memcpy(dst_buffer[0] + received * d_pitch, m_encoded_buffer->pBuffer, m_encoded_buffer->nFilledLen);
-      received += m_encoded_buffer->nFilledLen / d_pitch;
+      int planesize = m_encoded_buffer->nFilledLen / d_planes;
+      for (int i=0; i < d_planes; i++)
+        memcpy(dst_buffer[i] + received * d_pitch, (uint8_t *)m_encoded_buffer->pBuffer + i * planesize, planesize);
+      received += m_encoded_buffer->nFilledLen / d_samplesize;
     }
   }
   #ifdef DEBUG_VERBOSE
@@ -521,6 +559,7 @@ AVSampleFormat CActiveAEResample::GetAVSampleFormat(AEDataFormat format)
   else if (format == AE_FMT_S16NE)  return AV_SAMPLE_FMT_S16;
   else if (format == AE_FMT_S32NE)  return AV_SAMPLE_FMT_S32;
   else if (format == AE_FMT_S24NE4) return AV_SAMPLE_FMT_S32;
+  else if (format == AE_FMT_S24NE4MSB)return AV_SAMPLE_FMT_S32;
   else if (format == AE_FMT_FLOAT)  return AV_SAMPLE_FMT_FLT;
   else if (format == AE_FMT_DOUBLE) return AV_SAMPLE_FMT_DBL;
 
@@ -528,6 +567,7 @@ AVSampleFormat CActiveAEResample::GetAVSampleFormat(AEDataFormat format)
   else if (format == AE_FMT_S16NEP)  return AV_SAMPLE_FMT_S16P;
   else if (format == AE_FMT_S32NEP)  return AV_SAMPLE_FMT_S32P;
   else if (format == AE_FMT_S24NE4P) return AV_SAMPLE_FMT_S32P;
+  else if (format == AE_FMT_S24NE4MSB)return AV_SAMPLE_FMT_S32;
   else if (format == AE_FMT_FLOATP)  return AV_SAMPLE_FMT_FLTP;
   else if (format == AE_FMT_DOUBLEP) return AV_SAMPLE_FMT_DBLP;
 
@@ -537,29 +577,6 @@ AVSampleFormat CActiveAEResample::GetAVSampleFormat(AEDataFormat format)
     return AV_SAMPLE_FMT_FLT;
 }
 
-AEDataFormat CActiveAEResample::GetAESampleFormat(AVSampleFormat format, int bits)
-{
-  #ifdef DEBUG_VERBOSE
-  CLog::Log(LOGINFO, "%s::%s", CLASSNAME, __func__);
-  #endif
-  if      (format == AV_SAMPLE_FMT_U8)   return AE_FMT_U8;
-  else if (format == AV_SAMPLE_FMT_S16)  return AE_FMT_S16NE;
-  else if (format == AV_SAMPLE_FMT_S32 && bits == 32)  return AE_FMT_S32NE;
-  else if (format == AV_SAMPLE_FMT_S32 && bits == 24)  return AE_FMT_S24NE4;
-  else if (format == AV_SAMPLE_FMT_FLT)  return AE_FMT_FLOAT;
-  else if (format == AV_SAMPLE_FMT_DBL)  return AE_FMT_DOUBLE;
-
-  else if (format == AV_SAMPLE_FMT_U8P)   return AE_FMT_U8P;
-  else if (format == AV_SAMPLE_FMT_S16P)  return AE_FMT_S16NEP;
-  else if (format == AV_SAMPLE_FMT_S32P && bits == 32)  return AE_FMT_S32NEP;
-  else if (format == AV_SAMPLE_FMT_S32P && bits == 24)  return AE_FMT_S24NE4P;
-  else if (format == AV_SAMPLE_FMT_FLTP)  return AE_FMT_FLOATP;
-  else if (format == AV_SAMPLE_FMT_DBLP)  return AE_FMT_DOUBLEP;
-
-  CLog::Log(LOGERROR, "CActiveAEResample::GetAESampleFormat - format not supported");
-  return AE_FMT_INVALID;
-}
-
 uint64_t CActiveAEResample::GetAVChannel(enum AEChannel aechannel)
 {
   #ifdef DEBUG_VERBOSE
-- 
1.9.3


From 550dc53b57021d6c29c8f0e0dc23789643f375cf Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 15 Jun 2014 13:20:53 +0100
Subject: [PATCH 69/99] gles: Avoid crash when capturing snapshot when using
 dvdplayer

Note: snapshot will be blank, but that's better than crashing
---
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index 2929a37..53873f6 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -1598,7 +1598,9 @@ bool CLinuxRendererGLES::RenderCapture(CRenderCapture* capture)
     return false;
 
   // If rendered directly by the hardware
+#ifndef TARGET_RASPBERRY_PI
   if (m_renderMethod & RENDER_BYPASS)
+#endif
   {
     capture->BeginRender();
     capture->EndRender();
-- 
1.9.3


From 6b0003bb9a3c2449376a07aa3d8461f622e39af9 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 16 Jun 2014 19:05:14 +0100
Subject: [PATCH 70/99] sqlite: Bump to 3080500

---
 tools/depends/target/sqlite3/Makefile | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/tools/depends/target/sqlite3/Makefile b/tools/depends/target/sqlite3/Makefile
index 87f7eaa..8fe61e8 100644
--- a/tools/depends/target/sqlite3/Makefile
+++ b/tools/depends/target/sqlite3/Makefile
@@ -3,7 +3,9 @@ DEPS= ../../Makefile.include Makefile
 
 # lib name, version
 LIBNAME=sqlite
-VERSION=3071000
+VERSION=3080500
+BASE_URL=https://www.sqlite.org/2014
+
 SOURCE=$(LIBNAME)-autoconf-$(VERSION)
 ARCHIVE=$(SOURCE).tar.gz
 
-- 
1.9.3


From dcf091e7f5eaf365ef0670fde7a0db8ea1f84ae5 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 16 Jun 2014 19:06:00 +0100
Subject: [PATCH 71/99] [experimental] Disable quiet-noise generation

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
index 488a0df..d9f4a43 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
@@ -870,6 +870,7 @@ void CActiveAESink::SwapInit(CSampleBuffer* samples)
 
 void CActiveAESink::GenerateNoise()
 {
+#ifndef TARGET_RASPBERRY_PI
   int nb_floats = m_sampleOfSilence.pkt->max_nb_samples;
   nb_floats *= m_sampleOfSilence.pkt->config.channels;
 
@@ -907,6 +908,7 @@ void CActiveAESink::GenerateNoise()
                      (uint8_t**)&noise, m_sampleOfSilence.pkt->max_nb_samples, 1.0);
 
   _aligned_free(noise);
+#endif
 }
 
 void CActiveAESink::SetSilenceTimer()
-- 
1.9.3


From 07cc88baecc7104213d5c83dae193323744b685e Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 16 Jun 2014 19:07:21 +0100
Subject: [PATCH 72/99] [omxcodec] Adjust asserts

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp | 11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
index 494fdf5..23aaa9f 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/OpenMaxVideo.cpp
@@ -795,7 +795,7 @@ int COpenMaxVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
           // only push if we are successful with feeding OMX_EmptyThisBuffer
           pthread_mutex_lock(&m_omx_output_mutex);
           m_dts_queue.push(dts);
-          assert(m_dts_queue.size() < 32);
+          assert(m_dts_queue.size() < 64);
           pthread_mutex_unlock(&m_omx_output_mutex);
         }
 #endif
@@ -1037,9 +1037,12 @@ OMX_ERRORTYPE COpenMaxVideo::DecoderFillBufferDone(
   if ((!m_deinterlace || (buffer->omx_buffer->nFlags & OMX_BUFFERFLAG_FIRST_FIELD)) && buffer->omx_buffer->nFlags)
   {
     pthread_mutex_lock(&m_omx_output_mutex);
-    assert(!m_dts_queue.empty());
-    buffer->dts = m_dts_queue.front();
-    m_dts_queue.pop();
+    if (!m_dts_queue.empty())
+    {
+      buffer->dts = m_dts_queue.front();
+      m_dts_queue.pop();
+    }
+    else assert(0);
     pthread_mutex_unlock(&m_omx_output_mutex);
   }
 #endif
-- 
1.9.3


From 73a4d2fb59999726c9e906cf046e7dd262cf6eaa Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Thu, 11 Apr 2013 18:24:42 +0200
Subject: [PATCH 73/99] Added some vc_tv_* functions that were missing in
 DllBCM.

---
 xbmc/linux/DllBCM.h | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/xbmc/linux/DllBCM.h b/xbmc/linux/DllBCM.h
index b92fdb8..9c7e293 100644
--- a/xbmc/linux/DllBCM.h
+++ b/xbmc/linux/DllBCM.h
@@ -48,6 +48,9 @@ class DllBcmHostInterface
   virtual void bcm_host_init() = 0;
   virtual void bcm_host_deinit() = 0;
   virtual int32_t graphics_get_display_size( const uint16_t display_number, uint32_t *width, uint32_t *height) = 0;
+  virtual int vc_tv_power_off() = 0;
+  virtual int vc_tv_sdtv_power_on(SDTV_MODE_T mode, SDTV_OPTIONS_T *options) = 0;
+  virtual int vc_tv_hdmi_power_on_preferred() = 0;
   virtual int vc_tv_hdmi_power_on_best(uint32_t width, uint32_t height, uint32_t frame_rate,
                                        HDMI_INTERLACED_T scan_mode, EDID_MODE_MATCH_FLAG_T match_flags) = 0;
   virtual int vc_tv_hdmi_power_on_best_3d(uint32_t width, uint32_t height, uint32_t frame_rate,
@@ -92,6 +95,12 @@ class DllBcmHost : public DllDynamic, DllBcmHostInterface
     { return ::bcm_host_deinit(); };
   virtual int32_t graphics_get_display_size( const uint16_t display_number, uint32_t *width, uint32_t *height)
     { return ::graphics_get_display_size(display_number, width, height); };
+  virtual int vc_tv_power_off()
+    { return ::vc_tv_power_off(); }
+  virtual int vc_tv_sdtv_power_on(SDTV_MODE_T mode, SDTV_OPTIONS_T *options)
+    { return ::vc_tv_sdtv_power_on(mode, options); }
+  virtual int vc_tv_hdmi_power_on_preferred()
+    { return ::vc_tv_hdmi_power_on_preferred(); }
   virtual int vc_tv_hdmi_power_on_best(uint32_t width, uint32_t height, uint32_t frame_rate,
                                        HDMI_INTERLACED_T scan_mode, EDID_MODE_MATCH_FLAG_T match_flags)
     { return ::vc_tv_hdmi_power_on_best(width, height, frame_rate, scan_mode, match_flags); };
-- 
1.9.3


From 9760a28ec013598562927aa51cfc6957b1916712 Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Thu, 11 Apr 2013 18:29:03 +0200
Subject: [PATCH 74/99] Added private utility function to map a float display
 aspect, to the respective SDTV_ASPECT_* enum value.

---
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index a3edf0e..5ae2b59 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -410,6 +410,25 @@ static void SetResolutionString(RESOLUTION_INFO &res)
     res.dwFlags & D3DPRESENTFLAG_MODE3DTB   ? " 3DTB" : "",
     res.dwFlags & D3DPRESENTFLAG_MODE3DSBS  ? " 3DSBS" : "");
 }
+
+static SDTV_ASPECT_T get_sdtv_aspect_from_display_aspect(float display_aspect)
+{
+  SDTV_ASPECT_T aspect;
+  const float delta = 1e-3;
+  if(fabs(get_display_aspect_ratio(SDTV_ASPECT_16_9) - display_aspect) < delta)
+  {
+    aspect = SDTV_ASPECT_16_9;
+  }
+  else if(fabs(get_display_aspect_ratio(SDTV_ASPECT_14_9) - display_aspect) < delta)
+  {
+    aspect = SDTV_ASPECT_14_9;
+  }
+  else
+  {
+    aspect = SDTV_ASPECT_4_3;
+  }
+  return aspect;
+}
 #endif
 
 bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
-- 
1.9.3


From aed09b5994072e7e0c6e9bacf761f9eb7f82769f Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Thu, 11 Apr 2013 19:50:58 +0200
Subject: [PATCH 75/99] Changed SDTV resolutions to be treated similarly to
 HDMI resolutions in SetNativeResolution. This means that the SDTV interface
 is powered up and set to the right mode.

---
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp | 36 ++++++++++++++++++++-----
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h   |  1 -
 2 files changed, 29 insertions(+), 8 deletions(-)

diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index 5ae2b59..712fe9c 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -220,7 +220,7 @@ bool CEGLNativeTypeRaspberryPI::SetNativeResolution(const RESOLUTION_INFO &res)
 
   DestroyDispmaxWindow();
 
-  if(!m_fixedMode && GETFLAGS_GROUP(res.dwFlags) && GETFLAGS_MODE(res.dwFlags))
+  if(GETFLAGS_GROUP(res.dwFlags) && GETFLAGS_MODE(res.dwFlags))
   {
     sem_init(&m_tv_synced, 0, 0);
     m_DllBcmHost->vc_tv_register_callback(CallbackTvServiceCallback, this);
@@ -274,6 +274,33 @@ bool CEGLNativeTypeRaspberryPI::SetNativeResolution(const RESOLUTION_INFO &res)
 
     m_desktopRes = res;
   }
+  else if(!GETFLAGS_GROUP(res.dwFlags) && GETFLAGS_MODE(res.dwFlags))
+  {
+    sem_init(&m_tv_synced, 0, 0);
+    m_DllBcmHost->vc_tv_register_callback(CallbackTvServiceCallback, this);
+
+    SDTV_OPTIONS_T options;
+    options.aspect = get_sdtv_aspect_from_display_aspect((float)res.iScreenWidth / (float)res.iScreenHeight);
+
+    int success = m_DllBcmHost->vc_tv_sdtv_power_on((SDTV_MODE_T)GETFLAGS_MODE(res.dwFlags), &options);
+
+    if (success == 0)
+    {
+      CLog::Log(LOGDEBUG, "EGL set SDTV mode (%d,%d)=%d\n",
+                          GETFLAGS_GROUP(res.dwFlags), GETFLAGS_MODE(res.dwFlags), success);
+
+      sem_wait(&m_tv_synced);
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "EGL failed to set SDTV mode (%d,%d)=%d\n",
+                          GETFLAGS_GROUP(res.dwFlags), GETFLAGS_MODE(res.dwFlags), success);
+    }
+    m_DllBcmHost->vc_tv_unregister_callback(CallbackTvServiceCallback);
+    sem_destroy(&m_tv_synced);
+
+    m_desktopRes = res;
+  }
 
   m_dispman_display = m_DllBcmHost->vc_dispmanx_display_open(0);
 
@@ -439,8 +466,6 @@ bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &r
   if(!m_DllBcmHost)
     return false;
 
-  m_fixedMode               = false;
-
   /* read initial desktop resolution before probe resolutions.
    * probing will replace the desktop resolution when it finds the same one.
    * we raplace it because probing will generate more detailed 
@@ -483,7 +508,7 @@ bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &r
       m_desktopRes.iHeight      = tv_state.display.sdtv.height;
       m_desktopRes.iScreenWidth = tv_state.display.sdtv.width;
       m_desktopRes.iScreenHeight= tv_state.display.sdtv.height;
-      m_desktopRes.dwFlags      = D3DPRESENTFLAG_INTERLACED;
+      m_desktopRes.dwFlags      = MAKEFLAGS(HDMI_RES_GROUP_INVALID, tv_state.display.sdtv.mode, 1);
       m_desktopRes.fRefreshRate = (float)tv_state.display.sdtv.frame_rate;
       m_desktopRes.fPixelRatio  = get_display_aspect_ratio((SDTV_ASPECT_T)tv_state.display.sdtv.display_options.aspect) / ((float)m_desktopRes.iScreenWidth / (float)m_desktopRes.iScreenHeight);
     }
@@ -506,9 +531,6 @@ bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &r
     CLog::Log(LOGDEBUG, "EGL probe resolution %s:%x\n", m_desktopRes.strMode.c_str(), m_desktopRes.dwFlags);
   }
 
-  if(resolutions.size() < 2)
-    m_fixedMode = true;
-
   DLOG("CEGLNativeTypeRaspberryPI::ProbeResolutions\n");
   return true;
 #else
diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h
index 59401f5..a0acb1a 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h
@@ -59,7 +59,6 @@ class CEGLNativeTypeRaspberryPI : public CEGLNativeType
   DISPMANX_ELEMENT_HANDLE_T     m_dispman_element;
   TV_GET_STATE_RESP_T           m_tv_state;
   sem_t                         m_tv_synced;
-  bool                          m_fixedMode;
   RESOLUTION_INFO               m_desktopRes;
   int                           m_width;
   int                           m_height;
-- 
1.9.3


From c7907a1f7ade36d7d6ad7cc0b31bd00aa4af56ca Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Thu, 11 Apr 2013 19:54:59 +0200
Subject: [PATCH 76/99] Added methods SuspendVideoOutput() and
 ResumeVideoOutput() to CRBP class, which can be used to power down the
 Raspberry PI's video interface, and restore it at a later point.

---
 xbmc/linux/RBP.cpp                              | 15 +++++++++++++++
 xbmc/linux/RBP.h                                |  3 +++
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp |  3 +++
 3 files changed, 21 insertions(+)

diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index 9a5e9cb..87619e9 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -165,4 +165,19 @@ void CRBP::Deinitialize()
   m_initialized     = false;
   m_omx_initialized = false;
 }
+
+void CRBP::SuspendVideoOutput()
+{
+  CLog::Log(LOGDEBUG, "Raspberry PI suspending video output\n");
+  char response[80];
+  m_DllBcmHost->vc_gencmd(response, sizeof response, "display_power 0");
+}
+
+void CRBP::ResumeVideoOutput()
+{
+  char response[80];
+  m_DllBcmHost->vc_gencmd(response, sizeof response, "display_power 1");
+  CLog::Log(LOGDEBUG, "Raspberry PI resuming video output\n");
+}
+
 #endif
diff --git a/xbmc/linux/RBP.h b/xbmc/linux/RBP.h
index 2aae579..f06687c 100644
--- a/xbmc/linux/RBP.h
+++ b/xbmc/linux/RBP.h
@@ -57,6 +57,9 @@ class CRBP
   unsigned char *CaptureDisplay(int width, int height, int *stride, bool swap_red_blue, bool video_only = true);
   DllOMX *GetDllOMX() { return m_OMX ? m_OMX->GetDll() : NULL; }
 
+  void SuspendVideoOutput();
+  void ResumeVideoOutput();
+
 private:
   DllBcmHost *m_DllBcmHost;
   bool       m_initialized;
diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index 712fe9c..40d303e 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -58,7 +58,10 @@
 # define DLOG(fmt, args...)
 #endif
 
+#if defined(TARGET_RASPBERRY_PI)
 static void SetResolutionString(RESOLUTION_INFO &res);
+static SDTV_ASPECT_T get_sdtv_aspect_from_display_aspect(float display_aspect);
+#endif
 
 CEGLNativeTypeRaspberryPI::CEGLNativeTypeRaspberryPI()
 {
-- 
1.9.3


From 56fc582a96b00749ecb470e99cb3fe05834fc294 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 11 Aug 2013 15:03:36 +0100
Subject: [PATCH 77/99] PowerManager (and its IPowerSyscall instance) now gets
 called from CApplication::OnKey() and can process and suppress key presses.
 This is a requirement to implement a virtual sleep state.

---
 xbmc/Application.cpp                  | 7 +++++++
 xbmc/powermanagement/IPowerSyscall.h  | 7 +++++++
 xbmc/powermanagement/PowerManager.cpp | 6 ++++++
 xbmc/powermanagement/PowerManager.h   | 3 +++
 4 files changed, 23 insertions(+)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index 749e3c0..8415123 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -2369,6 +2369,13 @@ bool CApplication::OnKey(const CKey& key)
   // special handling if the screensaver is active
   CAction action = CButtonTranslator::GetInstance().GetAction(iWin, key);
 
+  // give the PowerManager a chance to process a keypress, and
+  // suppress further processing. we need this for virtual sleep.
+  if (g_powerManager.ProcessAction(action))
+  {
+    return true;
+  }
+
   // a key has been pressed.
   // reset Idle Timer
   m_idleTimer.StartZero();
diff --git a/xbmc/powermanagement/IPowerSyscall.h b/xbmc/powermanagement/IPowerSyscall.h
index 7f9e7ed..711abea 100644
--- a/xbmc/powermanagement/IPowerSyscall.h
+++ b/xbmc/powermanagement/IPowerSyscall.h
@@ -20,6 +20,9 @@
  *
  */
 
+// forward declaration
+class CAction;
+
 class IPowerEventsCallback
 {
 public:
@@ -60,6 +63,10 @@ class IPowerSyscall
    \param callback the callback to signal to
    */
   virtual bool PumpPowerEvents(IPowerEventsCallback *callback) = 0;
+
+  // this is an optional part of the interface, so we provide a no-op implementation here.
+  // return true to suppress further processing of the CAction.
+  virtual bool ProcessAction(const CAction& action) { return false; }
 };
 
 class CPowerSyscallWithoutEvents : public IPowerSyscall
diff --git a/xbmc/powermanagement/PowerManager.cpp b/xbmc/powermanagement/PowerManager.cpp
index fe72016..b392f76 100644
--- a/xbmc/powermanagement/PowerManager.cpp
+++ b/xbmc/powermanagement/PowerManager.cpp
@@ -232,6 +232,12 @@ void CPowerManager::ProcessEvents()
   nesting--;
 }
 
+bool CPowerManager::ProcessAction(const CAction& action)
+{
+  return m_instance->ProcessAction(action);
+}
+
+
 void CPowerManager::OnSleep()
 {
   CAnnouncementManager::Get().Announce(System, "xbmc", "OnSleep");
diff --git a/xbmc/powermanagement/PowerManager.h b/xbmc/powermanagement/PowerManager.h
index 0b1f10a..e42b143 100644
--- a/xbmc/powermanagement/PowerManager.h
+++ b/xbmc/powermanagement/PowerManager.h
@@ -58,6 +58,8 @@ class CNullPowerSyscall : public IPowerSyscall
 
 
   virtual bool PumpPowerEvents(IPowerEventsCallback *callback) { return false; }
+
+  virtual bool ProcessAction(const CAction& action) { return false; }
 };
 
 // This class will wrap and handle PowerSyscalls.
@@ -87,6 +89,7 @@ class CPowerManager : public IPowerEventsCallback
 
   static void SettingOptionsShutdownStatesFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current, void *data);
 
+  bool ProcessAction(const CAction& action);
 private:
   void OnSleep();
   void OnWake();
-- 
1.9.3


From a8dd2b7a35760c9d5c251bf7a1a695d81f14bed2 Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Wed, 17 Apr 2013 13:23:01 +0200
Subject: [PATCH 78/99] Added CPowerSyscallVirtualSleep class, which acts as a
 base class for devices that have no native standby mode, and need to fake it
 in some way.

---
 xbmc/powermanagement/Makefile                     |  1 +
 xbmc/powermanagement/PowerSyscallVirtualSleep.cpp | 84 +++++++++++++++++++++++
 xbmc/powermanagement/PowerSyscallVirtualSleep.h   | 56 +++++++++++++++
 3 files changed, 141 insertions(+)
 create mode 100644 xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
 create mode 100644 xbmc/powermanagement/PowerSyscallVirtualSleep.h

diff --git a/xbmc/powermanagement/Makefile b/xbmc/powermanagement/Makefile
index 0b4c029..16056af 100644
--- a/xbmc/powermanagement/Makefile
+++ b/xbmc/powermanagement/Makefile
@@ -1,5 +1,6 @@
 SRCS=DPMSSupport.cpp \
      PowerManager.cpp \
+     PowerSyscallVirtualSleep.cpp \
 
 LIB=powermanagement.a
 
diff --git a/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
new file mode 100644
index 0000000..6a1e47b
--- /dev/null
+++ b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
@@ -0,0 +1,84 @@
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "PowerSyscallVirtualSleep.h"
+#include "guilib/Key.h"
+#include "utils/log.h"
+#include "utils/StringUtils.h"
+
+bool CPowerSyscallVirtualSleep::Suspend()
+{
+  if (m_virtualSleepState == VIRTUAL_SLEEP_STATE_AWAKE)
+  {
+    if (VirtualSleep())
+    {
+      m_virtualSleepState = VIRTUAL_SLEEP_STATE_WILL_SLEEP;
+      return true;
+    }
+  }
+
+  return false;
+}
+
+bool CPowerSyscallVirtualSleep::PumpPowerEvents(IPowerEventsCallback *callback)
+{
+  if (m_virtualSleepState == VIRTUAL_SLEEP_STATE_WILL_WAKE)
+  {
+    callback->OnWake();
+    m_virtualSleepState = VIRTUAL_SLEEP_STATE_AWAKE;
+    return true;
+  }
+  else if (m_virtualSleepState == VIRTUAL_SLEEP_STATE_WILL_SLEEP)
+  {
+    callback->OnSleep();
+    m_virtualSleepState = VIRTUAL_SLEEP_STATE_ASLEEP;
+    return true;
+  }
+
+  return false;
+}
+
+bool CPowerSyscallVirtualSleep::ProcessAction(const CAction& action)
+{
+  if (m_virtualSleepState != VIRTUAL_SLEEP_STATE_ASLEEP)
+    return false;
+
+  // device is in virtual sleep, only one of the power keys will
+  // wake it up again.
+  if (action.GetID() == ACTION_BUILT_IN_FUNCTION)
+  {
+    CStdString name = action.GetName();
+    StringUtils::ToLower(name);
+    if(name.Equals("xbmc.suspend()") ||
+       name.Equals("shutdown") ||
+       name.Equals("suspend")  ||
+       name.Equals("hibernate"))
+    {
+      if(VirtualWake())
+      {
+        m_virtualSleepState = VIRTUAL_SLEEP_STATE_WILL_WAKE;
+        return false;
+      }
+    }
+  }
+
+  // wasn't a power key, suppress this and stay asleep
+  return true;
+}
diff --git a/xbmc/powermanagement/PowerSyscallVirtualSleep.h b/xbmc/powermanagement/PowerSyscallVirtualSleep.h
new file mode 100644
index 0000000..ef6e682
--- /dev/null
+++ b/xbmc/powermanagement/PowerSyscallVirtualSleep.h
@@ -0,0 +1,56 @@
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef _POWER_SYSCALL_VIRTUAL_SLEEP_H_
+#define _POWER_SYSCALL_VIRTUAL_SLEEP_H_
+#include "IPowerSyscall.h"
+
+// Systems that have no native standby mode, can base their
+// IPowerSyscall implementation on this class, and need only
+// implement VirtualSleep()/VirtualWake().
+class CPowerSyscallVirtualSleep : public IPowerSyscall
+{
+public:
+  CPowerSyscallVirtualSleep() : m_virtualSleepState(VIRTUAL_SLEEP_STATE_AWAKE) {}
+  virtual ~CPowerSyscallVirtualSleep() {}
+
+  virtual bool CanSuspend() { return true; }
+  virtual bool Suspend();
+
+  virtual bool PumpPowerEvents(IPowerEventsCallback *callback);
+
+  virtual bool ProcessAction(const CAction& action);
+
+  virtual bool VirtualSleep() = 0;
+  virtual bool VirtualWake()  = 0;
+
+protected:
+  // keep track of virtual sleep state for devices that support it
+  typedef enum {
+    VIRTUAL_SLEEP_STATE_AWAKE = 0,
+    VIRTUAL_SLEEP_STATE_ASLEEP,
+    VIRTUAL_SLEEP_STATE_WILL_WAKE,
+    VIRTUAL_SLEEP_STATE_WILL_SLEEP,
+  } VirtualSleepState;
+
+  VirtualSleepState m_virtualSleepState;
+};
+
+#endif // _POWER_SYSCALL_VIRTUAL_SLEEP_H_
-- 
1.9.3


From de43b0c0c8753091d5fad478684f44ce03dc04b6 Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Wed, 17 Apr 2013 13:24:22 +0200
Subject: [PATCH 79/99] Added power management support for the Raspberry Pi.
 Since it doesn't support true standby, we fake it by turning video on or off,
 and ignoring remote inputs during the standby phase.

---
 xbmc/powermanagement/PowerManager.cpp              |  4 ++
 xbmc/powermanagement/linux/Makefile                |  1 +
 .../linux/RaspberryPIPowerSyscall.cpp              | 38 +++++++++++++++++
 .../linux/RaspberryPIPowerSyscall.h                | 49 ++++++++++++++++++++++
 4 files changed, 92 insertions(+)
 create mode 100644 xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
 create mode 100644 xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h

diff --git a/xbmc/powermanagement/PowerManager.cpp b/xbmc/powermanagement/PowerManager.cpp
index b392f76..7dd691c 100644
--- a/xbmc/powermanagement/PowerManager.cpp
+++ b/xbmc/powermanagement/PowerManager.cpp
@@ -38,6 +38,8 @@
 
 #if defined(TARGET_DARWIN)
 #include "osx/CocoaPowerSyscall.h"
+#elif defined(TARGET_RASPBERRY_PI)
+#include "linux/RaspberryPIPowerSyscall.h"
 #elif defined(TARGET_ANDROID)
 #include "android/AndroidPowerSyscall.h"
 #elif defined(TARGET_POSIX)
@@ -74,6 +76,8 @@ void CPowerManager::Initialize()
 {
 #if defined(TARGET_DARWIN)
   m_instance = new CCocoaPowerSyscall();
+#elif defined(TARGET_RASPBERRY_PI)
+  m_instance = new CRaspberryPIPowerSyscall();
 #elif defined(TARGET_ANDROID)
   m_instance = new CAndroidPowerSyscall();
 #elif defined(TARGET_POSIX)
diff --git a/xbmc/powermanagement/linux/Makefile b/xbmc/powermanagement/linux/Makefile
index fc6f8b5..10809da 100644
--- a/xbmc/powermanagement/linux/Makefile
+++ b/xbmc/powermanagement/linux/Makefile
@@ -1,6 +1,7 @@
 SRCS=ConsoleDeviceKitPowerSyscall.cpp \
      ConsoleUPowerSyscall.cpp \
      HALPowerSyscall.cpp \
+     RaspberryPIPowerSyscall.cpp \
      UPowerSyscall.cpp \
      LogindUPowerSyscall.cpp
 
diff --git a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
new file mode 100644
index 0000000..10deeb8
--- /dev/null
+++ b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
@@ -0,0 +1,38 @@
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#if defined(TARGET_RASPBERRY_PI)
+
+#include "RaspberryPIPowerSyscall.h"
+#include "RBP.h"
+
+bool CRaspberryPIPowerSyscall::VirtualSleep()
+{
+  g_RBP.SuspendVideoOutput();
+  return true;
+}
+
+bool CRaspberryPIPowerSyscall::VirtualWake()
+{
+  g_RBP.ResumeVideoOutput();
+  return true;
+}
+
+#endif
diff --git a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h
new file mode 100644
index 0000000..fd1d67c
--- /dev/null
+++ b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h
@@ -0,0 +1,49 @@
+#pragma once
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef _RASPBERRY_PI_POWER_SYSCALL_H_
+#define _RASPBERRY_PI_POWER_SYSCALL_H_
+
+#if defined(TARGET_RASPBERRY_PI)
+#include "powermanagement/PowerSyscallVirtualSleep.h"
+
+class CRaspberryPIPowerSyscall : public CPowerSyscallVirtualSleep
+{
+public:
+  CRaspberryPIPowerSyscall() : CPowerSyscallVirtualSleep() {}
+  virtual ~CRaspberryPIPowerSyscall() {}
+
+  virtual bool Powerdown()    { return false; }
+  virtual bool Hibernate()    { return false; }
+  virtual bool Reboot()       { return false; }
+
+  virtual bool CanPowerdown() { return false; }
+  virtual bool CanHibernate() { return false; }
+  virtual bool CanReboot()    { return true; }
+
+  virtual int  BatteryLevel() { return 0; }
+
+  virtual bool VirtualSleep();
+  virtual bool VirtualWake();
+};
+#endif // TARGET_RASPBERRY_PI
+
+#endif // _RASPBERRY_PI_POWER_SYSCALL_H_
-- 
1.9.3


From 6eb17e4018ee5a5f8fb08bbf02d9f3e4f85cb51b Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Mar 2014 16:16:29 +0000
Subject: [PATCH 80/99] [power] hack - don't kill lirc or cec

---
 xbmc/peripherals/devices/PeripheralCecAdapter.cpp | 37 +++++++++++++++++++++++
 xbmc/powermanagement/PowerManager.cpp             |  4 +--
 2 files changed, 39 insertions(+), 2 deletions(-)

diff --git a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
index 6950f0c..4c8416f 100644
--- a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
+++ b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
@@ -183,12 +183,49 @@ void CPeripheralCecAdapter::Announce(AnnouncementFlag flag, const char *sender,
   }
   else if (flag == System && !strcmp(sender, "xbmc") && !strcmp(message, "OnSleep"))
   {
+#if 1
+  bool bSendStandbyCommands(false);
+  {
+    CSingleLock lock(m_critSection);
+    bSendStandbyCommands = m_iExitCode != EXITCODE_REBOOT &&
+                           m_iExitCode != EXITCODE_RESTARTAPP &&
+                           !m_bDeviceRemoved &&
+                           (!m_bGoingToStandby || GetSettingBool("standby_tv_on_pc_standby")) &&
+                           GetSettingBool("enabled");
+
+    if (m_bGoingToStandby)
+      m_bActiveSourceBeforeStandby = m_cecAdapter->IsLibCECActiveSource();
+  }
+
+  if (bSendStandbyCommands)
+  {
+    if (m_cecAdapter->IsLibCECActiveSource())
+    {
+      if (!m_configuration.powerOffDevices.IsEmpty())
+      {
+        CLog::Log(LOGDEBUG, "%s - sending standby commands", __FUNCTION__);
+        m_standbySent = CDateTime::GetCurrentDateTime();
+        m_cecAdapter->StandbyDevices();
+      }
+      else if (m_configuration.bSendInactiveSource == 1)
+      {
+        CLog::Log(LOGDEBUG, "%s - sending inactive source commands", __FUNCTION__);
+        m_cecAdapter->SetInactiveView();
+      }
+    }
+    else
+    {
+      CLog::Log(LOGDEBUG, "%s - XBMC is not the active source, not sending any standby commands", __FUNCTION__);
+    }
+  }
+#else
     // this will also power off devices when we're the active source
     {
       CSingleLock lock(m_critSection);
       m_bGoingToStandby = true;
     }
     StopThread();
+#endif
   }
   else if (flag == System && !strcmp(sender, "xbmc") && !strcmp(message, "OnWake"))
   {
diff --git a/xbmc/powermanagement/PowerManager.cpp b/xbmc/powermanagement/PowerManager.cpp
index 7dd691c..17f118a 100644
--- a/xbmc/powermanagement/PowerManager.cpp
+++ b/xbmc/powermanagement/PowerManager.cpp
@@ -248,7 +248,7 @@ void CPowerManager::OnSleep()
   CLog::Log(LOGNOTICE, "%s: Running sleep jobs", __FUNCTION__);
 
   // stop lirc
-#if defined(HAS_LIRC) || defined(HAS_IRSERVERSUITE)
+#if 0 //defined(HAS_LIRC) || defined(HAS_IRSERVERSUITE)
   CLog::Log(LOGNOTICE, "%s: Stopping lirc", __FUNCTION__);
   CBuiltins::Execute("LIRC.Stop");
 #endif
@@ -284,7 +284,7 @@ void CPowerManager::OnWake()
 #endif
 
   // restart lirc
-#if defined(HAS_LIRC) || defined(HAS_IRSERVERSUITE)
+#if 0 // defined(HAS_LIRC) || defined(HAS_IRSERVERSUITE)
   CLog::Log(LOGNOTICE, "%s: Restarting lirc", __FUNCTION__);
   CBuiltins::Execute("LIRC.Start");
 #endif
-- 
1.9.3


From dcf386bf37dd9ac82da59f2007243f195e7a54fe Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Mar 2014 16:47:54 +0000
Subject: [PATCH 81/99] [power] hack - wake on any action

---
 xbmc/powermanagement/PowerSyscallVirtualSleep.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
index 6a1e47b..a717a09 100644
--- a/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
+++ b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
@@ -62,14 +62,14 @@ bool CPowerSyscallVirtualSleep::ProcessAction(const CAction& action)
 
   // device is in virtual sleep, only one of the power keys will
   // wake it up again.
-  if (action.GetID() == ACTION_BUILT_IN_FUNCTION)
+  //if (action.GetID() == ACTION_BUILT_IN_FUNCTION)
   {
     CStdString name = action.GetName();
     StringUtils::ToLower(name);
-    if(name.Equals("xbmc.suspend()") ||
+    /*if(name.Equals("system.suspend") ||
        name.Equals("shutdown") ||
        name.Equals("suspend")  ||
-       name.Equals("hibernate"))
+       name.Equals("hibernate"))*/
     {
       if(VirtualWake())
       {
-- 
1.9.3


From c96538abd2449886b50ed185d19c6e0e3196aef3 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Mar 2014 17:30:07 +0000
Subject: [PATCH 82/99] [power] hack - Make suspend toggle suspend state

---
 xbmc/powermanagement/PowerSyscallVirtualSleep.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
index a717a09..d39c3ed 100644
--- a/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
+++ b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
@@ -33,6 +33,11 @@ bool CPowerSyscallVirtualSleep::Suspend()
       return true;
     }
   }
+  else if (VirtualWake())
+  {
+    m_virtualSleepState = VIRTUAL_SLEEP_STATE_WILL_WAKE;
+    return false;
+  }
 
   return false;
 }
-- 
1.9.3


From d76e483f4d9ba20926fe600dc0336a8a04b0e2a7 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 4 Mar 2014 19:33:44 +0000
Subject: [PATCH 83/99] [power] Add back in powerdown and reboot

---
 .../linux/RaspberryPIPowerSyscall.cpp              | 34 ++++++++++++++++++++++
 .../linux/RaspberryPIPowerSyscall.h                |  6 ++--
 2 files changed, 37 insertions(+), 3 deletions(-)

diff --git a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
index 10deeb8..220bca9 100644
--- a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
+++ b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
@@ -20,7 +20,11 @@
 
 #if defined(TARGET_RASPBERRY_PI)
 
+#include "system.h"
 #include "RaspberryPIPowerSyscall.h"
+#if defined(HAS_DBUS)
+#include "LogindUPowerSyscall.h"
+#endif
 #include "RBP.h"
 
 bool CRaspberryPIPowerSyscall::VirtualSleep()
@@ -35,4 +39,34 @@ bool CRaspberryPIPowerSyscall::VirtualWake()
   return true;
 }
 
+bool CRaspberryPIPowerSyscall::Powerdown()
+{
+  int s = false;
+#if defined(HAS_DBUS)
+  if (CLogindUPowerSyscall::HasLogind())
+  {
+    IPowerSyscall *m_instance = new CLogindUPowerSyscall;
+    if (m_instance->CanPowerdown())
+      s = m_instance->Powerdown();
+    delete m_instance;
+  }
+#endif
+  return s;
+}
+
+bool CRaspberryPIPowerSyscall::Reboot()
+{
+  int s = false;
+#if defined(HAS_DBUS)
+  if (CLogindUPowerSyscall::HasLogind())
+  {
+    IPowerSyscall *m_instance = new CLogindUPowerSyscall;
+    if (m_instance->CanReboot())
+      s = m_instance->Reboot();
+    delete m_instance;
+  }
+#endif
+  return s;
+}
+
 #endif
diff --git a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h
index fd1d67c..062132e 100644
--- a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h
+++ b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h
@@ -31,11 +31,11 @@ class CRaspberryPIPowerSyscall : public CPowerSyscallVirtualSleep
   CRaspberryPIPowerSyscall() : CPowerSyscallVirtualSleep() {}
   virtual ~CRaspberryPIPowerSyscall() {}
 
-  virtual bool Powerdown()    { return false; }
+  virtual bool Powerdown();
   virtual bool Hibernate()    { return false; }
-  virtual bool Reboot()       { return false; }
+  virtual bool Reboot();
 
-  virtual bool CanPowerdown() { return false; }
+  virtual bool CanPowerdown() { return true; }
   virtual bool CanHibernate() { return false; }
   virtual bool CanReboot()    { return true; }
 
-- 
1.9.3


From 5a0fe21fd2e50f7a17eeb6f5be38699137807366 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 18 Jun 2014 23:11:28 +0100
Subject: [PATCH 84/99] [rbp] Reduce GPU memory use when limited

Switching from default triple buffered output to double buffered saves 8M with 1080p GUI.
This may slightly reduce framerate, but is likely to be minimal.

Assume if gpu_mem is set below the default 128M that this memory reduction is wanted
---
 xbmc/linux/RBP.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index 87619e9..9f72a36 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -72,6 +72,9 @@ bool CRBP::Initialize()
   if (vc_gencmd(response, sizeof response, "codec_enabled WVC1") == 0)
     m_codec_wvc1_enabled = strcmp("WVC1=enabled", response) == 0;
 
+  if (m_gpu_mem < 128)
+    setenv("V3D_DOUBLE_BUFFER", "1", 1);
+
   g_OMXImage.Initialize();
   m_omx_image_init = true;
   return true;
-- 
1.9.3


From 4347a199d6dbdfffd00b64edf80cd905bd5c0fff Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 27 Jun 2014 00:01:05 +0100
Subject: [PATCH 87/99] [rbp] Resume video output on startup

---
 xbmc/linux/RBP.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index 9f72a36..f789bf1 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -75,6 +75,9 @@ bool CRBP::Initialize()
   if (m_gpu_mem < 128)
     setenv("V3D_DOUBLE_BUFFER", "1", 1);
 
+  // in case xbcm was restarted when suspended
+  ResumeVideoOutput();
+
   g_OMXImage.Initialize();
   m_omx_image_init = true;
   return true;
-- 
1.9.3


From 52d99a15f40cf0ba6ef4c7ac5a66154b2604eb71 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 27 Jun 2014 00:36:29 +0100
Subject: [PATCH 88/99] [omxplayer] Experimental support for anaglyph rendering
 of 3d videos

Requires updated firmware
---
 xbmc/cores/omxplayer/OMXPlayer.cpp      | 12 ++++++++--
 xbmc/cores/omxplayer/OMXPlayerVideo.cpp | 32 ++++++++++++++++++++++++++-
 xbmc/cores/omxplayer/OMXVideo.cpp       | 39 +++++++++++++++++++++------------
 xbmc/cores/omxplayer/OMXVideo.h         |  3 ++-
 xbmc/rendering/RenderSystem.cpp         |  4 ++++
 5 files changed, 72 insertions(+), 18 deletions(-)

diff --git a/xbmc/cores/omxplayer/OMXPlayer.cpp b/xbmc/cores/omxplayer/OMXPlayer.cpp
index 658b0a6..b295e91 100644
--- a/xbmc/cores/omxplayer/OMXPlayer.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayer.cpp
@@ -1502,6 +1502,8 @@ void COMXPlayer::Process()
     SetCaching(CACHESTATE_FLUSH);
 
   EDEINTERLACEMODE current_deinterlace = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+  RENDER_STEREO_MODE current_stereomode = g_graphicsContext.GetStereoMode();
+
   float current_sharpness = CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness;
   SetSharpness(current_sharpness);
 
@@ -1524,8 +1526,13 @@ void COMXPlayer::Process()
       float threshold = 0.1f;
       bool audio_fifo_low = false, video_fifo_low = false, audio_fifo_high = false, video_fifo_high = false;
 
-      // if deinterlace setting has changed, we should close and open video
-      if (current_deinterlace != CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode)
+      // if deinterlace or stereomode setting has changed, we should close and open video
+      RENDER_STEREO_MODE stereomode = g_graphicsContext.GetStereoMode();
+
+      if ((current_deinterlace != CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode) ||
+          (current_stereomode != stereomode &&
+          (current_stereomode == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN || current_stereomode == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA) !=
+          (stereomode == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN || stereomode == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA)))
       {
         int iStream = m_CurrentVideo.id, source = m_CurrentVideo.source;
         CloseVideoStream(false);
@@ -1533,6 +1540,7 @@ void COMXPlayer::Process()
         if (m_State.canseek)
           m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), true, true, true, true, true));
         current_deinterlace = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+        current_stereomode = stereomode;
       }
 
       // if sharpness setting has changed, we should update it
diff --git a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
index 605ea80..b2cb610 100644
--- a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
@@ -550,7 +550,29 @@ bool OMXPlayerVideo::OpenDecoder()
   else
     m_fForcedAspectRatio = 0.0;
 
-  bool bVideoDecoderOpen = m_omxVideo.Open(m_hints, m_av_clock, CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode, m_hdmi_clock_sync);
+
+  unsigned flags = GetStereoModeFlags(GetStereoMode());
+  RENDER_STEREO_MODE video_stereo_mode = (flags & CONF_FLAGS_STEREO_MODE_SBS) ? RENDER_STEREO_MODE_SPLIT_VERTICAL :
+                                         (flags & CONF_FLAGS_STEREO_MODE_TAB) ? RENDER_STEREO_MODE_SPLIT_HORIZONTAL : RENDER_STEREO_MODE_OFF;
+  bool stereo_invert                   = (flags & CONF_FLAGS_STEREO_CADANCE_RIGHT_LEFT) ? true : false;
+  OMX_IMAGEFILTERANAGLYPHTYPE anaglyph = OMX_ImageFilterAnaglyphNone;
+
+  if (g_graphicsContext.GetStereoMode() == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN)
+  {
+    if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+      anaglyph = OMX_ImageFilterAnaglyphSBStoRedCyan;
+    else if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+      anaglyph = OMX_ImageFilterAnaglyphTABtoRedCyan;
+  }
+  else if (g_graphicsContext.GetStereoMode() == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA)
+  {
+    if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+      anaglyph = OMX_ImageFilterAnaglyphSBStoGreenMagenta;
+    else if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+      anaglyph = OMX_ImageFilterAnaglyphTABtoGreenMagenta;
+  }
+
+  bool bVideoDecoderOpen = m_omxVideo.Open(m_hints, m_av_clock, CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode, anaglyph, m_hdmi_clock_sync);
   m_omxVideo.RegisterResolutionUpdateCallBack((void *)this, ResolutionUpdateCallBack);
 
   if(!bVideoDecoderOpen)
@@ -695,6 +717,10 @@ void OMXPlayerVideo::SetVideoRect(const CRect &InSrcRect, const CRect &InDestRec
       video_stereo_mode = RENDER_STEREO_MODE_OFF;
       display_stereo_mode = RENDER_STEREO_MODE_OFF;
     }
+    else if (display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA)
+    {
+      SrcRect.x2 *= 2.0f;
+    }
     else if (stereo_invert)
     {
       SrcRect.x1 += m_hints.width / 2;
@@ -711,6 +737,10 @@ void OMXPlayerVideo::SetVideoRect(const CRect &InSrcRect, const CRect &InDestRec
       video_stereo_mode = RENDER_STEREO_MODE_OFF;
       display_stereo_mode = RENDER_STEREO_MODE_OFF;
     }
+    else if (display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA)
+    {
+      SrcRect.y2 *= 2.0f;
+    }
     else if (stereo_invert)
     {
       SrcRect.y1 += m_hints.height / 2;
diff --git a/xbmc/cores/omxplayer/OMXVideo.cpp b/xbmc/cores/omxplayer/OMXVideo.cpp
index 6639804..07c4643 100644
--- a/xbmc/cores/omxplayer/OMXVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXVideo.cpp
@@ -113,6 +113,7 @@ COMXVideo::COMXVideo() : m_video_codec_name("")
   m_extrasize         = 0;
   m_deinterlace       = false;
   m_deinterlace_request = VS_DEINTERLACEMODE_OFF;
+  m_anaglyph          = OMX_ImageFilterAnaglyphNone;
   m_hdmi_clock_sync   = false;
   m_drop_state        = false;
   m_decoded_width     = 0;
@@ -227,9 +228,9 @@ bool COMXVideo::PortSettingsChanged()
   else
     m_deinterlace = interlace.eMode != OMX_InterlaceProgressive;
 
-    CLog::Log(LOGDEBUG, "%s::%s - %dx%d@%.2f interlace:%d deinterlace:%d", CLASSNAME, __func__,
+    CLog::Log(LOGDEBUG, "%s::%s - %dx%d@%.2f interlace:%d deinterlace:%d anaglyph:%d", CLASSNAME, __func__,
       port_image.format.video.nFrameWidth, port_image.format.video.nFrameHeight,
-      port_image.format.video.xFramerate / (float)(1<<16), interlace.eMode, m_deinterlace);
+      port_image.format.video.xFramerate / (float)(1<<16), interlace.eMode, m_deinterlace, m_anaglyph);
 
   // let OMXPlayerVideo know about resolution so it can inform RenderManager
   if (m_res_callback)
@@ -256,7 +257,7 @@ bool COMXVideo::PortSettingsChanged()
   if(!m_omx_sched.Initialize("OMX.broadcom.video_scheduler", OMX_IndexParamVideoInit))
     return false;
 
-  if(m_deinterlace)
+  if(m_deinterlace || m_anaglyph)
   {
     if(!m_omx_image_fx.Initialize("OMX.broadcom.image_fx", OMX_IndexParamImageInit))
       return false;
@@ -296,16 +297,24 @@ bool COMXVideo::PortSettingsChanged()
     }
   }
 
-  if(m_deinterlace)
+  if(m_deinterlace || m_anaglyph)
   {
     OMX_CONFIG_IMAGEFILTERPARAMSTYPE image_filter;
     OMX_INIT_STRUCTURE(image_filter);
 
     image_filter.nPortIndex = m_omx_image_fx.GetOutputPort();
-    image_filter.nNumParams = 1;
-    image_filter.nParams[0] = 3;
-    image_filter.eImageFilter = OMX_ImageFilterDeInterlaceAdvanced;
-
+    if (m_anaglyph != OMX_ImageFilterAnaglyphNone)
+    {
+      image_filter.nNumParams = 1;
+      image_filter.nParams[0] = m_anaglyph;
+      image_filter.eImageFilter = OMX_ImageFilterAnaglyph;
+    }
+    else
+    {
+      image_filter.nNumParams = 1;
+      image_filter.nParams[0] = 3;
+      image_filter.eImageFilter = OMX_ImageFilterDeInterlaceAdvanced;
+    }
     omx_err = m_omx_image_fx.SetConfig(OMX_IndexConfigCommonImageFilterParameters, &image_filter);
     if(omx_err != OMX_ErrorNone)
     {
@@ -314,7 +323,7 @@ bool COMXVideo::PortSettingsChanged()
     }
   }
 
-  if(m_deinterlace)
+  if(m_deinterlace || m_anaglyph)
   {
     m_omx_tunnel_decoder.Initialize(&m_omx_decoder, m_omx_decoder.GetOutputPort(), &m_omx_image_fx, m_omx_image_fx.GetInputPort());
     m_omx_tunnel_image_fx.Initialize(&m_omx_image_fx, m_omx_image_fx.GetOutputPort(), &m_omx_sched, m_omx_sched.GetInputPort());
@@ -341,7 +350,7 @@ bool COMXVideo::PortSettingsChanged()
     return false;
   }
 
-  if(m_deinterlace)
+  if(m_deinterlace || m_anaglyph)
   {
     omx_err = m_omx_tunnel_image_fx.Establish();
     if(omx_err != OMX_ErrorNone)
@@ -383,7 +392,7 @@ bool COMXVideo::PortSettingsChanged()
   return true;
 }
 
-bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, EDEINTERLACEMODE deinterlace, bool hdmi_clock_sync)
+bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, EDEINTERLACEMODE deinterlace, OMX_IMAGEFILTERANAGLYPHTYPE anaglyph, bool hdmi_clock_sync)
 {
   CSingleLock lock (m_critSection);
   bool vflip = false;
@@ -523,6 +532,7 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, EDEINTERLACEMODE de
     break;
   }
   m_deinterlace_request = deinterlace;
+  m_anaglyph = anaglyph;
 
   if(!m_omx_decoder.Initialize(decoder_name, OMX_IndexParamVideoInit))
     return false;
@@ -734,7 +744,7 @@ void COMXVideo::Close()
   dump_omx_buffer(NULL);
   m_omx_tunnel_clock.Deestablish();
   m_omx_tunnel_decoder.Deestablish();
-  if(m_deinterlace)
+  if(m_deinterlace || m_anaglyph)
     m_omx_tunnel_image_fx.Deestablish();
   m_omx_tunnel_sched.Deestablish();
 
@@ -742,7 +752,7 @@ void COMXVideo::Close()
 
   m_omx_sched.Deinitialize();
   m_omx_decoder.Deinitialize();
-  if(m_deinterlace)
+  if(m_deinterlace || m_anaglyph)
     m_omx_image_fx.Deinitialize();
   m_omx_render.Deinitialize();
 
@@ -755,6 +765,7 @@ void COMXVideo::Close()
 
   m_video_codec_name  = "";
   m_deinterlace       = false;
+  m_anaglyph          = OMX_ImageFilterAnaglyphNone;
   m_av_clock          = NULL;
 
   m_res_ctx           = NULL;
@@ -878,7 +889,7 @@ void COMXVideo::Reset(void)
 
   m_setStartTime = true;
   m_omx_decoder.FlushInput();
-  if(m_deinterlace)
+  if(m_deinterlace || m_anaglyph)
     m_omx_image_fx.FlushInput();
 }
 
diff --git a/xbmc/cores/omxplayer/OMXVideo.h b/xbmc/cores/omxplayer/OMXVideo.h
index 226000e..e2e79c2 100644
--- a/xbmc/cores/omxplayer/OMXVideo.h
+++ b/xbmc/cores/omxplayer/OMXVideo.h
@@ -49,7 +49,7 @@ class COMXVideo
 
   // Required overrides
   bool SendDecoderConfig();
-  bool Open(CDVDStreamInfo &hints, OMXClock *clock, EDEINTERLACEMODE deinterlace = VS_DEINTERLACEMODE_OFF, bool hdmi_clock_sync = false);
+  bool Open(CDVDStreamInfo &hints, OMXClock *clock, EDEINTERLACEMODE deinterlace = VS_DEINTERLACEMODE_OFF, OMX_IMAGEFILTERANAGLYPHTYPE anaglyph = OMX_ImageFilterAnaglyphNone, bool hdmi_clock_sync = false);
   bool PortSettingsChanged();
   void RegisterResolutionUpdateCallBack(void *ctx, ResolutionUpdateCallBackFn callback) { m_res_ctx = ctx; m_res_callback = callback; }
   void Close(void);
@@ -94,6 +94,7 @@ class COMXVideo
 
   bool              m_deinterlace;
   EDEINTERLACEMODE  m_deinterlace_request;
+  OMX_IMAGEFILTERANAGLYPHTYPE m_anaglyph;
   bool              m_hdmi_clock_sync;
   ResolutionUpdateCallBackFn m_res_callback;
   void              *m_res_ctx;
diff --git a/xbmc/rendering/RenderSystem.cpp b/xbmc/rendering/RenderSystem.cpp
index e5a98f6..3ee28e0 100644
--- a/xbmc/rendering/RenderSystem.cpp
+++ b/xbmc/rendering/RenderSystem.cpp
@@ -73,6 +73,10 @@ bool CRenderSystemBase::SupportsStereo(RENDER_STEREO_MODE mode) const
     case RENDER_STEREO_MODE_SPLIT_HORIZONTAL:
     case RENDER_STEREO_MODE_SPLIT_VERTICAL:
     case RENDER_STEREO_MODE_MONO:
+#ifdef TARGET_RASPBERRY_PI
+    case RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN:
+    case RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA:
+#endif
       return true;
     default:
       return false;
-- 
1.9.3


From 6f203e648a17355451f48251837f4d281cfee04b Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 2 Jul 2014 12:24:01 +0100
Subject: [PATCH 89/99] [settings] Add update flag to omx acceleration

---
 system/settings/settings.xml | 3 +++
 xbmc/settings/Settings.cpp   | 1 +
 2 files changed, 4 insertions(+)

diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index 3e8118b..9b87290 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -740,6 +740,9 @@
           </dependencies>
           <level>2</level>
           <default>true</default>
+          <updates>
+            <update type="change" />
+          </updates>
           <control type="toggle" />
         </setting>
         <setting id="videoplayer.usevideotoolbox" type="boolean" label="13432" help="36162">
diff --git a/xbmc/settings/Settings.cpp b/xbmc/settings/Settings.cpp
index b5ed60a..84b3225 100644
--- a/xbmc/settings/Settings.cpp
+++ b/xbmc/settings/Settings.cpp
@@ -720,6 +720,7 @@ void CSettings::InitializeISettingCallbacks()
   settingSet.insert("videoscreen.testpattern");
   settingSet.insert("videoplayer.useamcodec");
   settingSet.insert("videoplayer.usemediacodec");
+  settingSet.insert("videoplayer.useomx");
   m_settingsManager->RegisterCallback(&g_application, settingSet);
 
   settingSet.clear();
-- 
1.9.3


From f75f4a67faef560be8c1102b0f059e45b6fe0c3c Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 1 Jul 2014 00:38:54 +0100
Subject: [PATCH 90/99] [omx] Avoid hang following jpegs that failed to decode

There's a few instanced of xbmc hanging following a jpeg that failed to decode on GPU:
http://forum.stmlabs.com/showthread.php?tid=14839
https://github.com/raspberrypi/firmware/issues/288
http://openelec.tv/forum/120-news-announcements/70709-openelec-4-0-released?start=15#105219

It should fail and continue with software decode. It hangs on the OMX_FreeBuffer call.
Looks like image_decode component should be returned to idle state before freeing buffers
when operation did not complete successfully
---
 xbmc/cores/omxplayer/OMXImage.cpp | 78 ++++++++++++++++++++++++++-------------
 xbmc/cores/omxplayer/OMXImage.h   |  4 ++
 2 files changed, 56 insertions(+), 26 deletions(-)

diff --git a/xbmc/cores/omxplayer/OMXImage.cpp b/xbmc/cores/omxplayer/OMXImage.cpp
index d2f6b21..085d050 100644
--- a/xbmc/cores/omxplayer/OMXImage.cpp
+++ b/xbmc/cores/omxplayer/OMXImage.cpp
@@ -905,6 +905,7 @@ COMXImageDec::COMXImageDec()
 {
   m_decoded_buffer = NULL;
   OMX_INIT_STRUCTURE(m_decoded_format);
+  m_success = false;
 }
 
 COMXImageDec::~COMXImageDec()
@@ -919,15 +920,20 @@ void COMXImageDec::Close()
 {
   CSingleLock lock(m_OMXSection);
 
-  if(m_omx_decoder.IsInitialized())
-  {
-    m_omx_decoder.FlushInput();
-    m_omx_decoder.FreeInputBuffers();
-  }
-  if(m_omx_resize.IsInitialized())
+  if (!m_success)
   {
-    m_omx_resize.FlushOutput();
-    m_omx_resize.FreeOutputBuffers();
+    if(m_omx_decoder.IsInitialized())
+    {
+      m_omx_decoder.SetStateForComponent(OMX_StateIdle);
+      m_omx_decoder.FlushInput();
+      m_omx_decoder.FreeInputBuffers();
+    }
+    if(m_omx_resize.IsInitialized())
+    {
+      m_omx_resize.SetStateForComponent(OMX_StateIdle);
+      m_omx_resize.FlushOutput();
+      m_omx_resize.FreeOutputBuffers();
+    }
   }
   if(m_omx_tunnel_decode.IsInitialized())
     m_omx_tunnel_decode.Deestablish();
@@ -1180,6 +1186,7 @@ bool COMXImageDec::Decode(const uint8_t *demuxer_content, unsigned demuxer_bytes
 
   memcpy( (char*)pixels, m_decoded_buffer->pBuffer, stride * height);
 
+  m_success = true;
   Close();
   return true;
 }
@@ -1194,6 +1201,7 @@ COMXImageEnc::COMXImageEnc()
   CSingleLock lock(m_OMXSection);
   OMX_INIT_STRUCTURE(m_encoded_format);
   m_encoded_buffer = NULL;
+  m_success = false;
 }
 
 COMXImageEnc::~COMXImageEnc()
@@ -1419,6 +1427,7 @@ COMXImageReEnc::COMXImageReEnc()
   m_encoded_buffer = NULL;
   m_pDestBuffer = NULL;
   m_nDestAllocSize = 0;
+  m_success = false;
 }
 
 COMXImageReEnc::~COMXImageReEnc()
@@ -1434,15 +1443,24 @@ void COMXImageReEnc::Close()
 {
   CSingleLock lock(m_OMXSection);
 
-  if(m_omx_decoder.IsInitialized())
-  {
-    m_omx_decoder.FlushInput();
-    m_omx_decoder.FreeInputBuffers();
-  }
-  if(m_omx_encoder.IsInitialized())
+  if (!m_success)
   {
-    m_omx_encoder.FlushOutput();
-    m_omx_encoder.FreeOutputBuffers();
+    if(m_omx_decoder.IsInitialized())
+    {
+      m_omx_decoder.SetStateForComponent(OMX_StateIdle);
+      m_omx_decoder.FlushInput();
+      m_omx_decoder.FreeInputBuffers();
+    }
+    if(m_omx_resize.IsInitialized())
+    {
+      m_omx_resize.SetStateForComponent(OMX_StateIdle);
+    }
+    if(m_omx_encoder.IsInitialized())
+    {
+      m_omx_encoder.SetStateForComponent(OMX_StateIdle);
+      m_omx_encoder.FlushOutput();
+      m_omx_encoder.FreeOutputBuffers();
+    }
   }
   if(m_omx_tunnel_decode.IsInitialized())
     m_omx_tunnel_decode.Deestablish();
@@ -1859,14 +1877,15 @@ bool COMXImageReEnc::ReEncode(COMXImageFile &srcFile, unsigned int maxWidth, uns
     }
   }
 
-  Close();
-
   if(m_omx_decoder.BadState())
     return false;
 
   pDestBuffer = m_pDestBuffer;
   CLog::Log(LOGDEBUG, "%s::%s : %s %dx%d -> %dx%d\n", CLASSNAME, __func__, srcFile.GetFilename(), srcFile.GetWidth(), srcFile.GetHeight(), maxWidth, maxHeight);
 
+  m_success = true;
+  Close();
+
   return true;
 }
 
@@ -1878,6 +1897,7 @@ bool COMXImageReEnc::ReEncode(COMXImageFile &srcFile, unsigned int maxWidth, uns
 
 COMXTexture::COMXTexture()
 {
+  m_success = false;
 }
 
 COMXTexture::~COMXTexture()
@@ -1889,15 +1909,20 @@ void COMXTexture::Close()
 {
   CSingleLock lock(m_OMXSection);
 
-  if(m_omx_decoder.IsInitialized())
-  {
-    m_omx_decoder.FlushInput();
-    m_omx_decoder.FreeInputBuffers();
-  }
-  if(m_omx_egl_render.IsInitialized())
+  if (!m_success)
   {
-    m_omx_egl_render.FlushOutput();
-    m_omx_egl_render.FreeOutputBuffers();
+    if(m_omx_decoder.IsInitialized())
+    {
+      m_omx_decoder.SetStateForComponent(OMX_StateIdle);
+      m_omx_decoder.FlushInput();
+      m_omx_decoder.FreeInputBuffers();
+    }
+    if(m_omx_egl_render.IsInitialized())
+    {
+      m_omx_egl_render.SetStateForComponent(OMX_StateIdle);
+      m_omx_egl_render.FlushOutput();
+      m_omx_egl_render.FreeOutputBuffers();
+    }
   }
   if (m_omx_tunnel_decode.IsInitialized())
     m_omx_tunnel_decode.Deestablish();
@@ -2199,6 +2224,7 @@ bool COMXTexture::Decode(const uint8_t *demuxer_content, unsigned demuxer_bytes,
       eos = true;
     }
   }
+  m_success = true;
   Close();
   return true;
 }
diff --git a/xbmc/cores/omxplayer/OMXImage.h b/xbmc/cores/omxplayer/OMXImage.h
index 9518190..90e513a 100644
--- a/xbmc/cores/omxplayer/OMXImage.h
+++ b/xbmc/cores/omxplayer/OMXImage.h
@@ -132,6 +132,7 @@ class COMXImageDec
   OMX_BUFFERHEADERTYPE          *m_decoded_buffer;
   OMX_PARAM_PORTDEFINITIONTYPE  m_decoded_format;
   CCriticalSection              m_OMXSection;
+  bool                          m_success;
 };
 
 class COMXImageEnc
@@ -150,6 +151,7 @@ class COMXImageEnc
   OMX_BUFFERHEADERTYPE          *m_encoded_buffer;
   OMX_PARAM_PORTDEFINITIONTYPE  m_encoded_format;
   CCriticalSection              m_OMXSection;
+  bool                          m_success;
 };
 
 class COMXImageReEnc
@@ -173,6 +175,7 @@ class COMXImageReEnc
   CCriticalSection              m_OMXSection;
   void                          *m_pDestBuffer;
   unsigned int                  m_nDestAllocSize;
+  bool                          m_success;
 };
 
 class COMXTexture
@@ -197,6 +200,7 @@ class COMXTexture
 
   OMX_BUFFERHEADERTYPE *m_egl_buffer;
   CCriticalSection              m_OMXSection;
+  bool              m_success;
 };
 
 extern COMXImage g_OMXImage;
-- 
1.9.3


From b51ea932eb3590cb06b9aefaaf001e0eab275dc6 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 2 Jul 2014 20:41:29 +0100
Subject: [PATCH 91/99] [pi] Reduce time textures are held for when memory is
 low

---
 xbmc/Application.cpp |  9 +++++++++
 xbmc/linux/RBP.cpp   | 10 ++++++++++
 xbmc/linux/RBP.h     |  1 +
 3 files changed, 20 insertions(+)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index 8415123..bdd1390 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -352,6 +352,10 @@
 #include "utils/AMLUtils.h"
 #endif
 
+#if defined(TARGET_RASPBERRY_PI)
+#include "linux/RBP.h"
+#endif
+
 #include "cores/FFmpeg.h"
 
 using namespace std;
@@ -5198,6 +5202,11 @@ void CApplication::ProcessSlow()
   if (!m_pPlayer->IsPlayingVideo())
     g_largeTextureManager.CleanupUnusedImages();
 
+#ifdef TARGET_RASPBERRY_PI
+  if (g_RBP.GetGpuMemFree() < 64)
+    g_TextureManager.FreeUnusedTextures();
+  else
+#endif
   g_TextureManager.FreeUnusedTextures(5000);
 
 #ifdef HAS_DVD_DRIVE
diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index f789bf1..65c95a3 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -83,6 +83,16 @@ bool CRBP::Initialize()
   return true;
 }
 
+int CRBP::GetGpuMemFree()
+{
+  int reloc_mem = 0;
+  char response[80] = "";
+
+  if (vc_gencmd(response, sizeof response, "get_mem reloc") == 0)
+    vc_gencmd_number_property(response, "reloc", &reloc_mem);
+  return reloc_mem;
+}
+
 void CRBP::LogFirmwareVerison()
 {
   char  response[1024];
diff --git a/xbmc/linux/RBP.h b/xbmc/linux/RBP.h
index f06687c..bf6dfdb 100644
--- a/xbmc/linux/RBP.h
+++ b/xbmc/linux/RBP.h
@@ -50,6 +50,7 @@ class CRBP
   void Deinitialize();
   int GetArmMem() { return m_arm_mem; }
   int GetGpuMem() { return m_gpu_mem; }
+  int GetGpuMemFree();
   bool GetCodecMpg2() { return m_codec_mpg2_enabled; }
   bool GetCodecWvc1() { return m_codec_wvc1_enabled; }
   void GetDisplaySize(int &width, int &height);
-- 
1.9.3


From 9723e98bf9a3f4387b226e8d7d0313469b4cd0c8 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 2 Jul 2014 21:03:59 +0100
Subject: [PATCH 92/99] [omx] Restrict the number of outstanding jpeg calls to
 gpu

Allowing more than one outstanding call to gpu for texture encode/decode can be beneficial as processing
can be overlapped with vchiq message transfer.

Experimentally, 3 outstanding operations is optimal.

Allowing more that this ties up memory on GPU without any performance benefit, so avoid submitting more jobs
---
 xbmc/cores/omxplayer/OMXImage.cpp | 35 +++++++++++++++++++++++++++++++++++
 1 file changed, 35 insertions(+)

diff --git a/xbmc/cores/omxplayer/OMXImage.cpp b/xbmc/cores/omxplayer/OMXImage.cpp
index 085d050..efd3343 100644
--- a/xbmc/cores/omxplayer/OMXImage.cpp
+++ b/xbmc/cores/omxplayer/OMXImage.cpp
@@ -49,6 +49,33 @@
 #define EXIF_TAG_ORIENTATION    0x0112
 
 
+// A helper for restricting threads calling GPU functions to limit memory use
+static XbmcThreads::ConditionVariable g_count_cond;
+static CCriticalSection               g_count_lock;
+static int g_count_val;
+
+static void limit_calls_enter(int &count, int allowed)
+{
+  //printf("%s  in=%d\n", __func__, m_count_val);
+  CSingleLock lock(g_count_lock);
+  while (count >= allowed)
+  {
+    g_count_cond.wait(lock);
+  }
+  count++;
+  //printf("%s out=%d\n", __func__, m_count_val);
+}
+
+static void limit_calls_leave(int &count)
+{
+  //printf("%s  in=%d\n", __func__, m_count_val);
+  CSingleLock lock(g_count_lock);
+  count--;
+  g_count_cond.notifyAll();
+  //printf("%s out=%d\n", __func__, m_count_val);
+}
+
+
 #ifdef CLASSNAME
 #undef CLASSNAME
 #endif
@@ -903,6 +930,7 @@ bool COMXImageFile::ReadFile(const std::string& inputFile)
 
 COMXImageDec::COMXImageDec()
 {
+  limit_calls_enter(g_count_val, 3);
   m_decoded_buffer = NULL;
   OMX_INIT_STRUCTURE(m_decoded_format);
   m_success = false;
@@ -914,6 +942,7 @@ COMXImageDec::~COMXImageDec()
 
   OMX_INIT_STRUCTURE(m_decoded_format);
   m_decoded_buffer = NULL;
+  limit_calls_leave(g_count_val);
 }
 
 void COMXImageDec::Close()
@@ -1198,6 +1227,7 @@ bool COMXImageDec::Decode(const uint8_t *demuxer_content, unsigned demuxer_bytes
 
 COMXImageEnc::COMXImageEnc()
 {
+  limit_calls_enter(g_count_val, 3);
   CSingleLock lock(m_OMXSection);
   OMX_INIT_STRUCTURE(m_encoded_format);
   m_encoded_buffer = NULL;
@@ -1212,6 +1242,7 @@ COMXImageEnc::~COMXImageEnc()
   m_encoded_buffer = NULL;
   if(m_omx_encoder.IsInitialized())
     m_omx_encoder.Deinitialize();
+  limit_calls_leave(g_count_val);
 }
 
 bool COMXImageEnc::Encode(unsigned char *buffer, int size, unsigned width, unsigned height, unsigned int pitch)
@@ -1424,6 +1455,7 @@ bool COMXImageEnc::CreateThumbnailFromSurface(unsigned char* buffer, unsigned in
 
 COMXImageReEnc::COMXImageReEnc()
 {
+  limit_calls_enter(g_count_val, 3);
   m_encoded_buffer = NULL;
   m_pDestBuffer = NULL;
   m_nDestAllocSize = 0;
@@ -1437,6 +1469,7 @@ COMXImageReEnc::~COMXImageReEnc()
     free (m_pDestBuffer);
   m_pDestBuffer = NULL;
   m_nDestAllocSize = 0;
+  limit_calls_leave(g_count_val);
 }
 
 void COMXImageReEnc::Close()
@@ -1897,12 +1930,14 @@ bool COMXImageReEnc::ReEncode(COMXImageFile &srcFile, unsigned int maxWidth, uns
 
 COMXTexture::COMXTexture()
 {
+  limit_calls_enter(g_count_val, 3);
   m_success = false;
 }
 
 COMXTexture::~COMXTexture()
 {
   Close();
+  limit_calls_leave(g_count_val);
 }
 
 void COMXTexture::Close()
-- 
1.9.3


From b8837ec20d7b68b2441da31bc48ab2ec2b2be2e2 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 5 Jul 2014 19:26:46 +0100
Subject: [PATCH 93/99] [omxplayer] Explictly choose deinterlace method for
 1080i

As the 1080i deinterlace doesn't require the 3 frames of context we can save ~9MB by requesting it explicitly
---
 xbmc/cores/omxplayer/OMXVideo.cpp | 22 +++++++++++++++++++++-
 1 file changed, 21 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/omxplayer/OMXVideo.cpp b/xbmc/cores/omxplayer/OMXVideo.cpp
index 07c4643..15b62af 100644
--- a/xbmc/cores/omxplayer/OMXVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXVideo.cpp
@@ -299,6 +299,23 @@ bool COMXVideo::PortSettingsChanged()
 
   if(m_deinterlace || m_anaglyph)
   {
+    bool advanced_deinterlace = port_image.format.video.nFrameWidth * port_image.format.video.nFrameHeight <= 576 * 720;
+
+    if (m_anaglyph != OMX_ImageFilterAnaglyphNone || !advanced_deinterlace)
+    {
+      // Image_fx assumed 3 frames of context. anaglyph and simple deinterlace don't require this
+      OMX_PARAM_U32TYPE extra_buffers;
+      OMX_INIT_STRUCTURE(extra_buffers);
+      extra_buffers.nU32 = -2;
+
+      omx_err = m_omx_image_fx.SetParameter(OMX_IndexParamBrcmExtraBuffers, &extra_buffers);
+      if(omx_err != OMX_ErrorNone)
+      {
+        CLog::Log(LOGERROR, "%s::%s error OMX_IndexParamBrcmExtraBuffers omx_err(0x%08x)", CLASSNAME, __func__, omx_err);
+        return false;
+      }
+    }
+
     OMX_CONFIG_IMAGEFILTERPARAMSTYPE image_filter;
     OMX_INIT_STRUCTURE(image_filter);
 
@@ -313,7 +330,10 @@ bool COMXVideo::PortSettingsChanged()
     {
       image_filter.nNumParams = 1;
       image_filter.nParams[0] = 3;
-      image_filter.eImageFilter = OMX_ImageFilterDeInterlaceAdvanced;
+      if (!advanced_deinterlace)
+        image_filter.eImageFilter = OMX_ImageFilterDeInterlaceFast;
+      else
+        image_filter.eImageFilter = OMX_ImageFilterDeInterlaceAdvanced;
     }
     omx_err = m_omx_image_fx.SetConfig(OMX_IndexConfigCommonImageFilterParameters, &image_filter);
     if(omx_err != OMX_ErrorNone)
-- 
1.9.3


From d8c342416463b82d1bf890a304d5c1c0253e96b3 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 8 Jul 2014 21:00:44 +0100
Subject: [PATCH 94/99] [omxcodec] Fix 3D rendering for dvdplayer

Similar to https://github.com/xbmc/xbmc/pull/3887
---
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp | 31 +++++++++++++++++++++----
 1 file changed, 27 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index 53873f6..84a46ec 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -1369,10 +1369,11 @@ void CLinuxRendererGLES::RenderOpenMax(int index, int field)
   }
 
   // Set texture coordinates
-  tex[0][0] = tex[3][0] = 0;
-  tex[0][1] = tex[1][1] = 0;
-  tex[1][0] = tex[2][0] = 1;
-  tex[2][1] = tex[3][1] = 1;
+  YUVPLANE &plane = m_buffers[index].fields[0][0];
+  tex[0][0] = tex[3][0] = plane.rect.x1;
+  tex[0][1] = tex[1][1] = plane.rect.y1;
+  tex[1][0] = tex[2][0] = plane.rect.x2;
+  tex[2][1] = tex[3][1] = plane.rect.y2;
 
   glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_BYTE, idx);
 
@@ -2506,6 +2507,7 @@ void CLinuxRendererGLES::UploadOMXEGLTexture(int index)
   {
     //buf.openMaxBuffer->Sync();
   }
+  CalculateTextureSourceRects(index, 1);
 #endif
 }
 void CLinuxRendererGLES::DeleteOMXEGLTexture(int index)
@@ -2518,6 +2520,27 @@ void CLinuxRendererGLES::DeleteOMXEGLTexture(int index)
 }
 bool CLinuxRendererGLES::CreateOMXEGLTexture(int index)
 {
+  YV12Image &im     = m_buffers[index].image;
+  YUVFIELDS &fields = m_buffers[index].fields;
+  YUVPLANE  &plane  = fields[0][0];
+
+  memset(&im    , 0, sizeof(im));
+  memset(&fields, 0, sizeof(fields));
+
+  im.height = m_sourceHeight;
+  im.width  = m_sourceWidth;
+
+  plane.texwidth  = im.width;
+  plane.texheight = im.height;
+  plane.pixpertex_x = 1;
+  plane.pixpertex_y = 1;
+
+  if(m_renderMethod & RENDER_POT)
+  {
+    plane.texwidth  = NP2(plane.texwidth);
+    plane.texheight = NP2(plane.texheight);
+  }
+
   DeleteOMXEGLTexture(index);
   return true;
 }
-- 
1.9.3


From 57d075ae9b88cb6d25b04095e3f9c3c3f7a95289 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 9 Jul 2014 22:45:43 +0100
Subject: [PATCH 95/99] [rbp] Make cachemembuffersize default depend on memory
 size

---
 xbmc/linux/RBP.cpp                 | 5 +++++
 xbmc/settings/AdvancedSettings.cpp | 5 +++++
 2 files changed, 10 insertions(+)

diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index 65c95a3..bbf7ab5 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -21,6 +21,7 @@
 #include "RBP.h"
 #if defined(TARGET_RASPBERRY_PI)
 
+#include "settings/AdvancedSettings.h"
 #include "utils/log.h"
 
 #include "cores/omxplayer/OMXImage.h"
@@ -75,6 +76,9 @@ bool CRBP::Initialize()
   if (m_gpu_mem < 128)
     setenv("V3D_DOUBLE_BUFFER", "1", 1);
 
+  if (g_advancedSettings.m_cacheMemBufferSize == ~0)
+    g_advancedSettings.m_cacheMemBufferSize = m_arm_mem < 256 ? 1024 * 1024 * 2 : 1024 * 1024 * 20;
+
   // in case xbcm was restarted when suspended
   ResumeVideoOutput();
 
@@ -100,6 +104,7 @@ void CRBP::LogFirmwareVerison()
   response[sizeof(response) - 1] = '\0';
   CLog::Log(LOGNOTICE, "Raspberry PI firmware version: %s", response);
   CLog::Log(LOGNOTICE, "ARM mem: %dMB GPU mem: %dMB MPG2:%d WVC1:%d", m_arm_mem, m_gpu_mem, m_codec_mpg2_enabled, m_codec_wvc1_enabled);
+  CLog::Log(LOGNOTICE, "cacheMemBufferSize: %dMB",  g_advancedSettings.m_cacheMemBufferSize >> 20);
   m_DllBcmHost->vc_gencmd(response, sizeof response, "get_config int");
   response[sizeof(response) - 1] = '\0';
   CLog::Log(LOGNOTICE, "Config:\n%s", response);
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 1175eb1..fcf3fa7 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -364,7 +364,12 @@ void CAdvancedSettings::Initialize()
 
   m_measureRefreshrate = false;
 
+#ifdef TARGET_RASPBERRY_PI
+  // want default to be memory dependent, but interface to gpu not available yet, so set in RBP.cpp
+  m_cacheMemBufferSize = ~0;
+#else
   m_cacheMemBufferSize = 1024 * 1024 * 20;
+#endif
   m_networkBufferMode = 0; // Default (buffer all internet streams/filesystems)
   // the following setting determines the readRate of a player data
   // as multiply of the default data read rate
-- 
1.9.3


From b9b8cd6d8893e12ac3f9bc81d94e04874e3dcf13 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 9 Jul 2014 23:31:32 +0100
Subject: [PATCH 96/99] [rbp] Make gui limit default to 720 when memory is
 limited

---
 system/settings/rbp.xml | 4 ++--
 xbmc/linux/RBP.cpp      | 4 ++++
 2 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/system/settings/rbp.xml b/system/settings/rbp.xml
index 1429256..5d47c28 100644
--- a/system/settings/rbp.xml
+++ b/system/settings/rbp.xml
@@ -32,9 +32,9 @@
         </setting>
         <setting id="videoscreen.limitgui" type="integer" label="37021" help="36548">
           <level>2</level>
-          <default>1080</default>
+          <default>0</default>
           <constraints>
-            <minimum>540</minimum>
+            <minimum>0</minimum>
             <step>16</step>
             <maximum>1080</maximum>
           </constraints>
diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index bbf7ab5..85e1f21 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -22,6 +22,7 @@
 #if defined(TARGET_RASPBERRY_PI)
 
 #include "settings/AdvancedSettings.h"
+#include "settings/Settings.h"
 #include "utils/log.h"
 
 #include "cores/omxplayer/OMXImage.h"
@@ -79,6 +80,9 @@ bool CRBP::Initialize()
   if (g_advancedSettings.m_cacheMemBufferSize == ~0)
     g_advancedSettings.m_cacheMemBufferSize = m_arm_mem < 256 ? 1024 * 1024 * 2 : 1024 * 1024 * 20;
 
+  if (!CSettings::Get().GetInt("videoscreen.limitgui"))
+    CSettings::Get().SetInt("videoscreen.limitgui", m_gpu_mem < 128 ? 720:1080);
+
   // in case xbcm was restarted when suspended
   ResumeVideoOutput();
 
-- 
1.9.3


From 80f2924035713ee6094830548514b6df5d03d7c6 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 13 Jul 2014 11:28:20 +0100
Subject: [PATCH 97/99] [ResamplePi] Fix xbmc crash with usb audio when music
 file switched

Need to handle the case where AE requests fewer output samples that are produced.

See:
http://forum.xbmc.org/showthread.php?tid=199244
http://openelec.tv/forum/124-raspberry-pi/71119-openelec-4-0-1-crashes-after-each-song?start=15#110835
---
 .../Engines/ActiveAE/ActiveAEResamplePi.cpp        | 60 +++++++++++++++++-----
 .../Engines/ActiveAE/ActiveAEResamplePi.h          |  1 +
 2 files changed, 48 insertions(+), 13 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
index 1604030..08da688 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
@@ -69,6 +69,7 @@ CActiveAEResample::CActiveAEResample()
   m_last_dst_fmt = AV_SAMPLE_FMT_NONE;
   m_last_src_channels = 0;
   m_last_dst_channels = 0;
+  m_encoded_buffer = NULL;
 }
 
 CActiveAEResample::~CActiveAEResample()
@@ -382,6 +383,14 @@ bool CActiveAEResample::Init(uint64_t dst_chan_layout, int dst_channels, int dst
   return true;
 }
 
+
+static void copy_planes(uint8_t **dst_buffer, int d_pitch, int d_planes, int d_samplesize, int offset, uint8_t *src_buffer, int src_samples)
+{
+  int planesize = src_samples * d_samplesize / d_planes;
+  for (int i=0; i < d_planes; i++)
+    memcpy(dst_buffer[i] + offset * d_pitch, src_buffer + i * planesize, planesize);
+}
+
 int CActiveAEResample::Resample(uint8_t **dst_buffer, int dst_samples, uint8_t **src_buffer, int src_samples, double ratio)
 {
   #ifdef DEBUG_VERBOSE
@@ -398,21 +407,35 @@ int CActiveAEResample::Resample(uint8_t **dst_buffer, int dst_samples, uint8_t *
   const int s_pitch = s_chans * m_src_bits >> 3;
   const int d_pitch = d_chans * m_dst_bits >> 3;
 
+  const int s_samplesize = m_src_channels * m_src_bits >> 3;
+  const int d_samplesize = m_dst_channels * m_dst_bits >> 3;
+  const int max_src_samples = BUFFERSIZE / s_samplesize;
+  const int max_dst_samples = (long long)(BUFFERSIZE / d_samplesize) * m_src_rate / (m_dst_rate + m_src_rate-1);
+
   int sent = 0;
   int received = 0;
+
+  if (m_encoded_buffer && m_encoded_buffer->nFilledLen)
+  {
+    int samples_available = m_encoded_buffer->nFilledLen / d_samplesize - m_encoded_buffer->nOffset;
+    int samples = std::min(samples_available, dst_samples - received);
+    copy_planes(dst_buffer, d_pitch, d_planes, d_samplesize, received, (uint8_t *)m_encoded_buffer->pBuffer + m_encoded_buffer->nOffset * d_pitch, samples);
+    received += samples;
+    samples_available -= samples;
+    if (samples_available > 0)
+      m_encoded_buffer->nOffset += samples;
+    else
+      m_encoded_buffer = NULL;
+  }
+  assert(!m_encoded_buffer);
   while (sent < src_samples)
   {
     OMX_BUFFERHEADERTYPE *omx_buffer = NULL;
-    OMX_BUFFERHEADERTYPE *m_encoded_buffer = NULL;
 
     omx_buffer = m_omx_mixer.GetInputBuffer(1000);
     if (omx_buffer == NULL)
       return false;
 
-    const int s_samplesize = m_src_channels * m_src_bits >> 3;
-    const int d_samplesize = m_dst_channels * m_dst_bits >> 3;
-    const int max_src_samples = BUFFERSIZE / s_samplesize;
-    const int max_dst_samples = (long long)(BUFFERSIZE / d_samplesize) * m_src_rate / (m_dst_rate + m_src_rate-1);
     int send = std::min(std::min(max_dst_samples, max_src_samples), src_samples - sent);
 
     omx_buffer->nOffset = 0;
@@ -464,22 +487,28 @@ int CActiveAEResample::Resample(uint8_t **dst_buffer, int dst_samples, uint8_t *
 
     if (m_encoded_buffer->nFilledLen)
     {
-      int planesize = m_encoded_buffer->nFilledLen / d_planes;
-      for (int i=0; i < d_planes; i++)
-        memcpy(dst_buffer[i] + received * d_pitch, (uint8_t *)m_encoded_buffer->pBuffer + i * planesize, planesize);
-      received += m_encoded_buffer->nFilledLen / d_samplesize;
+      int samples_available = m_encoded_buffer->nFilledLen / d_samplesize;
+      int samples = std::min(samples_available, dst_samples - received);
+      copy_planes(dst_buffer, d_pitch, d_planes, d_samplesize, received, (uint8_t *)m_encoded_buffer->pBuffer, samples);
+      received += samples;
+      samples_available -= samples;
+      if (samples_available > 0)
+        m_encoded_buffer->nOffset += samples;
+      else
+        m_encoded_buffer = NULL;
     }
   }
   #ifdef DEBUG_VERBOSE
   CLog::Log(LOGINFO, "%s::%s format:%d->%d rate:%d->%d chan:%d->%d samples %d->%d (%f) %d =%d", CLASSNAME, __func__,
     (int)m_src_fmt, (int)m_dst_fmt, m_src_rate, m_dst_rate, m_src_channels, m_dst_channels, src_samples, dst_samples, ratio, m_Initialized, received);
   #endif
+  assert(received <= dst_samples);
   return received;
 }
 
 int64_t CActiveAEResample::GetDelay(int64_t base)
 {
-  int ret = 0;
+  int ret = m_dst_rate ? 1000 * GetBufferedSamples() / m_dst_rate : 0;
   #ifdef DEBUG_VERBOSE
   CLog::Log(LOGINFO, "%s::%s = %d", CLASSNAME, __func__, ret);
   #endif
@@ -488,11 +517,16 @@ int64_t CActiveAEResample::GetDelay(int64_t base)
 
 int CActiveAEResample::GetBufferedSamples()
 {
-  int ret = 0;
+  int samples = 0;
+  if (m_encoded_buffer)
+  {
+    const int d_samplesize = m_dst_channels * m_dst_bits >> 3;
+    samples = m_encoded_buffer->nFilledLen / d_samplesize - m_encoded_buffer->nOffset;
+  }
   #ifdef DEBUG_VERBOSE
-  CLog::Log(LOGINFO, "%s::%s = %d", CLASSNAME, __func__, ret);
+  CLog::Log(LOGINFO, "%s::%s = %d", CLASSNAME, __func__, samples);
   #endif
-  return ret;
+  return samples;
 }
 
 int CActiveAEResample::CalcDstSampleCount(int src_samples, int dst_rate, int src_rate)
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.h
index 47a9e08..b88a90b 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.h
@@ -57,6 +57,7 @@ class CActiveAEResample
   bool                 m_Initialized;
   AVSampleFormat m_last_src_fmt, m_last_dst_fmt;
   int m_last_src_channels, m_last_dst_channels;
+  OMX_BUFFERHEADERTYPE *m_encoded_buffer;
 };
 
 }
-- 
1.9.3


From 10a26b5fd921c328f0c4c152caa8a348baffa4c2 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Thu, 17 Jul 2014 08:40:22 +0200
Subject: [PATCH 98/99] ffmpeg: bump to 2.3

---
 tools/depends/target/ffmpeg/FFMPEG-VERSION | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/tools/depends/target/ffmpeg/FFMPEG-VERSION b/tools/depends/target/ffmpeg/FFMPEG-VERSION
index 33f458e..d394b94 100644
--- a/tools/depends/target/ffmpeg/FFMPEG-VERSION
+++ b/tools/depends/target/ffmpeg/FFMPEG-VERSION
@@ -1,5 +1,5 @@
 LIBNAME=ffmpeg
 BASE_URL=https://github.com/xbmc/FFmpeg/archive
-VERSION=2.2-Helix-alpha2
+VERSION=2.3-Helix-alpha2
 ARCHIVE=$(LIBNAME)-$(VERSION).tar.gz
 
-- 
1.9.3


From dc0901d679e407e66274a6acbe3a1356434c7c3b Mon Sep 17 00:00:00 2001
From: Memphiz <memphis@machzwo.de>
Date: Thu, 17 Jul 2014 09:14:45 +0200
Subject: [PATCH 99/99] - bump gas to
 https://git.libav.org/?p=gas-preprocessor.git;a=commit;h=03e23216b7e657fdf202befc129ca94cd582c253
 - needed for ffmpeg2.3 compilation on ios

---
 .../gas-preprocessor-native/gas-preprocessor.pl    | 847 ++++++++++++++++-----
 1 file changed, 654 insertions(+), 193 deletions(-)

diff --git a/tools/depends/native/gas-preprocessor-native/gas-preprocessor.pl b/tools/depends/native/gas-preprocessor-native/gas-preprocessor.pl
index f932c60..9cc3610 100755
--- a/tools/depends/native/gas-preprocessor-native/gas-preprocessor.pl
+++ b/tools/depends/native/gas-preprocessor-native/gas-preprocessor.pl
@@ -10,17 +10,74 @@
 # implements the subset of the gas preprocessor used by x264 and ffmpeg
 # that isn't supported by Apple's gas.
 
-my @gcc_cmd = @ARGV;
+my %canonical_arch = ("aarch64" => "aarch64", "arm64" => "aarch64",
+                      "arm"     => "arm",
+                      "powerpc" => "powerpc", "ppc"   => "powerpc");
+
+my %comments = ("aarch64" => '//',
+                "arm"     => '@',
+                "powerpc" => '#');
+
+my @gcc_cmd;
 my @preprocess_c_cmd;
 
+my $comm;
+my $arch;
+my $as_type = "apple-gas";
+
 my $fix_unreq = $^O eq "darwin";
+my $force_thumb = 0;
+
+my $arm_cond_codes = "eq|ne|cs|cc|mi|pl|vs|vc|hi|ls|ge|lt|gt|le|al|hs|lo";
+
+my $usage_str = "
+$0\n
+Gas-preprocessor.pl converts assembler files using modern GNU as syntax for
+Apple's ancient gas version or clang's incompatible integrated assembler. The
+conversion is regularly tested for Libav, x264 and vlc. Other projects might
+use different features which are not correctly handled.
+
+Options for this program needs to be separated with ' -- ' from the assembler
+command. Following options are currently supported:
+
+    -help         - this usage text
+    -arch         - target architecture
+    -as-type      - one value out of {{,apple-}{gas,clang},armasm}
+    -fix-unreq
+    -no-fix-unreq
+    -force-thumb  - assemble as thumb regardless of the input source
+                    (note, this is incomplete and only works for sources
+                    it explicitly was tested with)
+";
+
+sub usage() {
+    print $usage_str;
+}
 
-if ($gcc_cmd[0] eq "-fix-unreq") {
-    $fix_unreq = 1;
-    shift @gcc_cmd;
-} elsif ($gcc_cmd[0] eq "-no-fix-unreq") {
-    $fix_unreq = 0;
-    shift @gcc_cmd;
+while (@ARGV) {
+    my $opt = shift;
+
+    if ($opt =~ /^-(no-)?fix-unreq$/) {
+        $fix_unreq = $1 ne "no-";
+    } elsif ($opt eq "-force-thumb") {
+        $force_thumb = 1;
+    } elsif ($opt eq "-arch") {
+        $arch = shift;
+        die "unknown arch: '$arch'\n" if not exists $comments{$arch};
+    } elsif ($opt eq "-as-type") {
+        $as_type = shift;
+        die "unknown as type: '$as_type'\n" if $as_type !~ /^((apple-)?(gas|clang)|armasm)$/;
+    } elsif ($opt eq "-help") {
+        usage();
+        exit 0;
+    } elsif ($opt eq "--" ) {
+	@gcc_cmd = @ARGV;
+    } elsif ($opt =~ /^-/) {
+        die "option '$opt' is not known. See '$0 -help' for usage information\n";
+    } else {
+	push @gcc_cmd, $opt, @ARGV;
+    }
+    last if (@gcc_cmd);
 }
 
 if (grep /\.c$/, @gcc_cmd) {
@@ -29,9 +86,33 @@
 } elsif (grep /\.[sS]$/, @gcc_cmd) {
     # asm file, just do C preprocessor
     @preprocess_c_cmd = (@gcc_cmd, "-E");
+} elsif (grep /-(v|-version|dumpversion)/, @gcc_cmd) {
+    # pass -v/--version along, used during probing. Matching '-v' might have
+    # uninteded results but it doesn't matter much if gas-preprocessor or
+    # the compiler fails.
+    exec(@gcc_cmd);
 } else {
     die "Unrecognized input filetype";
 }
+if ($as_type eq "armasm") {
+
+    $preprocess_c_cmd[0] = "cpp";
+
+    @preprocess_c_cmd = grep ! /^-nologo$/, @preprocess_c_cmd;
+    # Remove -ignore XX parameter pairs from preprocess_c_cmd
+    my $index = 1;
+    while ($index < $#preprocess_c_cmd) {
+        if ($preprocess_c_cmd[$index] eq "-ignore" and $index + 1 < $#preprocess_c_cmd) {
+            splice(@preprocess_c_cmd, $index, 2);
+            next;
+        }
+        $index++;
+    }
+    if (grep /^-MM$/, @preprocess_c_cmd) {
+        system(@preprocess_c_cmd) == 0 or die "Error running preprocessor";
+        exit 0;
+    }
+}
 
 # if compiling, avoid creating an output file named '-.o'
 if ((grep /^-c$/, @gcc_cmd) && !(grep /^-o/, @gcc_cmd)) {
@@ -45,50 +126,95 @@
         }
     }
 }
-@gcc_cmd = map { /\.[csS]$/ ? qw(-x assembler -) : $_ } @gcc_cmd;
-@preprocess_c_cmd = map { /\.o$/ ? "-" : $_ } @preprocess_c_cmd;
-
-my $comm;
+# replace only the '-o' argument with '-', avoids rewriting the make dependency
+# target specified with -MT to '-'
+my $index = 1;
+while ($index < $#preprocess_c_cmd) {
+    if ($preprocess_c_cmd[$index] eq "-o") {
+        $index++;
+        $preprocess_c_cmd[$index] = "-";
+    }
+    $index++;
+}
 
-# detect architecture from gcc binary name
-if      ($gcc_cmd[0] =~ /arm/) {
-    $comm = '@';
-} elsif ($gcc_cmd[0] =~ /powerpc|ppc/) {
-    $comm = '#';
+my $tempfile;
+if ($as_type ne "armasm") {
+    @gcc_cmd = map { /\.[csS]$/ ? qw(-x assembler -) : $_ } @gcc_cmd;
+} else {
+    @preprocess_c_cmd = grep ! /^-c$/, @preprocess_c_cmd;
+    @preprocess_c_cmd = grep ! /^-m/, @preprocess_c_cmd;
+
+    @preprocess_c_cmd = grep ! /^-G/, @preprocess_c_cmd;
+    @preprocess_c_cmd = grep ! /^-W/, @preprocess_c_cmd;
+    @preprocess_c_cmd = grep ! /^-Z/, @preprocess_c_cmd;
+    @preprocess_c_cmd = grep ! /^-fp/, @preprocess_c_cmd;
+    @preprocess_c_cmd = grep ! /^-EHsc$/, @preprocess_c_cmd;
+    @preprocess_c_cmd = grep ! /^-O/, @preprocess_c_cmd;
+
+    @gcc_cmd = grep ! /^-G/, @gcc_cmd;
+    @gcc_cmd = grep ! /^-W/, @gcc_cmd;
+    @gcc_cmd = grep ! /^-Z/, @gcc_cmd;
+    @gcc_cmd = grep ! /^-fp/, @gcc_cmd;
+    @gcc_cmd = grep ! /^-EHsc$/, @gcc_cmd;
+    @gcc_cmd = grep ! /^-O/, @gcc_cmd;
+
+    my @outfiles = grep /\.(o|obj)$/, @gcc_cmd;
+    $tempfile = $outfiles[0].".asm";
+
+    # Remove most parameters from gcc_cmd, which actually is the armasm command,
+    # which doesn't support any of the common compiler/preprocessor options.
+    @gcc_cmd = grep ! /^-D/, @gcc_cmd;
+    @gcc_cmd = grep ! /^-U/, @gcc_cmd;
+    @gcc_cmd = grep ! /^-m/, @gcc_cmd;
+    @gcc_cmd = grep ! /^-M/, @gcc_cmd;
+    @gcc_cmd = grep ! /^-c$/, @gcc_cmd;
+    @gcc_cmd = grep ! /^-I/, @gcc_cmd;
+    @gcc_cmd = map { /\.S$/ ? $tempfile : $_ } @gcc_cmd;
 }
 
-# look for -arch flag
-foreach my $i (1 .. $#gcc_cmd-1) {
-    if ($gcc_cmd[$i] eq "-arch") {
-        if ($gcc_cmd[$i+1] =~ /arm/) {
-            $comm = '@';
-        } elsif ($gcc_cmd[$i+1] =~ /powerpc|ppc/) {
-            $comm = '#';
+# detect architecture from gcc binary name
+if (!$arch) {
+    if ($gcc_cmd[0] =~ /(arm64|aarch64|arm|powerpc|ppc)/) {
+        $arch = $1;
+    } else {
+        # look for -arch flag
+        foreach my $i (1 .. $#gcc_cmd-1) {
+            if ($gcc_cmd[$i] eq "-arch" and
+                $gcc_cmd[$i+1] =~ /(arm64|aarch64|arm|powerpc|ppc)/) {
+                $arch = $1;
+            }
         }
     }
 }
 
 # assume we're not cross-compiling if no -arch or the binary doesn't have the arch name
-if (!$comm) {
-    my $native_arch = qx/arch/;
-    if ($native_arch =~ /arm/) {
-        $comm = '@';
-    } elsif ($native_arch =~ /powerpc|ppc/) {
-        $comm = '#';
-    }
-}
+$arch = qx/arch/ if (!$arch);
 
-if (!$comm) {
-    die "Unable to identify target architecture";
-}
+die "Unknown target architecture '$arch'" if not exists $canonical_arch{$arch};
+
+$arch = $canonical_arch{$arch};
+$comm = $comments{$arch};
+my $inputcomm = $comm;
+$comm = ";" if $as_type =~ /armasm/;
 
 my %ppc_spr = (ctr    => 9,
                vrsave => 256);
 
-open(ASMFILE, "-|", @preprocess_c_cmd) || die "Error running preprocessor";
+open(INPUT, "-|", @preprocess_c_cmd) || die "Error running preprocessor";
+
+if ($ENV{GASPP_DEBUG}) {
+    open(ASMFILE, ">&STDOUT");
+} else {
+    if ($as_type ne "armasm") {
+        open(ASMFILE, "|-", @gcc_cmd) or die "Error running assembler";
+    } else {
+        open(ASMFILE, ">", $tempfile);
+    }
+}
 
 my $current_macro = '';
 my $macro_level = 0;
+my $rept_level = 0;
 my %macro_lines;
 my %macro_args;
 my %macro_args_default;
@@ -96,39 +222,55 @@
 my $altmacro = 0;
 my $in_irp = 0;
 
-my @pass1_lines;
+my $num_repts;
+my @rept_lines;
+
+my @irp_args;
+my $irp_param;
+
 my @ifstack;
 
 my %symbols;
 
+my @sections;
+
+my %literal_labels;     # for ldr <reg>, =<expr>
+my $literal_num = 0;
+my $literal_expr = ".word";
+$literal_expr = ".quad" if $arch eq "aarch64";
+
+my $thumb = 0;
+
+my %thumb_labels;
+my %call_targets;
+my %mov32_targets;
+
+my %neon_alias_reg;
+my %neon_alias_type;
+
+my $temp_label_next = 0;
+my %last_temp_labels;
+my %next_temp_labels;
+
+my %labels_seen;
+
+my %aarch64_req_alias;
+
+if ($force_thumb) {
+    parse_line(".thumb\n");
+}
+
 # pass 1: parse .macro
 # note that the handling of arguments is probably overly permissive vs. gas
 # but it should be the same for valid cases
-while (<ASMFILE>) {
+while (<INPUT>) {
     # remove all comments (to avoid interfering with evaluating directives)
-    s/(?<!\\)$comm.*//x;
-
-    # comment out unsupported directives
-    s/\.type/$comm.type/x;
-    s/\.func/$comm.func/x;
-    s/\.endfunc/$comm.endfunc/x;
-    s/\.ltorg/$comm.ltorg/x;
-    s/\.size/$comm.size/x;
-    s/\.fpu/$comm.fpu/x;
-    s/\.arch/$comm.arch/x;
-    s/\.object_arch/$comm.object_arch/x;
-
-    # the syntax for these is a little different
-    s/\.global/.globl/x;
-    # also catch .section .rodata since the equivalent to .const_data is .section __DATA,__const
-    s/(.*)\.rodata/.const_data/x;
-    s/\.int/.long/x;
-    s/\.float/.single/x;
-
-    # catch unknown section names that aren't mach-o style (with a comma)
-    if (/.section ([^,]*)$/) {
-        die ".section $1 unsupported; figure out the mach-o section name and add it";
-    }
+    s/(?<!\\)$inputcomm.*//x;
+    # Strip out windows linefeeds
+    s/\r$//;
+    # Strip out line number comments - armasm can handle them in a separate
+    # syntax, but since the line numbers are off they are only misleading.
+    s/^#\s+(\d+).*//          if $as_type =~ /armasm/;
 
     parse_line($_);
 }
@@ -137,7 +279,7 @@ sub eval_expr {
     my $expr = $_[0];
     while ($expr =~ /([A-Za-z._][A-Za-z0-9._]*)/g) {
         my $sym = $1;
-        $expr =~ s/$sym/$symbols{$sym}/ if defined $symbols{$sym};
+        $expr =~ s/$sym/($symbols{$sym})/ if defined $symbols{$sym};
     }
     eval $expr;
 }
@@ -167,7 +309,7 @@ sub handle_if {
         } elsif ($type eq "lt") {
             $result = eval_expr($expr) < 0;
         } else {
-	    chomp($line);
+            chomp($line);
             die "unhandled .if varient. \"$line\"";
         }
         push (@ifstack, $result);
@@ -178,25 +320,30 @@ sub handle_if {
 }
 
 sub parse_if_line {
-    my $line = @_[0];
+    my $line = $_[0];
 
     # evaluate .if blocks
     if (scalar(@ifstack)) {
-        if ($line =~ /\.endif/) {
-            pop(@ifstack);
-            return 1;
-        } elsif ($line =~ /\.elseif\s+(.*)/) {
-            if ($ifstack[-1] == 0) {
-                $ifstack[-1] = !!eval_expr($1);
-            } elsif ($ifstack[-1] > 0) {
-                $ifstack[-1] = -$ifstack[-1];
+        # Don't evaluate any new if statements if we're within
+        # a repetition or macro - they will be evaluated once
+        # the repetition is unrolled or the macro is expanded.
+        if (scalar(@rept_lines) == 0 and $macro_level == 0) {
+            if ($line =~ /\.endif/) {
+                pop(@ifstack);
+                return 1;
+            } elsif ($line =~ /\.elseif\s+(.*)/) {
+                if ($ifstack[-1] == 0) {
+                    $ifstack[-1] = !!eval_expr($1);
+                } elsif ($ifstack[-1] > 0) {
+                    $ifstack[-1] = -$ifstack[-1];
+                }
+                return 1;
+            } elsif ($line =~ /\.else/) {
+                $ifstack[-1] = !$ifstack[-1];
+                return 1;
+            } elsif (handle_if($line)) {
+                return 1;
             }
-            return 1;
-        } elsif ($line =~ /\.else/) {
-            $ifstack[-1] = !$ifstack[-1];
-            return 1;
-        } elsif (handle_if($line)) {
-            return 1;
         }
 
         # discard lines in false .if blocks
@@ -210,31 +357,39 @@ sub parse_if_line {
 }
 
 sub parse_line {
-    my $line = @_[0];
+    my $line = $_[0];
 
     return if (parse_if_line($line));
 
-    if (/\.macro/) {
-        $macro_level++;
-        if ($macro_level > 1 && !$current_macro) {
-            die "nested macros but we don't have master macro";
-        }
-    } elsif (/\.endm/) {
-        $macro_level--;
-        if ($macro_level < 0) {
-            die "unmatched .endm";
-        } elsif ($macro_level == 0) {
-            $current_macro = '';
-            return;
+    if (scalar(@rept_lines) == 0) {
+        if (/\.macro/) {
+            $macro_level++;
+            if ($macro_level > 1 && !$current_macro) {
+                die "nested macros but we don't have master macro";
+            }
+        } elsif (/\.endm/) {
+            $macro_level--;
+            if ($macro_level < 0) {
+                die "unmatched .endm";
+            } elsif ($macro_level == 0) {
+                $current_macro = '';
+                return;
+            }
+        }
+    }
+
+    if ($macro_level == 0) {
+        if ($line =~ /\.(rept|irp)/) {
+            $rept_level++;
+        } elsif ($line =~ /.endr/) {
+            $rept_level--;
         }
-    } elsif (/\.irp/ or /\.rept/) {
-        $in_irp = 1;
-    } elsif (/.endr/) {
-        $in_irp = 0;
     }
 
     if ($macro_level > 1) {
         push(@{$macro_lines{$current_macro}}, $line);
+    } elsif (scalar(@rept_lines) and $rept_level >= 1) {
+        push(@rept_lines, $line);
     } elsif ($macro_level == 0) {
         expand_macros($line);
     } else {
@@ -267,15 +422,17 @@ sub handle_set {
     my $line = $_[0];
     if ($line =~ /\.set\s+(.*),\s*(.*)/) {
         $symbols{$1} = eval_expr($2);
+        return 1;
     }
+    return 0;
 }
 
 sub expand_macros {
-    my $line = @_[0];
+    my $line = $_[0];
 
     # handle .if directives; apple's assembler doesn't support important non-basic ones
     # evaluating them is also needed to handle recursive macros
-    if (!$in_irp && handle_if($line)) {
+    if (handle_if($line)) {
         return;
     }
 
@@ -298,10 +455,69 @@ sub expand_macros {
 
     $line =~ s/\%([^,]*)/eval_expr($1)/eg if $altmacro;
 
-    handle_set($line);
+    # Strip out the .set lines from the armasm output
+    return if (handle_set($line) and $as_type eq "armasm");
+
+    if ($line =~ /\.rept\s+(.*)/) {
+        $num_repts = $1;
+        @rept_lines = ("\n");
+
+        # handle the possibility of repeating another directive on the same line
+        # .endr on the same line is not valid, I don't know if a non-directive is
+        if ($num_repts =~ s/(\.\w+.*)//) {
+            push(@rept_lines, "$1\n");
+        }
+        $num_repts = eval_expr($num_repts);
+    } elsif ($line =~ /\.irp\s+([\d\w\.]+)\s*(.*)/) {
+        $in_irp = 1;
+        $num_repts = 1;
+        @rept_lines = ("\n");
+        $irp_param = $1;
+
+        # only use whitespace as the separator
+        my $irp_arglist = $2;
+        $irp_arglist =~ s/,/ /g;
+        $irp_arglist =~ s/^\s+//;
+        @irp_args = split(/\s+/, $irp_arglist);
+    } elsif ($line =~ /\.irpc\s+([\d\w\.]+)\s*(.*)/) {
+        $in_irp = 1;
+        $num_repts = 1;
+        @rept_lines = ("\n");
+        $irp_param = $1;
+
+        my $irp_arglist = $2;
+        $irp_arglist =~ s/,/ /g;
+        $irp_arglist =~ s/^\s+//;
+        @irp_args = split(//, $irp_arglist);
+    } elsif ($line =~ /\.endr/) {
+        my @prev_rept_lines = @rept_lines;
+        my $prev_in_irp = $in_irp;
+        my @prev_irp_args = @irp_args;
+        my $prev_irp_param = $irp_param;
+        my $prev_num_repts = $num_repts;
+        @rept_lines = ();
+        $in_irp = 0;
+        @irp_args = '';
 
-    if ($line =~ /(\S+:|)\s*([\w\d\.]+)\s*(.*)/ && exists $macro_lines{$2}) {
-        push(@pass1_lines, $1);
+        if ($prev_in_irp != 0) {
+            foreach my $i (@prev_irp_args) {
+                foreach my $origline (@prev_rept_lines) {
+                    my $line = $origline;
+                    $line =~ s/\\$prev_irp_param/$i/g;
+                    $line =~ s/\\\(\)//g;     # remove \()
+                    parse_line($line);
+                }
+            }
+        } else {
+            for (1 .. $prev_num_repts) {
+                foreach my $origline (@prev_rept_lines) {
+                    my $line = $origline;
+                    parse_line($line);
+                }
+            }
+        }
+    } elsif ($line =~ /(\S+:|)\s*([\w\d\.]+)\s*(.*)/ && exists $macro_lines{$2}) {
+        handle_serialized_line($1);
         my $macro = $2;
 
         # commas are optional here too, but are syntactically important because
@@ -313,7 +529,7 @@ sub expand_macros {
         my $comma_sep_required = 0;
         foreach (@arglist) {
             # allow arithmetic/shift operators in macro arguments
-            $_ =~ s/\s*(\+|-|\*|\/|<<|>>)\s*/$1/g;
+            $_ =~ s/\s*(\+|-|\*|\/|<<|>>|<|>)\s*/$1/g;
 
             my @whitespace_split = split(/\s+/, $_);
             if (!@whitespace_split) {
@@ -377,39 +593,49 @@ sub expand_macros {
             foreach (reverse sort {length $a <=> length $b} keys %replacements) {
                 $macro_line =~ s/\\$_/$replacements{$_}/g;
             }
+            if ($altmacro) {
+                foreach (reverse sort {length $a <=> length $b} keys %replacements) {
+                    $macro_line =~ s/\b$_\b/$replacements{$_}/g;
+                }
+            }
             $macro_line =~ s/\\\@/$count/g;
             $macro_line =~ s/\\\(\)//g;     # remove \()
             parse_line($macro_line);
         }
     } else {
-        push(@pass1_lines, $line);
+        handle_serialized_line($line);
     }
 }
 
-close(ASMFILE) or exit 1;
-if ($ENV{GASPP_DEBUG}) {
-    open(ASMFILE, ">&STDOUT");
-} else {
-    open(ASMFILE, "|-", @gcc_cmd) or die "Error running assembler";
+sub is_arm_register {
+    my $name = $_[0];
+    if ($name eq "lr" or
+        $name eq "ip" or
+        $name =~ /^[rav]\d+$/) {
+        return 1;
+    }
+    return 0;
 }
 
-my @sections;
-my $num_repts;
-my @rept_lines;
-
-my %literal_labels;     # for ldr <reg>, =<expr>
-my $literal_num = 0;
-
-my $thumb = 0;
-
-my %thumb_labels;
-my %call_targets;
+sub handle_local_label {
+    my $line = $_[0];
+    my $num  = $_[1];
+    my $dir  = $_[2];
+    my $target = "$num$dir";
+    if ($dir eq "b") {
+        $line =~ s/$target/$last_temp_labels{$num}/g;
+    } else {
+        my $name = "temp_label_$temp_label_next";
+        $temp_label_next++;
+        push(@{$next_temp_labels{$num}}, $name);
+        $line =~ s/$target/$name/g;
+    }
+    return $line;
+}
 
-my @irp_args;
-my $irp_param;
+sub handle_serialized_line {
+    my $line = $_[0];
 
-# pass 2: parse .rept and .if variants
-foreach my $line (@pass1_lines) {
     # handle .previous (only with regard to .section not .subsection)
     if ($line =~ /\.(section|text|const_data)/) {
         push(@sections, $line);
@@ -425,7 +651,7 @@ sub expand_macros {
     $thumb = 0 if $line =~ /\.code\s+32|\.arm/;
 
     # handle ldr <reg>, =<expr>
-    if ($line =~ /(.*)\s*ldr([\w\s\d]+)\s*,\s*=(.*)/) {
+    if ($line =~ /(.*)\s*ldr([\w\s\d]+)\s*,\s*=(.*)/ and $as_type ne "armasm") {
         my $label = $literal_labels{$3};
         if (!$label) {
             $label = "Literal_$literal_num";
@@ -433,14 +659,21 @@ sub expand_macros {
             $literal_labels{$3} = $label;
         }
         $line = "$1 ldr$2, $label\n";
-    } elsif ($line =~ /\.ltorg/) {
+    } elsif ($line =~ /\.ltorg/ and $as_type ne "armasm") {
         $line .= ".align 2\n";
         foreach my $literal (keys %literal_labels) {
-            $line .= "$literal_labels{$literal}:\n .word $literal\n";
+            $line .= "$literal_labels{$literal}:\n $literal_expr $literal\n";
         }
         %literal_labels = ();
     }
 
+    # handle GNU as pc-relative relocations for adrp/add
+    if ($line =~ /(.*)\s*adrp([\w\s\d]+)\s*,\s*#?:pg_hi21:([^\s]+)/) {
+        $line = "$1 adrp$2, ${3}\@PAGE\n";
+    } elsif ($line =~ /(.*)\s*add([\w\s\d]+)\s*,([\w\s\d]+)\s*,\s*#?:lo12:([^\s]+)/) {
+        $line = "$1 add$2, $3, ${4}\@PAGEOFF\n";
+    }
+
     # thumb add with large immediate needs explicit add.w
     if ($thumb and $line =~ /add\s+.*#([^@]+)/) {
         $line =~ s/add/add.w/ if eval_expr($1) > 255;
@@ -449,15 +682,26 @@ sub expand_macros {
     # mach-o local symbol names start with L (no dot)
     $line =~ s/(?<!\w)\.(L\w+)/$1/g;
 
+    # recycle the '.func' directive for '.thumb_func'
+    if ($thumb and $as_type =~ /^apple-/) {
+        $line =~ s/\.func/.thumb_func/x;
+    }
+
     if ($thumb and $line =~ /^\s*(\w+)\s*:/) {
         $thumb_labels{$1}++;
     }
 
-    if ($line =~ /^\s*((\w+\s*:\s*)?bl?x?(?:..)?(?:\.w)?|\.globl)\s+(\w+)/) {
-        if (exists $thumb_labels{$3}) {
-            print ASMFILE ".thumb_func $3\n";
-        } else {
-            $call_targets{$3}++;
+    if ($as_type =~ /^apple-/ and
+        $line =~ /^\s*((\w+\s*:\s*)?bl?x?(..)?(?:\.w)?|\.global)\s+(\w+)/) {
+        my $cond = $3;
+        my $label = $4;
+        # Don't interpret e.g. bic as b<cc> with ic as conditional code
+        if ($cond =~ /|$arm_cond_codes/) {
+            if (exists $thumb_labels{$label}) {
+                print ASMFILE ".thumb_func $label\n";
+            } else {
+                $call_targets{$label}++;
+            }
         }
     }
 
@@ -474,6 +718,16 @@ sub expand_macros {
         }
     }
 
+    if ($line =~ /\.unreq\s+(.*)/) {
+        if (defined $neon_alias_reg{$1}) {
+            delete $neon_alias_reg{$1};
+            delete $neon_alias_type{$1};
+            return;
+        } elsif (defined $aarch64_req_alias{$1}) {
+            delete $aarch64_req_alias{$1};
+            return;
+        }
+    }
     # old gas versions store upper and lower case names on .req,
     # but they remove only one on .unreq
     if ($fix_unreq) {
@@ -483,81 +737,288 @@ sub expand_macros {
         }
     }
 
-    if ($line =~ /\.rept\s+(.*)/) {
-        $num_repts = $1;
-        @rept_lines = ("\n");
+    if ($line =~ /(\w+)\s+\.(dn|qn)\s+(\w+)(?:\.(\w+))?(\[\d+\])?/) {
+        $neon_alias_reg{$1} = "$3$5";
+        $neon_alias_type{$1} = $4;
+        return;
+    }
+    if (scalar keys %neon_alias_reg > 0 && $line =~ /^\s+v\w+/) {
+        # This line seems to possibly have a neon instruction
+        foreach (keys %neon_alias_reg) {
+            my $alias = $_;
+            # Require the register alias to match as an invididual word, not as a substring
+            # of a larger word-token.
+            if ($line =~ /\b$alias\b/) {
+                $line =~ s/\b$alias\b/$neon_alias_reg{$alias}/g;
+                # Add the type suffix. If multiple aliases match on the same line,
+                # only do this replacement the first time (a vfoo.bar string won't match v\w+).
+                $line =~ s/^(\s+)(v\w+)(\s+)/$1$2.$neon_alias_type{$alias}$3/;
+            }
+        }
+    }
 
-        # handle the possibility of repeating another directive on the same line
-        # .endr on the same line is not valid, I don't know if a non-directive is
-        if ($num_repts =~ s/(\.\w+.*)//) {
-            push(@rept_lines, "$1\n");
+    if ($arch eq "aarch64" or $as_type eq "armasm") {
+        # clang's integrated aarch64 assembler in Xcode 5 does not support .req/.unreq
+        if ($line =~ /\b(\w+)\s+\.req\s+(\w+)\b/) {
+            $aarch64_req_alias{$1} = $2;
+            return;
         }
-        $num_repts = eval_expr($num_repts);
-    } elsif ($line =~ /\.irp\s+([\d\w\.]+)\s*(.*)/) {
-        $in_irp = 1;
-        $num_repts = 1;
-        @rept_lines = ("\n");
-        $irp_param = $1;
+        foreach (keys %aarch64_req_alias) {
+            my $alias = $_;
+            # recursively resolve aliases
+            my $resolved = $aarch64_req_alias{$alias};
+            while (defined $aarch64_req_alias{$resolved}) {
+                $resolved = $aarch64_req_alias{$resolved};
+            }
+            $line =~ s/\b$alias\b/$resolved/g;
+        }
+    }
+    if ($arch eq "aarch64") {
+        # fix missing aarch64 instructions in Xcode 5.1 (beta3)
+        # mov with vector arguments is not supported, use alias orr instead
+        if ($line =~ /^\s*mov\s+(v\d[\.{}\[\]\w]+),\s*(v\d[\.{}\[\]\w]+)\b\s*$/) {
+            $line = "        orr $1, $2, $2\n";
+        }
+        # movi 16, 32 bit shifted variant, shift is optional
+        if ($line =~ /^\s*movi\s+(v[0-3]?\d\.(?:2|4|8)[hsHS])\s*,\s*(#\w+)\b\s*$/) {
+            $line = "        movi $1, $2, lsl #0\n";
+        }
+        # Xcode 5 misses the alias uxtl. Replace it with the more general ushll.
+        # Clang 3.4 misses the alias sxtl too. Replace it with the more general sshll.
+        if ($line =~ /^\s*(s|u)xtl(2)?\s+(v[0-3]?\d\.[248][hsdHSD])\s*,\s*(v[0-3]?\d\.(?:2|4|8|16)[bhsBHS])\b\s*$/) {
+            $line = "        $1shll$2 $3, $4, #0\n";
+        }
+        # clang 3.4 does not automatically use shifted immediates in add/sub
+        if ($as_type eq "clang" and
+            $line =~ /^(\s*(?:add|sub)s?) ([^#l]+)#([\d\+\-\*\/ <>]+)\s*$/) {
+            my $imm = eval $3;
+            if ($imm > 4095 and not ($imm & 4095)) {
+                $line = "$1 $2#" . ($imm >> 12) . ", lsl #12\n";
+            }
+        }
+        if ($ENV{GASPP_FIX_XCODE5}) {
+            if ($line =~ /^\s*bsl\b/) {
+                $line =~ s/\b(bsl)(\s+v[0-3]?\d\.(\w+))\b/$1.$3$2/;
+                $line =~ s/\b(v[0-3]?\d)\.$3\b/$1/g;
+            }
+            if ($line =~ /^\s*saddl2?\b/) {
+                $line =~ s/\b(saddl2?)(\s+v[0-3]?\d\.(\w+))\b/$1.$3$2/;
+                $line =~ s/\b(v[0-3]?\d)\.\w+\b/$1/g;
+            }
+            if ($line =~ /^\s*dup\b.*\]$/) {
+                $line =~ s/\bdup(\s+v[0-3]?\d)\.(\w+)\b/dup.$2$1/g;
+                $line =~ s/\b(v[0-3]?\d)\.[bhsdBHSD](\[\d\])$/$1$2/g;
+            }
+        }
+    }
 
-        # only use whitespace as the separator
-        my $irp_arglist = $2;
-        $irp_arglist =~ s/,/ /g;
-        $irp_arglist =~ s/^\s+//;
-        @irp_args = split(/\s+/, $irp_arglist);
-    } elsif ($line =~ /\.irpc\s+([\d\w\.]+)\s*(.*)/) {
-        $in_irp = 1;
-        $num_repts = 1;
-        @rept_lines = ("\n");
-        $irp_param = $1;
+    if ($as_type eq "armasm") {
+        # Also replace variables set by .set
+        foreach (keys %symbols) {
+            my $sym = $_;
+            $line =~ s/\b$sym\b/$symbols{$sym}/g;
+        }
 
-        my $irp_arglist = $2;
-        $irp_arglist =~ s/,/ /g;
-        $irp_arglist =~ s/^\s+//;
-        @irp_args = split(//, $irp_arglist);
-    } elsif ($line =~ /\.endr/) {
-        if ($in_irp != 0) {
-            foreach my $i (@irp_args) {
-                foreach my $origline (@rept_lines) {
-                    my $line = $origline;
-                    $line =~ s/\\$irp_param/$i/g;
-                    $line =~ s/\\\(\)//g;     # remove \()
-                    if (!parse_if_line($line) && !handle_if($line)) {
-                        handle_set($line);
-                        print ASMFILE $line;
-                    }
-                }
+        # Handle function declarations and keep track of the declared labels
+        if ($line =~ s/^\s*\.func\s+(\w+)/$1 PROC/) {
+            $labels_seen{$1} = 1;
+        }
+
+        if ($line =~ s/^(\d+)://) {
+            # Convert local labels into unique labels. armasm (at least in
+            # RVCT) has something similar, but still different enough.
+            # By converting to unique labels we avoid any possible
+            # incompatibilities.
+
+            my $num = $1;
+            foreach (@{$next_temp_labels{$num}}) {
+                $line = "$_\n" . $line;
             }
-        } else {
-            for (1 .. $num_repts) {
-                foreach my $line (@rept_lines) {
-                    if (!parse_if_line($line) && !handle_if($line)) {
-                        handle_set($line);
-                        print ASMFILE $line;
-                    }
-                }
+            @next_temp_labels{$num} = ();
+            my $name = "temp_label_$temp_label_next";
+            $temp_label_next++;
+            # The matching regexp above removes the label from the start of
+            # the line (which might contain an instruction as well), readd
+            # it on a separate line above it.
+            $line = "$name:\n" . $line;
+            $last_temp_labels{$num} = $name;
+        }
+
+        if ($line =~ s/^(\w+):/$1/) {
+            # Skip labels that have already been declared with a PROC,
+            # labels must not be declared multiple times.
+            return if (defined $labels_seen{$1});
+            $labels_seen{$1} = 1;
+        } elsif ($line !~ /(\w+) PROC/) {
+            # If not a label, make sure the line starts with whitespace,
+            # otherwise ms armasm interprets it incorrectly.
+            $line =~ s/^[\.\w]/\t$&/;
+        }
+
+
+        # Check branch instructions
+        if ($line =~ /(?:^|\n)\s*(\w+\s*:\s*)?(bl?x?(..)?(\.w)?)\s+(\w+)/) {
+            my $instr = $2;
+            my $cond = $3;
+            my $width = $4;
+            my $target = $5;
+            # Don't interpret e.g. bic as b<cc> with ic as conditional code
+            if ($cond !~ /|$arm_cond_codes/) {
+                # Not actually a branch
+            } elsif ($target =~ /(\d+)([bf])/) {
+                # The target is a local label
+                $line = handle_local_label($line, $1, $2);
+                $line =~ s/\b$instr\b/$&.w/ if $width eq "";
+            } elsif (!is_arm_register($target)) {
+                $call_targets{$target}++;
+            }
+        } elsif ($line =~ /^\s*.h?word.*\b\d+[bf]\b/) {
+            while ($line =~ /\b(\d+)([bf])\b/g) {
+                $line = handle_local_label($line, $1, $2);
             }
         }
-        @rept_lines = ();
-        $in_irp = 0;
-        @irp_args = '';
-    } elsif (scalar(@rept_lines)) {
-        push(@rept_lines, $line);
-    } else {
-        handle_set($line);
-        print ASMFILE $line;
+
+        # ALIGN in armasm syntax is the actual number of bytes
+        if ($line =~ /\.align\s+(\d+)/) {
+            my $align = 1 << $1;
+            $line =~ s/\.align\s(\d+)/ALIGN $align/;
+        }
+        # Convert gas style [r0, :128] into armasm [r0@128] alignment specification
+        $line =~ s/\[([^\[]+),\s*:(\d+)\]/[$1\@$2]/g;
+
+        # armasm treats logical values {TRUE} and {FALSE} separately from
+        # numeric values - logical operators and values can't be intermixed
+        # with numerical values. Evaluate !<number> and (a <> b) into numbers,
+        # let the assembler evaluate the rest of the expressions. This current
+        # only works for cases when ! and <> are used with actual constant numbers,
+        # we don't evaluate subexpressions here.
+
+        # Evaluate !<number>
+        while ($line =~ /!\s*(\d+)/g) {
+            my $val = ($1 != 0) ? 0 : 1;
+            $line =~ s/!(\d+)/$val/;
+        }
+        # Evaluate (a > b)
+        while ($line =~ /\(\s*(\d+)\s*([<>])\s*(\d+)\s*\)/) {
+            my $val;
+            if ($2 eq "<") {
+                $val = ($1 < $3) ? 1 : 0;
+            } else {
+                $val = ($1 > $3) ? 1 : 0;
+            }
+            $line =~ s/\(\s*(\d+)\s*([<>])\s*(\d+)\s*\)/$val/;
+        }
+
+        # Change a movw... #:lower16: into a mov32 pseudoinstruction
+        $line =~ s/^(\s*)movw(\s+\w+\s*,\s*)\#:lower16:(.*)$/$1mov32$2$3/;
+        # and remove the following, matching movt completely
+        $line =~ s/^\s*movt\s+\w+\s*,\s*\#:upper16:.*$//;
+
+        if ($line =~ /^\s*mov32\s+\w+,\s*([a-zA-Z]\w*)/) {
+            $mov32_targets{$1}++;
+        }
+
+        # Misc bugs/deficiencies:
+        # armasm seems unable to parse e.g. "vmov s0, s1" without a type
+        # qualifier, thus add .f32.
+        $line =~ s/^(\s+(?:vmov|vadd))(\s+s)/$1.f32$2/;
+        # armasm is unable to parse &0x - add spacing
+        $line =~ s/&0x/& 0x/g;
+    }
+
+    if ($force_thumb) {
+        # Convert register post indexing to a separate add instruction.
+        # This converts e.g. "ldr r0, [r1], r2" into "ldr r0, [r1]",
+        # "add r1, r1, r2".
+        $line =~ s/(ldr|str)\s+(\w+),\s*\[(\w+)\],\s*(\w+)/$1 $2, [$3]\n\tadd $3, $3, $4/g;
+
+        # Convert "mov pc, lr" into "bx lr", since the former only works
+        # for switching from arm to thumb (and only in armv7), but not
+        # from thumb to arm.
+        s/mov\s*pc\s*,\s*lr/bx lr/g;
+
+        # Convert stmdb/ldmia with only one register into a plain str/ldr with post-increment/decrement
+        $line =~ s/stmdb\s+sp!\s*,\s*\{([^,-]+)\}/str $1, [sp, #-4]!/g;
+        $line =~ s/ldmia\s+sp!\s*,\s*\{([^,-]+)\}/ldr $1, [sp], #4/g;
+
+        $line =~ s/\.arm/.thumb/x;
     }
-}
 
-print ASMFILE ".text\n";
-print ASMFILE ".align 2\n";
-foreach my $literal (keys %literal_labels) {
-    my $label = $literal_labels{$literal};
-    print ASMFILE ".set Lval_$label, $literal\n";
-    print ASMFILE "$label: .word Lval_$label\n";
+    # comment out unsupported directives
+    $line =~ s/\.type/$comm$&/x        if $as_type =~ /^(apple-|armasm)/;
+    $line =~ s/\.func/$comm$&/x        if $as_type =~ /^(apple-|clang)/;
+    $line =~ s/\.endfunc/$comm$&/x     if $as_type =~ /^(apple-|clang)/;
+    $line =~ s/\.endfunc/ENDP/x        if $as_type =~ /armasm/;
+    $line =~ s/\.ltorg/$comm$&/x       if $as_type =~ /^(apple-|clang)/;
+    $line =~ s/\.ltorg/LTORG/x         if $as_type eq "armasm";
+    $line =~ s/\.size/$comm$&/x        if $as_type =~ /^(apple-|armasm)/;
+    $line =~ s/\.fpu/$comm$&/x         if $as_type =~ /^(apple-|armasm)/;
+    $line =~ s/\.arch/$comm$&/x        if $as_type =~ /^(apple-|clang|armasm)/;
+    $line =~ s/\.object_arch/$comm$&/x if $as_type =~ /^(apple-|armasm)/;
+    $line =~ s/.section\s+.note.GNU-stack.*/$comm$&/x if $as_type =~ /^(apple-|armasm)/;
+
+    $line =~ s/\.syntax/$comm$&/x      if $as_type =~ /armasm/;
+
+    $line =~ s/\.hword/.short/x;
+
+    if ($as_type =~ /^apple-/) {
+        # the syntax for these is a little different
+        $line =~ s/\.global/.globl/x;
+        # also catch .section .rodata since the equivalent to .const_data is .section __DATA,__const
+        $line =~ s/(.*)\.rodata/.const_data/x;
+        $line =~ s/\.int/.long/x;
+        $line =~ s/\.float/.single/x;
+    }
+    if ($as_type eq "armasm") {
+        $line =~ s/\.global/EXPORT/x;
+        $line =~ s/\.int/dcd/x;
+        $line =~ s/\.long/dcd/x;
+        $line =~ s/\.float/dcfs/x;
+        $line =~ s/\.word/dcd/x;
+        $line =~ s/\.short/dcw/x;
+        $line =~ s/\.byte/dcb/x;
+        $line =~ s/\.thumb/THUMB/x;
+        $line =~ s/\.arm/ARM/x;
+        # The alignment in AREA is the power of two, just as .align in gas
+        $line =~ s/\.text/AREA |.text|, CODE, READONLY, ALIGN=2, CODEALIGN/;
+        $line =~ s/(\s*)(.*)\.rodata/$1AREA |.rodata|, DATA, READONLY, ALIGN=5/;
+
+        $line =~ s/fmxr/vmsr/;
+        $line =~ s/fmrx/vmrs/;
+        $line =~ s/fadds/vadd/;
+    }
+
+    # catch unknown section names that aren't mach-o style (with a comma)
+    if ($as_type =~ /apple-/ and $line =~ /.section ([^,]*)$/) {
+        die ".section $1 unsupported; figure out the mach-o section name and add it";
+    }
+
+    print ASMFILE $line;
 }
 
-map print(ASMFILE ".thumb_func $_\n"),
-    grep exists $thumb_labels{$_}, keys %call_targets;
+if ($as_type ne "armasm") {
+    print ASMFILE ".text\n";
+    print ASMFILE ".align 2\n";
+    foreach my $literal (keys %literal_labels) {
+        print ASMFILE "$literal_labels{$literal}:\n $literal_expr $literal\n";
+    }
+
+    map print(ASMFILE ".thumb_func $_\n"),
+        grep exists $thumb_labels{$_}, keys %call_targets;
+} else {
+    map print(ASMFILE "\tIMPORT $_\n"),
+        grep ! exists $labels_seen{$_}, (keys %call_targets, keys %mov32_targets);
+
+    print ASMFILE "\tEND\n";
+}
 
+close(INPUT) or exit 1;
 close(ASMFILE) or exit 1;
+if ($as_type eq "armasm" and ! defined $ENV{GASPP_DEBUG}) {
+    system(@gcc_cmd) == 0 or die "Error running assembler";
+}
+
+END {
+    unlink($tempfile) if defined $tempfile;
+}
 #exit 1
-- 
1.9.3

