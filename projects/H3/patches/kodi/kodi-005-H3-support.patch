diff -Nur a/addons/resource.language.en_gb/resources/strings.po codec/addons/resource.language.en_gb/resources/strings.po
--- a/addons/resource.language.en_gb/resources/strings.po	2016-04-17 14:05:15.000000000 +0200
+++ codec/addons/resource.language.en_gb/resources/strings.po	2016-10-24 17:57:39.882181450 +0200
@@ -8333,7 +8333,13 @@
 msgid "IMX - Fast motion (double)"
 msgstr ""
 
-#empty strings from id 16336 to 16399
+#. Description of OSD video settings for deinterlace method with label #16336
+#: xbmc/video/dialogs/GUIDialogVideoSettings.cpp
+msgctxt "#16336"
+msgid "Disp2 - BOB"
+msgstr ""
+
+#empty strings from id 16337 to 16399
 
 #: xbmc/video/dialogs/GUIDialogVideoSettings.cpp
 msgctxt "#16400"
diff -Nur a/configure.ac codec/configure.ac
--- a/configure.ac	2016-08-03 19:58:43.996813544 +0200
+++ codec/configure.ac	2016-10-24 17:57:39.882181450 +0200
@@ -513,7 +513,7 @@
 
 AC_ARG_ENABLE([codec],
   [AS_HELP_STRING([--enable-codec],
-  [enable additional codecs from a list of comma separated names, (default is none, choices are amcodec, libstagefright and imxvpu)])],
+  [enable additional codecs from a list of comma separated names, (default is none, choices are amcodec, libstagefright, imxvpu and cedarx)])],
   [add_codecs=$enableval],
   [add_codecs=no])
 
@@ -1876,6 +1876,10 @@
     *libstagefright*)
         XB_ADD_CODEC([LIBSTAGEFRIGHT], [libstagefright], [$codecs])
         ;;
+    *cedarx*)
+        AC_CHECK_LIB([vdecoder], main, LIBS="$LIBS -lvdecoder -lMemAdapter", AC_MSG_ERROR($missing_library))
+        XB_ADD_CODEC([CEDARX], [cedarx], [$codecs])
+        ;;
     *imxvpu*)
       AC_CHECK_HEADER([imx-mm/vpu/vpu_wrapper.h],, AC_MSG_ERROR($missing_headers))
       AC_CHECK_LIB([vpu], main, LIBS="$LIBS -lfslvpuwrap -lvpu -lg2d", AC_MSG_ERROR($missing_library))
diff -Nur a/system/settings/sunxi.xml codec/system/settings/sunxi.xml
--- a/system/settings/sunxi.xml	1970-01-01 01:00:00.000000000 +0100
+++ codec/system/settings/sunxi.xml	2016-10-24 17:57:39.885514784 +0200
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="utf-8" ?>
+<settings>
+  <section id="system">
+    <category id="videoscreen">
+      <group id="1">
+        <setting id="videoscreen.fakefullscreen">
+          <visible>false</visible>
+        </setting>
+      </group>
+      <group id="3">
+        <setting id="videoscreen.vsync">
+          <default>3</default> <!-- VSYNC_DRIVER -->
+        </setting>
+      </group>
+    </category>
+  </section>
+</settings>
diff -Nur a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp codec/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	2016-04-17 14:05:15.000000000 +0200
+++ codec/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	2016-10-24 17:57:39.885514784 +0200
@@ -40,6 +40,7 @@
 #if defined(HAS_IMXVPU)
 #include "Video/DVDVideoCodecIMX.h"
 #endif
+#include "Video/DVDVideoCodecCedarX.h"
 #include "Video/MMALCodec.h"
 #include "Video/DVDVideoCodecStageFright.h"
 #if defined(HAS_LIBAMCODEC)
@@ -159,6 +160,11 @@
 #else
   hwSupport += "AMCodec:no ";
 #endif
+#if defined(HAS_CEDARX)
+  hwSupport += "CedarX:yes ";
+#else
+  hwSupport += "CedarX:no ";
+#endif
 #if defined(TARGET_ANDROID)
   hwSupport += "MediaCodec:yes ";
 #else
@@ -233,6 +239,13 @@
   }
 #endif
 
+#if defined(HAS_CEDARX)
+  if (!hint.software)
+  {
+    if ( (pCodec = OpenCodec(new CDVDVideoCodecSunxi(), hint, options)) ) return pCodec;
+  }
+#endif
+
 #if defined(TARGET_DARWIN_OSX)
   if (!hint.software && CSettings::GetInstance().GetBool(CSettings::SETTING_VIDEOPLAYER_USEVDA) && !g_advancedSettings.m_useFfmpegVda)
   {
diff -Nur a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCedarX.cpp codec/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCedarX.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCedarX.cpp	1970-01-01 01:00:00.000000000 +0100
+++ codec/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCedarX.cpp	2016-10-25 18:45:50.176909349 +0200
@@ -0,0 +1,922 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <sys/ioctl.h>
+#include <math.h>
+#include <stdio.h>
+
+#include <cedarx/memoryAdapter.h>
+
+#include "DVDVideoCodecCedarX.h"
+#include "DVDClock.h"
+#include "utils/log.h"
+#include "threads/Atomics.h"
+#include "windowing/WindowingFactory.h"
+
+#define _4CC(c1,c2,c3,c4) (((uint32_t)(c4)<<24)|((uint32_t)(c3)<<16)|((uint32_t)(c2)<<8)|(uint32_t)(c1))
+
+#define DI_MODULE_TIMEOUT    0x1055
+#define DI_IOC_MAGIC        'D'
+#define DI_IOCSTART          _IOWR(DI_IOC_MAGIC, 0, DiParaT *)
+
+typedef enum
+{
+  DI_FORMAT_NV12      =0x00,
+  DI_FORMAT_NV21      =0x01,
+  DI_FORMAT_MB32_12   =0x02, //UV mapping like NV12
+  DI_FORMAT_MB32_21   =0x03, //UV mapping like NV21
+} DiPixelformatE;
+
+typedef struct
+{
+  unsigned int nWidth;
+  unsigned int nHeight;
+} DiRectSizeT;
+
+typedef struct
+{
+  uintptr_t         addr[2];  // the address of frame buffer
+  DiRectSizeT       mRectSize;
+  DiPixelformatE    eFormat;
+} DiFbT;
+
+typedef struct
+{
+  DiFbT         mInputFb;        //current frame fb
+  DiFbT         mPreFb;          //previous frame fb
+  DiRectSizeT   mSourceRegion;   //current frame and previous frame process region
+  DiFbT         mOutputFb;       //output frame fb
+  DiRectSizeT   mOutRegion;      //output frame region
+  unsigned int  nField;          //process field <0-top field ; 1-bottom field>
+  unsigned int  bTopFieldFirst;  //video infomation <0-is not top_field_first; 1-is top_field_first>
+} DiParaT;
+
+// global instance
+CSunxiContext g_SunxiContext;
+
+CDVDVideoCodecSunxi::CDVDVideoCodecSunxi() :
+  m_videoCodec(nullptr),
+  m_pFormatName("cedarx-xxx"),
+  m_dropState(false),
+  m_vp9orhevccodec(false),
+  m_bitstream(nullptr)
+{
+  
+}
+
+CDVDVideoCodecSunxi::~CDVDVideoCodecSunxi()
+{
+  CLog::Log(LOGDEBUG, "CDVDVideoCodecSunxi destructor");
+  Dispose();
+}
+
+bool CDVDVideoCodecSunxi::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
+{
+  VConfig vConfig;
+  bool ignoreExtraData = false;
+  
+  m_hints = hints;
+  
+  memset(&m_streamInfo, 0, sizeof(m_streamInfo));
+  memset(&vConfig, 0, sizeof(VConfig));
+  vConfig.eOutputPixelFormat = PIXEL_FORMAT_NV21;
+
+  CLog::Log(LOGDEBUG, "Codec profile %d level %d", m_hints.profile, m_hints.level);
+
+  switch (hints.codec)
+  {
+    case AV_CODEC_ID_MPEG1VIDEO:
+      m_pFormatName = "cedarx-mpeg1";
+      m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_MPEG1;
+      break;
+    case AV_CODEC_ID_MPEG2VIDEO:
+    case AV_CODEC_ID_MPEG2VIDEO_XVMC:
+      m_pFormatName = "cedarx-mpeg2";
+      m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_MPEG2;
+      break;
+    case AV_CODEC_ID_H263:
+      m_pFormatName = "cedarx-h263";
+      m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_H263;
+      break;
+    case AV_CODEC_ID_MPEG4:
+      switch(m_hints.codec_tag)
+      {
+      case _4CC('d','i','v','x'):
+      case _4CC('D','I','V','X'):
+        m_pFormatName = "cedarx-divx";
+        m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_DIVX4;
+        break;
+      case _4CC('D','X','5','0'):
+      case _4CC('d','x','5','0'):
+      case _4CC('D','I','V','5'):
+      case _4CC('d','i','v','5'):
+        m_pFormatName = "cedarx-divx5";
+        m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_DIVX5;
+        break;
+      case _4CC('X','V','I','D'):
+      case _4CC('x','v','i','d'):
+      case _4CC('M','P','4','V'):
+      case _4CC('m','p','4','v'):
+      case _4CC('P','M','P','4'):
+      case _4CC('F','M','P','4'):
+        m_pFormatName = "cedarx-xvid";
+        m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_XVID;
+        break;
+      default:
+        CLog::Log(LOGWARNING, "CedarX : Using XVID for MPEG4 codec with tag %d.", m_hints.codec_tag);
+        m_pFormatName = "cedarx-xvid";
+        m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_XVID;
+        break;
+      }
+      break;
+    case AV_CODEC_ID_MSMPEG4V1:
+      m_pFormatName = "cedarx-mpeg4v1";
+      m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_MSMPEG4V1;
+      break;
+    case AV_CODEC_ID_MSMPEG4V2:
+      m_pFormatName = "cedarx-mpeg4v2";
+      m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_MSMPEG4V2;
+      break;
+    case AV_CODEC_ID_MSMPEG4V3:
+      m_pFormatName = "cedarx-divx3";
+      m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_DIVX3;
+      break;
+    case AV_CODEC_ID_FLV1:
+      m_pFormatName = "cedarx-flv1";
+      m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_SORENSSON_H263;
+      break;
+    case AV_CODEC_ID_RV10:
+    case AV_CODEC_ID_RV20:
+      m_pFormatName = "cedarx-rxg2";
+      m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_RXG2;
+      break;
+    case AV_CODEC_ID_RV30:
+    case AV_CODEC_ID_RV40:
+      m_pFormatName = "cedarx-rx";
+      m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_RX;
+      break;
+    case AV_CODEC_ID_H264:
+      // Test for VPU unsupported profiles to revert to sw decoding
+      if (m_hints.profile == 110) //hi10p
+      {
+	CLog::Log(LOGNOTICE, "CedarX is not able to decode AVC profile %d level %d", m_hints.profile, m_hints.level);
+	return false;
+      }
+      m_pFormatName = "cedarx-h264";
+      m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_H264;
+      // convert h264-avcC to h264-annex-b as h264-avcC
+      // under streamers can have issues when seeking.
+      if (hints.extradata)
+      {
+        m_bitstream = new CBitstreamConverter;
+        if (!m_bitstream->Open(hints.codec, (uint8_t*)hints.extradata, hints.extrasize, true))
+        {
+          SAFE_DELETE(m_bitstream);
+        } 
+        else 
+        {
+            // make sure we do not leak the existing hints.extradata
+            free(hints.extradata);
+            hints.extrasize = m_bitstream->GetExtraSize();
+            hints.extradata = malloc(hints.extrasize);
+            memcpy(hints.extradata, m_bitstream->GetExtraData(), hints.extrasize);
+        }
+      }
+      break;
+    case AV_CODEC_ID_MJPEG:
+      m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_MJPEG;
+      m_pFormatName = "cedarx-mjpeg";
+      break;
+    case AV_CODEC_ID_WMV1:
+      m_pFormatName = "cedarx-wmv1";
+      m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_WMV1;
+      break;
+    case AV_CODEC_ID_WMV2:
+      m_pFormatName = "cedarx-wmv2";
+      m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_WMV2;
+      break;
+    case AV_CODEC_ID_VC1:
+      ignoreExtraData = true;
+    case AV_CODEC_ID_WMV3:
+      m_pFormatName = "cedarx-wmv3";
+      m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_WMV3;
+      m_streamInfo.bIsFramePackage = 1;
+      break;
+    case AV_CODEC_ID_AVS:
+    case AV_CODEC_ID_CAVS:
+      m_pFormatName = "cedarx-avs";
+      m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_AVS;
+      break;
+    case AV_CODEC_ID_HEVC:
+      // Test for VPU unsupported profiles to revert to sw decoding
+      if ((m_hints.profile == 2) && (m_hints.level == 120)) //Main 10 - 10 bit
+      {
+	CLog::Log(LOGNOTICE, "CedarX is not able to decode HEVC profile %d level %d", m_hints.profile, m_hints.level);
+	return false;
+      }
+      m_pFormatName = "cedarx-h265";
+      m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_H265;
+      m_vp9orhevccodec = true;
+      break;
+    case AV_CODEC_ID_VP6:
+      m_pFormatName = "cedarx-vp6";
+      m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_VP6;
+      break;
+    case AV_CODEC_ID_VP8:
+      m_pFormatName = "cedarx-vp8";
+      m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_VP8;
+      break;
+    case AV_CODEC_ID_VP9:
+      m_pFormatName = "cedarx-vp9";
+      m_streamInfo.eCodecFormat = VIDEO_CODEC_FORMAT_VP9;
+      m_vp9orhevccodec = true;
+      // for some reason, there is a problem with NV21
+      vConfig.eOutputPixelFormat = PIXEL_FORMAT_YV12;
+      break;
+    default:
+      CLog::Log(LOGDEBUG, "CDVDVideoCodecSunxi::OpenDecoder - Codec format is not supported (%d)!", (int)hints.codec);
+      return false;
+  }
+  
+  m_streamInfo.nWidth = hints.width;
+  m_streamInfo.nHeight = hints.height;
+
+  // handle video rate
+  if((hints.rfpsscale > 0) && (hints.rfpsrate > 0))
+  {
+    // check ffmpeg r_frame_rate 1st
+    m_streamInfo.nFrameRate = hints.rfpsrate * 1000 / hints.rfpsscale; 
+  }
+  else if(hints.fpsscale > 0)
+  {
+    // then ffmpeg avg_frame_rate next
+    m_streamInfo.nFrameRate = hints.fpsrate * 1000 / hints.fpsscale; 
+  }
+  else
+  {
+    m_streamInfo.nFrameRate = hints.fpsrate * 1000;
+  }
+  
+  CLog::Log(LOGDEBUG, "CDVDVideoCodecSunxi::OpenDecoder - AVCodecID(%d) -> CedarXID(0x%x)",
+            (int)hints.codec, m_streamInfo.eCodecFormat);
+  
+  if ((hints.extrasize > 0) && !ignoreExtraData)
+  {
+    m_streamInfo.pCodecSpecificData = (char*)hints.extradata;
+    m_streamInfo.nCodecSpecificDataLen = hints.extrasize;
+    CLog::Log(LOGDEBUG, "CDVDVideoCodecSunxi::OpenDecoder - ExtraSize[%d]", m_streamInfo.nCodecSpecificDataLen);
+  }
+
+  m_videoCodec = CreateVideoDecoder();
+  if(m_videoCodec == nullptr)
+  {
+      CLog::Log(LOGERROR,"CDVDVideoCodecSunxi::OpenDecoder - CreateVideoDecoder failed!\n");
+      return false;
+  }
+  
+  InitializeVideoDecoder(m_videoCodec, &m_streamInfo, &vConfig);
+  g_SunxiContext.Configure();
+  g_SunxiContext.AddDecoder(m_videoCodec);
+
+  CLog::Log(LOGINFO, "CDVDVideoCodecSunxi: Opened AllwinnerTech CedarX Codec");
+  
+  return true;
+}
+
+void CDVDVideoCodecSunxi::Dispose(void)
+{
+  CLog::Log(LOGDEBUG,"CDVDVideoCodecSunxi::Dispose");
+  
+  g_SunxiContext.Close();
+  
+  if (m_videoCodec) 
+  {
+    g_SunxiContext.RemoveDecoder(m_videoCodec);
+    DestroyVideoDecoder(m_videoCodec);
+    m_videoCodec = nullptr;
+  }
+  
+  if (m_bitstream)
+  {
+    m_bitstream->Close();
+    SAFE_DELETE(m_bitstream);
+  }
+}
+
+int CDVDVideoCodecSunxi::Decode(uint8_t *pData, int iSize, double dts, double pts)
+{
+  VideoPicture        *picture;
+  VideoStreamDataInfo  dataInfo;
+  char*                buf0;
+  char*                buf1;
+  int64_t              nPts = -1;
+  int                  buf0Size;
+  int                  buf1Size;
+  int                  ret;
+  int                  status;
+  
+  if (m_hints.ptsinvalid)
+    pts = DVD_NOPTS_VALUE; 
+  if (pts != DVD_NOPTS_VALUE)
+    nPts = pts;
+  else if (dts!= DVD_NOPTS_VALUE)
+    nPts = dts;
+
+  if((pData != nullptr) && (iSize > 0))
+  {
+    if (m_bitstream)
+    {
+      if (!m_bitstream->Convert(pData, iSize))
+        return VC_ERROR;
+
+      pData = m_bitstream->GetConvertBuffer();
+      iSize = m_bitstream->GetConvertSize();
+    }
+  
+    ret = RequestVideoStreamBuffer(m_videoCodec, iSize, &buf0,
+                                   &buf0Size, &buf1, &buf1Size, 0);
+    if(ret < 0)
+    {
+        CLog::Log(LOGERROR,"CDVDVideoCodecSunxi::Decode - RequestVideoStreamBuffer failed");
+        return VC_ERROR;
+    }
+    
+    if(iSize > buf0Size)
+    {
+      memcpy(buf0, pData,            buf0Size);
+      memcpy(buf1, pData + buf0Size, buf1Size);
+    }
+    else
+    {
+      memcpy(buf0, pData, iSize);
+    }
+    
+    memset(&dataInfo, 0, sizeof(dataInfo));    
+    dataInfo.pData = buf0;   
+    dataInfo.nLength = iSize;
+    dataInfo.bIsFirstPart = 1;
+    dataInfo.bIsLastPart = 1;
+    dataInfo.nPts = nPts;
+
+    ret = SubmitVideoStreamData(m_videoCodec, &dataInfo, 0);
+    if (ret != 0)
+    {
+      CLog::Log(LOGERROR, "SubmitVideoStreamData() error!");
+      return VC_ERROR;
+    }
+  }
+  
+  ret = DecodeVideoStream(m_videoCodec, 0, 0, 0, 0);
+  switch(ret)
+  {
+    case VDECODE_RESULT_FRAME_DECODED:
+    case VDECODE_RESULT_KEYFRAME_DECODED:
+    case VDECODE_RESULT_OK:
+    case VDECODE_RESULT_NO_FRAME_BUFFER: //FIXME: what to do for this one?
+    case VDECODE_RESULT_NO_BITSTREAM:
+    case VDECODE_RESULT_CONTINUE:
+      status = VC_BUFFER;
+      break;
+    case VDECODE_RESULT_RESOLUTION_CHANGE:
+      status = VC_REOPEN;
+      break;
+    case VDECODE_RESULT_UNSUPPORTED:
+    default:
+      status = VC_ERROR;
+      break;
+  }
+  
+  //CLog::Log(LOGDEBUG, "CDVDVideoCodecSunxi::Decode - returned value: %d", ret);
+  
+  picture = RequestPicture(m_videoCodec, 0);
+  if(picture != nullptr)
+  { 
+    m_buffer = new CCedarXBuffer;
+    
+    if(m_vp9orhevccodec)
+    {
+      m_buffer->leftOffset = picture->nLeftOffset;
+      m_buffer->topOffset = picture->nTopOffset;
+    }
+    else
+    {
+      m_buffer->leftOffset = 0;
+      m_buffer->topOffset = 0;
+    }
+    
+    m_buffer->pPicture = picture;
+    m_buffer->pVideoCodec = m_videoCodec;
+    m_buffer->Lock();
+    
+    status |= VC_PICTURE;
+  }
+  
+  return status;
+}
+
+void CDVDVideoCodecSunxi::Reset(void)
+{
+  if(m_videoCodec != nullptr)
+  {
+    ResetVideoDecoder(m_videoCodec);
+  }
+}
+
+bool CDVDVideoCodecSunxi::ClearPicture(DVDVideoPicture* pDvdVideoPicture)
+{
+  if(pDvdVideoPicture != nullptr)
+  {
+    SAFE_RELEASE(pDvdVideoPicture->Disp2Buffer);
+  }
+  
+  return true;
+}
+
+bool CDVDVideoCodecSunxi::GetPicture(DVDVideoPicture* pDvdVideoPicture)
+{
+  if (pDvdVideoPicture != nullptr)
+  {
+    int realWidth  = m_buffer->pPicture->nRightOffset - m_buffer->leftOffset;
+    int realHeight = m_buffer->pPicture->nBottomOffset - m_buffer->topOffset;
+
+    // if the offset is not right, we should not use them to compute width and height
+    //FIXME: Why is there a problem with some videos? Is this limited to interlaced MPEG2s?
+    if ((realWidth <= 0) || (realHeight <= 0) ||
+        (m_streamInfo.eCodecFormat == VIDEO_CODEC_FORMAT_MPEG2))
+    {
+      realWidth  = m_buffer->pPicture->nWidth;
+      realHeight = m_buffer->pPicture->nHeight;
+    }
+    
+    pDvdVideoPicture->pts = (m_buffer->pPicture->nPts > 0) ? 
+      (double)m_buffer->pPicture->nPts : DVD_NOPTS_VALUE;
+    pDvdVideoPicture->dts = DVD_NOPTS_VALUE;
+    
+    pDvdVideoPicture->format = RENDER_FMT_DISP2;
+    pDvdVideoPicture->iWidth  = realWidth;
+    pDvdVideoPicture->iHeight = realHeight;
+    pDvdVideoPicture->iDisplayWidth  = realWidth;
+    pDvdVideoPicture->iDisplayHeight = realHeight;
+    pDvdVideoPicture->Disp2Buffer = m_buffer;
+    
+    pDvdVideoPicture->color_range  = 0;
+    pDvdVideoPicture->color_matrix = 4;
+    
+    pDvdVideoPicture->iFlags = DVP_FLAG_ALLOCATED;
+    if (!m_buffer->pPicture->bIsProgressive)
+      pDvdVideoPicture->iFlags |= DVP_FLAG_INTERLACED;
+    if (m_buffer->pPicture->bTopFieldFirst)
+      pDvdVideoPicture->iFlags |= DVP_FLAG_TOP_FIELD_FIRST;
+    if (m_buffer->pPicture->bRepeatTopField)
+      pDvdVideoPicture->iFlags |= DVP_FLAG_REPEAT_TOP_FIELD;
+    if (m_dropState)
+      pDvdVideoPicture->iFlags |= DVP_FLAG_DROPPED;
+    
+    return true;
+  }
+  
+  return false;
+}
+
+void CDVDVideoCodecSunxi::SetSpeed(int iSpeed)
+{
+  g_SunxiContext.Pause(iSpeed == DVD_PLAYSPEED_PAUSE);
+}
+
+void CCedarXBuffer::Lock()
+{
+  AtomicIncrement(&m_iRefs);
+}
+
+long CCedarXBuffer::Release()
+{
+  if (AtomicDecrement(&m_iRefs) == 0)
+  {
+    delete this;
+  }
+
+  return m_iRefs;
+}
+
+CCedarXBuffer::~CCedarXBuffer()
+{
+  VideoPicture *pic = pPicture;
+  pPicture = nullptr;
+  g_SunxiContext.FreePicture(pVideoCodec, pic);
+}
+
+CSunxiContext::CSunxiContext() : 
+  m_deinterlace(false),
+  m_last(nullptr),
+  m_paused(false),
+  m_instances(0),
+  m_vsync(false),
+  m_fbHandle(-1),
+  m_screenid(0)
+{
+  unsigned long args[4];
+  disp_output para;
+  
+  m_difd = open("/dev/deinterlace", O_RDWR);
+  if (m_difd == -1)
+  {
+      CLog::Log(LOGERROR, "Can't open HW deinterlacer!");
+  }
+  
+  m_disp = open("/dev/disp", O_RDWR);
+  if (m_disp == -1)
+  {
+    CLog::Log(LOGERROR, "%s - Can't open display. Nothing will work!\n", __FUNCTION__);
+    return;
+  }
+  
+  args[0] = 0;
+  args[1] = (unsigned long)(&para);
+  ioctl(m_disp, DISP_GET_OUTPUT, args);
+  
+  m_screenid = (para.type == 0) ? 1 : 0;
+}
+
+CSunxiContext::~CSunxiContext()
+{
+  if (m_difd != -1)
+  {
+    close(m_difd);
+  }
+  
+  if (m_disp != -1)
+  {
+    close(m_disp);
+  }
+}
+
+void CSunxiContext::Configure()
+{
+  CSingleLock lk(m_renderLock);
+  
+  if(m_instances == 0)
+  {
+    unsigned long args[4] = { m_screenid, (unsigned long)(&video_config), 1, 0 };
+  
+    // framebuffer is always at layer(1,0)
+    video_config.channel = 1;
+    video_config.layer_id = 0;
+
+    ioctl(m_disp, DISP_LAYER_GET_CONFIG, args);
+    
+    m_savedMode = video_config.info.alpha_mode;
+    m_savedZOrder = video_config.info.zorder;
+    
+    video_config.info.alpha_mode = 0;
+    video_config.info.zorder = 1; // highest number is on top
+    
+    ioctl(m_disp, DISP_LAYER_SET_CONFIG, args);
+
+    video_config.info.mode = LAYER_MODE_BUFFER;
+    video_config.info.alpha_mode = 1;
+    video_config.info.alpha_value = 255;
+
+    video_config.enable = 0;
+    video_config.channel = 0;
+    video_config.layer_id = 0;
+    video_config.info.zorder = 0;
+
+    ioctl(m_disp, DISP_LAYER_SET_CONFIG, args);
+    
+    m_fbHandle  = open("/dev/fb0", O_RDWR);
+    if (m_fbHandle == -1)
+    {
+        CLog::Log(LOGERROR, "Can't open framebuffer!");
+    }
+  }
+  
+  m_instances++;
+}
+
+void CSunxiContext::Close()
+{
+  CSingleLock lk(m_renderLock);
+  
+  if (m_instances == 0)
+    return;
+  
+  if (m_instances == 1)
+  {
+    unsigned long args[4] = { m_screenid, (unsigned long)(&video_config), 1, 0 };
+    
+    SAFE_RELEASE(m_last);
+
+    video_config.enable = 0;
+
+    ioctl(m_disp, DISP_LAYER_SET_CONFIG, args);
+  
+    // framebuffer is always at layer(1,0)
+    video_config.channel = 1;
+    video_config.layer_id = 0;
+
+    ioctl(m_disp, DISP_LAYER_GET_CONFIG, args);
+    
+    video_config.info.alpha_mode = m_savedMode;
+    video_config.info.zorder = m_savedZOrder;
+    
+    ioctl(m_disp, DISP_LAYER_SET_CONFIG, args);
+    
+    if (m_fbHandle != -1)
+    {
+      close(m_fbHandle);
+    }
+  }
+  
+  m_instances--;
+}
+
+void CSunxiContext::SetDeinterlacing(bool enabled)
+{
+  m_deinterlace = enabled;
+}
+
+void CSunxiContext::Pause(bool enabled)
+{
+  m_paused = enabled;
+}
+
+void CSunxiContext::SetVSync(bool enabled)
+{
+  unsigned long args[4] = { 0, (unsigned long)(&video_config), 1, 0 };
+  
+  args[0] = m_screenid;
+  args[1] = enabled ? 1 : 0;
+  args[2] = 0;
+  args[3] = 0;
+  ioctl(m_disp, DISP_VSYNC_EVENT_EN, args);
+  
+  m_vsync = enabled && (m_fbHandle != -1);
+}
+
+void CSunxiContext::Render(CCedarXBuffer *buffer, CRect &srcRect, CRect &dstRect)
+{
+  CSingleLock lk(m_renderLock);
+  unsigned long args[4] = { m_screenid, (unsigned long)(&video_config), 1, 0 };
+  int numOfPasses = 1;
+  
+  if (!buffer || !buffer->pPicture || !IsDecoderValid(buffer->pVideoCodec))
+    return;
+  
+  if (m_instances == 0)
+    return;
+
+  if ((m_last != nullptr) && !IsDecoderValid(m_last->pVideoCodec))
+    SAFE_RELEASE(m_last);
+  
+  if ((m_deinterlace) && (m_last != nullptr) &&
+      (m_difd != -1) && (buffer->pPicture->ePixelFormat == PIXEL_FORMAT_NV21))
+  {
+    numOfPasses = 2;
+  }
+  
+  for(int index = 0; index < numOfPasses; index++)
+  {
+    CCedarXBuffer *renderbuf;
+    VideoPicture *pPicture;
+    unsigned long memAddr0 = 0;
+    unsigned long memAddr1 = 0;
+    unsigned long memAddr2 = 0;
+    
+    if(numOfPasses > 1)
+    {
+      if(!m_paused)
+        renderbuf = Deinterlace(buffer, index);
+      else
+        renderbuf = m_last;
+    }
+    else
+      renderbuf = buffer;
+    
+    // sanity check
+    if(renderbuf == nullptr)
+      continue;
+    
+    pPicture = renderbuf->pPicture;
+
+    // Y, U and V buffer format and addresses
+    if (pPicture->ePixelFormat == PIXEL_FORMAT_YV12)
+    {
+      video_config.info.fb.format  = DISP_FORMAT_YUV420_P;
+      memAddr0 = (unsigned long)MemAdapterGetPhysicAddressCpu(pPicture->pData0);
+      memAddr1 = (unsigned long)MemAdapterGetPhysicAddressCpu(pPicture->pData2);
+      memAddr2 = (unsigned long)MemAdapterGetPhysicAddressCpu(pPicture->pData1);
+      
+      // sanity check
+      if (!memAddr0 || !memAddr1 || !memAddr2)
+	return;
+    }
+    else // NV21 is default
+    {
+      video_config.info.fb.format  = DISP_FORMAT_YUV420_SP_VUVU;
+      memAddr0 = (unsigned long)MemAdapterGetPhysicAddressCpu(pPicture->pData0);
+      memAddr1 = (unsigned long)MemAdapterGetPhysicAddressCpu(pPicture->pData1);
+      
+      // sanity check
+      if (!memAddr0 || !memAddr1)
+	return;
+    }
+    
+    video_config.info.fb.addr[0] = memAddr0;
+    video_config.info.fb.addr[1] = memAddr1;
+    video_config.info.fb.addr[2] = memAddr2;
+    
+    // Y, U and V buffer sizes
+    //int bufWidth = (pPicture->nWidth + 15) & ~15;
+    //int bufHeight = (pPicture->nHeight + 15) & ~15;
+    int bufWidth = pPicture->nWidth;
+    int bufHeight = pPicture->nHeight;
+    
+    video_config.info.fb.size[0].width = bufWidth;
+    video_config.info.fb.size[0].height = bufHeight;
+    video_config.info.fb.size[1].width = bufWidth / 2;
+    video_config.info.fb.size[1].height = bufHeight / 2;
+    video_config.info.fb.size[2].width = bufWidth / 2;
+    video_config.info.fb.size[2].height = bufHeight / 2;
+    video_config.info.fb.align[0] = 0;
+    video_config.info.fb.align[1] = 0;
+    video_config.info.fb.align[2] = 0;
+    
+    // display rectangle
+    video_config.info.screen_win.x = lrint(dstRect.x1);
+    video_config.info.screen_win.y = lrint(dstRect.y1);
+    video_config.info.screen_win.width = lrint(dstRect.x2 - dstRect.x1);
+    video_config.info.screen_win.height = lrint(dstRect.y2 - dstRect.y1);
+    
+    // check zoom
+    unsigned int width = g_Windowing.GetWidth();
+    unsigned int height = g_Windowing.GetHeight();
+    double xzoom = (dstRect.x2 - dstRect.x1) / (srcRect.x2 - srcRect.x1);
+    double yzoom = (dstRect.y2 - dstRect.y1) / (srcRect.y2 - srcRect.x1);
+    double cropX = renderbuf->leftOffset + srcRect.x1;
+    double cropY = renderbuf->topOffset + srcRect.y1;
+    double cropWidth = srcRect.x2 - srcRect.x1;
+    double cropHeight = srcRect.y2 - srcRect.y1;
+
+    if (video_config.info.screen_win.x < 0)
+    {
+      cropX -= video_config.info.screen_win.x / xzoom;
+      video_config.info.screen_win.x = 0;
+    }
+    if (video_config.info.screen_win.width > width)
+    {
+      cropWidth -= (video_config.info.screen_win.width - width) / xzoom;
+      video_config.info.screen_win.width = width;
+    }
+
+    if (video_config.info.screen_win.y < 0)
+    {
+      cropY -= video_config.info.screen_win.y / yzoom;
+      video_config.info.screen_win.y = 0;
+    }
+    if (video_config.info.screen_win.height > height)
+    {
+      cropHeight -= (video_config.info.screen_win.height - height) / yzoom;
+      video_config.info.screen_win.height = height;
+    }
+    
+    // image cropping
+    video_config.info.fb.crop.x = (unsigned long long)(lrint(cropX)) << 32;
+    video_config.info.fb.crop.y = (unsigned long long)(lrint(cropY)) << 32;
+    video_config.info.fb.crop.width = (unsigned long long)(lrint(cropWidth)) << 32;
+    video_config.info.fb.crop.height = (unsigned long long)(lrint(cropHeight)) << 32;
+    
+    // misc
+    video_config.enable = 1;
+    //NOTE: Height calculation is strictly speaking incorrect, but will do.
+    video_config.info.fb.color_space = ((srcRect.y2 - srcRect.y1) < 720) ? DISP_BT601 : DISP_BT709;
+
+    ioctl(m_disp, DISP_LAYER_SET_CONFIG, args);
+    
+    renderbuf->Lock();
+    SAFE_RELEASE(m_last);
+    m_last = renderbuf;
+    
+    // Wait for sync
+//     if (m_vsync)
+//     {
+//       if (ioctl(m_fbHandle, FBIO_WAITFORVSYNC, 0) < 0)
+//         CLog::Log(LOGWARNING, "Vsync failed: %s\n", strerror(errno));
+//     }
+    
+    if(m_paused)
+      break;
+  }
+}
+
+CCedarXBuffer *CSunxiContext::Deinterlace(CCedarXBuffer *current, int nField)
+{
+  DiParaT     mDiParaT;
+  DiRectSizeT mSrcSize;
+  DiRectSizeT mDstSize; 
+  uintptr_t   preMemAddr0;
+  uintptr_t   preMemAddr1;
+  uintptr_t   curMemAddr0;
+  uintptr_t   curMemAddr1;
+  
+  // sanity check
+  if ((m_last == nullptr) || (current == nullptr))
+    return nullptr;
+  
+  VideoPicture *pPrePicture = m_last->pPicture;
+  VideoPicture *pCurPicture = current->pPicture;
+  
+  // sanity check #2
+  if ((pPrePicture == nullptr) || (pCurPicture == nullptr))
+    return nullptr;
+  
+  preMemAddr0 = (uintptr_t)MemAdapterGetPhysicAddressCpu((void*)pPrePicture->pData0);
+  preMemAddr1 = (uintptr_t)MemAdapterGetPhysicAddressCpu((void*)pPrePicture->pData1);
+  curMemAddr0 = (uintptr_t)MemAdapterGetPhysicAddressCpu((void*)pCurPicture->pData0);
+  curMemAddr1 = (uintptr_t)MemAdapterGetPhysicAddressCpu((void*)pCurPicture->pData1);
+  
+  // sanity check #3
+  if (!preMemAddr0 || !preMemAddr1 || !curMemAddr0 || !curMemAddr0)
+  {
+    CLog::Log(LOGERROR, "CedarX deinterlacing: Could not resolve phy memory address!");
+    return nullptr;
+  }
+
+  mSrcSize.nWidth  = pCurPicture->nWidth;
+  mSrcSize.nHeight = pCurPicture->nHeight;
+  mDstSize.nWidth  = pPrePicture->nLineStride;
+  mDstSize.nHeight = pPrePicture->nHeight;
+  mDiParaT.mInputFb.mRectSize  = mSrcSize;
+  mDiParaT.mInputFb.eFormat    = DI_FORMAT_NV21;
+  mDiParaT.mPreFb.mRectSize    = mSrcSize;
+  mDiParaT.mPreFb.eFormat      = DI_FORMAT_NV21;
+  mDiParaT.mOutputFb.mRectSize = mDstSize;
+  mDiParaT.mOutputFb.eFormat   = DI_FORMAT_NV21;
+  mDiParaT.mSourceRegion       = mSrcSize;
+  mDiParaT.mOutRegion          = mSrcSize;
+  mDiParaT.nField              = nField;
+  mDiParaT.bTopFieldFirst      = pCurPicture->bTopFieldFirst;
+
+  mDiParaT.mInputFb.addr[0]    = curMemAddr0;
+  mDiParaT.mInputFb.addr[1]    = curMemAddr1;
+  mDiParaT.mPreFb.addr[0]      = preMemAddr0;
+  mDiParaT.mPreFb.addr[1]      = preMemAddr1;
+  mDiParaT.mOutputFb.addr[0]   = mDiParaT.mPreFb.addr[0];
+  mDiParaT.mOutputFb.addr[1]   = mDiParaT.mPreFb.addr[1];
+
+  if (ioctl(m_difd, DI_IOCSTART, &mDiParaT) != 0)
+  {
+    CLog::Log(LOGERROR, "HW deinterlacing failed!");
+    return nullptr;
+  }
+  
+  return m_last;
+}
+
+void CSunxiContext::AddDecoder(VideoDecoder *decoder)
+{
+  CSingleLock lk(m_renderLock);
+  
+  if(decoder != nullptr)
+  {
+    m_decoders.insert(decoder);
+  }
+}
+
+void CSunxiContext::RemoveDecoder(VideoDecoder *decoder)
+{
+  CSingleLock lk(m_renderLock);
+  
+  m_decoders.erase(decoder);
+}
+
+void CSunxiContext::FreePicture(VideoDecoder *decoder, VideoPicture *picture)
+{
+  CSingleLock lk(m_renderLock);
+  
+  if((picture != nullptr) && IsDecoderValid(decoder))
+  { 
+    ReturnPicture(decoder, picture);
+  }
+}
+
+bool CSunxiContext::IsDecoderValid(VideoDecoder *decoder)
+{
+  return m_decoders.find(decoder) != m_decoders.end();
+}
diff -Nur a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCedarX.h codec/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCedarX.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCedarX.h	1970-01-01 01:00:00.000000000 +0100
+++ codec/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecCedarX.h	2016-10-24 18:10:42.145554063 +0200
@@ -0,0 +1,128 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <cedarx/vdecoder.h>
+#include "sunxi_display2.h"
+#include <linux/fb.h>
+#include <set>
+
+#include "DVDVideoCodec.h"
+#include "DVDStreamInfo.h"
+#include "utils/BitstreamConverter.h"
+#include "guilib/Geometry.h"
+#include "threads/SingleLock.h"
+
+class CCedarXBuffer 
+{
+public:
+  CCedarXBuffer() : pPicture(nullptr),
+  pVideoCodec(nullptr), leftOffset(0),
+  topOffset(0), m_iRefs(0) {}
+
+  // Shared pointer interface
+  virtual void Lock();
+  virtual long Release();
+
+public:
+  VideoPicture *pPicture;
+  VideoDecoder *pVideoCodec;
+  int           leftOffset;
+  int           topOffset;
+  
+protected:
+  long          m_iRefs;
+  
+private:
+  // private because we are reference counted
+  virtual ~CCedarXBuffer();
+};
+
+class CDVDVideoCodecSunxi : public CDVDVideoCodec
+{
+public:
+  CDVDVideoCodecSunxi();
+  virtual ~CDVDVideoCodecSunxi();
+
+  // Required overrides
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
+  virtual void Dispose(void);
+  virtual int  Decode(uint8_t *pData, int iSize, double dts, double pts);
+  virtual void Reset(void);
+  virtual bool ClearPicture(DVDVideoPicture* pDvdVideoPicture);
+  virtual bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
+  virtual void SetDropState(bool bDrop) { m_dropState = bDrop; }
+  virtual const char* GetName(void) { return (const char*)m_pFormatName; }
+  virtual void SetSpeed(int iSpeed);
+  
+protected:
+  CCedarXBuffer   *m_buffer;
+  CDVDStreamInfo   m_hints;
+  VideoDecoder    *m_videoCodec;
+  VideoStreamInfo  m_streamInfo;
+  const char      *m_pFormatName;
+  bool             m_dropState;
+  bool             m_vp9orhevccodec;
+
+  CBitstreamConverter *m_bitstream;
+};
+
+class CSunxiContext
+{
+public:
+  CSunxiContext();
+  ~CSunxiContext();
+  void Configure();
+  void Close();
+  
+  void SetDeinterlacing(bool enabled);
+  void DeinterlaceMode(bool bottomFirst);
+  void Pause(bool enabled);
+  void Render(CCedarXBuffer *buffer, CRect &srcRect, CRect &dstRect);
+  CCedarXBuffer *Deinterlace(CCedarXBuffer *current, int nField);
+  void SetVSync(bool enabled);
+  
+// ugly hack
+  void AddDecoder(VideoDecoder *decoder);
+  void RemoveDecoder(VideoDecoder *decoder);
+  void FreePicture(VideoDecoder *decoder, VideoPicture *picture);
+
+private:
+  inline bool IsDecoderValid(VideoDecoder *decoder);
+  
+private:
+  disp_layer_config video_config;
+  CCriticalSection  m_renderLock;
+  bool              m_deinterlace;
+  int               m_difd;
+  CCedarXBuffer    *m_last;
+  bool              m_paused;
+  unsigned int      m_instances;
+  bool              m_vsync;
+  int               m_fbHandle;
+  unsigned long     m_screenid;
+  int               m_disp;
+  unsigned char     m_savedMode;
+  unsigned char     m_savedZOrder;
+  // ugly hack
+  std::set<VideoDecoder*> m_decoders;
+};
+
+extern CSunxiContext g_SunxiContext;
diff -Nur a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h codec/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h	2016-04-17 14:05:15.000000000 +0200
+++ codec/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h	2016-10-24 17:57:39.885514784 +0200
@@ -52,6 +52,7 @@
 class CDVDMediaCodecInfo;
 class CDVDVideoCodecIMXBuffer;
 class CMMALVideoBuffer;
+class CCedarXBuffer;
 typedef void* EGLImageKHR;
 
 
@@ -102,6 +103,10 @@
     struct {
       CMMALVideoBuffer *MMALBuffer;
     };
+    
+    struct {
+      CCedarXBuffer *Disp2Buffer;
+    };
 
   };
 
diff -Nur a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in codec/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in	2016-04-17 14:05:15.000000000 +0200
+++ codec/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in	2016-10-24 17:57:39.885514784 +0200
@@ -23,6 +23,9 @@
 ifeq (@USE_IMXVPU@,1)
 SRCS += DVDVideoCodecIMX.cpp
 endif
+ifeq (@USE_CEDARX@,1)
+SRCS += DVDVideoCodecCedarX.cpp
+endif
 ifeq (@USE_LIBAMCODEC@,1)
 SRCS += AMLCodec.cpp
 SRCS += DVDVideoCodecAmlogic.cpp
diff -Nur a/xbmc/cores/dvdplayer/DVDCodecs/Video/sunxi_display2.h codec/xbmc/cores/dvdplayer/DVDCodecs/Video/sunxi_display2.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/sunxi_display2.h	1970-01-01 01:00:00.000000000 +0100
+++ codec/xbmc/cores/dvdplayer/DVDCodecs/Video/sunxi_display2.h	2016-10-24 17:57:39.885514784 +0200
@@ -0,0 +1,388 @@
+#ifndef __SUNXI_DISPLAY_H__
+#define __SUNXI_DISPLAY_H__
+
+typedef struct {unsigned char  alpha;unsigned char red;unsigned char green; unsigned char blue; }disp_color;
+typedef struct {int x; int y; unsigned int width; unsigned int height;}disp_rect;
+typedef struct {unsigned int width;unsigned int height;                   }disp_rectsz;
+typedef struct {int x; int y;                           }disp_position;
+
+typedef enum
+{
+	DISP_FORMAT_ARGB_8888                    = 0x00,//MSB  A-R-G-B  LSB
+	DISP_FORMAT_ABGR_8888                    = 0x01,
+	DISP_FORMAT_RGBA_8888                    = 0x02,
+	DISP_FORMAT_BGRA_8888                    = 0x03,
+	DISP_FORMAT_XRGB_8888                    = 0x04,
+	DISP_FORMAT_XBGR_8888                    = 0x05,
+	DISP_FORMAT_RGBX_8888                    = 0x06,
+	DISP_FORMAT_BGRX_8888                    = 0x07,
+	DISP_FORMAT_RGB_888                      = 0x08,
+	DISP_FORMAT_BGR_888                      = 0x09,
+	DISP_FORMAT_RGB_565                      = 0x0a,
+	DISP_FORMAT_BGR_565                      = 0x0b,
+	DISP_FORMAT_ARGB_4444                    = 0x0c,
+	DISP_FORMAT_ABGR_4444                    = 0x0d,
+	DISP_FORMAT_RGBA_4444                    = 0x0e,
+	DISP_FORMAT_BGRA_4444                    = 0x0f,
+	DISP_FORMAT_ARGB_1555                    = 0x10,
+	DISP_FORMAT_ABGR_1555                    = 0x11,
+	DISP_FORMAT_RGBA_5551                    = 0x12,
+	DISP_FORMAT_BGRA_5551                    = 0x13,
+
+	/* SP: semi-planar, P:planar, I:interleaved
+	 * UVUV: U in the LSBs;     VUVU: V in the LSBs */
+	DISP_FORMAT_YUV444_I_AYUV                = 0x40,//MSB  A-Y-U-V  LSB, reserved
+	DISP_FORMAT_YUV444_I_VUYA                = 0x41,//MSB  V-U-Y-A  LSB
+	DISP_FORMAT_YUV422_I_YVYU                = 0x42,//MSB  Y-V-Y-U  LSB
+	DISP_FORMAT_YUV422_I_YUYV                = 0x43,//MSB  Y-U-Y-V  LSB
+	DISP_FORMAT_YUV422_I_UYVY                = 0x44,//MSB  U-Y-V-Y  LSB
+	DISP_FORMAT_YUV422_I_VYUY                = 0x45,//MSB  V-Y-U-Y  LSB
+	DISP_FORMAT_YUV444_P                     = 0x46,//MSB  P3-2-1-0 LSB,  YYYY UUUU VVVV, reserved
+	DISP_FORMAT_YUV422_P                     = 0x47,//MSB  P3-2-1-0 LSB   YYYY UU   VV
+	DISP_FORMAT_YUV420_P                     = 0x48,//MSB  P3-2-1-0 LSB   YYYY U    V
+	DISP_FORMAT_YUV411_P                     = 0x49,//MSB  P3-2-1-0 LSB   YYYY U    V
+	DISP_FORMAT_YUV422_SP_UVUV               = 0x4a,//MSB  V-U-V-U  LSB
+	DISP_FORMAT_YUV422_SP_VUVU               = 0x4b,//MSB  U-V-U-V  LSB
+	DISP_FORMAT_YUV420_SP_UVUV               = 0x4c,
+	DISP_FORMAT_YUV420_SP_VUVU               = 0x4d,
+	DISP_FORMAT_YUV411_SP_UVUV               = 0x4e,
+	DISP_FORMAT_YUV411_SP_VUVU               = 0x4f,
+}disp_pixel_format;
+
+typedef enum
+{
+	DISP_3D_OUT_MODE_CI_1 = 0x5,//column interlaved 1
+	DISP_3D_OUT_MODE_CI_2 = 0x6,//column interlaved 2
+	DISP_3D_OUT_MODE_CI_3 = 0x7,//column interlaved 3
+	DISP_3D_OUT_MODE_CI_4 = 0x8,//column interlaved 4
+	DISP_3D_OUT_MODE_LIRGB = 0x9,//line interleaved rgb
+
+	DISP_3D_OUT_MODE_TB = 0x0,//top bottom
+	DISP_3D_OUT_MODE_FP = 0x1,//frame packing
+	DISP_3D_OUT_MODE_SSF = 0x2,//side by side full
+	DISP_3D_OUT_MODE_SSH = 0x3,//side by side half
+	DISP_3D_OUT_MODE_LI = 0x4,//line interleaved
+	DISP_3D_OUT_MODE_FA = 0xa,//field alternative
+}disp_3d_out_mode;
+
+typedef enum
+{
+	DISP_BT601  = 0,
+	DISP_BT709  = 1,
+	DISP_YCC    = 2,
+}disp_color_space;
+
+typedef enum
+{
+	DISP_CSC_TYPE_RGB        = 0,
+	DISP_CSC_TYPE_YUV1       = 1,//HDMI
+	DISP_CSC_TYPE_YUV2       = 2,//TV
+}disp_csc_type;
+
+typedef enum
+{
+	DISP_COLOR_RANGE_16_255 = 0,
+	DISP_COLOR_RANGE_0_255  = 1,
+	DISP_COLOR_RANGE_16_235 = 2,
+}disp_color_range;
+
+typedef enum
+{
+	DISP_OUTPUT_TYPE_NONE   = 0,
+	DISP_OUTPUT_TYPE_LCD    = 1,
+	DISP_OUTPUT_TYPE_TV     = 2,
+	DISP_OUTPUT_TYPE_HDMI   = 4,
+	DISP_OUTPUT_TYPE_VGA    = 8,
+}disp_output_type;
+
+typedef enum
+{
+	DISP_TV_MOD_480I                = 0,
+	DISP_TV_MOD_576I                = 1,
+	DISP_TV_MOD_480P                = 2,
+	DISP_TV_MOD_576P                = 3,
+	DISP_TV_MOD_720P_50HZ           = 4,
+	DISP_TV_MOD_720P_60HZ           = 5,
+	DISP_TV_MOD_1080I_50HZ          = 6,
+	DISP_TV_MOD_1080I_60HZ          = 7,
+	DISP_TV_MOD_1080P_24HZ          = 8,
+	DISP_TV_MOD_1080P_50HZ          = 9,
+	DISP_TV_MOD_1080P_60HZ          = 0xa,
+	DISP_TV_MOD_1080P_24HZ_3D_FP    = 0x17,
+	DISP_TV_MOD_720P_50HZ_3D_FP     = 0x18,
+	DISP_TV_MOD_720P_60HZ_3D_FP     = 0x19,
+	DISP_TV_MOD_1080P_25HZ          = 0x1a,
+	DISP_TV_MOD_1080P_30HZ          = 0x1b,
+	DISP_TV_MOD_PAL                 = 0xb,
+	DISP_TV_MOD_PAL_SVIDEO          = 0xc,
+	DISP_TV_MOD_NTSC                = 0xe,
+	DISP_TV_MOD_NTSC_SVIDEO         = 0xf,
+	DISP_TV_MOD_PAL_M               = 0x11,
+	DISP_TV_MOD_PAL_M_SVIDEO        = 0x12,
+	DISP_TV_MOD_PAL_NC              = 0x14,
+	DISP_TV_MOD_PAL_NC_SVIDEO       = 0x15,
+	DISP_TV_MOD_3840_2160P_30HZ     = 0x1c,
+	DISP_TV_MOD_3840_2160P_25HZ     = 0x1d,
+	DISP_TV_MOD_3840_2160P_24HZ     = 0x1e,
+	DISP_TV_MODE_NUM                = 0x1f,
+}disp_tv_mode;
+
+
+//FIXME:still need?
+typedef enum
+{
+	DISP_EXIT_MODE_CLEAN_ALL    = 0,
+	DISP_EXIT_MODE_CLEAN_PARTLY = 1,//only clean interrupt temply
+}disp_exit_mode;
+
+typedef enum
+{
+	DISP_BF_NORMAL        = 0,//non-stereo
+	DISP_BF_STEREO_TB     = 1 << 0,//stereo top-bottom
+	DISP_BF_STEREO_FP     = 1 << 1,//stereo frame packing
+	DISP_BF_STEREO_SSH    = 1 << 2,//stereo side by side half
+	DISP_BF_STEREO_SSF    = 1 << 3,//stereo side by side full
+	DISP_BF_STEREO_LI     = 1 << 4,//stereo line interlace
+}disp_buffer_flags;
+
+typedef enum
+{
+	LAYER_MODE_BUFFER = 0,
+	LAYER_MODE_COLOR = 1,
+}disp_layer_mode;
+
+typedef enum
+{
+	DISP_SCAN_PROGRESSIVE                 = 0,//non interlace
+	DISP_SCAN_INTERLACED_ODD_FLD_FIRST    = 1 << 0,//interlace ,odd field first
+	DISP_SCAN_INTERLACED_EVEN_FLD_FIRST   = 1 << 1,//interlace,even field first
+}disp_scan_flags;
+
+typedef struct
+{
+	unsigned int type;
+	unsigned int mode;
+}disp_output;
+
+typedef struct
+{
+	long long x;
+	long long y;
+	long long width;
+	long long height;
+}disp_rect64;
+
+typedef struct
+{
+	unsigned long long   addr[3];          /* address of frame buffer,
+																						single addr for interleaved fomart,
+																						double addr for semi-planar fomart
+																						triple addr for planar format */
+	disp_rectsz           size[3];          //size for 3 component,unit: pixels
+	unsigned int          align[3];         //align for 3 comonent,unit: bytes(align=2^n,i.e. 1/2/4/8/16/32..)
+	disp_pixel_format     format;
+	disp_color_space      color_space;      //color space
+	unsigned int          trd_right_addr[3];/* right address of 3d fb,
+																						used when in frame packing 3d mode */
+	bool                  pre_multiply;     //true: pre-multiply fb
+	disp_rect64           crop;             //crop rectangle boundaries
+	disp_buffer_flags     flags;            //indicate stereo or non-stereo buffer
+	disp_scan_flags       scan;             //scan type & scan order
+}disp_fb_info;
+
+typedef struct
+{
+	disp_layer_mode           mode;
+	unsigned char             zorder;      /*specifies the front-to-back ordering of the layers on the screen,
+											 the top layer having the highest Z value
+											 can't set zorder, but can get */
+	unsigned char             alpha_mode;  //0: pixel alpha;  1: global alpha;  2: global pixel alpha
+	unsigned char             alpha_value; //global alpha value
+	disp_rect                 screen_win;  //display window on the screen
+	bool                      b_trd_out;   //3d display
+	disp_3d_out_mode          out_trd_mode;//3d display mode
+	union {
+		unsigned int            color;       //valid when LAYER_MODE_COLOR
+		disp_fb_info            fb;          //framebuffer, valid when LAYER_MODE_BUFFER
+	};
+
+	unsigned int              id;          /* frame id, can get the id of frame display currently
+																						by DISP_LAYER_GET_FRAME_ID */
+}disp_layer_info;
+
+typedef struct
+{
+	disp_layer_info info;
+	bool enable;
+	unsigned int channel;
+	unsigned int layer_id;
+}disp_layer_config;
+
+typedef struct
+{
+    disp_color      ck_max;
+    disp_color      ck_min;
+    unsigned int    red_match_rule;//0/1:always match; 2:match if min<=color<=max; 3:match if color>max or color<min
+    unsigned int    green_match_rule;//0/1:always match; 2:match if min<=color<=max; 3:match if color>max or color<min
+    unsigned int    blue_match_rule;//0/1:always match; 2:match if min<=color<=max; 3:match if color>max or color<min
+}disp_colorkey;
+
+typedef struct
+{
+	disp_pixel_format format;
+	disp_rectsz size[3];
+	disp_rect crop;
+	unsigned long long addr[3];
+}disp_s_frame;
+
+typedef struct
+{
+	disp_rect window;  // capture window, rectangle of screen to be captured
+	                          //capture the whole screen if window eq ZERO
+	disp_s_frame out_frame;
+}disp_capture_info;
+
+typedef enum
+{
+	FB_MODE_SCREEN0 = 0,
+	FB_MODE_SCREEN1 = 1,
+	FB_MODE_SCREEN2 = 2,
+	FB_MODE_DUAL_SAME_SCREEN_TB = 3,//two screen, top buffer for screen0, bottom buffer for screen1
+	FB_MODE_DUAL_DIFF_SCREEN_SAME_CONTENTS = 4,//two screen, they have same contents;
+}disp_fb_mode;
+
+typedef struct
+{
+	disp_fb_mode       fb_mode;
+	disp_layer_mode    mode;
+	unsigned int       buffer_num;
+	unsigned int       width;
+	unsigned int       height;
+
+	unsigned int       output_width;//used when scaler mode
+	unsigned int       output_height;//used when scaler mode
+}disp_fb_create_info;
+
+typedef enum
+{
+	DISP_INIT_MODE_SCREEN0 = 0,//fb0 for screen0
+	DISP_INIT_MODE_SCREEN1 = 1,//fb0 for screen1
+	DISP_INIT_MODE_SCREEN2 = 2,//fb0 for screen1
+	DISP_INIT_MODE_TWO_DIFF_SCREEN = 3,//fb0 for screen0 and fb1 for screen1
+	DISP_INIT_MODE_TWO_SAME_SCREEN = 4,//fb0(up buffer for screen0, down buffer for screen1)
+	DISP_INIT_MODE_TWO_DIFF_SCREEN_SAME_CONTENTS = 5,//fb0 for two different screen(screen0 layer is normal layer, screen1 layer is scaler layer);
+}disp_init_mode;
+
+typedef enum
+{
+    DISP_TV_DAC_SRC_COMPOSITE       = 0,
+    DISP_TV_DAC_SRC_LUMA            = 1,
+    DISP_TV_DAC_SRC_CHROMA          = 2,
+    DISP_TV_DAC_SRC_Y               = 4,
+    DISP_TV_DAC_SRC_PB              = 5,
+    DISP_TV_DAC_SRC_PR              = 6,
+    DISP_TV_DAC_SRC_NONE            = 7,
+}disp_tv_dac_source;
+
+typedef enum
+{
+    DISP_TV_NONE    = 0,
+    DISP_TV_CVBS    = 1,
+    DISP_TV_YPBPR   = 2,
+    DISP_TV_SVIDEO  = 4,
+}disp_tv_output;
+
+typedef enum tag_DISP_CMD
+{
+	//----disp global----
+	DISP_RESERVE0 = 0x00,
+	DISP_RESERVE1 = 0x01,
+	DISP_SET_BKCOLOR = 0x03,
+	DISP_GET_BKCOLOR = 0x04,
+	DISP_SET_COLORKEY = 0x05,
+	DISP_GET_COLORKEY = 0x06,
+	DISP_GET_SCN_WIDTH = 0x07,
+	DISP_GET_SCN_HEIGHT = 0x08,
+	DISP_GET_OUTPUT_TYPE = 0x09,
+	DISP_SET_EXIT_MODE = 0x0A,
+	DISP_VSYNC_EVENT_EN = 0x0B,
+	DISP_BLANK = 0x0C,
+	DISP_SHADOW_PROTECT = 0x0D,
+	DISP_HWC_COMMIT = 0x0E,
+	DISP_DEVICE_SWITCH = 0x0F,
+	DISP_GET_OUTPUT = 0x10,
+	DISP_SET_COLOR_RANGE = 0x11,
+	DISP_GET_COLOR_RANGE = 0x12,
+
+	//----layer----
+	DISP_LAYER_ENABLE = 0x40,
+	DISP_LAYER_DISABLE = 0x41,
+	DISP_LAYER_SET_INFO = 0x42,
+	DISP_LAYER_GET_INFO = 0x43,
+	DISP_LAYER_TOP = 0x44,
+	DISP_LAYER_BOTTOM = 0x45,
+	DISP_LAYER_GET_FRAME_ID = 0x46,
+	DISP_LAYER_SET_CONFIG = 0x47,
+	DISP_LAYER_GET_CONFIG = 0x48,
+
+	//----hdmi----
+	DISP_HDMI_SUPPORT_MODE = 0xc4,
+	DISP_SET_TV_HPD = 0xc5,
+	DISP_HDMI_GET_EDID = 0xc6,
+
+	//----lcd----
+	DISP_LCD_ENABLE = 0x100,
+	DISP_LCD_DISABLE = 0x101,
+	DISP_LCD_SET_BRIGHTNESS = 0x102,
+	DISP_LCD_GET_BRIGHTNESS = 0x103,
+	DISP_LCD_BACKLIGHT_ENABLE  = 0x104,
+	DISP_LCD_BACKLIGHT_DISABLE  = 0x105,
+	DISP_LCD_SET_SRC = 0x106,
+	DISP_LCD_SET_FPS  = 0x107,
+	DISP_LCD_GET_FPS  = 0x108,
+	DISP_LCD_GET_SIZE = 0x109,
+	DISP_LCD_GET_MODEL_NAME = 0x10a,
+	DISP_LCD_SET_GAMMA_TABLE = 0x10b,
+	DISP_LCD_GAMMA_CORRECTION_ENABLE = 0x10c,
+	DISP_LCD_GAMMA_CORRECTION_DISABLE = 0x10d,
+	DISP_LCD_USER_DEFINED_FUNC = 0x10e,
+	DISP_LCD_CHECK_OPEN_FINISH = 0x10f,
+	DISP_LCD_CHECK_CLOSE_FINISH = 0x110,
+
+	//---- capture ---
+	DISP_CAPTURE_START = 0x140,//caputre screen and scaler to dram
+	DISP_CAPTURE_STOP = 0x141,
+	DISP_CAPTURE_COMMIT = 0x142,
+
+	//---enhance ---
+	DISP_ENHANCE_ENABLE = 0x180,
+	DISP_ENHANCE_DISABLE = 0x181,
+	DISP_ENHANCE_GET_EN = 0x182,
+	DISP_ENHANCE_SET_WINDOW = 0x183,
+	DISP_ENHANCE_GET_WINDOW = 0x184,
+	DISP_ENHANCE_SET_MODE = 0x185,
+	DISP_ENHANCE_GET_MODE = 0x186,
+	DISP_ENHANCE_DEMO_ENABLE = 0x187,
+	DISP_ENHANCE_DEMO_DISABLE = 0x188,
+
+	//---smart backlight ---
+	DISP_SMBL_ENABLE = 0x200,
+	DISP_SMBL_DISABLE = 0x201,
+	DISP_SMBL_GET_EN = 0x202,
+	DISP_SMBL_SET_WINDOW = 0x203,
+	DISP_SMBL_GET_WINDOW = 0x204,
+
+	//---- for test
+	DISP_FB_REQUEST = 0x280,
+	DISP_FB_RELEASE = 0x281,
+
+	DISP_MEM_REQUEST = 0x2c0,
+	DISP_MEM_RELEASE = 0x2c1,
+	DISP_MEM_GETADR = 0x2c2,
+}__DISP_t;
+
+#define FBIOGET_LAYER_HDL_0 0x4700
+#define FBIOGET_LAYER_HDL_1 0x4701
+
+#endif
+
diff -Nur a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp codec/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp	2016-04-17 14:05:15.000000000 +0200
+++ codec/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp	2016-10-24 17:57:39.888848117 +0200
@@ -931,6 +931,7 @@
     case RENDER_FMT_MEDIACODECSURFACE:return "MEDIACODECSURFACE";
     case RENDER_FMT_IMXMAP:    return "IMXMAP";
     case RENDER_FMT_MMAL:      return "MMAL";
+    case RENDER_FMT_DISP2:     return "DISP2";
     case RENDER_FMT_NONE:      return "NONE";
   }
   return "UNKNOWN";
diff -Nur a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp codec/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp	2016-04-17 14:05:15.000000000 +0200
+++ codec/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp	2016-10-25 19:31:52.130381366 +0200
@@ -93,6 +93,10 @@
 #include "DVDCodecs/Video/DVDVideoCodecAndroidMediaCodec.h"
 #endif
 
+#ifdef HAS_CEDARX
+#include "DVDCodecs/Video/DVDVideoCodecCedarX.h"
+#endif
+
 using namespace Shaders;
 
 CLinuxRendererGLES::YUVBUFFER::YUVBUFFER()
@@ -116,6 +120,9 @@
 #ifdef HAS_IMXVPU
   IMXBuffer = NULL;
 #endif
+#ifdef HAS_CEDARX
+  Disp2Buffer = NULL;
+#endif
 }
 
 CLinuxRendererGLES::YUVBUFFER::~YUVBUFFER()
@@ -304,6 +311,11 @@
   {
     return source;
   }
+  
+  if ( m_renderMethod & RENDER_DISP2 )
+  {
+    return source;
+  }
 
 #ifdef HAVE_VIDEOTOOLBOXDECODER
   if (m_renderMethod & RENDER_CVREF )
@@ -733,6 +745,45 @@
 #endif
   }
 #endif
+#ifdef HAS_CEDARX
+  else if (m_renderMethod & RENDER_DISP2)
+  {
+    CCedarXBuffer *buffer = m_buffers[m_iYV12RenderBuffer].Disp2Buffer;
+    if (buffer)
+    {
+      // this hack is needed to get the 2D mode of a 3D movie going
+      RENDER_STEREO_MODE stereo_mode = g_graphicsContext.GetStereoMode();
+      if (stereo_mode)
+        g_graphicsContext.SetStereoView(RENDER_STEREO_VIEW_LEFT);
+
+      ManageDisplay();
+
+      if (stereo_mode)
+        g_graphicsContext.SetStereoView(RENDER_STEREO_VIEW_OFF);
+
+      CRect dstRect(m_destRect);
+      CRect srcRect(m_sourceRect);
+      switch (stereo_mode)
+      {
+        case RENDER_STEREO_MODE_SPLIT_HORIZONTAL:
+          dstRect.y2 *= 2.0;
+          srcRect.y2 *= 2.0;
+        break;
+
+        case RENDER_STEREO_MODE_SPLIT_VERTICAL:
+          dstRect.x2 *= 2.0;
+          srcRect.x2 *= 2.0;
+        break;
+
+        default:
+        break;
+      }
+
+      g_SunxiContext.SetDeinterlacing(flags & RENDER_FLAG_FIELDMASK);
+      g_SunxiContext.Render(buffer, srcRect, dstRect);
+    }
+  }
+#endif
 }
 
 void CLinuxRendererGLES::FlipPage(int source)
@@ -780,6 +831,9 @@
 #ifdef HAS_IMXVPU
   m_formats.push_back(RENDER_FMT_IMXMAP);
 #endif
+#ifdef HAS_CEDARX
+  m_formats.push_back(RENDER_FMT_DISP2);
+#endif
 
   // setup the background colour
   m_clearColour = (float)(g_advancedSettings.m_videoBlackBarColour & 0xff) / 0xff;
@@ -894,6 +948,12 @@
         m_renderMethod = RENDER_IMXMAP;
         break;
       }
+      else if (m_format == RENDER_FMT_DISP2)
+      {
+        CLog::Log(LOGNOTICE, "GL: Using DISP2 render method");
+        m_renderMethod = RENDER_DISP2;
+        break;
+      }
       else if (m_format == RENDER_FMT_BYPASS)
       {
         CLog::Log(LOGNOTICE, "GL: Using BYPASS render method");
@@ -992,6 +1052,12 @@
     m_textureCreate = &CLinuxRendererGLES::CreateIMXMAPTexture;
     m_textureDelete = &CLinuxRendererGLES::DeleteIMXMAPTexture;
   }
+  else if (m_format == RENDER_FMT_DISP2)
+  {
+    m_textureUpload = &CLinuxRendererGLES::UploadDisp2Texture;
+    m_textureCreate = &CLinuxRendererGLES::CreateDisp2Texture;
+    m_textureDelete = &CLinuxRendererGLES::DeleteDisp2Texture;
+  }
   else if (m_format == RENDER_FMT_OMXEGL)
   {
     m_textureUpload = &CLinuxRendererGLES::UploadOpenMaxTexture;
@@ -1110,6 +1176,10 @@
   if (m_renderMethod & RENDER_IMXMAP)
     SAFE_RELEASE(buf.IMXBuffer);
 #endif
+#ifdef HAS_CEDARX
+  if (m_renderMethod & RENDER_DISP2)
+    SAFE_RELEASE(buf.Disp2Buffer);
+#endif
 }
 
 void CLinuxRendererGLES::Render(DWORD flags, int index)
@@ -1176,6 +1246,11 @@
     RenderIMXMAPTexture(index, m_currentField);
     VerifyGLState();
   }
+  else if (m_renderMethod & RENDER_DISP2)
+  {
+    RenderDisp2Texture(index, m_currentField);
+    VerifyGLState();
+  }
   else
   {
     RenderSoftware(index, m_currentField);
@@ -1892,6 +1967,10 @@
 {
 }
 
+void CLinuxRendererGLES::RenderDisp2Texture(int index, int field)
+{
+}
+
 bool CLinuxRendererGLES::RenderCapture(CRenderCapture* capture)
 {
   if (!m_bValidated)
@@ -2889,7 +2968,28 @@
   glDisable(m_textureTarget);
   return true;
 }
+//********************************************************************************************************
+// DISP2 creation, deletion, copying + clearing
+//********************************************************************************************************
+void CLinuxRendererGLES::UploadDisp2Texture(int index)
+{
+}
+
+void CLinuxRendererGLES::DeleteDisp2Texture(int index)
+{
+#ifdef HAS_CEDARX
+  YUVBUFFER &buf = m_buffers[index];
+  SAFE_RELEASE(buf.Disp2Buffer);
+#endif
+}
 
+bool CLinuxRendererGLES::CreateDisp2Texture(int index)
+{
+#ifdef HAS_CEDARX
+  m_buffers[index].Disp2Buffer = nullptr;
+#endif
+  return true;
+}
 
 bool CLinuxRendererGLES::Supports(ERENDERFEATURE feature)
 {
@@ -2996,6 +3096,14 @@
 
   if(m_renderMethod & RENDER_CVREF)
     return false;
+  
+  if(m_renderMethod & RENDER_DISP2)
+  {
+    if(method == VS_INTERLACEMETHOD_DISP2_BOB)
+      return true;
+    else
+      return false;
+  }
 
   if(method == VS_INTERLACEMETHOD_AUTO)
     return true;
@@ -3034,6 +3142,10 @@
 
   if(m_renderMethod & RENDER_IMXMAP)
     return false;
+  
+  //FIXME: enable scaling
+  if(m_renderMethod & RENDER_DISP2)
+    return false;
 
   if (m_renderMethod & RENDER_MEDIACODECSURFACE)
     return false;
@@ -3073,6 +3185,9 @@
 
   if(m_renderMethod & RENDER_IMXMAP)
     return VS_INTERLACEMETHOD_IMX_FASTMOTION;
+  
+  if(m_renderMethod & RENDER_DISP2)
+    return VS_INTERLACEMETHOD_DISP2_BOB;
 
 #if !defined(TARGET_ANDROID) && (defined(__i386__) || defined(__x86_64__))
   return VS_INTERLACEMETHOD_DEINTERLACE_HALF;
@@ -3090,7 +3205,8 @@
      m_format == RENDER_FMT_CVBREF ||
      m_format == RENDER_FMT_EGLIMG ||
      m_format == RENDER_FMT_MEDIACODEC ||
-    m_format == RENDER_FMT_MEDIACODECSURFACE)
+     m_format == RENDER_FMT_MEDIACODECSURFACE ||
+     m_format == RENDER_FMT_DISP2)
     info.optimal_buffer_size = 2;
   else if(m_format == RENDER_FMT_IMXMAP)
   {
@@ -3187,9 +3303,22 @@
 }
 #endif
 
+#ifdef HAS_CEDARX
+void CLinuxRendererGLES::AddProcessor(CCedarXBuffer *buffer, int index)
+{
+  YUVBUFFER &buf = m_buffers[index];
+
+  SAFE_RELEASE(buf.Disp2Buffer);
+  buf.Disp2Buffer = buffer;
+
+  if (buffer)
+    buffer->Lock();
+}
+#endif
+
 bool CLinuxRendererGLES::IsGuiLayer()
 {
-  if (m_format == RENDER_FMT_BYPASS || m_format == RENDER_FMT_IMXMAP || m_format == RENDER_FMT_MEDIACODECSURFACE)
+  if (m_format == RENDER_FMT_BYPASS || m_format == RENDER_FMT_IMXMAP || m_format == RENDER_FMT_MEDIACODECSURFACE || m_format == RENDER_FMT_DISP2)
     return false;
   else
     return true;
diff -Nur a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h codec/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h	2016-04-17 14:05:15.000000000 +0200
+++ codec/xbmc/cores/VideoRenderers/LinuxRendererGLES.h	2016-10-24 17:57:39.888848117 +0200
@@ -45,6 +45,7 @@
 #ifdef HAS_IMXVPU
 class CDVDVideoCodecIMXBuffer;
 #endif
+class CCedarXBuffer;
 typedef std::vector<int>     Features;
 
 
@@ -94,7 +95,8 @@
   RENDER_EGLIMG = 0x200,
   RENDER_MEDIACODEC = 0x400,
   RENDER_MEDIACODECSURFACE = 0x800,
-  RENDER_IMXMAP = 0x1000
+  RENDER_IMXMAP = 0x1000,
+  RENDER_DISP2  = 0x2000
 };
 
 enum RenderQuality
@@ -177,6 +179,9 @@
 #ifdef HAS_IMXVPU
   virtual void         AddProcessor(CDVDVideoCodecIMXBuffer *codecinfo, int index);
 #endif
+#ifdef HAS_CEDARX
+  virtual void         AddProcessor(CCedarXBuffer *codecinfo, int index);
+#endif
 
 protected:
   virtual void Render(DWORD flags, int index);
@@ -225,6 +230,10 @@
   void UploadIMXMAPTexture(int index);
   void DeleteIMXMAPTexture(int index);
   bool CreateIMXMAPTexture(int index);
+  
+  void UploadDisp2Texture(int index);
+  void DeleteDisp2Texture(int index);
+  bool CreateDisp2Texture(int index);
 
   void CalculateTextureSourceRects(int source, int num_planes);
 
@@ -237,6 +246,7 @@
   void RenderCoreVideoRef(int index, int field);  // CoreVideo reference
   void RenderSurfaceTexture(int index, int field);// MediaCodec rendering using SurfaceTexture
   void RenderIMXMAPTexture(int index, int field); // IMXMAP rendering
+  void RenderDisp2Texture(int index, int field); // Disp2 rendering
 
   CFrameBufferObject m_fbo;
 
@@ -306,6 +316,9 @@
 #ifdef HAS_IMXVPU
     CDVDVideoCodecIMXBuffer *IMXBuffer;
 #endif
+#ifdef HAS_CEDARX
+    CCedarXBuffer *Disp2Buffer;
+#endif
   };
 
   typedef YUVBUFFER          YUVBUFFERS[NUM_BUFFERS];
diff -Nur a/xbmc/cores/VideoRenderers/RenderFormats.h codec/xbmc/cores/VideoRenderers/RenderFormats.h
--- a/xbmc/cores/VideoRenderers/RenderFormats.h	2016-04-17 14:05:15.000000000 +0200
+++ codec/xbmc/cores/VideoRenderers/RenderFormats.h	2016-10-24 17:57:39.888848117 +0200
@@ -43,6 +43,7 @@
   RENDER_FMT_MEDIACODECSURFACE,
   RENDER_FMT_IMXMAP,
   RENDER_FMT_MMAL,
+  RENDER_FMT_DISP2,
 };
 
 struct CRenderInfo
diff -Nur a/xbmc/cores/VideoRenderers/RenderManager.cpp codec/xbmc/cores/VideoRenderers/RenderManager.cpp
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp	2016-04-17 14:05:15.000000000 +0200
+++ codec/xbmc/cores/VideoRenderers/RenderManager.cpp	2016-10-24 17:57:39.888848117 +0200
@@ -1029,6 +1029,10 @@
   else if(pic.format == RENDER_FMT_MMAL)
     m_pRenderer->AddProcessor(pic.MMALBuffer, index);
 #endif
+#ifdef HAS_CEDARX
+  else if(pic.format == RENDER_FMT_DISP2)
+    m_pRenderer->AddProcessor(pic.Disp2Buffer, index);
+#endif
 
   m_pRenderer->ReleaseImage(index, false);
 
diff -Nur a/xbmc/settings/Settings.cpp codec/xbmc/settings/Settings.cpp
--- a/xbmc/settings/Settings.cpp	2016-08-03 19:58:43.960146875 +0200
+++ codec/xbmc/settings/Settings.cpp	2016-10-24 17:57:39.892181451 +0200
@@ -812,6 +812,9 @@
 #elif defined(HAS_IMXVPU)
   if (CFile::Exists(SETTINGS_XML_FOLDER "imx6.xml") && !Initialize(SETTINGS_XML_FOLDER "imx6.xml"))
     CLog::Log(LOGFATAL, "Unable to load imx6-specific settings definitions");
+#elif defined(HAS_CEDARX)
+  if (CFile::Exists(SETTINGS_XML_FOLDER "sunxi.xml") && !Initialize(SETTINGS_XML_FOLDER "sunxi.xml"))
+    CLog::Log(LOGFATAL, "Unable to load sunxi-specific settings definitions");
 #elif defined(TARGET_LINUX)
   if (CFile::Exists(SETTINGS_XML_FOLDER "linux.xml") && !Initialize(SETTINGS_XML_FOLDER "linux.xml"))
     CLog::Log(LOGFATAL, "Unable to load linux-specific settings definitions");
diff -Nur a/xbmc/settings/VideoSettings.h codec/xbmc/settings/VideoSettings.h
--- a/xbmc/settings/VideoSettings.h	2016-04-17 14:05:15.000000000 +0200
+++ codec/xbmc/settings/VideoSettings.h	2016-10-24 17:57:39.892181451 +0200
@@ -74,6 +74,8 @@
 
   VS_INTERLACEMETHOD_IMX_FASTMOTION = 29,
   VS_INTERLACEMETHOD_IMX_FASTMOTION_DOUBLE = 30,
+  
+  VS_INTERLACEMETHOD_DISP2_BOB = 31,
 
   VS_INTERLACEMETHOD_MAX // do not use and keep as last enum value.
 };
diff -Nur a/xbmc/video/dialogs/GUIDialogVideoSettings.cpp codec/xbmc/video/dialogs/GUIDialogVideoSettings.cpp
--- a/xbmc/video/dialogs/GUIDialogVideoSettings.cpp	2016-04-17 14:05:15.000000000 +0200
+++ codec/xbmc/video/dialogs/GUIDialogVideoSettings.cpp	2016-10-24 17:57:39.892181451 +0200
@@ -274,6 +274,7 @@
   entries.push_back(std::make_pair(16333, VS_INTERLACEMETHOD_MMAL_BOB_HALF));
   entries.push_back(std::make_pair(16334, VS_INTERLACEMETHOD_IMX_FASTMOTION));
   entries.push_back(std::make_pair(16335, VS_INTERLACEMETHOD_IMX_FASTMOTION_DOUBLE));
+  entries.push_back(std::make_pair(16336, VS_INTERLACEMETHOD_DISP2_BOB));
 
   /* remove unsupported methods */
   for (StaticIntegerSettingOptions::iterator it = entries.begin(); it != entries.end(); )
