From c978b5c00d5b6c19364a171c9c44a65bc0c96c59 Mon Sep 17 00:00:00 2001
From: Aneesh V <aneesh@ti.com>
Date: Fri, 25 Feb 2011 16:30:28 +0530
Subject: [PATCH 16/22] omap4: add sdram init support

Add support for the SDRAM controller (EMIF).

Signed-off-by: Aneesh V <aneesh@ti.com>
---
 arch/arm/cpu/armv7/omap4/Makefile           |    3 +
 arch/arm/cpu/armv7/omap4/board.c            |    2 +-
 arch/arm/cpu/armv7/omap4/emif.c             |  281 +++++++++++
 arch/arm/cpu/armv7/omap4/sdram_elpida.c     |  118 +++++
 arch/arm/include/asm/arch-omap4/emif.h      |  719 +++++++++++++++++++++++++++
 arch/arm/include/asm/arch-omap4/omap4.h     |   11 +
 arch/arm/include/asm/arch-omap4/sys_proto.h |    1 +
 include/configs/omap4_sdp4430.h             |    5 -
 spl/board/ti/sdp4430/Makefile               |   10 +-
 9 files changed, 1143 insertions(+), 7 deletions(-)
 create mode 100644 arch/arm/cpu/armv7/omap4/emif.c
 create mode 100644 arch/arm/cpu/armv7/omap4/sdram_elpida.c
 create mode 100644 arch/arm/include/asm/arch-omap4/emif.h

diff --git a/arch/arm/cpu/armv7/omap4/Makefile b/arch/arm/cpu/armv7/omap4/Makefile
index 6154e86..d9714fe 100644
--- a/arch/arm/cpu/armv7/omap4/Makefile
+++ b/arch/arm/cpu/armv7/omap4/Makefile
@@ -31,6 +31,9 @@ COBJS	+= board.o
 COBJS	+= mem.o
 COBJS	+= sys_info.o
 COBJS	+= clocks.o
+COBJS	+= emif.o
+COBJS	+= sdram_elpida.o
+
 
 SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
diff --git a/arch/arm/cpu/armv7/omap4/board.c b/arch/arm/cpu/armv7/omap4/board.c
index 62a59ad..89b1213 100644
--- a/arch/arm/cpu/armv7/omap4/board.c
+++ b/arch/arm/cpu/armv7/omap4/board.c
@@ -109,6 +109,7 @@ void s_init(void)
 #ifdef CONFIG_PRELOADER
 	preloader_console_init();
 #endif
+	sdram_init();
 }
 
 /*
@@ -169,7 +170,6 @@ u32 sdram_size(void)
  */
 int dram_init(void)
 {
-
 	gd->ram_size = sdram_size();
 
 	return 0;
diff --git a/arch/arm/cpu/armv7/omap4/emif.c b/arch/arm/cpu/armv7/omap4/emif.c
new file mode 100644
index 0000000..ee77743
--- /dev/null
+++ b/arch/arm/cpu/armv7/omap4/emif.c
@@ -0,0 +1,281 @@
+/*
+ * EMIF programming
+ *
+ * (C) Copyright 2010
+ * Texas Instruments, <www.ti.com>
+ *
+ * Aneesh V <aneesh@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/emif.h>
+#include <asm/arch/clocks.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/omap_common.h>
+
+static inline u32 emif_num(u32 base)
+{
+	if (base == OMAP44XX_EMIF1)
+		return 1;
+	else if (base == OMAP44XX_EMIF2)
+		return 2;
+	else
+		return 0;
+}
+
+static inline u32 get_mr(u32 base, u32 cs, u32 mr_addr)
+{
+	u32 mr;
+	struct emif_reg_struct *emif = (struct emif_reg_struct *)base;
+
+	mr_addr |= cs << OMAP44XX_REG_CS_SHIFT;
+	writel(mr_addr, &emif->emif_lpddr2_mode_reg_cfg);
+	if (omap4_revision() == OMAP4430_ES2_0)
+		mr = readl(&emif->emif_lpddr2_mode_reg_data_es2);
+	else
+		mr = readl(&emif->emif_lpddr2_mode_reg_data);
+	debug("get_mr: EMIF%d cs %d mr %08x val 0x%x\n", emif_num(base),
+	      cs, mr_addr, mr);
+	return mr;
+}
+
+static inline void set_mr(u32 base, u32 cs, u32 mr_addr, u32 mr_val)
+{
+	struct emif_reg_struct *emif = (struct emif_reg_struct *)base;
+
+	mr_addr |= cs << OMAP44XX_REG_CS_SHIFT;
+	writel(mr_addr, &emif->emif_lpddr2_mode_reg_cfg);
+	writel(mr_val, &emif->emif_lpddr2_mode_reg_data);
+}
+void emif_reset_phy(u32 base)
+{
+	struct emif_reg_struct *emif = (struct emif_reg_struct *)base;
+	u32 iodft;
+
+	iodft = readl(&emif->emif_iodft_tlgc);
+	iodft |= OMAP44XX_REG_RESET_PHY_MASK;
+	writel(iodft, &emif->emif_iodft_tlgc);
+}
+
+static void do_lpddr2_init(u32 base, u32 cs)
+{
+	u32 mr_addr;
+
+	/* Wait till device auto initialization is complete */
+	while (get_mr(base, cs, LPDDR2_MR0) & LPDDR2_MR0_DAI_MASK)
+		;
+	set_mr(base, cs, LPDDR2_MR10, MR10_ZQ_ZQINIT);
+	sdelay(10);
+	set_mr(base, cs, LPDDR2_MR1, MR1_BL_8_BT_SEQ_WRAP_EN_NWR_3);
+	set_mr(base, cs, LPDDR2_MR16, MR16_REF_FULL_ARRAY);
+	/*
+	 * Enable refresh along with writing MR2
+	 * Encoding of RL in MR2 is (RL - 2)
+	 */
+	mr_addr = LPDDR2_MR2 | OMAP44XX_REG_REFRESH_EN_MASK;
+	set_mr(base, cs, mr_addr, RL_FINAL - 2);
+}
+
+static void lpddr2_init(u32 base, const struct emif_regs *regs)
+{
+	struct emif_reg_struct *emif = (struct emif_reg_struct *)base;
+	u32 nvm;
+
+	/* Not NVM */
+	nvm = readl(&emif->emif_lpddr2_nvm_config);
+	nvm &= (~OMAP44XX_REG_CS1NVMEN_MASK);
+	writel(nvm, &emif->emif_lpddr2_nvm_config);
+	/*
+	 * Set the SDRAM_CONFIG and PHY_CTRL for the
+	 * un-locked frequency & default RL
+	 */
+	writel(regs->sdram_config_init, &emif->emif_sdram_config);
+	writel(regs->emif_ddr_phy_ctlr_1_init, &emif->emif_ddr_phy_ctrl_1);
+
+	do_lpddr2_init(base, CS0);
+	if (regs->sdram_config & OMAP44XX_REG_EBANK_MASK)
+		do_lpddr2_init(base, CS1);
+
+	writel(regs->sdram_config, &emif->emif_sdram_config);
+	writel(regs->emif_ddr_phy_ctlr_1, &emif->emif_ddr_phy_ctrl_1);
+}
+
+static void emif_update_timings(u32 base, const struct emif_regs *regs)
+{
+	struct emif_reg_struct *emif = (struct emif_reg_struct *)base;
+
+	writel(regs->ref_ctrl, &emif->emif_sdram_ref_ctrl_shdw);
+	writel(regs->sdram_tim1, &emif->emif_sdram_tim_1_shdw);
+	writel(regs->sdram_tim2, &emif->emif_sdram_tim_2_shdw);
+	writel(regs->sdram_tim3, &emif->emif_sdram_tim_3_shdw);
+	if (omap4_revision() == OMAP4430_ES1_0) {
+		/* ES1 bug EMIF should be in force idle during freq_update */
+		writel(0, &emif->emif_pwr_mgmt_ctrl);
+	} else {
+		writel(EMIF_PWR_MGMT_CTRL, &emif->emif_pwr_mgmt_ctrl);
+		writel(EMIF_PWR_MGMT_CTRL_SHDW, &emif->emif_pwr_mgmt_ctrl_shdw);
+	}
+	writel(regs->read_idle_ctrl, &emif->emif_read_idlectrl_shdw);
+	writel(regs->zq_config, &emif->emif_zq_config);
+	writel(regs->temp_alert_config, &emif->emif_temp_alert_config);
+	writel(regs->emif_ddr_phy_ctlr_1, &emif->emif_ddr_phy_ctrl_1_shdw);
+	/*
+	 * Workaround:
+	 * In a specific situation, the OCP interface between the DMM and
+	 * EMIF may hang.
+	 * 1. A TILER port is used to perform 2D burst writes of
+	 *       width 1 and height 8
+	 * 2. ELLAn port is used to perform reads
+	 * 3. All accesses are routed to the same EMIF controller
+	 *
+	 * Work around to avoid this issue REG_SYS_THRESH_MAX value should
+	 * be kept higher than default 0x7. As per recommondation 0x0A will
+	 * be used for better performance with REG_LL_THRESH_MAX = 0x00
+	 */
+	if (omap4_revision() == OMAP4430_ES1_0) {
+		writel(EMIF_L3_CONFIG_VAL_SYS_THRESH_0A_LL_THRESH_00,
+		       &emif->emif_l3_config);
+	}
+}
+
+static void do_sdram_init(u32 base)
+{
+	const struct emif_regs *regs, *tmp_regs;
+	u32 in_sdram, emif_nr;
+
+	in_sdram = running_from_sdram();
+	emif_nr = (base == OMAP44XX_EMIF1) ? 1 : 2;
+
+	emif_get_reg_dump(&regs, &tmp_regs);
+	regs = (emif_nr == 1) ? regs : tmp_regs;
+
+	/*
+	 * Initializing the LPDDR2 device can not happen from SDRAM.
+	 * Changing the timing registers in EMIF can happen(going from one
+	 * OPP to another)
+	 */
+	if (!in_sdram)
+		lpddr2_init(base, regs);
+
+	/* Write to the shadow registers */
+	emif_update_timings(base, regs);
+}
+
+void sdram_init_pads(void)
+{
+	u32 lpddr2io;
+	u32 omap4_rev = omap4_revision();
+
+	if (omap4_rev == OMAP4430_ES1_0)
+		lpddr2io = CONTROL_LPDDR2IO_SLEW_125PS_DRV8_PULL_DOWN;
+	else if (omap4_rev == OMAP4430_ES2_0)
+		lpddr2io = CONTROL_LPDDR2IO_SLEW_325PS_DRV8_GATE_KEEPER;
+	else
+		return;		/* Post ES2.1 reset values will work */
+
+	writel(lpddr2io, CONTROL_LPDDR2IO1_0);
+	writel(lpddr2io, CONTROL_LPDDR2IO1_1);
+	writel(lpddr2io, CONTROL_LPDDR2IO1_2);
+	writel(lpddr2io, CONTROL_LPDDR2IO2_0);
+	writel(lpddr2io, CONTROL_LPDDR2IO2_1);
+	writel(lpddr2io, CONTROL_LPDDR2IO2_2);
+
+	writel(CONTROL_EFUSE_2_NMOS_PMOS_PTV_CODE_1, CONTROL_EFUSE_2);
+}
+
+static void emif_post_init_config(u32 base)
+{
+	struct emif_reg_struct *emif = (struct emif_reg_struct *)base;
+	u32 omap4_rev = omap4_revision();
+
+	/* reset phy on ES2.0 */
+	if (omap4_rev == OMAP4430_ES2_0)
+		emif_reset_phy(base);
+
+	/* Put EMIF back in smart idle on ES1.0 */
+	if (omap4_rev == OMAP4430_ES1_0)
+		writel(0x80000000, &emif->emif_pwr_mgmt_ctrl);
+}
+
+static void dmm_init(u32 base)
+{
+	const struct dmm_lisa_map_regs *lisa_map_regs;
+
+	emif_get_dmm_regs(&lisa_map_regs);
+
+	struct dmm_lisa_map_regs *hw_lisa_map_regs =
+	    (struct dmm_lisa_map_regs *)base;
+
+	writel(0, &hw_lisa_map_regs->dmm_lisa_map_3);
+	writel(0, &hw_lisa_map_regs->dmm_lisa_map_2);
+	writel(0, &hw_lisa_map_regs->dmm_lisa_map_1);
+	writel(0, &hw_lisa_map_regs->dmm_lisa_map_0);
+
+	writel(lisa_map_regs->dmm_lisa_map_3,
+		&hw_lisa_map_regs->dmm_lisa_map_3);
+	writel(lisa_map_regs->dmm_lisa_map_2,
+		&hw_lisa_map_regs->dmm_lisa_map_2);
+	writel(lisa_map_regs->dmm_lisa_map_1,
+		&hw_lisa_map_regs->dmm_lisa_map_1);
+	writel(lisa_map_regs->dmm_lisa_map_0,
+		&hw_lisa_map_regs->dmm_lisa_map_0);
+}
+
+/*
+ * SDRAM initialization:
+ * SDRAM initialization has two parts:
+ * 1. Configuring the SDRAM device
+ * 2. Update the AC timings related parameters in the EMIF module
+ * (1) should be done only once and should not be done while we are
+ * running from SDRAM.
+ * (2) can and should be done more than once if OPP changes.
+ * Particularly, this may be needed when we boot without SPL and
+ * and using Configuration Header(CH). ROM code supports only at 50% OPP
+ * at boot (low power boot). So u-boot has to switch to OPP100 and update
+ * the frequency. So,
+ * Doing (1) and (2) makes sense - first time initialization
+ * Doing (2) and not (1) makes sense - OPP change (when using CH)
+ * Doing (1) and not (2) doen't make sense
+ * See do_sdram_init() for the details
+ */
+void sdram_init(void)
+{
+	u32 in_sdram;
+
+	in_sdram = running_from_sdram();
+
+	if (!in_sdram) {
+		sdram_init_pads();
+		bypass_dpll(CM_CLKMODE_DPLL_CORE);
+	}
+
+	do_sdram_init(OMAP44XX_EMIF1);
+	do_sdram_init(OMAP44XX_EMIF2);
+
+	if (!in_sdram) {
+		dmm_init(OMAP44XX_DMM_LISA_MAP_BASE);
+		emif_post_init_config(OMAP44XX_EMIF1);
+		emif_post_init_config(OMAP44XX_EMIF2);
+	}
+
+	/* for the shadow registers to take effect */
+	freq_update_core();
+}
diff --git a/arch/arm/cpu/armv7/omap4/sdram_elpida.c b/arch/arm/cpu/armv7/omap4/sdram_elpida.c
new file mode 100644
index 0000000..37e808c
--- /dev/null
+++ b/arch/arm/cpu/armv7/omap4/sdram_elpida.c
@@ -0,0 +1,118 @@
+/*
+ * Timing and Organization details of the Elpida parts used in OMAP4
+ * SDPs and Panda
+ *
+ * (C) Copyright 2010
+ * Texas Instruments, <www.ti.com>
+ *
+ * Aneesh V <aneesh@ti.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <asm/arch/emif.h>
+#include <asm/arch/sys_proto.h>
+
+static const struct emif_regs emif_regs_elpida_200_mhz_2cs = {
+	.sdram_config_init		= 0x80000eb9,
+	.sdram_config			= 0x80001ab9,
+	.ref_ctrl			= 0x0000030c,
+	.sdram_tim1			= 0x08648311,
+	.sdram_tim2			= 0x101b06ca,
+	.sdram_tim3			= 0x0048a19f,
+	.read_idle_ctrl			= 0x000501ff,
+	.zq_config			= 0x500b3214,
+	.temp_alert_config		= 0xd8016893,
+	.emif_ddr_phy_ctlr_1_init	= 0x049ffff5,
+	.emif_ddr_phy_ctlr_1		= 0x049ff808
+};
+
+static const struct emif_regs emif_regs_elpida_380_mhz_1cs = {
+	.sdram_config_init		= 0x80000eb1,
+	.sdram_config			= 0x80001ab1,
+	.ref_ctrl			= 0x000005cd,
+	.sdram_tim1			= 0x10cb0622,
+	.sdram_tim2			= 0x20350d52,
+	.sdram_tim3			= 0x00b1431f,
+	.read_idle_ctrl			= 0x000501ff,
+	.zq_config			= 0x500b3214,
+	.temp_alert_config		= 0x58016893,
+	.emif_ddr_phy_ctlr_1_init	= 0x049ffff5,
+	.emif_ddr_phy_ctlr_1		= 0x049ff418
+};
+
+const struct emif_regs emif_regs_elpida_400_mhz_2cs = {
+	.sdram_config_init		= 0x80000eb9,
+	.sdram_config			= 0x80001ab9,
+	.ref_ctrl			= 0x00000618,
+	.sdram_tim1			= 0x10eb0662,
+	.sdram_tim2			= 0x20370dd2,
+	.sdram_tim3			= 0x00b1c33f,
+	.read_idle_ctrl			= 0x000501ff,
+	.zq_config			= 0xd00b3214,
+	.temp_alert_config		= 0xd8016893,
+	.emif_ddr_phy_ctlr_1_init	= 0x049ffff5,
+	.emif_ddr_phy_ctlr_1		= 0x049ff418
+};
+const struct dmm_lisa_map_regs lisa_map_2G_x_1_x_2 = {
+	.dmm_lisa_map_0 = 0xFF020100,
+	.dmm_lisa_map_1 = 0,
+	.dmm_lisa_map_2 = 0,
+	.dmm_lisa_map_3 = 0x80540300
+};
+
+const struct dmm_lisa_map_regs lisa_map_2G_x_2_x_2 = {
+	.dmm_lisa_map_0 = 0xFF020100,
+	.dmm_lisa_map_1 = 0,
+	.dmm_lisa_map_2 = 0,
+	.dmm_lisa_map_3 = 0x80640300
+};
+
+void emif_get_reg_dump_sdp(const struct emif_regs **emif1_regs,
+			const struct emif_regs **emif2_regs)
+{
+	u32 omap4_rev = omap4_revision();
+
+	if (omap4_rev == OMAP4430_ES1_0) {
+		*emif1_regs = &emif_regs_elpida_380_mhz_1cs;
+		*emif2_regs = &emif_regs_elpida_380_mhz_1cs;
+	} else if (omap4_rev == OMAP4430_ES2_0) {
+		*emif1_regs = &emif_regs_elpida_200_mhz_2cs;
+		*emif2_regs = &emif_regs_elpida_200_mhz_2cs;
+	} else {
+		*emif1_regs = &emif_regs_elpida_400_mhz_2cs;
+		*emif2_regs = &emif_regs_elpida_400_mhz_2cs;
+	}
+}
+void emif_get_reg_dump(const struct emif_regs **emif1_regs,
+			const struct emif_regs **emif2_regs)
+	__attribute__((weak, alias("emif_get_reg_dump_sdp")));
+
+void emif_get_dmm_regs_sdp(const struct dmm_lisa_map_regs **dmm_lisa_regs)
+{
+	u32 omap_rev = omap4_revision();
+
+	if (omap_rev == OMAP4430_ES1_0)
+		*dmm_lisa_regs = &lisa_map_2G_x_1_x_2;
+	else
+		*dmm_lisa_regs = &lisa_map_2G_x_2_x_2;
+}
+
+void emif_get_dmm_regs(const struct dmm_lisa_map_regs **dmm_lisa_regs)
+	__attribute__((weak, alias("emif_get_dmm_regs_sdp")));
diff --git a/arch/arm/include/asm/arch-omap4/emif.h b/arch/arm/include/asm/arch-omap4/emif.h
new file mode 100644
index 0000000..f2d54cb
--- /dev/null
+++ b/arch/arm/include/asm/arch-omap4/emif.h
@@ -0,0 +1,719 @@
+/*
+ * OMAP44xx EMIF header
+ *
+ * Copyright (C) 2009-2010 Texas Instruments, Inc.
+ *
+ * Aneesh V <aneesh@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _EMIF_H_
+#define _EMIF_H_
+#include <asm/types.h>
+#include <common.h>
+
+/* Base address */
+#define OMAP44XX_EMIF1				0x4c000000
+#define OMAP44XX_EMIF2				0x4d000000
+
+/* Registers shifts and masks */
+
+/* EMIF_MOD_ID_REV */
+#define OMAP44XX_REG_SCHEME_SHIFT			30
+#define OMAP44XX_REG_SCHEME_MASK			(0x3 << 30)
+#define OMAP44XX_REG_MODULE_ID_SHIFT			16
+#define OMAP44XX_REG_MODULE_ID_MASK			(0xfff << 16)
+#define OMAP44XX_REG_RTL_VERSION_SHIFT			11
+#define OMAP44XX_REG_RTL_VERSION_MASK			(0x1f << 11)
+#define OMAP44XX_REG_MAJOR_REVISION_SHIFT		8
+#define OMAP44XX_REG_MAJOR_REVISION_MASK		(0x7 << 8)
+#define OMAP44XX_REG_MINOR_REVISION_SHIFT		0
+#define OMAP44XX_REG_MINOR_REVISION_MASK		(0x3f << 0)
+
+/* STATUS */
+#define OMAP44XX_REG_BE_SHIFT				31
+#define OMAP44XX_REG_BE_MASK				(1 << 31)
+#define OMAP44XX_REG_DUAL_CLK_MODE_SHIFT		30
+#define OMAP44XX_REG_DUAL_CLK_MODE_MASK			(1 << 30)
+#define OMAP44XX_REG_FAST_INIT_SHIFT			29
+#define OMAP44XX_REG_FAST_INIT_MASK			(1 << 29)
+#define OMAP44XX_REG_PHY_DLL_READY_SHIFT		2
+#define OMAP44XX_REG_PHY_DLL_READY_MASK			(1 << 2)
+
+/* SDRAM_CONFIG */
+#define OMAP44XX_REG_SDRAM_TYPE_SHIFT			29
+#define OMAP44XX_REG_SDRAM_TYPE_MASK			(0x7 << 29)
+#define OMAP44XX_REG_IBANK_POS_SHIFT			27
+#define OMAP44XX_REG_IBANK_POS_MASK			(0x3 << 27)
+#define OMAP44XX_REG_DDR_TERM_SHIFT			24
+#define OMAP44XX_REG_DDR_TERM_MASK			(0x7 << 24)
+#define OMAP44XX_REG_DDR2_DDQS_SHIFT			23
+#define OMAP44XX_REG_DDR2_DDQS_MASK			(1 << 23)
+#define OMAP44XX_REG_DYN_ODT_SHIFT			21
+#define OMAP44XX_REG_DYN_ODT_MASK			(0x3 << 21)
+#define OMAP44XX_REG_DDR_DISABLE_DLL_SHIFT		20
+#define OMAP44XX_REG_DDR_DISABLE_DLL_MASK		(1 << 20)
+#define OMAP44XX_REG_SDRAM_DRIVE_SHIFT			18
+#define OMAP44XX_REG_SDRAM_DRIVE_MASK			(0x3 << 18)
+#define OMAP44XX_REG_CWL_SHIFT				16
+#define OMAP44XX_REG_CWL_MASK				(0x3 << 16)
+#define OMAP44XX_REG_NARROW_MODE_SHIFT			14
+#define OMAP44XX_REG_NARROW_MODE_MASK			(0x3 << 14)
+#define OMAP44XX_REG_CL_SHIFT				10
+#define OMAP44XX_REG_CL_MASK				(0xf << 10)
+#define OMAP44XX_REG_ROWSIZE_SHIFT			7
+#define OMAP44XX_REG_ROWSIZE_MASK			(0x7 << 7)
+#define OMAP44XX_REG_IBANK_SHIFT			4
+#define OMAP44XX_REG_IBANK_MASK				(0x7 << 4)
+#define OMAP44XX_REG_EBANK_SHIFT			3
+#define OMAP44XX_REG_EBANK_MASK				(1 << 3)
+#define OMAP44XX_REG_PAGESIZE_SHIFT			0
+#define OMAP44XX_REG_PAGESIZE_MASK			(0x7 << 0)
+
+/* SDRAM_CONFIG_2 */
+#define OMAP44XX_REG_CS1NVMEN_SHIFT			30
+#define OMAP44XX_REG_CS1NVMEN_MASK			(1 << 30)
+#define OMAP44XX_REG_EBANK_POS_SHIFT			27
+#define OMAP44XX_REG_EBANK_POS_MASK			(1 << 27)
+#define OMAP44XX_REG_RDBNUM_SHIFT			4
+#define OMAP44XX_REG_RDBNUM_MASK			(0x3 << 4)
+#define OMAP44XX_REG_RDBSIZE_SHIFT			0
+#define OMAP44XX_REG_RDBSIZE_MASK			(0x7 << 0)
+
+/* SDRAM_REF_CTRL */
+#define OMAP44XX_REG_INITREF_DIS_SHIFT			31
+#define OMAP44XX_REG_INITREF_DIS_MASK			(1 << 31)
+#define OMAP44XX_REG_SRT_SHIFT				29
+#define OMAP44XX_REG_SRT_MASK				(1 << 29)
+#define OMAP44XX_REG_ASR_SHIFT				28
+#define OMAP44XX_REG_ASR_MASK				(1 << 28)
+#define OMAP44XX_REG_PASR_SHIFT				24
+#define OMAP44XX_REG_PASR_MASK				(0x7 << 24)
+#define OMAP44XX_REG_REFRESH_RATE_SHIFT			0
+#define OMAP44XX_REG_REFRESH_RATE_MASK			(0xffff << 0)
+
+/* SDRAM_REF_CTRL_SHDW */
+#define OMAP44XX_REG_REFRESH_RATE_SHDW_SHIFT		0
+#define OMAP44XX_REG_REFRESH_RATE_SHDW_MASK		(0xffff << 0)
+
+/* SDRAM_TIM_1 */
+#define OMAP44XX_REG_T_RP_SHIFT				25
+#define OMAP44XX_REG_T_RP_MASK				(0xf << 25)
+#define OMAP44XX_REG_T_RCD_SHIFT			21
+#define OMAP44XX_REG_T_RCD_MASK				(0xf << 21)
+#define OMAP44XX_REG_T_WR_SHIFT				17
+#define OMAP44XX_REG_T_WR_MASK				(0xf << 17)
+#define OMAP44XX_REG_T_RAS_SHIFT			12
+#define OMAP44XX_REG_T_RAS_MASK				(0x1f << 12)
+#define OMAP44XX_REG_T_RC_SHIFT				6
+#define OMAP44XX_REG_T_RC_MASK				(0x3f << 6)
+#define OMAP44XX_REG_T_RRD_SHIFT			3
+#define OMAP44XX_REG_T_RRD_MASK				(0x7 << 3)
+#define OMAP44XX_REG_T_WTR_SHIFT			0
+#define OMAP44XX_REG_T_WTR_MASK				(0x7 << 0)
+
+/* SDRAM_TIM_1_SHDW */
+#define OMAP44XX_REG_T_RP_SHDW_SHIFT			25
+#define OMAP44XX_REG_T_RP_SHDW_MASK			(0xf << 25)
+#define OMAP44XX_REG_T_RCD_SHDW_SHIFT			21
+#define OMAP44XX_REG_T_RCD_SHDW_MASK			(0xf << 21)
+#define OMAP44XX_REG_T_WR_SHDW_SHIFT			17
+#define OMAP44XX_REG_T_WR_SHDW_MASK			(0xf << 17)
+#define OMAP44XX_REG_T_RAS_SHDW_SHIFT			12
+#define OMAP44XX_REG_T_RAS_SHDW_MASK			(0x1f << 12)
+#define OMAP44XX_REG_T_RC_SHDW_SHIFT			6
+#define OMAP44XX_REG_T_RC_SHDW_MASK			(0x3f << 6)
+#define OMAP44XX_REG_T_RRD_SHDW_SHIFT			3
+#define OMAP44XX_REG_T_RRD_SHDW_MASK			(0x7 << 3)
+#define OMAP44XX_REG_T_WTR_SHDW_SHIFT			0
+#define OMAP44XX_REG_T_WTR_SHDW_MASK			(0x7 << 0)
+
+/* SDRAM_TIM_2 */
+#define OMAP44XX_REG_T_XP_SHIFT				28
+#define OMAP44XX_REG_T_XP_MASK				(0x7 << 28)
+#define OMAP44XX_REG_T_ODT_SHIFT			25
+#define OMAP44XX_REG_T_ODT_MASK				(0x7 << 25)
+#define OMAP44XX_REG_T_XSNR_SHIFT			16
+#define OMAP44XX_REG_T_XSNR_MASK			(0x1ff << 16)
+#define OMAP44XX_REG_T_XSRD_SHIFT			6
+#define OMAP44XX_REG_T_XSRD_MASK			(0x3ff << 6)
+#define OMAP44XX_REG_T_RTP_SHIFT			3
+#define OMAP44XX_REG_T_RTP_MASK				(0x7 << 3)
+#define OMAP44XX_REG_T_CKE_SHIFT			0
+#define OMAP44XX_REG_T_CKE_MASK				(0x7 << 0)
+
+/* SDRAM_TIM_2_SHDW */
+#define OMAP44XX_REG_T_XP_SHDW_SHIFT			28
+#define OMAP44XX_REG_T_XP_SHDW_MASK			(0x7 << 28)
+#define OMAP44XX_REG_T_ODT_SHDW_SHIFT			25
+#define OMAP44XX_REG_T_ODT_SHDW_MASK			(0x7 << 25)
+#define OMAP44XX_REG_T_XSNR_SHDW_SHIFT			16
+#define OMAP44XX_REG_T_XSNR_SHDW_MASK			(0x1ff << 16)
+#define OMAP44XX_REG_T_XSRD_SHDW_SHIFT			6
+#define OMAP44XX_REG_T_XSRD_SHDW_MASK			(0x3ff << 6)
+#define OMAP44XX_REG_T_RTP_SHDW_SHIFT			3
+#define OMAP44XX_REG_T_RTP_SHDW_MASK			(0x7 << 3)
+#define OMAP44XX_REG_T_CKE_SHDW_SHIFT			0
+#define OMAP44XX_REG_T_CKE_SHDW_MASK			(0x7 << 0)
+
+/* SDRAM_TIM_3 */
+#define OMAP44XX_REG_T_CKESR_SHIFT			21
+#define OMAP44XX_REG_T_CKESR_MASK			(0x7 << 21)
+#define OMAP44XX_REG_ZQ_ZQCS_SHIFT			15
+#define OMAP44XX_REG_ZQ_ZQCS_MASK			(0x3f << 15)
+#define OMAP44XX_REG_T_TDQSCKMAX_SHIFT			13
+#define OMAP44XX_REG_T_TDQSCKMAX_MASK			(0x3 << 13)
+#define OMAP44XX_REG_T_RFC_SHIFT			4
+#define OMAP44XX_REG_T_RFC_MASK				(0x1ff << 4)
+#define OMAP44XX_REG_T_RAS_MAX_SHIFT			0
+#define OMAP44XX_REG_T_RAS_MAX_MASK			(0xf << 0)
+
+/* SDRAM_TIM_3_SHDW */
+#define OMAP44XX_REG_T_CKESR_SHDW_SHIFT			21
+#define OMAP44XX_REG_T_CKESR_SHDW_MASK			(0x7 << 21)
+#define OMAP44XX_REG_ZQ_ZQCS_SHDW_SHIFT			15
+#define OMAP44XX_REG_ZQ_ZQCS_SHDW_MASK			(0x3f << 15)
+#define OMAP44XX_REG_T_TDQSCKMAX_SHDW_SHIFT		13
+#define OMAP44XX_REG_T_TDQSCKMAX_SHDW_MASK		(0x3 << 13)
+#define OMAP44XX_REG_T_RFC_SHDW_SHIFT			4
+#define OMAP44XX_REG_T_RFC_SHDW_MASK			(0x1ff << 4)
+#define OMAP44XX_REG_T_RAS_MAX_SHDW_SHIFT		0
+#define OMAP44XX_REG_T_RAS_MAX_SHDW_MASK		(0xf << 0)
+
+/* LPDDR2_NVM_TIM */
+#define OMAP44XX_REG_NVM_T_XP_SHIFT			28
+#define OMAP44XX_REG_NVM_T_XP_MASK			(0x7 << 28)
+#define OMAP44XX_REG_NVM_T_WTR_SHIFT			24
+#define OMAP44XX_REG_NVM_T_WTR_MASK			(0x7 << 24)
+#define OMAP44XX_REG_NVM_T_RP_SHIFT			20
+#define OMAP44XX_REG_NVM_T_RP_MASK			(0xf << 20)
+#define OMAP44XX_REG_NVM_T_WRA_SHIFT			16
+#define OMAP44XX_REG_NVM_T_WRA_MASK			(0xf << 16)
+#define OMAP44XX_REG_NVM_T_RRD_SHIFT			8
+#define OMAP44XX_REG_NVM_T_RRD_MASK			(0xff << 8)
+#define OMAP44XX_REG_NVM_T_RCDMIN_SHIFT			0
+#define OMAP44XX_REG_NVM_T_RCDMIN_MASK			(0xff << 0)
+
+/* LPDDR2_NVM_TIM_SHDW */
+#define OMAP44XX_REG_NVM_T_XP_SHDW_SHIFT		28
+#define OMAP44XX_REG_NVM_T_XP_SHDW_MASK			(0x7 << 28)
+#define OMAP44XX_REG_NVM_T_WTR_SHDW_SHIFT		24
+#define OMAP44XX_REG_NVM_T_WTR_SHDW_MASK		(0x7 << 24)
+#define OMAP44XX_REG_NVM_T_RP_SHDW_SHIFT		20
+#define OMAP44XX_REG_NVM_T_RP_SHDW_MASK			(0xf << 20)
+#define OMAP44XX_REG_NVM_T_WRA_SHDW_SHIFT		16
+#define OMAP44XX_REG_NVM_T_WRA_SHDW_MASK		(0xf << 16)
+#define OMAP44XX_REG_NVM_T_RRD_SHDW_SHIFT		8
+#define OMAP44XX_REG_NVM_T_RRD_SHDW_MASK		(0xff << 8)
+#define OMAP44XX_REG_NVM_T_RCDMIN_SHDW_SHIFT		0
+#define OMAP44XX_REG_NVM_T_RCDMIN_SHDW_MASK		(0xff << 0)
+
+/* PWR_MGMT_CTRL */
+#define OMAP44XX_REG_IDLEMODE_SHIFT			30
+#define OMAP44XX_REG_IDLEMODE_MASK			(0x3 << 30)
+#define OMAP44XX_REG_PD_TIM_SHIFT			12
+#define OMAP44XX_REG_PD_TIM_MASK			(0xf << 12)
+#define OMAP44XX_REG_DPD_EN_SHIFT			11
+#define OMAP44XX_REG_DPD_EN_MASK			(1 << 11)
+#define OMAP44XX_REG_LP_MODE_SHIFT			8
+#define OMAP44XX_REG_LP_MODE_MASK			(0x7 << 8)
+#define OMAP44XX_REG_SR_TIM_SHIFT			4
+#define OMAP44XX_REG_SR_TIM_MASK			(0xf << 4)
+#define OMAP44XX_REG_CS_TIM_SHIFT			0
+#define OMAP44XX_REG_CS_TIM_MASK			(0xf << 0)
+
+/* PWR_MGMT_CTRL_SHDW */
+#define OMAP44XX_REG_PD_TIM_SHDW_SHIFT			8
+#define OMAP44XX_REG_PD_TIM_SHDW_MASK			(0xf << 8)
+#define OMAP44XX_REG_SR_TIM_SHDW_SHIFT			4
+#define OMAP44XX_REG_SR_TIM_SHDW_MASK			(0xf << 4)
+#define OMAP44XX_REG_CS_TIM_SHDW_SHIFT			0
+#define OMAP44XX_REG_CS_TIM_SHDW_MASK			(0xf << 0)
+
+/* LPDDR2_MODE_REG_DATA */
+#define OMAP44XX_REG_VALUE_0_SHIFT			0
+#define OMAP44XX_REG_VALUE_0_MASK			(0x7f << 0)
+
+/* LPDDR2_MODE_REG_CFG */
+#define OMAP44XX_REG_CS_SHIFT				31
+#define OMAP44XX_REG_CS_MASK				(1 << 31)
+#define OMAP44XX_REG_REFRESH_EN_SHIFT			30
+#define OMAP44XX_REG_REFRESH_EN_MASK			(1 << 30)
+#define OMAP44XX_REG_ADDRESS_SHIFT			0
+#define OMAP44XX_REG_ADDRESS_MASK			(0xff << 0)
+
+/* OCP_CONFIG */
+#define OMAP44XX_REG_SYS_THRESH_MAX_SHIFT		24
+#define OMAP44XX_REG_SYS_THRESH_MAX_MASK		(0xf << 24)
+#define OMAP44XX_REG_LL_THRESH_MAX_SHIFT		16
+#define OMAP44XX_REG_LL_THRESH_MAX_MASK			(0xf << 16)
+#define OMAP44XX_REG_PR_OLD_COUNT_SHIFT			0
+#define OMAP44XX_REG_PR_OLD_COUNT_MASK			(0xff << 0)
+
+/* OCP_CFG_VAL_1 */
+#define OMAP44XX_REG_SYS_BUS_WIDTH_SHIFT		30
+#define OMAP44XX_REG_SYS_BUS_WIDTH_MASK			(0x3 << 30)
+#define OMAP44XX_REG_LL_BUS_WIDTH_SHIFT			28
+#define OMAP44XX_REG_LL_BUS_WIDTH_MASK			(0x3 << 28)
+#define OMAP44XX_REG_WR_FIFO_DEPTH_SHIFT		8
+#define OMAP44XX_REG_WR_FIFO_DEPTH_MASK			(0xff << 8)
+#define OMAP44XX_REG_CMD_FIFO_DEPTH_SHIFT		0
+#define OMAP44XX_REG_CMD_FIFO_DEPTH_MASK		(0xff << 0)
+
+/* OCP_CFG_VAL_2 */
+#define OMAP44XX_REG_RREG_FIFO_DEPTH_SHIFT		16
+#define OMAP44XX_REG_RREG_FIFO_DEPTH_MASK		(0xff << 16)
+#define OMAP44XX_REG_RSD_FIFO_DEPTH_SHIFT		8
+#define OMAP44XX_REG_RSD_FIFO_DEPTH_MASK		(0xff << 8)
+#define OMAP44XX_REG_RCMD_FIFO_DEPTH_SHIFT		0
+#define OMAP44XX_REG_RCMD_FIFO_DEPTH_MASK		(0xff << 0)
+
+/* IODFT_TLGC */
+#define OMAP44XX_REG_TLEC_SHIFT				16
+#define OMAP44XX_REG_TLEC_MASK				(0xffff << 16)
+#define OMAP44XX_REG_MT_SHIFT				14
+#define OMAP44XX_REG_MT_MASK				(1 << 14)
+#define OMAP44XX_REG_ACT_CAP_EN_SHIFT			13
+#define OMAP44XX_REG_ACT_CAP_EN_MASK			(1 << 13)
+#define OMAP44XX_REG_OPG_LD_SHIFT			12
+#define OMAP44XX_REG_OPG_LD_MASK			(1 << 12)
+#define OMAP44XX_REG_RESET_PHY_SHIFT			10
+#define OMAP44XX_REG_RESET_PHY_MASK			(1 << 10)
+#define OMAP44XX_REG_MMS_SHIFT				8
+#define OMAP44XX_REG_MMS_MASK				(1 << 8)
+#define OMAP44XX_REG_MC_SHIFT				4
+#define OMAP44XX_REG_MC_MASK				(0x3 << 4)
+#define OMAP44XX_REG_PC_SHIFT				1
+#define OMAP44XX_REG_PC_MASK				(0x7 << 1)
+#define OMAP44XX_REG_TM_SHIFT				0
+#define OMAP44XX_REG_TM_MASK				(1 << 0)
+
+/* IODFT_CTRL_MISR_RSLT */
+#define OMAP44XX_REG_DQM_TLMR_SHIFT			16
+#define OMAP44XX_REG_DQM_TLMR_MASK			(0x3ff << 16)
+#define OMAP44XX_REG_CTL_TLMR_SHIFT			0
+#define OMAP44XX_REG_CTL_TLMR_MASK			(0x7ff << 0)
+
+/* IODFT_ADDR_MISR_RSLT */
+#define OMAP44XX_REG_ADDR_TLMR_SHIFT			0
+#define OMAP44XX_REG_ADDR_TLMR_MASK			(0x1fffff << 0)
+
+/* IODFT_DATA_MISR_RSLT_1 */
+#define OMAP44XX_REG_DATA_TLMR_31_0_SHIFT		0
+#define OMAP44XX_REG_DATA_TLMR_31_0_MASK		(0xffffffff << 0)
+
+/* IODFT_DATA_MISR_RSLT_2 */
+#define OMAP44XX_REG_DATA_TLMR_63_32_SHIFT		0
+#define OMAP44XX_REG_DATA_TLMR_63_32_MASK		(0xffffffff << 0)
+
+/* IODFT_DATA_MISR_RSLT_3 */
+#define OMAP44XX_REG_DATA_TLMR_66_64_SHIFT		0
+#define OMAP44XX_REG_DATA_TLMR_66_64_MASK		(0x7 << 0)
+
+/* PERF_CNT_1 */
+#define OMAP44XX_REG_COUNTER1_SHIFT			0
+#define OMAP44XX_REG_COUNTER1_MASK			(0xffffffff << 0)
+
+/* PERF_CNT_2 */
+#define OMAP44XX_REG_COUNTER2_SHIFT			0
+#define OMAP44XX_REG_COUNTER2_MASK			(0xffffffff << 0)
+
+/* PERF_CNT_CFG */
+#define OMAP44XX_REG_CNTR2_MCONNID_EN_SHIFT		31
+#define OMAP44XX_REG_CNTR2_MCONNID_EN_MASK		(1 << 31)
+#define OMAP44XX_REG_CNTR2_REGION_EN_SHIFT		30
+#define OMAP44XX_REG_CNTR2_REGION_EN_MASK		(1 << 30)
+#define OMAP44XX_REG_CNTR2_CFG_SHIFT			16
+#define OMAP44XX_REG_CNTR2_CFG_MASK			(0xf << 16)
+#define OMAP44XX_REG_CNTR1_MCONNID_EN_SHIFT		15
+#define OMAP44XX_REG_CNTR1_MCONNID_EN_MASK		(1 << 15)
+#define OMAP44XX_REG_CNTR1_REGION_EN_SHIFT		14
+#define OMAP44XX_REG_CNTR1_REGION_EN_MASK		(1 << 14)
+#define OMAP44XX_REG_CNTR1_CFG_SHIFT			0
+#define OMAP44XX_REG_CNTR1_CFG_MASK			(0xf << 0)
+
+/* PERF_CNT_SEL */
+#define OMAP44XX_REG_MCONNID2_SHIFT			24
+#define OMAP44XX_REG_MCONNID2_MASK			(0xff << 24)
+#define OMAP44XX_REG_REGION_SEL2_SHIFT			16
+#define OMAP44XX_REG_REGION_SEL2_MASK			(0x3 << 16)
+#define OMAP44XX_REG_MCONNID1_SHIFT			8
+#define OMAP44XX_REG_MCONNID1_MASK			(0xff << 8)
+#define OMAP44XX_REG_REGION_SEL1_SHIFT			0
+#define OMAP44XX_REG_REGION_SEL1_MASK			(0x3 << 0)
+
+/* PERF_CNT_TIM */
+#define OMAP44XX_REG_TOTAL_TIME_SHIFT			0
+#define OMAP44XX_REG_TOTAL_TIME_MASK			(0xffffffff << 0)
+
+/* READ_IDLE_CTRL */
+#define OMAP44XX_REG_READ_IDLE_LEN_SHIFT		16
+#define OMAP44XX_REG_READ_IDLE_LEN_MASK			(0xf << 16)
+#define OMAP44XX_REG_READ_IDLE_INTERVAL_SHIFT		0
+#define OMAP44XX_REG_READ_IDLE_INTERVAL_MASK		(0x1ff << 0)
+
+/* READ_IDLE_CTRL_SHDW */
+#define OMAP44XX_REG_READ_IDLE_LEN_SHDW_SHIFT		16
+#define OMAP44XX_REG_READ_IDLE_LEN_SHDW_MASK		(0xf << 16)
+#define OMAP44XX_REG_READ_IDLE_INTERVAL_SHDW_SHIFT	0
+#define OMAP44XX_REG_READ_IDLE_INTERVAL_SHDW_MASK	(0x1ff << 0)
+
+/* IRQ_EOI */
+#define OMAP44XX_REG_EOI_SHIFT				0
+#define OMAP44XX_REG_EOI_MASK				(1 << 0)
+
+/* IRQSTATUS_RAW_SYS */
+#define OMAP44XX_REG_DNV_SYS_SHIFT			2
+#define OMAP44XX_REG_DNV_SYS_MASK			(1 << 2)
+#define OMAP44XX_REG_TA_SYS_SHIFT			1
+#define OMAP44XX_REG_TA_SYS_MASK			(1 << 1)
+#define OMAP44XX_REG_ERR_SYS_SHIFT			0
+#define OMAP44XX_REG_ERR_SYS_MASK			(1 << 0)
+
+/* IRQSTATUS_RAW_LL */
+#define OMAP44XX_REG_DNV_LL_SHIFT			2
+#define OMAP44XX_REG_DNV_LL_MASK			(1 << 2)
+#define OMAP44XX_REG_TA_LL_SHIFT			1
+#define OMAP44XX_REG_TA_LL_MASK				(1 << 1)
+#define OMAP44XX_REG_ERR_LL_SHIFT			0
+#define OMAP44XX_REG_ERR_LL_MASK			(1 << 0)
+
+/* IRQSTATUS_SYS */
+
+/* IRQSTATUS_LL */
+
+/* IRQENABLE_SET_SYS */
+#define OMAP44XX_REG_EN_DNV_SYS_SHIFT			2
+#define OMAP44XX_REG_EN_DNV_SYS_MASK			(1 << 2)
+#define OMAP44XX_REG_EN_TA_SYS_SHIFT			1
+#define OMAP44XX_REG_EN_TA_SYS_MASK			(1 << 1)
+#define OMAP44XX_REG_EN_ERR_SYS_SHIFT			0
+#define OMAP44XX_REG_EN_ERR_SYS_MASK			(1 << 0)
+
+/* IRQENABLE_SET_LL */
+#define OMAP44XX_REG_EN_DNV_LL_SHIFT			2
+#define OMAP44XX_REG_EN_DNV_LL_MASK			(1 << 2)
+#define OMAP44XX_REG_EN_TA_LL_SHIFT			1
+#define OMAP44XX_REG_EN_TA_LL_MASK			(1 << 1)
+#define OMAP44XX_REG_EN_ERR_LL_SHIFT			0
+#define OMAP44XX_REG_EN_ERR_LL_MASK			(1 << 0)
+
+/* IRQENABLE_CLR_SYS */
+
+/* IRQENABLE_CLR_LL */
+
+/* ZQ_CONFIG */
+#define OMAP44XX_REG_ZQ_CS1EN_SHIFT			31
+#define OMAP44XX_REG_ZQ_CS1EN_MASK			(1 << 31)
+#define OMAP44XX_REG_ZQ_CS0EN_SHIFT			30
+#define OMAP44XX_REG_ZQ_CS0EN_MASK			(1 << 30)
+#define OMAP44XX_REG_ZQ_DUALCALEN_SHIFT			29
+#define OMAP44XX_REG_ZQ_DUALCALEN_MASK			(1 << 29)
+#define OMAP44XX_REG_ZQ_SFEXITEN_SHIFT			28
+#define OMAP44XX_REG_ZQ_SFEXITEN_MASK			(1 << 28)
+#define OMAP44XX_REG_ZQ_ZQINIT_MULT_SHIFT		18
+#define OMAP44XX_REG_ZQ_ZQINIT_MULT_MASK		(0x3 << 18)
+#define OMAP44XX_REG_ZQ_ZQCL_MULT_SHIFT			16
+#define OMAP44XX_REG_ZQ_ZQCL_MULT_MASK			(0x3 << 16)
+#define OMAP44XX_REG_ZQ_REFINTERVAL_SHIFT		0
+#define OMAP44XX_REG_ZQ_REFINTERVAL_MASK		(0xffff << 0)
+
+/* TEMP_ALERT_CONFIG */
+#define OMAP44XX_REG_TA_CS1EN_SHIFT			31
+#define OMAP44XX_REG_TA_CS1EN_MASK			(1 << 31)
+#define OMAP44XX_REG_TA_CS0EN_SHIFT			30
+#define OMAP44XX_REG_TA_CS0EN_MASK			(1 << 30)
+#define OMAP44XX_REG_TA_SFEXITEN_SHIFT			28
+#define OMAP44XX_REG_TA_SFEXITEN_MASK			(1 << 28)
+#define OMAP44XX_REG_TA_DEVWDT_SHIFT			26
+#define OMAP44XX_REG_TA_DEVWDT_MASK			(0x3 << 26)
+#define OMAP44XX_REG_TA_DEVCNT_SHIFT			24
+#define OMAP44XX_REG_TA_DEVCNT_MASK			(0x3 << 24)
+#define OMAP44XX_REG_TA_REFINTERVAL_SHIFT		0
+#define OMAP44XX_REG_TA_REFINTERVAL_MASK		(0x3fffff << 0)
+
+/* OCP_ERR_LOG */
+#define OMAP44XX_REG_MADDRSPACE_SHIFT			14
+#define OMAP44XX_REG_MADDRSPACE_MASK			(0x3 << 14)
+#define OMAP44XX_REG_MBURSTSEQ_SHIFT			11
+#define OMAP44XX_REG_MBURSTSEQ_MASK			(0x7 << 11)
+#define OMAP44XX_REG_MCMD_SHIFT				8
+#define OMAP44XX_REG_MCMD_MASK				(0x7 << 8)
+#define OMAP44XX_REG_MCONNID_SHIFT			0
+#define OMAP44XX_REG_MCONNID_MASK			(0xff << 0)
+
+/* DDR_PHY_CTRL_1 */
+#define OMAP44XX_REG_DDR_PHY_CTRL_1_SHIFT		4
+#define OMAP44XX_REG_DDR_PHY_CTRL_1_MASK		(0xfffffff << 4)
+#define OMAP44XX_REG_READ_LATENCY_SHIFT			0
+#define OMAP44XX_REG_READ_LATENCY_MASK			(0xf << 0)
+#define OMAP44XX_REG_DLL_SLAVE_DLY_CTRL_SHIFT		4
+#define OMAP44XX_REG_DLL_SLAVE_DLY_CTRL_MASK		(0xFF << 4)
+#define OMAP44XX_EMIF_DDR_PHY_CTRL_1_BASE_VAL_SHIFT	12
+#define OMAP44XX_EMIF_DDR_PHY_CTRL_1_BASE_VAL_MASK	(0xFFFFF << 12)
+
+/* DDR_PHY_CTRL_1_SHDW */
+#define OMAP44XX_REG_DDR_PHY_CTRL_1_SHDW_SHIFT		4
+#define OMAP44XX_REG_DDR_PHY_CTRL_1_SHDW_MASK		(0xfffffff << 4)
+#define OMAP44XX_REG_READ_LATENCY_SHDW_SHIFT		0
+#define OMAP44XX_REG_READ_LATENCY_SHDW_MASK		(0xf << 0)
+#define OMAP44XX_REG_DLL_SLAVE_DLY_CTRL_SHDW_SHIFT	4
+#define OMAP44XX_REG_DLL_SLAVE_DLY_CTRL_SHDW_MASK	(0xFF << 4)
+#define OMAP44XX_EMIF_DDR_PHY_CTRL_1_BASE_VAL_SHDW_SHIFT 12
+#define OMAP44XX_EMIF_DDR_PHY_CTRL_1_BASE_VAL_SHDW_MASK	(0xFFFFF << 12)
+
+/* DDR_PHY_CTRL_2 */
+#define OMAP44XX_REG_DDR_PHY_CTRL_2_SHIFT		0
+#define OMAP44XX_REG_DDR_PHY_CTRL_2_MASK		(0xffffffff << 0)
+
+/* DMM */
+#define OMAP44XX_DMM_BASE		0x4E000000
+#define OMAP44XX_DMM_LISA_MAP_BASE		(0x4E000000 + 0x40)
+
+/* DMM_LISA_MAP */
+#define OMAP44XX_SYS_ADDR_SHIFT		24
+#define OMAP44XX_SYS_ADDR_MASK		(0xff << 24)
+#define OMAP44XX_SYS_SIZE_SHIFT		20
+#define OMAP44XX_SYS_SIZE_MASK		(0x7 << 20)
+#define OMAP44XX_SDRC_INTL_SHIFT	18
+#define OMAP44XX_SDRC_INTL_MASK		(0x3 << 18)
+#define OMAP44XX_SDRC_ADDRSPC_SHIFT	16
+#define OMAP44XX_SDRC_ADDRSPC_MASK	(0x3 << 16)
+#define OMAP44XX_SDRC_MAP_SHIFT		8
+#define OMAP44XX_SDRC_MAP_MASK		(0x3 << 8)
+#define OMAP44XX_SDRC_ADDR_SHIFT	0
+#define OMAP44XX_SDRC_ADDR_MASK		(0xff << 0)
+
+/* DMM_LISA_MAP fields */
+#define DMM_SDRC_MAP_UNMAPPED		0
+#define DMM_SDRC_MAP_EMIF1_ONLY		1
+#define DMM_SDRC_MAP_EMIF2_ONLY		2
+#define DMM_SDRC_MAP_EMIF1_AND_EMIF2	3
+
+#define DMM_SDRC_INTL_NONE		0
+#define DMM_SDRC_INTL_128B		1
+#define DMM_SDRC_INTL_256B		2
+#define DMM_SDRC_INTL_512		3
+
+#define DMM_SDRC_ADDR_SPC_SDRAM		0
+#define DMM_SDRC_ADDR_SPC_NVM		1
+#define DMM_SDRC_ADDR_SPC_INVALID	2
+
+#define DMM_LISA_MAP_INTERLEAVED_BASE_VAL		(\
+	(DMM_SDRC_MAP_EMIF1_AND_EMIF2 << OMAP44XX_SDRC_MAP_SHIFT) |\
+	(DMM_SDRC_ADDR_SPC_SDRAM << OMAP44XX_SDRC_ADDRSPC_SHIFT) |\
+	(DMM_SDRC_INTL_128B << OMAP44XX_SDRC_INTL_SHIFT) |\
+	(CONFIG_SYS_SDRAM_BASE << OMAP44XX_SYS_ADDR_SHIFT))
+
+#define DMM_LISA_MAP_EMIF1_ONLY_BASE_VAL	(\
+	(DMM_SDRC_MAP_EMIF1_ONLY << OMAP44XX_SDRC_MAP_SHIFT)|\
+	(DMM_SDRC_ADDR_SPC_SDRAM << OMAP44XX_SDRC_ADDRSPC_SHIFT)|\
+	(DMM_SDRC_INTL_NONE << OMAP44XX_SDRC_INTL_SHIFT))
+
+#define DMM_LISA_MAP_EMIF2_ONLY_BASE_VAL	(\
+	(DMM_SDRC_MAP_EMIF2_ONLY << OMAP44XX_SDRC_MAP_SHIFT)|\
+	(DMM_SDRC_ADDR_SPC_SDRAM << OMAP44XX_SDRC_ADDRSPC_SHIFT)|\
+	(DMM_SDRC_INTL_NONE << OMAP44XX_SDRC_INTL_SHIFT))
+
+/* Trap for invalid TILER PAT entries */
+#define DMM_LISA_MAP_0_INVAL_ADDR_TRAP		(\
+		(0  << OMAP44XX_SDRC_ADDR_SHIFT) |\
+		(DMM_SDRC_MAP_EMIF1_ONLY << OMAP44XX_SDRC_MAP_SHIFT)|\
+		(DMM_SDRC_ADDR_SPC_INVALID << OMAP44XX_SDRC_ADDRSPC_SHIFT)|\
+		(DMM_SDRC_INTL_NONE << OMAP44XX_SDRC_INTL_SHIFT)|\
+		(0xFF << OMAP44XX_SYS_ADDR_SHIFT))
+
+
+/* Reg mapping structure */
+struct __attribute__ ((__packed__)) emif_reg_struct{
+	u32 emif_mod_id_rev;
+	u32 emif_status;
+	u32 emif_sdram_config;
+	u32 emif_lpddr2_nvm_config;
+	u32 emif_sdram_ref_ctrl;
+	u32 emif_sdram_ref_ctrl_shdw;
+	u32 emif_sdram_tim_1;
+	u32 emif_sdram_tim_1_shdw;
+	u32 emif_sdram_tim_2;
+	u32 emif_sdram_tim_2_shdw;
+	u32 emif_sdram_tim_3;
+	u32 emif_sdram_tim_3_shdw;
+	u32 emif_lpddr2_nvm_tim;
+	u32 emif_lpddr2_nvm_tim_shdw;
+	u32 emif_pwr_mgmt_ctrl;
+	u32 emif_pwr_mgmt_ctrl_shdw;
+	u32 emif_lpddr2_mode_reg_data;
+	u32 padding1[1];
+	u32 emif_lpddr2_mode_reg_data_es2;
+	u32 padding11[1];
+	u32 emif_lpddr2_mode_reg_cfg;
+	u32 emif_l3_config;
+	u32 emif_l3_cfg_val_1;
+	u32 emif_l3_cfg_val_2;
+	u32 emif_iodft_tlgc;
+	u32 padding2[7];
+	u32 emif_perf_cnt_1;
+	u32 emif_perf_cnt_2;
+	u32 emif_perf_cnt_cfg;
+	u32 emif_perf_cnt_sel;
+	u32 emif_perf_cnt_tim;
+	u32 padding3;
+	u32 emif_read_idlectrl;
+	u32 emif_read_idlectrl_shdw;
+	u32 padding4;
+	u32 emif_irqstatus_raw_sys;
+	u32 emif_irqstatus_raw_ll;
+	u32 emif_irqstatus_sys;
+	u32 emif_irqstatus_ll;
+	u32 emif_irqenable_set_sys;
+	u32 emif_irqenable_set_ll;
+	u32 emif_irqenable_clr_sys;
+	u32 emif_irqenable_clr_ll;
+	u32 padding5;
+	u32 emif_zq_config;
+	u32 emif_temp_alert_config;
+	u32 emif_l3_err_log;
+	u32 padding6[4];
+	u32 emif_ddr_phy_ctrl_1;
+	u32 emif_ddr_phy_ctrl_1_shdw;
+	u32 emif_ddr_phy_ctrl_2;
+};
+
+struct __attribute__ ((__packed__)) dmm_lisa_map_regs {
+	u32 dmm_lisa_map_0;
+	u32 dmm_lisa_map_1;
+	u32 dmm_lisa_map_2;
+	u32 dmm_lisa_map_3;
+};
+
+#define CS0	0
+#define CS1	1
+/* Read Latency used by the device at reset */
+#define RL_BOOT		3
+/* Read Latency for the highest frequency you want to use */
+#define RL_FINAL	6
+/* EMIF_PWR_MGMT_CTRL register */
+/* Low power modes */
+#define LP_MODE_DISABLE		0
+#define LP_MODE_CLOCK_STOP	1
+#define LP_MODE_SELF_REFRESH	2
+#define LP_MODE_PWR_DN		3
+
+/* REG_DPD_EN */
+#define DPD_DISABLE	0
+#define DPD_ENABLE	1
+
+/* Maximum delay before Low Power Modes */
+#define REG_CS_TIM		0xF
+#define REG_SR_TIM		0xF
+#define REG_PD_TIM		0xF
+
+/* EMIF_PWR_MGMT_CTRL register */
+#define EMIF_PWR_MGMT_CTRL (\
+	((REG_CS_TIM << OMAP44XX_REG_CS_TIM_SHIFT) & OMAP44XX_REG_CS_TIM_MASK)|\
+	((REG_SR_TIM << OMAP44XX_REG_SR_TIM_SHIFT) & OMAP44XX_REG_SR_TIM_MASK)|\
+	((REG_PD_TIM << OMAP44XX_REG_PD_TIM_SHIFT) & OMAP44XX_REG_PD_TIM_MASK)|\
+	((REG_PD_TIM << OMAP44XX_REG_PD_TIM_SHIFT) & OMAP44XX_REG_PD_TIM_MASK)|\
+	((LP_MODE_DISABLE << OMAP44XX_REG_LP_MODE_SHIFT)\
+			& OMAP44XX_REG_LP_MODE_MASK) |\
+	((DPD_DISABLE << OMAP44XX_REG_DPD_EN_SHIFT)\
+			& OMAP44XX_REG_DPD_EN_MASK))\
+
+#define EMIF_PWR_MGMT_CTRL_SHDW (\
+	((REG_CS_TIM << OMAP44XX_REG_CS_TIM_SHDW_SHIFT)\
+			& OMAP44XX_REG_CS_TIM_SHDW_MASK) |\
+	((REG_SR_TIM << OMAP44XX_REG_SR_TIM_SHDW_SHIFT)\
+			& OMAP44XX_REG_SR_TIM_SHDW_MASK) |\
+	((REG_PD_TIM << OMAP44XX_REG_PD_TIM_SHDW_SHIFT)\
+			& OMAP44XX_REG_PD_TIM_SHDW_MASK) |\
+	((REG_PD_TIM << OMAP44XX_REG_PD_TIM_SHDW_SHIFT)\
+			& OMAP44XX_REG_PD_TIM_SHDW_MASK))
+
+/* EMIF_L3_CONFIG register value for ES1*/
+#define EMIF_L3_CONFIG_VAL_SYS_THRESH_0A_LL_THRESH_00	0x0A0000FF
+
+/*
+* MR1 value:
+* Burst length	: 8
+* Burst type	: sequential
+* Wrap		: enabled
+* nWR		: 3(default). EMIF does not do pre-charge.
+*		: So nWR is don't care
+*/
+#define MR1_BL_8_BT_SEQ_WRAP_EN_NWR_3	0x23
+
+/* MR2 */
+#define MR2_RL3_WL1			1
+#define MR2_RL4_WL2			2
+#define MR2_RL5_WL2			3
+#define MR2_RL6_WL3			4
+
+/* MR10: ZQ calibration codes */
+#define MR10_ZQ_ZQCS		0x56
+#define MR10_ZQ_ZQCL		0xAB
+#define MR10_ZQ_ZQINIT		0xFF
+#define MR10_ZQ_ZQRESET		0xC3
+
+/* MR16 value: refresh full array(no partial array self refresh) */
+#define MR16_REF_FULL_ARRAY	0
+
+/* LPDDR2 IO reg values */
+#define CONTROL_LPDDR2IO_SLEW_125PS_DRV8_PULL_DOWN	0x1C1C1C1C
+#define CONTROL_LPDDR2IO_SLEW_325PS_DRV8_GATE_KEEPER	0x9E9E9E9E
+
+/* CONTROL_EFUSE_2 */
+#define CONTROL_EFUSE_2_NMOS_PMOS_PTV_CODE_1		0x00ffc000
+
+/* Mode register numbers */
+#define LPDDR2_MR0	0
+#define LPDDR2_MR1	1
+#define LPDDR2_MR2	2
+#define LPDDR2_MR3	3
+#define LPDDR2_MR4	4
+#define LPDDR2_MR5	5
+#define LPDDR2_MR6	6
+#define LPDDR2_MR7	7
+#define LPDDR2_MR8	8
+#define LPDDR2_MR9	9
+#define LPDDR2_MR10	10
+#define LPDDR2_MR11	11
+#define LPDDR2_MR16	16
+#define LPDDR2_MR17	17
+#define LPDDR2_MR18	18
+
+/* MR0 */
+#define LPDDR2_MR0_DAI_SHIFT	0
+#define LPDDR2_MR0_DAI_MASK	1
+#define LPDDR2_MR0_DI_SHIFT	1
+#define LPDDR2_MR0_DI_MASK	(1 << 1)
+#define LPDDR2_MR0_DNVI_SHIFT	2
+#define LPDDR2_MR0_DNVI_MASK	(1 << 2)
+
+/*
+ * Structure containing shadow of important registers in EMIF
+ * The calculation function fills in this structure to be later used for
+ * initialization and DVFS
+ */
+struct emif_regs {
+	u32 freq;
+	u32 sdram_config_init;
+	u32 sdram_config;
+	u32 ref_ctrl;
+	u32 sdram_tim1;
+	u32 sdram_tim2;
+	u32 sdram_tim3;
+	u32 read_idle_ctrl;
+	u32 zq_config;
+	u32 temp_alert_config;
+	u32 emif_ddr_phy_ctlr_1_init;
+	u32 emif_ddr_phy_ctlr_1;
+};
+
+void emif_get_reg_dump(const struct emif_regs **emif1_regs,
+			const struct emif_regs **emif2_regs);
+void emif_get_dmm_regs(const struct dmm_lisa_map_regs **dmm_lisa_regs);
+
+#endif
diff --git a/arch/arm/include/asm/arch-omap4/omap4.h b/arch/arm/include/asm/arch-omap4/omap4.h
index 740ca9d..a1c4883 100644
--- a/arch/arm/include/asm/arch-omap4/omap4.h
+++ b/arch/arm/include/asm/arch-omap4/omap4.h
@@ -51,6 +51,17 @@
 #define CONTROL_PADCONF_CORE	(OMAP44XX_L4_CORE_BASE + 0x100000)
 #define CONTROL_PADCONF_WKUP	(OMAP44XX_L4_CORE_BASE + 0x31E000)
 
+/* LPDDR2 IO regs */
+#define CONTROL_LPDDR2IO1_0	(CONTROL_PADCONF_CORE + 0x0638)
+#define CONTROL_LPDDR2IO1_1	(CONTROL_PADCONF_CORE + 0x063C)
+#define CONTROL_LPDDR2IO1_2	(CONTROL_PADCONF_CORE + 0x0640)
+#define CONTROL_LPDDR2IO1_3	(CONTROL_PADCONF_CORE + 0x0644)
+#define CONTROL_LPDDR2IO2_0	(CONTROL_PADCONF_CORE + 0x0648)
+#define CONTROL_LPDDR2IO2_1	(CONTROL_PADCONF_CORE + 0x064C)
+#define CONTROL_LPDDR2IO2_2	(CONTROL_PADCONF_CORE + 0x0650)
+#define CONTROL_LPDDR2IO2_3	(CONTROL_PADCONF_CORE + 0x0654)
+#define CONTROL_EFUSE_2		(CONTROL_PADCONF_CORE + 0x0704)
+
 /* CONTROL_ID_CODE */
 #define CONTROL_ID_CODE		(CTRL_BASE + 0x204)
 
diff --git a/arch/arm/include/asm/arch-omap4/sys_proto.h b/arch/arm/include/asm/arch-omap4/sys_proto.h
index fd21afd..4beff42 100644
--- a/arch/arm/include/asm/arch-omap4/sys_proto.h
+++ b/arch/arm/include/asm/arch-omap4/sys_proto.h
@@ -44,6 +44,7 @@ void bypass_dpll(u32 base);
 void freq_update_core(void);
 u32 get_syc_clk_freq(void);
 u32 omap4_ddr_clk(void);
+void sdram_init(void);
 u32 omap4_revision(void);
 
 static inline u32 running_from_sdram(void)
diff --git a/include/configs/omap4_sdp4430.h b/include/configs/omap4_sdp4430.h
index 5b20841..07d45a0 100644
--- a/include/configs/omap4_sdp4430.h
+++ b/include/configs/omap4_sdp4430.h
@@ -245,11 +245,6 @@
 /* Defines for Clock init */
 #define CONFIG_SYS_OMAP4_ABE_SYSCK
 
-/* Defines for SDRAM init */
-#define CONFIG_SYS_AUTOMATIC_SDRAM_DETECTION	1
-#define CONFIG_SYS_EMIF_UPDATE_TIMINGS		1
-#define CONFIG_SYS_DEFAULT_LPDDR2_TIMINGS	1
-
 /* Defines for SPL */
 #define CONFIG_SPL
 #define CONFIG_SYS_SPL_TEXT_BASE	0x40304360
diff --git a/spl/board/ti/sdp4430/Makefile b/spl/board/ti/sdp4430/Makefile
index 40e3e79..1f25f77 100644
--- a/spl/board/ti/sdp4430/Makefile
+++ b/spl/board/ti/sdp4430/Makefile
@@ -115,12 +115,20 @@ $(obj)board.c:$(obj)omap4_mux_data.h
 	@rm -f $@
 	@ln -s $(TOPDIR)/arch/arm/cpu/armv7/omap4/board.c $@
 
+$(obj)emif.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/arch/arm/cpu/armv7/omap4/emif.c $@
+
+$(obj)sdram_elpida.c:
+	@rm -f $@
+	@ln -s $(TOPDIR)/arch/arm/cpu/armv7/omap4/sdram_elpida.c $@
+
 $(obj)clocks.c:
 	@rm -f $@
 	@ln -s $(TOPDIR)/arch/arm/cpu/armv7/omap4/clocks.c $@
 
 SOBJS	+= lowlevel_init.o
-COBJS	+= board.o clocks.o
+COBJS	+= board.o clocks.o emif.o sdram_elpida.o
 
 # rules
 LDPPFLAGS += -include $(TOPDIR)/include/config.h
-- 
1.7.2.3

