From 23d2cd19f9f867637bb0e72e57bba56ded85f60c Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 8 Oct 2011 10:44:23 +0200
Subject: [PATCH 1/6] vdpau: notify decoder when refresh rate is going to
 change and flush renderer

---
 xbmc/ApplicationMessenger.cpp                  |    5 ++
 xbmc/ApplicationMessenger.h                    |    1 +
 xbmc/cores/VideoRenderers/BaseRenderer.h       |    1 +
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp  |   14 ++++
 xbmc/cores/VideoRenderers/LinuxRendererGL.h    |    1 +
 xbmc/cores/VideoRenderers/RenderManager.cpp    |   29 ++++++++
 xbmc/cores/VideoRenderers/RenderManager.h      |    2 +
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp |   79 ++++++++++++++++++---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h   |   22 ++++--
 xbmc/guilib/DispResource.h                     |   33 +++++++++
 xbmc/windowing/X11/WinSystemX11.cpp            |   90 ++++++++++++++++++++++++
 xbmc/windowing/X11/WinSystemX11.h              |   11 +++
 xbmc/windowing/X11/WinSystemX11GL.cpp          |    2 +
 13 files changed, 274 insertions(+), 16 deletions(-)
 create mode 100644 xbmc/guilib/DispResource.h

diff --git a/xbmc/ApplicationMessenger.cpp b/xbmc/ApplicationMessenger.cpp
index 9cd3723..5e7bcfa 100644
--- a/xbmc/ApplicationMessenger.cpp
+++ b/xbmc/ApplicationMessenger.cpp
@@ -42,6 +42,7 @@
 #include "guilib/GUIDialog.h"
 #include "windowing/WindowingFactory.h"
 #include "GUIInfoManager.h"
+#include "cores/VideoRenderers/RenderManager.h"
 
 #include "powermanagement/PowerManager.h"
 
@@ -231,6 +232,10 @@ void CApplicationMessenger::ProcessMessage(ThreadMessage *pMsg)
           case POWERSTATE_MINIMIZE:
             Minimize();
             break;
+
+          case TMSG_RENDERER_FLUSH:
+            g_renderManager.Flush();
+            break;
         }
       }
       break;
diff --git a/xbmc/ApplicationMessenger.h b/xbmc/ApplicationMessenger.h
index b0b4687..31b4ffb 100644
--- a/xbmc/ApplicationMessenger.h
+++ b/xbmc/ApplicationMessenger.h
@@ -76,6 +76,7 @@ class CGUIWindow;
 #define TMSG_MINIMIZE             309
 #define TMSG_TOGGLEFULLSCREEN     310
 #define TMSG_SETLANGUAGE          311
+#define TMSG_RENDERER_FLUSH       312
 
 #define TMSG_HTTPAPI              400
 
diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.h b/xbmc/cores/VideoRenderers/BaseRenderer.h
index faef87c..af51852 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.h
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.h
@@ -64,6 +64,7 @@ public:
   float GetAspectRatio() const;
 
   virtual bool AddVideoPicture(DVDVideoPicture* picture) { return false; }
+  virtual void Flush() {};
 
   virtual unsigned int GetProcessorSize() { return 0; }
 
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index 02d317e..0e247aa 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -554,6 +554,20 @@ void CLinuxRendererGL::Reset()
   }
 }
 
+void CLinuxRendererGL::Flush()
+{
+  if (!m_bValidated)
+    return;
+
+  glFinish();
+
+  for (int i = 0 ; i < m_NumYV12Buffers ; i++)
+    (this->*m_textureDelete)(i);
+
+  glFinish();
+  m_bValidated = false;
+}
+
 void CLinuxRendererGL::Update(bool bPauseDrawing)
 {
   if (!m_bConfigured) return;
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.h b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
index 8f1664a..38c84aa 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
@@ -140,6 +140,7 @@ public:
   virtual unsigned int PreInit();
   virtual void         UnInit();
   virtual void         Reset(); /* resets renderer after seek for example */
+  virtual void         Flush();
 
 #ifdef HAVE_LIBVDPAU
   virtual void         AddProcessor(CVDPAU* vdpau);
diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 50c465c..31bb49a 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -337,6 +337,35 @@ void CXBMCRenderManager::UnInit()
     m_pRenderer->UnInit();
 }
 
+bool CXBMCRenderManager::Flush()
+{
+  if (!m_pRenderer)
+    return true;
+
+  if (g_application.IsCurrentThread())
+  {
+    CLog::Log(LOGDEBUG, "%s - flushing renderer", __FUNCTION__);
+
+    CRetakeLock<CExclusiveLock> lock(m_sharedSection);
+    m_pRenderer->Flush();
+    m_flushEvent.Set();
+  }
+  else
+  {
+    ThreadMessage msg = {TMSG_RENDERER_FLUSH};
+    m_flushEvent.Reset();
+    g_application.getApplicationMessenger().SendMessage(msg, false);
+    if (!m_flushEvent.WaitMSec(1000))
+    {
+      CLog::Log(LOGERROR, "%s - timed out waiting for renderer to flush", __FUNCTION__);
+      return false;
+    }
+    else
+      return true;
+  }
+  return true;
+}
+
 void CXBMCRenderManager::SetupScreenshot()
 {
   CSharedLock lock(m_sharedSection);
diff --git a/xbmc/cores/VideoRenderers/RenderManager.h b/xbmc/cores/VideoRenderers/RenderManager.h
index f8f68ab..b81bced 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.h
+++ b/xbmc/cores/VideoRenderers/RenderManager.h
@@ -76,6 +76,7 @@ public:
   void FlipPage(volatile bool& bStop, double timestamp = 0.0, int source = -1, EFIELDSYNC sync = FS_NONE);
   unsigned int PreInit();
   void UnInit();
+  bool Flush();
 
   void AddOverlay(CDVDOverlay* o, double pts)
   {
@@ -227,6 +228,7 @@ protected:
   EPRESENTSTEP     m_presentstep;
   int        m_presentsource;
   CEvent     m_presentevent;
+  CEvent     m_flushEvent;
 
 
   OVERLAY::CRenderer m_overlays;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 0ad0451..06629df 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -95,6 +95,7 @@ CVDPAU::CVDPAU()
   recover = false;
   m_mixerfield = VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME;
   m_mixerstep  = 0;
+  m_DisplayState = VDPAU_OPEN;
 
   m_glPixmap = 0;
   m_Pixmap = 0;
@@ -191,6 +192,8 @@ bool CVDPAU::Open(AVCodecContext* avctx, const enum PixelFormat, unsigned int su
     avctx->release_buffer  = CVDPAU::FFReleaseBuffer;
     avctx->draw_horiz_band = CVDPAU::FFDrawSlice;
     avctx->slice_flags=SLICE_FLAG_CODED_ORDER|SLICE_FLAG_ALLOW_FIELD;
+
+    g_Windowing.Register(this);
     return true;
   }
   return false;
@@ -208,6 +211,8 @@ void CVDPAU::Close()
   FiniVDPAUOutput();
   FiniVDPAUProcs();
 
+  g_Windowing.Unregister(this);
+
   if (m_glPixmap)
   {
     CLog::Log(LOGINFO, "GLX: Destroying glPixmap");
@@ -363,6 +368,11 @@ bool CVDPAU::MakePixmap(int width, int height)
 
 void CVDPAU::BindPixmap()
 {
+  { CSingleLock lock(m_DisplaySection);
+    if (m_DisplayState != VDPAU_OPEN)
+      return;
+  }
+
   if (m_glPixmap)
   {
     if(presentSurface != VDP_INVALID_HANDLE)
@@ -389,6 +399,11 @@ void CVDPAU::BindPixmap()
 
 void CVDPAU::ReleasePixmap()
 {
+  { CSingleLock lock(m_DisplaySection);
+    if (m_DisplayState != VDPAU_OPEN)
+      return;
+  }
+
   if (m_glPixmap)
   {
     glXReleaseTexImageEXT(m_Display, m_glPixmap, GLX_FRONT_LEFT_EXT);
@@ -396,22 +411,53 @@ void CVDPAU::ReleasePixmap()
   else CLog::Log(LOGERROR,"(VDPAU) ReleasePixmap called without valid pixmap");
 }
 
-bool CVDPAU::CheckRecover(bool force)
+void CVDPAU::OnLostDevice()
+{
+  CSingleLock lock(m_DisplaySection);
+  m_DisplayState = VDPAU_LOST;
+  m_DisplayEvent.Reset();
+}
+
+void CVDPAU::OnResetDevice()
+{
+  CSingleLock lock(m_DisplaySection);
+
+  if (m_DisplayState == VDPAU_LOST)
+  {
+    m_DisplayState = VDPAU_RESET;
+    m_DisplayEvent.Set();
+  }
+}
+
+int CVDPAU::Check(AVCodecContext* avctx)
 {
-  if (recover || force)
+  CSingleLock lock(m_DisplaySection);
+
+  if (m_DisplayState == VDPAU_LOST)
+  {
+    lock.Leave();
+    if (!m_DisplayEvent.WaitMSec(2000))
+    {
+      CLog::Log(LOGERROR, "CVDPAU::Check - device didn't reset in reasonable time");
+      return VC_ERROR;
+    }
+    lock.Enter();
+  }
+  if (recover || m_DisplayState == VDPAU_RESET)
   {
     CLog::Log(LOGNOTICE,"Attempting recovery");
 
     FiniVDPAUOutput();
     FiniVDPAUProcs();
 
-    recover = false;
-
     InitVDPAUProcs();
 
-    return true;
+    recover = false;
+    m_DisplayState = VDPAU_OPEN;
+
+    return VC_FLUSHED;
   }
-  return false;
+  return 0;
 }
 
 bool CVDPAU::IsVDPAUFormat(PixelFormat format)
@@ -750,6 +796,9 @@ void CVDPAU::InitVDPAUProcs()
                                    &VDPPreemptionCallbackFunction,
                                    (void*)this);
   CheckStatus(vdp_st, __LINE__);
+
+  CSingleLock lock(m_DisplaySection);
+  m_DisplayState = VDPAU_OPEN;
 }
 
 void CVDPAU::FiniVDPAUProcs()
@@ -1132,8 +1181,9 @@ int CVDPAU::Decode(AVCodecContext *avctx, AVFrame *pFrame)
   VdpStatus vdp_st;
   VdpTime time;
 
-  if (CheckRecover(false))
-    return VC_FLUSHED;
+  int result = Check(avctx);
+  if (result)
+    return result;
 
   if (!vdpauConfigured)
     return VC_ERROR;
@@ -1318,6 +1368,11 @@ int CVDPAU::Decode(AVCodecContext *avctx, AVFrame *pFrame)
 
 bool CVDPAU::GetPicture(AVCodecContext* avctx, AVFrame* frame, DVDVideoPicture* picture)
 {
+  { CSingleLock lock(m_DisplaySection);
+    if (m_DisplayState != VDPAU_OPEN)
+      return false;
+  }
+
   *picture = m_DVDVideoPics.front();
   // if this is the first field of an interlaced frame, we'll need
   // this same picture for the second field later
@@ -1358,6 +1413,12 @@ void CVDPAU::Present()
 {
   //CLog::Log(LOGNOTICE,"%s",__FUNCTION__);
   VdpStatus vdp_st;
+
+  { CSingleLock lock(m_DisplaySection);
+    if (m_DisplayState != VDPAU_OPEN)
+      return;
+  }
+
   presentSurface = outputSurface;
 
   vdp_st = vdp_presentation_queue_display(vdp_flip_queue,
@@ -1370,7 +1431,7 @@ void CVDPAU::Present()
 
 void CVDPAU::VDPPreemptionCallbackFunction(VdpDevice device, void* context)
 {
-  CLog::Log(LOGERROR,"VDPAU Device Preempted - attempting recovery");
+  CLog::Log(LOGDEBUG,"VDPAU Device Preempted - attempting recovery");
   CVDPAU* pCtx = (CVDPAU*)context;
   pCtx->recover = true;
 }
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
index 2056de1..6eab3fc 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
@@ -33,6 +33,8 @@
 #include <queue>
 #include "threads/CriticalSection.h"
 #include "settings/VideoSettings.h"
+#include "guilib/DispResource.h"
+#include "threads/Event.h"
 namespace Surface { class CSurface; }
 
 #define NUM_OUTPUT_SURFACES                4
@@ -44,6 +46,7 @@ namespace Surface { class CSurface; }
 
 class CVDPAU
  : public CDVDVideoCodecFFmpeg::IHardwareDecoder
+ , public IDispResource
 {
 public:
 
@@ -69,13 +72,8 @@ public:
   virtual void Reset();
   virtual void Close();
 
-  virtual int  Check(AVCodecContext* avctx) 
-  { 
-    if(CheckRecover(false))
-      return VC_FLUSHED;
-    else
-      return 0;
-  }
+  virtual int  Check(AVCodecContext* avctx);
+
   virtual const std::string Name() { return "vdpau"; }
 
   bool MakePixmap(int width, int height);
@@ -227,4 +225,14 @@ public:
                           , VdpChromaType     &chroma_type);
 
   std::vector<vdpau_render_state*> m_videoSurfaces;
+
+  enum EDisplayState
+  { VDPAU_OPEN
+  , VDPAU_RESET
+  , VDPAU_LOST
+  } m_DisplayState;
+  CCriticalSection m_DisplaySection;
+  CEvent           m_DisplayEvent;
+  virtual void OnLostDevice();
+  virtual void OnResetDevice();
 };
diff --git a/xbmc/guilib/DispResource.h b/xbmc/guilib/DispResource.h
new file mode 100644
index 0000000..d2833cb
--- /dev/null
+++ b/xbmc/guilib/DispResource.h
@@ -0,0 +1,33 @@
+/*
+*      Copyright (C) 2005-2008 Team XBMC
+*      http://www.xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, write to
+*  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*  http://www.gnu.org/copyleft/gpl.html
+*
+*/
+
+#pragma once
+
+#ifdef HAS_GLX
+class IDispResource
+{
+public:
+  virtual ~IDispResource() {};
+  virtual void OnLostDevice() {};
+  virtual void OnResetDevice() {};
+};
+
+#endif
diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 4287a04..ea20c0e 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -27,9 +27,18 @@
 #include "WinSystemX11.h"
 #include "settings/Settings.h"
 #include "guilib/Texture.h"
+#include "guilib/DispResource.h"
 #include "utils/log.h"
 #include "XRandR.h"
 #include <vector>
+#include "threads/SingleLock.h"
+#include <X11/Xlib.h>
+#include "cores/VideoRenderers/RenderManager.h"
+#include "utils/TimeUtils.h"
+
+#if defined(HAS_XRANDR)
+#include <X11/extensions/Xrandr.h>
+#endif
 
 using namespace std;
 
@@ -42,6 +51,7 @@ CWinSystemX11::CWinSystemX11() : CWinSystemBase()
   m_glWindow = 0;
   m_wmWindow = 0;
   m_bWasFullScreenBeforeMinimize = false;
+  m_dpyLostTime = 0;
 }
 
 CWinSystemX11::~CWinSystemX11()
@@ -126,6 +136,13 @@ bool CWinSystemX11::CreateNewWindow(const CStdString& name, bool fullScreen, RES
   SDL_WM_SetIcon(SDL_CreateRGBSurfaceFrom(iconTexture.GetPixels(), iconTexture.GetWidth(), iconTexture.GetHeight(), 32, iconTexture.GetPitch(), 0xff0000, 0x00ff00, 0x0000ff, 0xff000000L), NULL);
   SDL_WM_SetCaption("XBMC Media Center", NULL);
 
+  // register XRandR Events
+#if defined(HAS_XRANDR)
+  int iReturn;
+  XRRQueryExtension(m_dpy, &m_RREventBase, &iReturn);
+  XRRSelectInput(m_dpy, m_wmWindow, RRScreenChangeNotifyMask);
+#endif
+
   m_bWindowCreated = true;
   return true;
 }
@@ -175,7 +192,10 @@ bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
   mode.id  = res.strId;
  
   if(m_bFullScreen)
+  {
+    OnLostDevice();
     g_xrandr.SetMode(out, mode);
+  }
   else
     g_xrandr.RestoreState();
 #endif
@@ -444,4 +464,74 @@ bool CWinSystemX11::Show(bool raise)
   XSync(m_dpy, False);
   return true;
 }
+
+void CWinSystemX11::CheckDisplayEvents()
+{
+#if defined(HAS_XRANDR)
+  bool bGotEvent(false);
+  bool bTimeout(false);
+  XEvent Event;
+  while (XCheckTypedEvent(m_dpy, m_RREventBase + RRScreenChangeNotify, &Event))
+  {
+    if (Event.type == m_RREventBase + RRScreenChangeNotify)
+    {
+      CLog::Log(LOGDEBUG, "%s: Received RandR event %i", __FUNCTION__, Event.type);
+      bGotEvent = true;
+    }
+    XRRUpdateConfiguration(&Event);
+  }
+
+  // check fail safe timer
+  if (m_dpyLostTime && CurrentHostCounter() - m_dpyLostTime > (uint64_t)3 * CurrentHostFrequency())
+  {
+    CLog::Log(LOGERROR, "%s - no display event after 3 seconds", __FUNCTION__);
+    bTimeout = true;
+  }
+
+  if (bGotEvent || bTimeout)
+  {
+    CLog::Log(LOGDEBUG, "%s - notify display reset event", __FUNCTION__);
+
+    CSingleLock lock(m_resourceSection);
+
+    // tell any shared resources
+    for (vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); i++)
+      (*i)->OnResetDevice();
+
+    // reset fail safe timer
+    m_dpyLostTime = 0;
+  }
+#endif
+}
+
+void CWinSystemX11::OnLostDevice()
+{
+  CLog::Log(LOGDEBUG, "%s - notify display change event", __FUNCTION__);
+
+  { CSingleLock lock(m_resourceSection);
+    for (vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); i++)
+      (*i)->OnLostDevice();
+  }
+
+  // make sure renderer has no invalid references
+  g_renderManager.Flush();
+
+  // fail safe timer
+  m_dpyLostTime = CurrentHostCounter();
+}
+
+void CWinSystemX11::Register(IDispResource *resource)
+{
+  CSingleLock lock(m_resourceSection);
+  m_resources.push_back(resource);
+}
+
+void CWinSystemX11::Unregister(IDispResource* resource)
+{
+  CSingleLock lock(m_resourceSection);
+  vector<IDispResource*>::iterator i = find(m_resources.begin(), m_resources.end(), resource);
+  if (i != m_resources.end())
+    m_resources.erase(i);
+}
+
 #endif
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index da6accf..5b941be 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -26,6 +26,9 @@
 #include "windowing/WinSystem.h"
 #include "utils/Stopwatch.h"
 #include <GL/glx.h>
+#include "threads/CriticalSection.h"
+
+class IDispResource;
 
 class CWinSystemX11 : public CWinSystemBase
 {
@@ -51,6 +54,8 @@ public:
   virtual bool Restore() ;
   virtual bool Hide();
   virtual bool Show(bool raise = true);
+  virtual void Register(IDispResource *resource);
+  virtual void Unregister(IDispResource *resource);
 
   // Local to WinSystemX11 only
   Display*  GetDisplay() { return m_dpy; }
@@ -58,6 +63,8 @@ public:
 
 protected:
   bool RefreshGlxContext();
+  void CheckDisplayEvents();
+  void OnLostDevice();
 
   SDL_Surface* m_SDLSurface;
   GLXContext   m_glContext;
@@ -65,6 +72,10 @@ protected:
   Window       m_wmWindow;
   Display*     m_dpy;
   bool         m_bWasFullScreenBeforeMinimize;
+  int          m_RREventBase;
+  CCriticalSection             m_resourceSection;
+  std::vector<IDispResource*>  m_resources;
+  uint64_t                     m_dpyLostTime;
 
 private:
   bool IsSuitableVisual(XVisualInfo *vInfo);
diff --git a/xbmc/windowing/X11/WinSystemX11GL.cpp b/xbmc/windowing/X11/WinSystemX11GL.cpp
index 94f369e..ed9ed6d 100644
--- a/xbmc/windowing/X11/WinSystemX11GL.cpp
+++ b/xbmc/windowing/X11/WinSystemX11GL.cpp
@@ -43,6 +43,8 @@ CWinSystemX11GL::~CWinSystemX11GL()
 
 bool CWinSystemX11GL::PresentRenderImpl(const CDirtyRegionList& dirty)
 {
+  CheckDisplayEvents();
+
   if(m_iVSyncMode == 3)
   {
     glFinish();
-- 
1.7.5.4


From e29ca1112c976afd9a78c7cdfbda7e26efb8880a Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 15 Oct 2011 22:28:24 +0200
Subject: [PATCH 2/6] vdpau: remove recover variable and use diplay state

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp |   39 +++++++++++++++--------
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h   |    5 ++-
 2 files changed, 28 insertions(+), 16 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 06629df..8debcb6 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -92,7 +92,7 @@ CVDPAU::CVDPAU()
   surfaceNum      = presentSurfaceNum = 0;
   picAge.b_age    = picAge.ip_age[0] = picAge.ip_age[1] = 256*256*256*64;
   vdpauConfigured = false;
-  recover = false;
+  m_DisplayState = VDPAU_OPEN;
   m_mixerfield = VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME;
   m_mixerstep  = 0;
   m_DisplayState = VDPAU_OPEN;
@@ -443,7 +443,7 @@ int CVDPAU::Check(AVCodecContext* avctx)
     }
     lock.Enter();
   }
-  if (recover || m_DisplayState == VDPAU_RESET)
+  if (m_DisplayState == VDPAU_RESET)
   {
     CLog::Log(LOGNOTICE,"Attempting recovery");
 
@@ -452,7 +452,6 @@ int CVDPAU::Check(AVCodecContext* avctx)
 
     InitVDPAUProcs();
 
-    recover = false;
     m_DisplayState = VDPAU_OPEN;
 
     return VC_FLUSHED;
@@ -1038,10 +1037,12 @@ int CVDPAU::FFGetBuffer(AVCodecContext *avctx, AVFrame *pic)
   struct pictureAge*    pA         = &vdp->picAge;
 
   // while we are waiting to recover we can't do anything
-  if(vdp->recover)
-  {
-    CLog::Log(LOGWARNING, "CVDPAU::FFGetBuffer - returning due to awaiting recovery");
-    return -1;
+  { CSingleLock lock(vdp->m_DisplaySection);
+    if(vdp->m_DisplayState != VDPAU_OPEN)
+    {
+      CLog::Log(LOGWARNING, "CVDPAU::FFGetBuffer - returning due to awaiting recovery");
+      return -1;
+    }
   }
 
   vdpau_render_state * render = NULL;
@@ -1134,9 +1135,11 @@ void CVDPAU::FFDrawSlice(struct AVCodecContext *s,
   CDVDVideoCodecFFmpeg* ctx = (CDVDVideoCodecFFmpeg*)s->opaque;
   CVDPAU*               vdp = (CVDPAU*)ctx->GetHardware();
 
-  /* while we are waiting to recover we can't do anything */
-  if(vdp->recover)
-    return;
+  // while we are waiting to recover we can't do anything
+  { CSingleLock lock(vdp->m_DisplaySection);
+    if(vdp->m_DisplayState != VDPAU_OPEN)
+      return;
+  }
 
   if(src->linesize[0] || src->linesize[1] || src->linesize[2]
   || offset[0] || offset[1] || offset[2])
@@ -1433,23 +1436,31 @@ void CVDPAU::VDPPreemptionCallbackFunction(VdpDevice device, void* context)
 {
   CLog::Log(LOGDEBUG,"VDPAU Device Preempted - attempting recovery");
   CVDPAU* pCtx = (CVDPAU*)context;
-  pCtx->recover = true;
+
+  { CSingleLock lock(pCtx->m_DisplaySection);
+    if(pCtx->m_DisplayState == VDPAU_OPEN)
+      pCtx->m_DisplayState = VDPAU_RESET;
+  }
 }
 
 bool CVDPAU::CheckStatus(VdpStatus vdp_st, int line)
 {
+  CSingleLock lock(m_DisplaySection);
+
   if (vdp_st == VDP_STATUS_HANDLE_DEVICE_MISMATCH
   ||  vdp_st == VDP_STATUS_DISPLAY_PREEMPTED)
-    recover = true;
+    if(m_DisplayState == VDPAU_OPEN)
+      m_DisplayState = VDPAU_RESET;
 
   // no need to log errors about this case, as it will happen on cleanup
-  if (vdp_st == VDP_STATUS_INVALID_HANDLE && recover && vdpauConfigured)
+  if (vdp_st == VDP_STATUS_INVALID_HANDLE && (m_DisplayState != VDPAU_OPEN) && vdpauConfigured)
     return false;
 
   if (vdp_st != VDP_STATUS_OK)
   {
     CLog::Log(LOGERROR, " (VDPAU) Error: %s(%d) at %s:%d\n", vdp_get_error_string(vdp_st), vdp_st, __FILE__, line);
-    recover = true;
+    if(m_DisplayState == VDPAU_OPEN)
+      m_DisplayState = VDPAU_RESET;
     return true;
   }
   return false;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
index 6eab3fc..31cb653 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
@@ -102,7 +102,6 @@ public:
   void InitCSCMatrix(int Height);
   bool CheckStatus(VdpStatus vdp_st, int line);
 
-  bool CheckRecover(bool force = false);
   void CheckFeatures();
   void SetColor();
   void SetNoiseReduction();
@@ -111,7 +110,6 @@ public:
   void SetHWUpscaling();
 
   pictureAge picAge;
-  bool       recover;
   vdpau_render_state *past[2], *current, *future;
   int        tmpDeintMode, tmpDeintGUI, tmpDeint;
   float      tmpNoiseReduction, tmpSharpness;
@@ -226,6 +224,9 @@ public:
 
   std::vector<vdpau_render_state*> m_videoSurfaces;
 
+  // OnLostDevice triggers transition from all states to LOST
+  // internal errors trigger transition from OPEN to RESET
+  // OnResetDevice triggers transition from LOST to RESET
   enum EDisplayState
   { VDPAU_OPEN
   , VDPAU_RESET
-- 
1.7.5.4


From 27662f3b3212db24c5691514a7159f801a02e4d2 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Wed, 19 Oct 2011 16:20:15 +0200
Subject: [PATCH 3/6] vdpau: fix memory leak and access violation in
 vdpau_render_state structure

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp |   54 +++++++++++++++++++-----
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h   |    2 +
 2 files changed, 45 insertions(+), 11 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 8debcb6..cb2aaac 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -151,6 +151,9 @@ bool CVDPAU::Open(AVCodecContext* avctx, const enum PixelFormat, unsigned int su
     }
   }
 
+  if (!m_dllAvUtil.Load())
+    return false;
+
   InitVDPAUProcs();
 
   if (vdp_device != VDP_INVALID_HANDLE)
@@ -212,6 +215,7 @@ void CVDPAU::Close()
   FiniVDPAUProcs();
 
   g_Windowing.Unregister(this);
+  m_dllAvUtil.Unload();
 
   if (m_glPixmap)
   {
@@ -431,19 +435,24 @@ void CVDPAU::OnResetDevice()
 
 int CVDPAU::Check(AVCodecContext* avctx)
 {
-  CSingleLock lock(m_DisplaySection);
+  EDisplayState state;
 
-  if (m_DisplayState == VDPAU_LOST)
+  { CSingleLock lock(m_DisplaySection);
+    state = m_DisplayState;
+  }
+
+  if (state == VDPAU_LOST)
   {
-    lock.Leave();
     if (!m_DisplayEvent.WaitMSec(2000))
     {
       CLog::Log(LOGERROR, "CVDPAU::Check - device didn't reset in reasonable time");
       return VC_ERROR;
     }
-    lock.Enter();
+    { CSingleLock lock(m_DisplaySection);
+      state = m_DisplayState;
+    }
   }
-  if (m_DisplayState == VDPAU_RESET)
+  if (state == VDPAU_RESET)
   {
     CLog::Log(LOGNOTICE,"Attempting recovery");
 
@@ -452,8 +461,6 @@ int CVDPAU::Check(AVCodecContext* avctx)
 
     InitVDPAUProcs();
 
-    m_DisplayState = VDPAU_OPEN;
-
     return VC_FLUSHED;
   }
   return 0;
@@ -863,6 +870,7 @@ void CVDPAU::FiniVDPAUOutput()
     vdp_st = vdp_video_surface_destroy(m_videoSurfaces[i]->surface);
     CheckStatus(vdp_st, __LINE__);
     m_videoSurfaces[i]->surface = VDP_INVALID_HANDLE;
+    m_dllAvUtil.av_freep(&m_videoSurfaces[i]->bitstream_buffers);
     free(m_videoSurfaces[i]);
   }
   m_videoSurfaces.clear();
@@ -1065,6 +1073,11 @@ int CVDPAU::FFGetBuffer(AVCodecContext *avctx, AVFrame *pic)
     VdpDecoderProfile profile;
     ReadFormatOf(avctx->pix_fmt, profile, vdp->vdp_chroma_type);
     render = (vdpau_render_state*)calloc(sizeof(vdpau_render_state), 1);
+    if (render == NULL)
+    {
+      CLog::Log(LOGWARNING, "CVDPAU::FFGetBuffer - calloc failed");
+      return -1;
+    }
     vdp_st = vdp->vdp_video_surface_create(vdp->vdp_device,
                                            vdp->vdp_chroma_type,
                                            avctx->width,
@@ -1112,19 +1125,38 @@ int CVDPAU::FFGetBuffer(AVCodecContext *avctx, AVFrame *pic)
 void CVDPAU::FFReleaseBuffer(AVCodecContext *avctx, AVFrame *pic)
 {
   //CLog::Log(LOGNOTICE,"%s",__FUNCTION__);
-  vdpau_render_state * render;
-  int i;
+  CDVDVideoCodecFFmpeg* ctx        = (CDVDVideoCodecFFmpeg*)avctx->opaque;
+  CVDPAU*               vdp        = (CVDPAU*)ctx->GetHardware();
+  vdpau_render_state  * render;
+  unsigned int i;
 
   render=(vdpau_render_state*)pic->data[0];
   if(!render)
   {
-    CLog::Log(LOGERROR, "CVDPAU::FFDrawSlice - invalid context handle provided");
+    CLog::Log(LOGERROR, "CVDPAU::FFReleaseBuffer - invalid context handle provided");
     return;
   }
 
-  render->state &= ~FF_VDPAU_STATE_USED_FOR_REFERENCE;
   for(i=0; i<4; i++)
     pic->data[i]= NULL;
+
+  // find render state in queue
+  bool found(false);
+  for(i = 0; i < vdp->m_videoSurfaces.size(); ++i)
+  {
+    if(vdp->m_videoSurfaces[i] == render)
+    {
+      found = true;
+      break;
+    }
+  }
+  if (!found)
+  {
+    CLog::Log(LOGDEBUG, "CVDPAU::FFReleaseBuffer - buffer not found");
+    return;
+  }
+
+  render->state &= ~FF_VDPAU_STATE_USED_FOR_REFERENCE;
 }
 
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
index 31cb653..d10d845 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
@@ -21,6 +21,7 @@
  *
  */
 
+#include "DllAvUtil.h"
 #include "DVDVideoCodec.h"
 #include "DVDVideoCodecFFmpeg.h"
 #include "libavcodec/vdpau.h"
@@ -223,6 +224,7 @@ public:
                           , VdpChromaType     &chroma_type);
 
   std::vector<vdpau_render_state*> m_videoSurfaces;
+  DllAvUtil   m_dllAvUtil;
 
   // OnLostDevice triggers transition from all states to LOST
   // internal errors trigger transition from OPEN to RESET
-- 
1.7.5.4


From dcfe717dd680598f09fd3fbe34e77bd75d390660 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 21 Oct 2011 09:06:06 +0200
Subject: [PATCH 4/6] vdpau: revamp error recovery, verify picture buffers
 from ffmpeg because some decoders like vc-1 dont flush

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp |  168 ++++++++++++------------
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h   |    3 -
 2 files changed, 84 insertions(+), 87 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index cb2aaac..814c05c 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -73,12 +73,6 @@ static struct SInterlaceMapping
 , {VS_INTERLACEMETHOD_NONE                       , (VdpVideoMixerFeature)-1}
 };
 
-#define CHECK_VDPAU_RETURN(vdp, value) \
-        do { \
-          if(CheckStatus(vdp, __LINE__)) \
-            return value; \
-        } while(0);
-
 //since libvdpau 0.4, vdp_device_create_x11() installs a callback on the Display*,
 //if we unload libvdpau with dlclose(), we segfault on XCloseDisplay,
 //so we just keep a static handle to libvdpau around
@@ -99,7 +93,6 @@ CVDPAU::CVDPAU()
 
   m_glPixmap = 0;
   m_Pixmap = 0;
-  m_glContext = 0;
   if (!glXBindTexImageEXT)
     glXBindTexImageEXT    = (PFNGLXBINDTEXIMAGEEXTPROC)glXGetProcAddress((GLubyte *) "glXBindTexImageEXT");
   if (!glXReleaseTexImageEXT)
@@ -230,13 +223,6 @@ void CVDPAU::Close()
     XFreePixmap(m_Display, m_Pixmap);
     m_Pixmap = NULL;
   }
-
-  if (m_glContext)
-  {
-    CLog::Log(LOGINFO, "GLX: Destroying glContext");
-    glXDestroyContext(m_Display, m_glContext);
-    m_glContext = NULL;
-  }
 }
 
 bool CVDPAU::MakePixmapGL()
@@ -284,36 +270,9 @@ bool CVDPAU::MakePixmapGL()
     XFree(fbConfigs);
     return false;
   }
-
-  /* to make the pixmap usable, it needs to have any context associated with it */
-  GLXContext  lastctx = glXGetCurrentContext();
-  GLXDrawable lastdrw = glXGetCurrentDrawable();
-
-  XVisualInfo *visInfo;
-  visInfo = glXGetVisualFromFBConfig(m_Display, fbConfigs[fbConfigIndex]);
-  if (!visInfo)
-  {
-    CLog::Log(LOGINFO, "GLX Error: Could not obtain X Visual Info for pixmap");
-    XFree(fbConfigs);
-    return false;
-  }
   XFree(fbConfigs);
 
-  CLog::Log(LOGINFO, "GLX: Creating Pixmap context");
-  m_glContext = glXCreateContext(m_Display, visInfo, NULL, True);
-  XFree(visInfo);
-
-  if (!glXMakeCurrent(m_Display, m_glPixmap, m_glContext))
-  {
-    CLog::Log(LOGINFO, "GLX Error: Could not make Pixmap current");
-    return false;
-  }
-
-  /* restore what thread had before */
-  glXMakeCurrent(m_Display, lastdrw, lastctx);
-
   return true;
-
 }
 
 bool CVDPAU::MakePixmap(int width, int height)
@@ -798,17 +757,26 @@ void CVDPAU::InitVDPAUProcs()
   
 #undef VDP_PROC
 
-  vdp_st = vdp_preemption_callback_register(vdp_device,
-                                   &VDPPreemptionCallbackFunction,
-                                   (void*)this);
-  CheckStatus(vdp_st, __LINE__);
-
   CSingleLock lock(m_DisplaySection);
   m_DisplayState = VDPAU_OPEN;
+  vdpauConfigured = false;
 }
 
 void CVDPAU::FiniVDPAUProcs()
 {
+  while (!m_videoSurfaces.empty())
+  {
+    vdpau_render_state *render = m_videoSurfaces.back();
+    m_videoSurfaces.pop_back();
+    if (render->bitstream_buffers_allocated)
+      m_dllAvUtil.av_freep(&render->bitstream_buffers);
+    render->bitstream_buffers_allocated = 0;
+    free(render);
+  }
+
+  while (!m_DVDVideoPics.empty())
+    m_DVDVideoPics.pop();
+
   if (vdp_device == VDP_INVALID_HANDLE) return;
 
   VdpStatus vdp_st;
@@ -841,15 +809,18 @@ void CVDPAU::FiniVDPAUOutput()
   VdpStatus vdp_st;
 
   vdp_st = vdp_decoder_destroy(decoder);
-  CheckStatus(vdp_st, __LINE__);
+  if (CheckStatus(vdp_st, __LINE__))
+    return;
   decoder = VDP_INVALID_HANDLE;
 
   vdp_st = vdp_presentation_queue_destroy(vdp_flip_queue);
-  CheckStatus(vdp_st, __LINE__);
+  if (CheckStatus(vdp_st, __LINE__))
+    return;
   vdp_flip_queue = VDP_INVALID_HANDLE;
 
   vdp_st = vdp_presentation_queue_target_destroy(vdp_flip_target);
-  CheckStatus(vdp_st, __LINE__);
+  if (CheckStatus(vdp_st, __LINE__))
+    return;
   vdp_flip_target = VDP_INVALID_HANDLE;
 
   outputSurface = presentSurface = VDP_INVALID_HANDLE;
@@ -857,23 +828,30 @@ void CVDPAU::FiniVDPAUOutput()
   for (int i = 0; i < totalAvailableOutputSurfaces; i++)
   {
     vdp_st = vdp_output_surface_destroy(outputSurfaces[i]);
-    CheckStatus(vdp_st, __LINE__);
+    if (CheckStatus(vdp_st, __LINE__))
+      return;
     outputSurfaces[i] = VDP_INVALID_HANDLE;
   }
 
   vdp_st = vdp_video_mixer_destroy(videoMixer);
-  CheckStatus(vdp_st, __LINE__);
+  if (CheckStatus(vdp_st, __LINE__))
+    return;
   videoMixer = VDP_INVALID_HANDLE;
 
-  for(unsigned int i = 0; i < m_videoSurfaces.size(); i++)
+  while (!m_videoSurfaces.empty())
   {
-    vdp_st = vdp_video_surface_destroy(m_videoSurfaces[i]->surface);
-    CheckStatus(vdp_st, __LINE__);
-    m_videoSurfaces[i]->surface = VDP_INVALID_HANDLE;
-    m_dllAvUtil.av_freep(&m_videoSurfaces[i]->bitstream_buffers);
-    free(m_videoSurfaces[i]);
+    vdpau_render_state *render = m_videoSurfaces.back();
+    m_videoSurfaces.pop_back();
+    if (render->bitstream_buffers_allocated)
+      m_dllAvUtil.av_freep(&render->bitstream_buffers);
+    render->bitstream_buffers_allocated = 0;
+    vdp_st = vdp_video_surface_destroy(render->surface);
+    render->surface = VDP_INVALID_HANDLE;
+    free(render);
+    if (CheckStatus(vdp_st, __LINE__))
+      return;
   }
-  m_videoSurfaces.clear();
+
   while (!m_DVDVideoPics.empty())
     m_DVDVideoPics.pop();
 }
@@ -947,17 +925,20 @@ bool CVDPAU::ConfigVDPAU(AVCodecContext* avctx, int ref_frames)
                               vid_height,
                               max_references,
                               &decoder);
-  CHECK_VDPAU_RETURN(vdp_st, false);
+  if (CheckStatus(vdp_st, __LINE__))
+    return false;
 
   vdp_st = vdp_presentation_queue_target_create_x11(vdp_device,
                                                     m_Pixmap, //x_window,
                                                     &vdp_flip_target);
-  CHECK_VDPAU_RETURN(vdp_st, false);
+  if (CheckStatus(vdp_st, __LINE__))
+    return false;
 
   vdp_st = vdp_presentation_queue_create(vdp_device,
                                          vdp_flip_target,
                                          &vdp_flip_queue);
-  CHECK_VDPAU_RETURN(vdp_st, false);
+  if (CheckStatus(vdp_st, __LINE__))
+    return false;
 
   totalAvailableOutputSurfaces = 0;
 
@@ -973,7 +954,8 @@ bool CVDPAU::ConfigVDPAU(AVCodecContext* avctx, int ref_frames)
                                        OutWidth,
                                        OutHeight,
                                        &outputSurfaces[i]);
-    CHECK_VDPAU_RETURN(vdp_st, false);
+    if (CheckStatus(vdp_st, __LINE__))
+      return false;
     totalAvailableOutputSurfaces++;
   }
   CLog::Log(LOGNOTICE, " (VDPAU) Total Output Surfaces Available: %i of a max (tmp: %i const: %i)",
@@ -983,8 +965,10 @@ bool CVDPAU::ConfigVDPAU(AVCodecContext* avctx, int ref_frames)
 
   surfaceNum = presentSurfaceNum = 0;
   outputSurface = outputSurfaces[surfaceNum];
+  outputSurface = presentSurface = VDP_INVALID_HANDLE;
+  videoMixer = VDP_INVALID_HANDLE;
 
-vdpauConfigured = true;
+  vdpauConfigured = true;
   return true;
 }
 
@@ -1152,7 +1136,7 @@ void CVDPAU::FFReleaseBuffer(AVCodecContext *avctx, AVFrame *pic)
   }
   if (!found)
   {
-    CLog::Log(LOGDEBUG, "CVDPAU::FFReleaseBuffer - buffer not found");
+    CLog::Log(LOGDEBUG, "CVDPAU::FFReleaseBuffer - ignoring invalid buffer");
     return;
   }
 
@@ -1190,6 +1174,22 @@ void CVDPAU::FFDrawSlice(struct AVCodecContext *s,
     return;
   }
 
+  // ffmpeg vc-1 decoder does not flush, make sure the data buffer is still valid
+  bool found(false);
+  for(unsigned int i = 0; i < vdp->m_videoSurfaces.size(); ++i)
+  {
+    if(vdp->m_videoSurfaces[i] == render)
+    {
+      found = true;
+      break;
+    }
+  }
+  if (!found)
+  {
+    CLog::Log(LOGWARNING, "CVDPAU::FFDrawSlice - ignoring invalid buffer");
+    return;
+  }
+
   uint32_t max_refs = 0;
   if(s->pix_fmt == PIX_FMT_VDPAU_H264)
     max_refs = render->info.h264.num_ref_frames;
@@ -1250,6 +1250,22 @@ int CVDPAU::Decode(AVCodecContext *avctx, AVFrame *pFrame)
     if(!render)
       return VC_ERROR;
 
+    // ffmpeg vc-1 decoder does not flush, make sure the data buffer is still valid
+    bool found(false);
+    for(unsigned int i = 0; i < m_videoSurfaces.size(); ++i)
+    {
+      if(m_videoSurfaces[i] == render)
+      {
+        found = true;
+        break;
+      }
+    }
+    if (!found)
+    {
+      CLog::Log(LOGWARNING, "CVDPAU::Decode - ignoring invalid buffer");
+      return VC_BUFFER;
+    }
+
     render->state |= FF_VDPAU_STATE_USED_FOR_RENDER;
 
     ClearUsedForRender(&past[0]);
@@ -1464,35 +1480,19 @@ void CVDPAU::Present()
   CheckStatus(vdp_st, __LINE__);
 }
 
-void CVDPAU::VDPPreemptionCallbackFunction(VdpDevice device, void* context)
-{
-  CLog::Log(LOGDEBUG,"VDPAU Device Preempted - attempting recovery");
-  CVDPAU* pCtx = (CVDPAU*)context;
-
-  { CSingleLock lock(pCtx->m_DisplaySection);
-    if(pCtx->m_DisplayState == VDPAU_OPEN)
-      pCtx->m_DisplayState = VDPAU_RESET;
-  }
-}
-
 bool CVDPAU::CheckStatus(VdpStatus vdp_st, int line)
 {
   CSingleLock lock(m_DisplaySection);
 
-  if (vdp_st == VDP_STATUS_HANDLE_DEVICE_MISMATCH
-  ||  vdp_st == VDP_STATUS_DISPLAY_PREEMPTED)
-    if(m_DisplayState == VDPAU_OPEN)
-      m_DisplayState = VDPAU_RESET;
-
-  // no need to log errors about this case, as it will happen on cleanup
-  if (vdp_st == VDP_STATUS_INVALID_HANDLE && (m_DisplayState != VDPAU_OPEN) && vdpauConfigured)
-    return false;
-
   if (vdp_st != VDP_STATUS_OK)
   {
     CLog::Log(LOGERROR, " (VDPAU) Error: %s(%d) at %s:%d\n", vdp_get_error_string(vdp_st), vdp_st, __FILE__, line);
+
+    vdp_device = VDP_INVALID_HANDLE;
+
     if(m_DisplayState == VDPAU_OPEN)
       m_DisplayState = VDPAU_RESET;
+
     return true;
   }
   return false;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
index d10d845..868ca60 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
@@ -87,7 +87,6 @@ public:
   PFNGLXRELEASETEXIMAGEEXTPROC glXReleaseTexImageEXT;
   GLXPixmap  m_glPixmap;
   Pixmap  m_Pixmap;
-  GLXContext m_glContext;
 
   static void             FFReleaseBuffer(AVCodecContext *avctx, AVFrame *pic);
   static void             FFDrawSlice(struct AVCodecContext *s,
@@ -95,8 +94,6 @@ public:
                                int y, int type, int height);
   static int              FFGetBuffer(AVCodecContext *avctx, AVFrame *pic);
 
-  static void             VDPPreemptionCallbackFunction(VdpDevice device, void* context);
-
   void Present();
   bool ConfigVDPAU(AVCodecContext *avctx, int ref_frames);
   void SpewHardwareAvailable();
-- 
1.7.5.4


From ad1dfc3aefe71075185cd8aaec5639b4af4de390 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 22 Oct 2011 10:31:47 +0200
Subject: [PATCH 5/6] LinuxRendererGL: call glFinish in uninit

---
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index 0e247aa..4c736bf 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -1049,6 +1049,8 @@ void CLinuxRendererGL::UnInit()
   CLog::Log(LOGDEBUG, "LinuxRendererGL: Cleaning up GL resources");
   CSingleLock lock(g_graphicsContext);
 
+  glFinish();
+
   if (m_rgbPbo)
   {
     glDeleteBuffersARB(1, &m_rgbPbo);
-- 
1.7.5.4


From e80b167c14fd96065ce40ac588772582788d8e93 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 22 Oct 2011 14:49:40 +0200
Subject: [PATCH 6/6] vdpau: change order of creation/clear down of pixmap and
 presentation queue

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp |  197 ++++++++++++++++--------
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h   |   17 ++-
 xbmc/windowing/X11/WinSystemX11.cpp            |    6 +-
 3 files changed, 152 insertions(+), 68 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 814c05c..c10c5b8 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -89,7 +89,6 @@ CVDPAU::CVDPAU()
   m_DisplayState = VDPAU_OPEN;
   m_mixerfield = VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME;
   m_mixerstep  = 0;
-  m_DisplayState = VDPAU_OPEN;
 
   m_glPixmap = 0;
   m_Pixmap = 0;
@@ -181,7 +180,6 @@ bool CVDPAU::Open(AVCodecContext* avctx, const enum PixelFormat, unsigned int su
     }
 
     InitCSCMatrix(avctx->height);
-    MakePixmap(avctx->width,avctx->height);
 
     /* finally setup ffmpeg */
     avctx->get_buffer      = CVDPAU::FFGetBuffer;
@@ -209,20 +207,6 @@ void CVDPAU::Close()
 
   g_Windowing.Unregister(this);
   m_dllAvUtil.Unload();
-
-  if (m_glPixmap)
-  {
-    CLog::Log(LOGINFO, "GLX: Destroying glPixmap");
-    glXReleaseTexImageEXT(m_Display, m_glPixmap, GLX_FRONT_LEFT_EXT);
-    glXDestroyPixmap(m_Display, m_glPixmap);
-    m_glPixmap = NULL;
-  }
-  if (m_Pixmap)
-  {
-    CLog::Log(LOGINFO, "GLX: Destroying XPixmap");
-    XFreePixmap(m_Display, m_Pixmap);
-    m_Pixmap = NULL;
-  }
 }
 
 bool CVDPAU::MakePixmapGL()
@@ -331,7 +315,9 @@ bool CVDPAU::MakePixmap(int width, int height)
 
 void CVDPAU::BindPixmap()
 {
-  { CSingleLock lock(m_DisplaySection);
+  CSharedLock lock(m_DecoderSection);
+
+  { CSharedLock dLock(m_DisplaySection);
     if (m_DisplayState != VDPAU_OPEN)
       return;
   }
@@ -362,7 +348,9 @@ void CVDPAU::BindPixmap()
 
 void CVDPAU::ReleasePixmap()
 {
-  { CSingleLock lock(m_DisplaySection);
+  CSharedLock lock(m_DecoderSection);
+
+  { CSharedLock dLock(m_DisplaySection);
     if (m_DisplayState != VDPAU_OPEN)
       return;
   }
@@ -376,15 +364,23 @@ void CVDPAU::ReleasePixmap()
 
 void CVDPAU::OnLostDevice()
 {
-  CSingleLock lock(m_DisplaySection);
+  CLog::Log(LOGNOTICE,"CVDPAU::OnLostDevice event");
+
+  { CExclusiveLock lock(m_DecoderSection);
+    FiniVDPAUOutput();
+    FiniVDPAUProcs();
+  }
+
+  CExclusiveLock lock(m_DisplaySection);
   m_DisplayState = VDPAU_LOST;
   m_DisplayEvent.Reset();
 }
 
 void CVDPAU::OnResetDevice()
 {
-  CSingleLock lock(m_DisplaySection);
+  CLog::Log(LOGNOTICE,"CVDPAU::OnResetDevice event");
 
+  CExclusiveLock lock(m_DisplaySection);
   if (m_DisplayState == VDPAU_LOST)
   {
     m_DisplayState = VDPAU_RESET;
@@ -396,18 +392,19 @@ int CVDPAU::Check(AVCodecContext* avctx)
 {
   EDisplayState state;
 
-  { CSingleLock lock(m_DisplaySection);
+  { CSharedLock lock(m_DisplaySection);
     state = m_DisplayState;
   }
 
   if (state == VDPAU_LOST)
   {
+    CLog::Log(LOGNOTICE,"CVDPAU::Check waiting for display reset event");
     if (!m_DisplayEvent.WaitMSec(2000))
     {
       CLog::Log(LOGERROR, "CVDPAU::Check - device didn't reset in reasonable time");
       return VC_ERROR;
     }
-    { CSingleLock lock(m_DisplaySection);
+    { CSharedLock lock(m_DisplaySection);
       state = m_DisplayState;
     }
   }
@@ -415,6 +412,9 @@ int CVDPAU::Check(AVCodecContext* avctx)
   {
     CLog::Log(LOGNOTICE,"Attempting recovery");
 
+    CSingleLock gLock(g_graphicsContext);
+    CExclusiveLock lock(m_DecoderSection);
+
     FiniVDPAUOutput();
     FiniVDPAUProcs();
 
@@ -757,7 +757,19 @@ void CVDPAU::InitVDPAUProcs()
   
 #undef VDP_PROC
 
-  CSingleLock lock(m_DisplaySection);
+  // set all vdpau resources to invalid
+  vdp_flip_target = VDP_INVALID_HANDLE;
+  vdp_flip_queue = VDP_INVALID_HANDLE;
+  videoMixer = VDP_INVALID_HANDLE;
+  totalAvailableOutputSurfaces = 0;
+  presentSurface = VDP_INVALID_HANDLE;
+  outputSurface = VDP_INVALID_HANDLE;
+  for (int i = 0; i < NUM_OUTPUT_SURFACES; i++)
+    outputSurfaces[i] = VDP_INVALID_HANDLE;
+
+  m_vdpauOutputMethod = OUTPUT_NONE;
+
+  CExclusiveLock lock(m_DisplaySection);
   m_DisplayState = VDPAU_OPEN;
   vdpauConfigured = false;
 }
@@ -774,9 +786,6 @@ void CVDPAU::FiniVDPAUProcs()
     free(render);
   }
 
-  while (!m_DVDVideoPics.empty())
-    m_DVDVideoPics.pop();
-
   if (vdp_device == VDP_INVALID_HANDLE) return;
 
   VdpStatus vdp_st;
@@ -802,6 +811,8 @@ void CVDPAU::InitCSCMatrix(int Height)
 
 void CVDPAU::FiniVDPAUOutput()
 {
+  FiniOutputMethod();
+
   if (vdp_device == VDP_INVALID_HANDLE || !vdpauConfigured) return;
 
   CLog::Log(LOGNOTICE, " (VDPAU) %s", __FUNCTION__);
@@ -813,31 +824,6 @@ void CVDPAU::FiniVDPAUOutput()
     return;
   decoder = VDP_INVALID_HANDLE;
 
-  vdp_st = vdp_presentation_queue_destroy(vdp_flip_queue);
-  if (CheckStatus(vdp_st, __LINE__))
-    return;
-  vdp_flip_queue = VDP_INVALID_HANDLE;
-
-  vdp_st = vdp_presentation_queue_target_destroy(vdp_flip_target);
-  if (CheckStatus(vdp_st, __LINE__))
-    return;
-  vdp_flip_target = VDP_INVALID_HANDLE;
-
-  outputSurface = presentSurface = VDP_INVALID_HANDLE;
-
-  for (int i = 0; i < totalAvailableOutputSurfaces; i++)
-  {
-    vdp_st = vdp_output_surface_destroy(outputSurfaces[i]);
-    if (CheckStatus(vdp_st, __LINE__))
-      return;
-    outputSurfaces[i] = VDP_INVALID_HANDLE;
-  }
-
-  vdp_st = vdp_video_mixer_destroy(videoMixer);
-  if (CheckStatus(vdp_st, __LINE__))
-    return;
-  videoMixer = VDP_INVALID_HANDLE;
-
   while (!m_videoSurfaces.empty())
   {
     vdpau_render_state *render = m_videoSurfaces.back();
@@ -851,9 +837,6 @@ void CVDPAU::FiniVDPAUOutput()
     if (CheckStatus(vdp_st, __LINE__))
       return;
   }
-
-  while (!m_DVDVideoPics.empty())
-    m_DVDVideoPics.pop();
 }
 
 
@@ -928,6 +911,23 @@ bool CVDPAU::ConfigVDPAU(AVCodecContext* avctx, int ref_frames)
   if (CheckStatus(vdp_st, __LINE__))
     return false;
 
+  m_vdpauOutputMethod = OUTPUT_NONE;
+
+  vdpauConfigured = true;
+  return true;
+}
+
+bool CVDPAU::ConfigOutputMethod(AVCodecContext *avctx, AVFrame *pFrame)
+{
+  VdpStatus vdp_st;
+
+  if (m_vdpauOutputMethod == OUTPUT_PIXMAP)
+    return true;
+
+  FiniOutputMethod();
+
+  MakePixmap(avctx->width,avctx->height);
+
   vdp_st = vdp_presentation_queue_target_create_x11(vdp_device,
                                                     m_Pixmap, //x_window,
                                                     &vdp_flip_target);
@@ -964,11 +964,67 @@ bool CVDPAU::ConfigVDPAU(AVCodecContext* avctx, int ref_frames)
                        NUM_OUTPUT_SURFACES);
 
   surfaceNum = presentSurfaceNum = 0;
-  outputSurface = outputSurfaces[surfaceNum];
   outputSurface = presentSurface = VDP_INVALID_HANDLE;
   videoMixer = VDP_INVALID_HANDLE;
 
-  vdpauConfigured = true;
+  m_vdpauOutputMethod = OUTPUT_PIXMAP;
+
+  return true;
+}
+
+bool CVDPAU::FiniOutputMethod()
+{
+  VdpStatus vdp_st;
+
+  if (vdp_flip_queue != VDP_INVALID_HANDLE)
+  {
+    vdp_st = vdp_presentation_queue_destroy(vdp_flip_queue);
+    vdp_flip_queue = VDP_INVALID_HANDLE;
+    CheckStatus(vdp_st, __LINE__);
+  }
+
+  if (vdp_flip_target != VDP_INVALID_HANDLE)
+  {
+    vdp_st = vdp_presentation_queue_target_destroy(vdp_flip_target);
+    vdp_flip_target = VDP_INVALID_HANDLE;
+    CheckStatus(vdp_st, __LINE__);
+  }
+
+  if (m_glPixmap)
+  {
+    CLog::Log(LOGDEBUG, "GLX: Destroying glPixmap");
+    glXDestroyPixmap(m_Display, m_glPixmap);
+    m_glPixmap = NULL;
+  }
+
+  if (m_Pixmap)
+  {
+    CLog::Log(LOGDEBUG, "GLX: Destroying XPixmap");
+    XFreePixmap(m_Display, m_Pixmap);
+    m_Pixmap = NULL;
+  }
+
+  outputSurface = presentSurface = VDP_INVALID_HANDLE;
+
+  for (int i = 0; i < totalAvailableOutputSurfaces; i++)
+  {
+    if (outputSurfaces[i] == VDP_INVALID_HANDLE)
+       continue;
+    vdp_st = vdp_output_surface_destroy(outputSurfaces[i]);
+    outputSurfaces[i] = VDP_INVALID_HANDLE;
+    CheckStatus(vdp_st, __LINE__);
+  }
+
+  if (videoMixer != VDP_INVALID_HANDLE)
+  {
+    vdp_st = vdp_video_mixer_destroy(videoMixer);
+    videoMixer = VDP_INVALID_HANDLE;
+    if (CheckStatus(vdp_st, __LINE__));
+  }
+
+  while (!m_DVDVideoPics.empty())
+    m_DVDVideoPics.pop();
+
   return true;
 }
 
@@ -1029,7 +1085,9 @@ int CVDPAU::FFGetBuffer(AVCodecContext *avctx, AVFrame *pic)
   struct pictureAge*    pA         = &vdp->picAge;
 
   // while we are waiting to recover we can't do anything
-  { CSingleLock lock(vdp->m_DisplaySection);
+  CSharedLock lock(vdp->m_DecoderSection);
+
+  { CSharedLock dLock(vdp->m_DisplaySection);
     if(vdp->m_DisplayState != VDPAU_OPEN)
     {
       CLog::Log(LOGWARNING, "CVDPAU::FFGetBuffer - returning due to awaiting recovery");
@@ -1114,6 +1172,8 @@ void CVDPAU::FFReleaseBuffer(AVCodecContext *avctx, AVFrame *pic)
   vdpau_render_state  * render;
   unsigned int i;
 
+  CSharedLock lock(vdp->m_DecoderSection);
+
   render=(vdpau_render_state*)pic->data[0];
   if(!render)
   {
@@ -1152,11 +1212,14 @@ void CVDPAU::FFDrawSlice(struct AVCodecContext *s,
   CVDPAU*               vdp = (CVDPAU*)ctx->GetHardware();
 
   // while we are waiting to recover we can't do anything
-  { CSingleLock lock(vdp->m_DisplaySection);
+  CSharedLock lock(vdp->m_DecoderSection);
+
+  { CSharedLock dLock(vdp->m_DisplaySection);
     if(vdp->m_DisplayState != VDPAU_OPEN)
       return;
   }
 
+
   if(src->linesize[0] || src->linesize[1] || src->linesize[2]
   || offset[0] || offset[1] || offset[2])
   {
@@ -1216,6 +1279,8 @@ int CVDPAU::Decode(AVCodecContext *avctx, AVFrame *pFrame)
   VdpStatus vdp_st;
   VdpTime time;
 
+  CSharedLock lock(m_DecoderSection);
+
   int result = Check(avctx);
   if (result)
     return result;
@@ -1223,6 +1288,10 @@ int CVDPAU::Decode(AVCodecContext *avctx, AVFrame *pFrame)
   if (!vdpauConfigured)
     return VC_ERROR;
 
+  // configure vdpau output
+  if (!ConfigOutputMethod(avctx, pFrame))
+    return VC_FLUSHED;
+
   outputSurface = outputSurfaces[surfaceNum];
 
   CheckFeatures();
@@ -1419,7 +1488,9 @@ int CVDPAU::Decode(AVCodecContext *avctx, AVFrame *pFrame)
 
 bool CVDPAU::GetPicture(AVCodecContext* avctx, AVFrame* frame, DVDVideoPicture* picture)
 {
-  { CSingleLock lock(m_DisplaySection);
+  CSharedLock lock(m_DecoderSection);
+
+  { CSharedLock dLock(m_DisplaySection);
     if (m_DisplayState != VDPAU_OPEN)
       return false;
   }
@@ -1465,7 +1536,9 @@ void CVDPAU::Present()
   //CLog::Log(LOGNOTICE,"%s",__FUNCTION__);
   VdpStatus vdp_st;
 
-  { CSingleLock lock(m_DisplaySection);
+  CSharedLock lock(m_DecoderSection);
+
+  { CSharedLock dLock(m_DisplaySection);
     if (m_DisplayState != VDPAU_OPEN)
       return;
   }
@@ -1482,13 +1555,11 @@ void CVDPAU::Present()
 
 bool CVDPAU::CheckStatus(VdpStatus vdp_st, int line)
 {
-  CSingleLock lock(m_DisplaySection);
-
   if (vdp_st != VDP_STATUS_OK)
   {
     CLog::Log(LOGERROR, " (VDPAU) Error: %s(%d) at %s:%d\n", vdp_get_error_string(vdp_st), vdp_st, __FILE__, line);
 
-    vdp_device = VDP_INVALID_HANDLE;
+    CExclusiveLock lock(m_DisplaySection);
 
     if(m_DisplayState == VDPAU_OPEN)
       m_DisplayState = VDPAU_RESET;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
index 868ca60..0686d98 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
@@ -33,6 +33,7 @@
 #include <GL/glx.h>
 #include <queue>
 #include "threads/CriticalSection.h"
+#include "threads/SharedSection.h"
 #include "settings/VideoSettings.h"
 #include "guilib/DispResource.h"
 #include "threads/Event.h"
@@ -134,6 +135,8 @@ public:
   void      InitVDPAUProcs();
   void      FiniVDPAUProcs();
   void      FiniVDPAUOutput();
+  bool      ConfigOutputMethod(AVCodecContext *avctx, AVFrame *pFrame);
+  bool      FiniOutputMethod();
 
   VdpDevice                            vdp_device;
   VdpGetProcAddress *                  vdp_get_proc_address;
@@ -223,6 +226,15 @@ public:
   std::vector<vdpau_render_state*> m_videoSurfaces;
   DllAvUtil   m_dllAvUtil;
 
+  enum VDPAUOutputMethod
+  {
+    OUTPUT_NONE,
+    OUTPUT_PIXMAP,
+    OUTPUT_GL_INTEROP_RGB,
+    OUTPUT_GL_INTEROP_YUV
+  };
+  VDPAUOutputMethod m_vdpauOutputMethod;
+
   // OnLostDevice triggers transition from all states to LOST
   // internal errors trigger transition from OPEN to RESET
   // OnResetDevice triggers transition from LOST to RESET
@@ -231,8 +243,9 @@ public:
   , VDPAU_RESET
   , VDPAU_LOST
   } m_DisplayState;
-  CCriticalSection m_DisplaySection;
-  CEvent           m_DisplayEvent;
+  CSharedSection m_DecoderSection;
+  CSharedSection m_DisplaySection;
+  CEvent         m_DisplayEvent;
   virtual void OnLostDevice();
   virtual void OnResetDevice();
 };
diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index ea20c0e..62cf554 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -508,14 +508,14 @@ void CWinSystemX11::OnLostDevice()
 {
   CLog::Log(LOGDEBUG, "%s - notify display change event", __FUNCTION__);
 
+  // make sure renderer has no invalid references
+  g_renderManager.Flush();
+
   { CSingleLock lock(m_resourceSection);
     for (vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); i++)
       (*i)->OnLostDevice();
   }
 
-  // make sure renderer has no invalid references
-  g_renderManager.Flush();
-
   // fail safe timer
   m_dpyLostTime = CurrentHostCounter();
 }
-- 
1.7.5.4

