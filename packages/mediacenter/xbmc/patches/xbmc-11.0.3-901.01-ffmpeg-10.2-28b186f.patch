diff --git a/configure.in b/configure.in
index c8bf4f1..fe7c790 100755
--- a/configure.in
+++ b/configure.in
@@ -2052,7 +2052,7 @@ XB_CONFIG_MODULE([lib/ffmpeg], [
       --disable-amd3dnow \
       --disable-armv5te \
       --disable-armv6t2 \
-      --disable-static \
+      --enable-static \
       `if test "$use_debug" = "no"; then echo --disable-debug; fi` \
       --disable-muxers \
       --enable-muxer=spdif \
@@ -2066,7 +2066,6 @@ XB_CONFIG_MODULE([lib/ffmpeg], [
       --disable-ffplay \
       --disable-ffserver \
       --disable-ffmpeg \
-      --enable-shared \
       --disable-doc \
       --disable-decoder=mpeg_xvmc \
       --enable-postproc \
@@ -2074,6 +2073,7 @@ XB_CONFIG_MODULE([lib/ffmpeg], [
       --enable-protocol=http \
       --enable-pthreads \
       --enable-runtime-cpudetect \
+      --disable-openmp \
       --cc="$CC" &&
     sed -ie "s#YASM=yasm#YASM=${prefix}/bin/yasm#" config.mak &&
     sed -ie "s#YASMDEP=yasm#YASMDEP=${prefix}/bin/yasm#" config.mak &&
diff --git a/lib/DllAvCodec.h b/lib/DllAvCodec.h
index 463ab48..1ab00ea 100644
--- a/lib/DllAvCodec.h
+++ b/lib/DllAvCodec.h
@@ -24,7 +24,7 @@
   #include "config.h"
 #endif
 #include "DynamicDll.h"
-#include "DllAvCore.h"
+#include "DllAvUtil.h"
 #include "utils/log.h"
 
 extern "C" {
@@ -76,28 +76,6 @@ extern "C" {
 #endif
 }
 
-/* Some convenience macros introduced at this particular revision of libavcodec.
- */
-#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(52,25,0)
-#define CH_LAYOUT_5POINT0_BACK      (CH_LAYOUT_SURROUND|CH_BACK_LEFT|CH_BACK_RIGHT)
-#define CH_LAYOUT_5POINT1_BACK      (CH_LAYOUT_5POINT0_BACK|CH_LOW_FREQUENCY)
-#undef CH_LAYOUT_7POINT1_WIDE
-#define CH_LAYOUT_7POINT1_WIDE      (CH_LAYOUT_5POINT1_BACK|\
-                                           CH_FRONT_LEFT_OF_CENTER|CH_FRONT_RIGHT_OF_CENTER)
-#endif
-
-#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(52,64,0)
-// API added on: 2010-03-31
-#define AVMediaType		CodecType
-#define AVMEDIA_TYPE_UNKNOWN    CODEC_TYPE_UNKNOWN
-#define AVMEDIA_TYPE_VIDEO      CODEC_TYPE_VIDEO
-#define AVMEDIA_TYPE_AUDIO      CODEC_TYPE_AUDIO
-#define AVMEDIA_TYPE_DATA       CODEC_TYPE_DATA
-#define AVMEDIA_TYPE_SUBTITLE   CODEC_TYPE_SUBTITLE
-#define AVMEDIA_TYPE_ATTACHMENT CODEC_TYPE_ATTACHMENT
-#define AVMEDIA_TYPE_NB         CODEC_TYPE_NB
-#endif
-
 #include "threads/SingleLock.h"
 
 class DllAvCodecInterface
@@ -106,20 +84,20 @@ public:
   virtual ~DllAvCodecInterface() {}
   virtual void avcodec_register_all(void)=0;
   virtual void avcodec_flush_buffers(AVCodecContext *avctx)=0;
-  virtual int avcodec_open_dont_call(AVCodecContext *avctx, AVCodec *codec)=0;
+  virtual int avcodec_open2_dont_call(AVCodecContext *avctx, AVCodec *codec, AVDictionary **options)=0;
   virtual AVCodec *avcodec_find_decoder(enum CodecID id)=0;
   virtual AVCodec *avcodec_find_encoder(enum CodecID id)=0;
   virtual int avcodec_close_dont_call(AVCodecContext *avctx)=0;
   virtual AVFrame *avcodec_alloc_frame(void)=0;
   virtual int avpicture_fill(AVPicture *picture, uint8_t *ptr, PixelFormat pix_fmt, int width, int height)=0;
   virtual int avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture, int *got_picture_ptr, AVPacket *avpkt)=0;
-  virtual int avcodec_decode_audio3(AVCodecContext *avctx, int16_t *samples, int *frame_size_ptr, AVPacket *avpkt)=0;
+  virtual int avcodec_decode_audio4(AVCodecContext *avctx, AVFrame *frame, int *got_frame_ptr, AVPacket *avpkt)=0;
   virtual int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub, int *got_sub_ptr, AVPacket *avpkt)=0;
   virtual int avcodec_encode_audio(AVCodecContext *avctx, uint8_t *buf, int buf_size, const short *samples)=0;
   virtual int avpicture_get_size(PixelFormat pix_fmt, int width, int height)=0;
-  virtual AVCodecContext *avcodec_alloc_context(void)=0;
+  virtual AVCodecContext *avcodec_alloc_context3(AVCodec *codec)=0;
   virtual void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)=0;
-  virtual void avcodec_get_context_defaults(AVCodecContext *s)=0;
+  virtual void avcodec_get_context_defaults3(AVCodecContext *s, AVCodec *codec)=0;
   virtual AVCodecParserContext *av_parser_init(int codec_id)=0;
   virtual int av_parser_parse2(AVCodecParserContext *s,AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size,
                     const uint8_t *buf, int buf_size,
@@ -137,7 +115,6 @@ public:
   virtual enum PixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum PixelFormat *fmt)=0;
   virtual int avcodec_default_get_buffer(AVCodecContext *s, AVFrame *pic)=0;
   virtual void avcodec_default_release_buffer(AVCodecContext *s, AVFrame *pic)=0;
-  virtual int avcodec_thread_init(AVCodecContext *s, int thread_count)=0;
   virtual AVCodec *av_codec_next(AVCodec *c)=0;
   virtual AVAudioConvert *av_audio_convert_alloc(enum AVSampleFormat out_fmt, int out_channels,
                                                  enum AVSampleFormat in_fmt , int in_channels,
@@ -151,7 +128,7 @@ public:
   virtual int64_t avcodec_guess_channel_layout(int nb_channels, enum CodecID codec_id, const char *fmt_name)=0;
 };
 
-#if (defined USE_EXTERNAL_FFMPEG)
+#if (defined USE_EXTERNAL_FFMPEG) || (defined TARGET_DARWIN)
 
 // Use direct layer
 class DllAvCodec : public DllDynamic, DllAvCodecInterface
@@ -166,12 +143,12 @@ public:
     ::avcodec_register_all();
   }
   virtual void avcodec_flush_buffers(AVCodecContext *avctx) { ::avcodec_flush_buffers(avctx); }
-  virtual int avcodec_open(AVCodecContext *avctx, AVCodec *codec)
+  virtual int avcodec_open2(AVCodecContext *avctx, AVCodec *codec, AVDictionary **options)
   {
     CSingleLock lock(DllAvCodec::m_critSection);
-    return ::avcodec_open(avctx, codec);
+    return ::avcodec_open2(avctx, codec, options);
   }
-  virtual int avcodec_open_dont_call(AVCodecContext *avctx, AVCodec *codec) { *(int *)0x0 = 0; return 0; }
+  virtual int avcodec_open2_dont_call(AVCodecContext *avctx, AVCodec *codec, AVDictionary **options) { *(int *)0x0 = 0; return 0; }
   virtual int avcodec_close_dont_call(AVCodecContext *avctx) { *(int *)0x0 = 0; return 0; }
   virtual AVCodec *avcodec_find_decoder(enum CodecID id) { return ::avcodec_find_decoder(id); }
   virtual AVCodec *avcodec_find_encoder(enum CodecID id) { return ::avcodec_find_encoder(id); }
@@ -182,33 +159,21 @@ public:
   }
   virtual AVFrame *avcodec_alloc_frame() { return ::avcodec_alloc_frame(); }
   virtual int avpicture_fill(AVPicture *picture, uint8_t *ptr, PixelFormat pix_fmt, int width, int height) { return ::avpicture_fill(picture, ptr, pix_fmt, width, height); }
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52,23,0)
-  // API added on: 2009-04-07
   virtual int avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture, int *got_picture_ptr, AVPacket *avpkt) { return ::avcodec_decode_video2(avctx, picture, got_picture_ptr, avpkt); }
-  virtual int avcodec_decode_audio3(AVCodecContext *avctx, int16_t *samples, int *frame_size_ptr, AVPacket *avpkt) { return ::avcodec_decode_audio3(avctx, samples, frame_size_ptr, avpkt); }
+  virtual int avcodec_decode_audio4(AVCodecContext *avctx, AVFrame *frame, int *got_frame_ptr, AVPacket *avpkt) { return ::avcodec_decode_audio4(avctx, frame, got_frame_ptr, avpkt); }
   virtual int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub, int *got_sub_ptr, AVPacket *avpkt) { return ::avcodec_decode_subtitle2(avctx, sub, got_sub_ptr, avpkt); }
-#else
-  virtual int avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture, int *got_picture_ptr, AVPacket *avpkt) { return ::avcodec_decode_video(avctx, picture, got_picture_ptr, avpkt->data, avpkt->size); }
-  virtual int avcodec_decode_audio3(AVCodecContext *avctx, int16_t *samples, int *frame_size_ptr, AVPacket *avpkt) { return ::avcodec_decode_audio2(avctx, samples, frame_size_ptr, avpkt->data, avpkt->size); }
-  virtual int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub, int *got_sub_ptr, AVPacket *avpkt) { return ::avcodec_decode_subtitle(avctx, sub, got_sub_ptr, avpkt->data, avpkt->size); }
-#endif
   virtual int avcodec_encode_audio(AVCodecContext *avctx, uint8_t *buf, int buf_size, const short *samples) { return ::avcodec_encode_audio(avctx, buf, buf_size, samples); }
   virtual int avpicture_get_size(PixelFormat pix_fmt, int width, int height) { return ::avpicture_get_size(pix_fmt, width, height); }
-  virtual AVCodecContext *avcodec_alloc_context() { return ::avcodec_alloc_context(); }
+  virtual AVCodecContext *avcodec_alloc_context3(AVCodec *codec) { return ::avcodec_alloc_context3(codec); }
   virtual void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode) { ::avcodec_string(buf, buf_size, enc, encode); }
-  virtual void avcodec_get_context_defaults(AVCodecContext *s) { ::avcodec_get_context_defaults(s); }
+  virtual void avcodec_get_context_defaults3(AVCodecContext *s, AVCodec *codec) { ::avcodec_get_context_defaults3(s, codec); }
 
   virtual AVCodecParserContext *av_parser_init(int codec_id) { return ::av_parser_init(codec_id); }
   virtual int av_parser_parse2(AVCodecParserContext *s,AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size,
                     const uint8_t *buf, int buf_size,
                     int64_t pts, int64_t dts, int64_t pos)
   {
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52,21,0)
-    // API added on : 2009-03-05
     return ::av_parser_parse2(s, avctx, poutbuf, poutbuf_size, buf, buf_size, pts, dts, pos);
-#else
-    return ::av_parser_parse(s, avctx, poutbuf, poutbuf_size, buf, buf_size, pts, dts);
-#endif
   }
   virtual void av_parser_close(AVCodecParserContext *s) { ::av_parser_close(s); }
 
@@ -225,7 +190,6 @@ public:
   virtual int avcodec_default_get_buffer(AVCodecContext *s, AVFrame *pic) { return ::avcodec_default_get_buffer(s, pic); }
   virtual void avcodec_default_release_buffer(AVCodecContext *s, AVFrame *pic) { ::avcodec_default_release_buffer(s, pic); }
   virtual enum PixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum PixelFormat *fmt) { return ::avcodec_default_get_format(s, fmt); }
-  virtual int avcodec_thread_init(AVCodecContext *s, int thread_count) { return ::avcodec_thread_init(s, thread_count); }
   virtual AVCodec *av_codec_next(AVCodec *c) { return ::av_codec_next(c); }
   virtual AVAudioConvert *av_audio_convert_alloc(enum AVSampleFormat out_fmt, int out_channels,
                                                  enum AVSampleFormat in_fmt , int in_channels,
@@ -256,12 +220,12 @@ class DllAvCodec : public DllDynamic, DllAvCodecInterface
 {
   DECLARE_DLL_WRAPPER(DllAvCodec, DLL_PATH_LIBAVCODEC)
   DEFINE_FUNC_ALIGNED1(void, __cdecl, avcodec_flush_buffers, AVCodecContext*)
-  DEFINE_FUNC_ALIGNED2(int, __cdecl, avcodec_open_dont_call, AVCodecContext*, AVCodec *)
+  DEFINE_FUNC_ALIGNED3(int, __cdecl, avcodec_open2_dont_call, AVCodecContext*, AVCodec *, AVDictionary **)
   DEFINE_FUNC_ALIGNED4(int, __cdecl, avcodec_decode_video2, AVCodecContext*, AVFrame*, int*, AVPacket*)
-  DEFINE_FUNC_ALIGNED4(int, __cdecl, avcodec_decode_audio3, AVCodecContext*, int16_t*, int*, AVPacket*)
+  DEFINE_FUNC_ALIGNED4(int, __cdecl, avcodec_decode_audio4, AVCodecContext*, AVFrame*, int*, AVPacket*)
   DEFINE_FUNC_ALIGNED4(int, __cdecl, avcodec_decode_subtitle2, AVCodecContext*, AVSubtitle*, int*, AVPacket*)
   DEFINE_FUNC_ALIGNED4(int, __cdecl, avcodec_encode_audio, AVCodecContext*, uint8_t*, int, const short*)
-  DEFINE_FUNC_ALIGNED0(AVCodecContext*, __cdecl, avcodec_alloc_context)
+  DEFINE_FUNC_ALIGNED1(AVCodecContext*, __cdecl, avcodec_alloc_context3, AVCodec *)
   DEFINE_FUNC_ALIGNED1(AVCodecParserContext*, __cdecl, av_parser_init, int)
   DEFINE_FUNC_ALIGNED9(int, __cdecl, av_parser_parse2, AVCodecParserContext*,AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int64_t, int64_t, int64_t)
   DEFINE_METHOD1(int, av_dup_packet, (AVPacket *p1))
@@ -278,7 +242,7 @@ class DllAvCodec : public DllDynamic, DllAvCodecInterface
   DEFINE_METHOD5(int, avpicture_fill, (AVPicture *p1, uint8_t *p2, PixelFormat p3, int p4, int p5))
   DEFINE_METHOD3(int, avpicture_get_size, (PixelFormat p1, int p2, int p3))
   DEFINE_METHOD4(void, avcodec_string, (char *p1, int p2, AVCodecContext *p3, int p4))
-  DEFINE_METHOD1(void, avcodec_get_context_defaults, (AVCodecContext *p1))
+  DEFINE_METHOD2(void, avcodec_get_context_defaults3, (AVCodecContext *p1, AVCodec *p2))
   DEFINE_METHOD1(void, av_parser_close, (AVCodecParserContext *p1))
   DEFINE_METHOD1(void, avpicture_free, (AVPicture *p1))
   DEFINE_METHOD1(AVBitStreamFilterContext*, av_bitstream_filter_init, (const char *p1))
@@ -290,7 +254,6 @@ class DllAvCodec : public DllDynamic, DllAvCodecInterface
   DEFINE_METHOD2(void, avcodec_default_release_buffer, (AVCodecContext *p1, AVFrame *p2))
   DEFINE_METHOD2(enum PixelFormat, avcodec_default_get_format, (struct AVCodecContext *p1, const enum PixelFormat *p2))
 
-  DEFINE_METHOD2(int, avcodec_thread_init, (AVCodecContext *p1, int p2))
   DEFINE_METHOD1(AVCodec*, av_codec_next, (AVCodec *p1))
   DEFINE_METHOD6(AVAudioConvert*, av_audio_convert_alloc, (enum AVSampleFormat p1, int p2,
                                                            enum AVSampleFormat p3, int p4,
@@ -301,7 +264,7 @@ class DllAvCodec : public DllDynamic, DllAvCodecInterface
                                                const void * const p4[6], const int p5[6], int p6))
   BEGIN_METHOD_RESOLVE()
     RESOLVE_METHOD(avcodec_flush_buffers)
-    RESOLVE_METHOD_RENAME(avcodec_open,avcodec_open_dont_call)
+    RESOLVE_METHOD_RENAME(avcodec_open2,avcodec_open2_dont_call)
     RESOLVE_METHOD_RENAME(avcodec_close,avcodec_close_dont_call)
     RESOLVE_METHOD(avcodec_find_decoder)
     RESOLVE_METHOD(avcodec_find_encoder)
@@ -309,13 +272,13 @@ class DllAvCodec : public DllDynamic, DllAvCodecInterface
     RESOLVE_METHOD_RENAME(avcodec_register_all, avcodec_register_all_dont_call)
     RESOLVE_METHOD(avpicture_fill)
     RESOLVE_METHOD(avcodec_decode_video2)
-    RESOLVE_METHOD(avcodec_decode_audio3)
+    RESOLVE_METHOD(avcodec_decode_audio4)
     RESOLVE_METHOD(avcodec_decode_subtitle2)
     RESOLVE_METHOD(avcodec_encode_audio)
     RESOLVE_METHOD(avpicture_get_size)
-    RESOLVE_METHOD(avcodec_alloc_context)
+    RESOLVE_METHOD(avcodec_alloc_context3)
     RESOLVE_METHOD(avcodec_string)
-    RESOLVE_METHOD(avcodec_get_context_defaults)
+    RESOLVE_METHOD(avcodec_get_context_defaults3)
     RESOLVE_METHOD(av_parser_init)
     RESOLVE_METHOD(av_parser_parse2)
     RESOLVE_METHOD(av_parser_close)
@@ -328,7 +291,6 @@ class DllAvCodec : public DllDynamic, DllAvCodecInterface
     RESOLVE_METHOD(avcodec_default_get_buffer)
     RESOLVE_METHOD(avcodec_default_release_buffer)
     RESOLVE_METHOD(avcodec_default_get_format)
-    RESOLVE_METHOD(avcodec_thread_init)
     RESOLVE_METHOD(av_codec_next)
     RESOLVE_METHOD(av_audio_convert_alloc)
     RESOLVE_METHOD(av_audio_convert_free)
@@ -339,15 +301,15 @@ class DllAvCodec : public DllDynamic, DllAvCodecInterface
   END_METHOD_RESOLVE()
 
   /* dependencies of libavcodec */
-  DllAvCore m_dllAvCore;
+  DllAvUtil m_dllAvUtil;
   // DllAvUtil loaded implicitely by m_dllAvCore
 
 public:
     static CCriticalSection m_critSection;
-    int avcodec_open(AVCodecContext *avctx, AVCodec *codec)
+    int avcodec_open2(AVCodecContext *avctx, AVCodec *codec, AVDictionary **options)
     {
       CSingleLock lock(DllAvCodec::m_critSection);
-      return avcodec_open_dont_call(avctx,codec);
+      return avcodec_open2_dont_call(avctx,codec, options);
     }
     int avcodec_close(AVCodecContext *avctx)
     {
@@ -361,7 +323,7 @@ public:
     }
     virtual bool Load()
     {
-      if (!m_dllAvCore.Load())
+      if (!m_dllAvUtil.Load())
 	return false;
       return DllDynamic::Load();
     }
diff --git a/lib/DllAvCore.h b/lib/DllAvCore.h
deleted file mode 100644
index 92a7ab7..0000000
--- a/lib/DllAvCore.h
+++ /dev/null
@@ -1,182 +0,0 @@
-#pragma once
-/*
- *      Copyright (C) 2005-2010 Team XBMC
- *      http://www.xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, write to the Free
- *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- *  Boston, MA  02110-1301, USA.
- *  http://www.gnu.org/copyleft/gpl.html
- *
- */
-
-#if (defined HAVE_CONFIG_H) && (!defined WIN32)
-  #include "config.h"
-#endif
-#include "DynamicDll.h"
-#include "DllAvUtil.h"
-#include "utils/log.h"
-
-extern "C" {
-#ifdef USE_EXTERNAL_FFMPEG
-  #ifdef HAVE_LIBAVUTIL_SAMPLEFMT_H
-    // libavcore was merged to libavutil on 2010-02-15
-    #include <libavutil/audioconvert.h>
-    #include <libavutil/samplefmt.h>
-  #endif
-
-  #ifdef HAVE_LIBAVCORE_AVCORE_H
-    #include <libavcore/avcore.h>
-  #endif
-  #ifdef HAVE_LIBAVCORE_SAMPLEFMT_H
-    #include <libavcore/samplefmt.h>
-  #endif
-
-  /* Needed for old FFmpeg versions as used below */
-  #ifdef HAVE_LIBAVCODEC_AVCODEC_H
-    #include <libavcodec/avcodec.h>
-  #else
-    #include <ffmpeg/avcodec.h>
-  #endif
-#else
-  #include "libavcore/avcore.h"
-  #include "libavcore/samplefmt.h"
-#endif
-}
-
-/* Compatibility for old external FFmpeg versions. */
-
-#ifdef USE_EXTERNAL_FFMPEG
-
-#ifndef LIBAVCORE_VERSION_INT
-// API added on: 2010-07-21, removed on 2010-02-15
-#define LIBAVCORE_VERSION_INT 0
-#endif
-
-#ifndef AV_SAMPLE_FMT_NONE
-// API added on: 2010-11-02
-#define AVSampleFormat     SampleFormat
-#define AV_SAMPLE_FMT_NONE SAMPLE_FMT_NONE
-#define AV_SAMPLE_FMT_U8   SAMPLE_FMT_U8
-#define AV_SAMPLE_FMT_S16  SAMPLE_FMT_S16
-#define AV_SAMPLE_FMT_S32  SAMPLE_FMT_S32
-#define AV_SAMPLE_FMT_FLT  SAMPLE_FMT_FLT
-#define AV_SAMPLE_FMT_DBL  SAMPLE_FMT_DBL
-#endif
-
-#ifndef AV_CH_FRONT_LEFT
-// API added on: 2010-11-21
-#define AV_CH_FRONT_LEFT            CH_FRONT_LEFT
-#define AV_CH_FRONT_RIGHT           CH_FRONT_RIGHT
-#define AV_CH_FRONT_CENTER          CH_FRONT_CENTER
-#define AV_CH_LOW_FREQUENCY         CH_LOW_FREQUENCY
-#define AV_CH_BACK_LEFT             CH_BACK_LEFT
-#define AV_CH_BACK_RIGHT            CH_BACK_RIGHT
-#define AV_CH_FRONT_LEFT_OF_CENTER  CH_FRONT_LEFT_OF_CENTER
-#define AV_CH_FRONT_RIGHT_OF_CENTER CH_FRONT_RIGHT_OF_CENTER
-#define AV_CH_BACK_CENTER           CH_BACK_CENTER
-#define AV_CH_SIDE_LEFT             CH_SIDE_LEFT
-#define AV_CH_SIDE_RIGHT            CH_SIDE_RIGHT
-#define AV_CH_TOP_CENTER            CH_TOP_CENTER
-#define AV_CH_TOP_FRONT_LEFT        CH_TOP_FRONT_LEFT
-#define AV_CH_TOP_FRONT_CENTER      CH_TOP_FRONT_CENTER
-#define AV_CH_TOP_FRONT_RIGHT       CH_TOP_FRONT_RIGHT
-#define AV_CH_TOP_BACK_LEFT         CH_TOP_BACK_LEFT
-#define AV_CH_TOP_BACK_CENTER       CH_TOP_BACK_CENTER
-#define AV_CH_TOP_BACK_RIGHT        CH_TOP_BACK_RIGHT
-#define AV_CH_STEREO_LEFT           CH_STEREO_LEFT
-#define AV_CH_STEREO_RIGHT          CH_STEREO_RIGHT
-
-#define AV_CH_LAYOUT_NATIVE         CH_LAYOUT_NATIVE
-
-#define AV_CH_LAYOUT_MONO           CH_LAYOUT_MONO
-#define AV_CH_LAYOUT_STEREO         CH_LAYOUT_STEREO
-#define AV_CH_LAYOUT_2_1            CH_LAYOUT_2_1
-#define AV_CH_LAYOUT_SURROUND       CH_LAYOUT_SURROUND
-#define AV_CH_LAYOUT_4POINT0        CH_LAYOUT_4POINT0
-#define AV_CH_LAYOUT_2_2            CH_LAYOUT_2_2
-#define AV_CH_LAYOUT_QUAD           CH_LAYOUT_QUAD
-#define AV_CH_LAYOUT_5POINT0        CH_LAYOUT_5POINT0
-#define AV_CH_LAYOUT_5POINT1        CH_LAYOUT_5POINT1
-#define AV_CH_LAYOUT_5POINT0_BACK   CH_LAYOUT_5POINT0_BACK
-#define AV_CH_LAYOUT_5POINT1_BACK   CH_LAYOUT_5POINT1_BACK
-#define AV_CH_LAYOUT_7POINT0        CH_LAYOUT_7POINT0
-#define AV_CH_LAYOUT_7POINT1        CH_LAYOUT_7POINT1
-#define AV_CH_LAYOUT_7POINT1_WIDE   CH_LAYOUT_7POINT1_WIDE
-#define AV_CH_LAYOUT_STEREO_DOWNMIX CH_LAYOUT_STEREO_DOWNMIX
-#endif
-
-#endif // USE_EXTERNAL_FFMPEG
-
-class DllAvCoreInterface
-{
-public:
-  virtual ~DllAvCoreInterface() {}
-  virtual int av_get_bits_per_sample_fmt(enum AVSampleFormat sample_fmt) = 0;
-};
-
-#if (defined USE_EXTERNAL_FFMPEG)
-
-// Use direct layer
-class DllAvCore : public DllDynamic, DllAvCoreInterface
-{
-public:
-  virtual ~DllAvCore() {}
-#if LIBAVCORE_VERSION_INT >= AV_VERSION_INT(0,12,0) || LIBAVUTIL_VERSION_INT >= AV_VERSION_INT(50,38,0)
-  // API added on: 2010-11-02, moved to libavutil on 2010-02-15
-  virtual int av_get_bits_per_sample_fmt(enum AVSampleFormat sample_fmt) { return ::av_get_bits_per_sample_fmt(sample_fmt); }
-#else
-  // from avcodec.h
-  virtual int av_get_bits_per_sample_fmt(enum AVSampleFormat sample_fmt) { return ::av_get_bits_per_sample_format(sample_fmt); }
-#endif
-
-  // DLL faking.
-  virtual bool ResolveExports() { return true; }
-  virtual bool Load() {
-#if LIBAVCORE_VERSION_INT > 0
-    CLog::Log(LOGDEBUG, "DllAvCore: Using libavcore system library");
-#endif
-    return true;
-  }
-  virtual void Unload() {}
-};
-
-#else
-
-class DllAvCore : public DllDynamic, DllAvCoreInterface
-{
-  DECLARE_DLL_WRAPPER(DllAvCore, DLL_PATH_LIBAVCORE)
-
-  LOAD_SYMBOLS()
-
-  DEFINE_METHOD1(int, av_get_bits_per_sample_fmt, (enum AVSampleFormat p1))
-
-  BEGIN_METHOD_RESOLVE()
-    RESOLVE_METHOD(av_get_bits_per_sample_fmt)
-  END_METHOD_RESOLVE()
-
-  /* dependency of libavcore */
-  DllAvUtil m_dllAvUtil;
-
-public:
-  virtual bool Load()
-  {
-    if (!m_dllAvUtil.Load())
-      return false;
-    return DllDynamic::Load();
-  }
-};
-
-#endif
-
diff --git a/lib/DllAvFilter.h b/lib/DllAvFilter.h
index a421225..e363082 100644
--- a/lib/DllAvFilter.h
+++ b/lib/DllAvFilter.h
@@ -24,8 +24,8 @@
   #include "config.h"
 #endif
 #include "DynamicDll.h"
-#include "DllAvCore.h"
 #include "DllAvCodec.h"
+#include "DllSwResample.h"
 #include "utils/log.h"
 
 extern "C" {
@@ -43,28 +43,17 @@ extern "C" {
 #if (defined USE_EXTERNAL_FFMPEG)
   #if (defined HAVE_LIBAVFILTER_AVFILTER_H)
     #include <libavfilter/avfiltergraph.h>
+    #include <libavfilter/buffersink.h>
+    #include <libavfilter/avcodec.h>
   #elif (defined HAVE_FFMPEG_AVFILTER_H)
     #include <ffmpeg/avfiltergraph.h>
-  #endif
-  /* for av_vsrc_buffer_add_frame */
-  #if (defined USE_OLD_AV_VSRC_BUFFER_ADD_FRAME)
-    #include <libavfilter/vsrc_buffer.h>
-  #else
-    #if LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,8,0)
-      #include <libavfilter/avcodec.h>
-    #elif LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,7,0)
-      int av_vsrc_buffer_add_frame(AVFilterContext *buffer_filter,
-                                   AVFrame *frame);
-    #elif LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(53,3,0)
-      int av_vsrc_buffer_add_frame(AVFilterContext *buffer_filter,
-                                   AVFrame *frame, int64_t pts);
-    #else
-      int av_vsrc_buffer_add_frame(AVFilterContext *buffer_filter,
-            AVFrame *frame, int64_t pts, AVRational pixel_aspect);
-    #endif
+    #include <ffmpeg/buffersink.h>
+    #include <ffmpeg/avcodec.h>
   #endif
 #else
   #include "libavfilter/avfiltergraph.h"
+  #include "libavfilter/buffersink.h"
+  #include "libavfilter/avcodec.h"
 #endif
 }
 
@@ -86,25 +75,16 @@ public:
   virtual int avfilter_graph_config(AVFilterGraph *graphctx, void *log_ctx)=0;
   virtual int avfilter_poll_frame(AVFilterLink *link)=0;
   virtual int avfilter_request_frame(AVFilterLink *link)=0;
-#if (defined USE_OLD_AV_VSRC_BUFFER_ADD_FRAME)
-  virtual int av_vsrc_buffer_add_frame(AVFilterContext *buffer_filter, AVFrame *frame, int64_t pts, AVRational pixel_aspect)=0;
-#else
-#if LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,13,0)
   virtual int av_vsrc_buffer_add_frame(AVFilterContext *buffer_filter, AVFrame *frame, int flags)=0;
-#elif LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,7,0)
-  virtual int av_vsrc_buffer_add_frame(AVFilterContext *buffer_filter, AVFrame *frame)=0;
-#elif LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(53,3,0)
-  virtual int av_vsrc_buffer_add_frame(AVFilterContext *buffer_filter, AVFrame *frame, int64_t pts)=0;
-#else
-  virtual int av_vsrc_buffer_add_frame(AVFilterContext *buffer_filter, AVFrame *frame, int64_t pts, AVRational pixel_aspect)=0;
-#endif
-#endif
   virtual AVFilterBufferRef *avfilter_get_video_buffer(AVFilterLink *link, int perms, int w, int h)=0;
   virtual void avfilter_unref_buffer(AVFilterBufferRef *ref)=0;
   virtual int avfilter_link(AVFilterContext *src, unsigned srcpad, AVFilterContext *dst, unsigned dstpad)=0;
+  virtual int av_buffersink_get_buffer_ref(AVFilterContext *buffer_sink, AVFilterBufferRef **bufref, int flags)=0;
+  virtual AVBufferSinkParams *av_buffersink_params_alloc()=0;
+  virtual int av_buffersink_poll_frame(AVFilterContext *ctx)=0;
 };
 
-#if (defined USE_EXTERNAL_FFMPEG)
+#if (defined USE_EXTERNAL_FFMPEG) || (defined TARGET_DARWIN)
 // Use direct mapping
 class DllAvFilter : public DllDynamic, DllAvFilterInterface
 {
@@ -123,12 +103,7 @@ public:
   virtual void avfilter_graph_free(AVFilterGraph **graph)
   {
     CSingleLock lock(DllAvCodec::m_critSection);
-#if LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(1,76,0)
     ::avfilter_graph_free(graph);
-#else
-    ::avfilter_graph_free(*graph);
-    *graph = NULL;
-#endif
   }
   void avfilter_register_all()
   {
@@ -141,60 +116,32 @@ public:
   virtual AVFilterInOut *avfilter_inout_alloc()
   {
     CSingleLock lock(DllAvCodec::m_critSection);
-#if LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,17,0)
     return ::avfilter_inout_alloc();
-#else
-    return (AVFilterInOut*)::av_mallocz(sizeof(AVFilterInOut));
-#endif
   }
   virtual void avfilter_inout_free(AVFilterInOut **inout)
   {
     CSingleLock lock(DllAvCodec::m_critSection);
-#if LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,17,0)
     ::avfilter_inout_free(inout);
-#else
-    *inout = NULL;
-#endif
   }
   virtual int avfilter_graph_parse(AVFilterGraph *graph, const char *filters, AVFilterInOut **inputs, AVFilterInOut **outputs, void *log_ctx)
   {
     CSingleLock lock(DllAvCodec::m_critSection);
-#if   (   LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(1,79,0) \
-       && LIBAVFILTER_VERSION_INT <  AV_VERSION_INT(2,0,0) ) \
-    ||(   LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,16,0))
     return ::avfilter_graph_parse(graph, filters, inputs, outputs, log_ctx);
-#elif LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,15,1)
-    return ::avfilter_graph_parse(graph, filters, *inputs, *outputs, log_ctx);
-#else
-    return ::avfilter_graph_parse(graph, filters, *inputs, *outputs, (AVClass*)log_ctx);
-#endif
   }
   virtual int avfilter_graph_config(AVFilterGraph *graphctx, void *log_ctx)
   {
-#if LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,15,1)
+
     return ::avfilter_graph_config(graphctx, log_ctx);
-#else
-    return ::avfilter_graph_config(graphctx, (AVClass*)log_ctx);
-#endif
   }
   virtual int avfilter_poll_frame(AVFilterLink *link) { return ::avfilter_poll_frame(link); }
   virtual int avfilter_request_frame(AVFilterLink *link) { return ::avfilter_request_frame(link); }
-#if (defined USE_OLD_AV_VSRC_BUFFER_ADD_FRAME)
-  virtual int av_vsrc_buffer_add_frame(AVFilterContext *buffer_filter, AVFrame *frame, int64_t pts, AVRational pixel_aspect) { return ::av_vsrc_buffer_add_frame(buffer_filter, frame, pts, pixel_aspect); }
-#else
-#if LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,13,0)
   virtual int av_vsrc_buffer_add_frame(AVFilterContext *buffer_filter, AVFrame *frame, int flags) { return ::av_vsrc_buffer_add_frame(buffer_filter, frame, flags); }
-#elif LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,7,0)
-  virtual int av_vsrc_buffer_add_frame(AVFilterContext *buffer_filter, AVFrame *frame) { return ::av_vsrc_buffer_add_frame(buffer_filter, frame); }
-#elif LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(53,3,0)
-  virtual int av_vsrc_buffer_add_frame(AVFilterContext *buffer_filter, AVFrame *frame, int64_t pts) { return ::av_vsrc_buffer_add_frame(buffer_filter, frame, pts); }
-#else
-  virtual int av_vsrc_buffer_add_frame(AVFilterContext *buffer_filter, AVFrame *frame, int64_t pts, AVRational pixel_aspect) { return ::av_vsrc_buffer_add_frame(buffer_filter, frame, pts, pixel_aspect); }
-#endif
-#endif
   virtual AVFilterBufferRef *avfilter_get_video_buffer(AVFilterLink *link, int perms, int w, int h) { return ::avfilter_get_video_buffer(link, perms, w, h); }
   virtual void avfilter_unref_buffer(AVFilterBufferRef *ref) { ::avfilter_unref_buffer(ref); }
   virtual int avfilter_link(AVFilterContext *src, unsigned srcpad, AVFilterContext *dst, unsigned dstpad) { return ::avfilter_link(src, srcpad, dst, dstpad); }
+  virtual int av_buffersink_get_buffer_ref(AVFilterContext *buffer_sink, AVFilterBufferRef **bufref, int flags) { return ::av_buffersink_get_buffer_ref(buffer_sink, bufref, flags); }
+  virtual AVBufferSinkParams *av_buffersink_params_alloc() { return ::av_buffersink_params_alloc(); }
+  virtual int av_buffersink_poll_frame(AVFilterContext *ctx) { return av_buffersink_poll_frame(ctx); }
   // DLL faking.
   virtual bool ResolveExports() { return true; }
   virtual bool Load() {
@@ -212,45 +159,24 @@ class DllAvFilter : public DllDynamic, DllAvFilterInterface
 
   DEFINE_METHOD3(int, avfilter_open_dont_call, (AVFilterContext **p1, AVFilter *p2, const char *p3))
   DEFINE_METHOD1(void, avfilter_free_dont_call, (AVFilterContext *p1))
-#if LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(1,76,0)
   DEFINE_METHOD1(void, avfilter_graph_free_dont_call, (AVFilterGraph **p1))
-#else
-  DEFINE_METHOD1(void, avfilter_graph_free_dont_call, (AVFilterGraph *p1))
-#endif
   DEFINE_METHOD0(void, avfilter_register_all_dont_call)
   DEFINE_METHOD6(int, avfilter_graph_create_filter, (AVFilterContext **p1, AVFilter *p2, const char *p3, const char *p4, void *p5, AVFilterGraph *p6))
   DEFINE_METHOD1(AVFilter*, avfilter_get_by_name, (const char *p1))
   DEFINE_METHOD0(AVFilterGraph*, avfilter_graph_alloc)
-#if LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,17,0)
   DEFINE_METHOD0(AVFilterInOut*, avfilter_inout_alloc_dont_call)
   DEFINE_METHOD1(void, avfilter_inout_free_dont_call, (AVFilterInOut **p1))
-#endif
-#if LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,16,0)
-  DEFINE_METHOD5(int, avfilter_graph_parse_dont_call, (AVFilterGraph *p1, const char *p2, AVFilterInOut **p3, AVFilterInOut **p4, void *p5))
-#elif LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,15,1)
-  DEFINE_METHOD5(int, avfilter_graph_parse_dont_call, (AVFilterGraph *p1, const char *p2, AVFilterInOut *p3, AVFilterInOut *p4, void *p5))
-#else
-  DEFINE_METHOD5(int, avfilter_graph_parse_dont_call, (AVFilterGraph *p1, const char *p2, AVFilterInOut *p3, AVFilterInOut *p4, AVClass *p5))
-#endif
-#if LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,15,1)
-  DEFINE_METHOD2(int, avfilter_graph_config_dont_call, (AVFilterGraph *p1, void *p2))
-#else
-  DEFINE_METHOD2(int, avfilter_graph_config_dont_call, (AVFilterGraph *p1, AVClass *p2))
-#endif
+  DEFINE_FUNC_ALIGNED5(int, __cdecl, avfilter_graph_parse_dont_call, AVFilterGraph *, const char *, AVFilterInOut **, AVFilterInOut **, void *)
+  DEFINE_FUNC_ALIGNED2(int, __cdecl, avfilter_graph_config_dont_call, AVFilterGraph *, void *)
   DEFINE_FUNC_ALIGNED1(int, __cdecl, avfilter_poll_frame, AVFilterLink *)
   DEFINE_FUNC_ALIGNED1(int, __cdecl, avfilter_request_frame, AVFilterLink*)
-#if LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,13,0)
   DEFINE_METHOD3(int, av_vsrc_buffer_add_frame, (AVFilterContext *p1, AVFrame *p2, int p3))
-#elif LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,7,0)
-  DEFINE_METHOD2(int, av_vsrc_buffer_add_frame, (AVFilterContext *p1, AVFrame *p2))
-#elif LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(53,3,0)
-  DEFINE_METHOD3(int, av_vsrc_buffer_add_frame, (AVFilterContext *p1, AVFrame *p2, int64_t p3))
-#else
-  DEFINE_METHOD4(int, av_vsrc_buffer_add_frame, (AVFilterContext *p1, AVFrame *p2, int64_t p3, AVRational p4))
-#endif
   DEFINE_METHOD4(AVFilterBufferRef*, avfilter_get_video_buffer, (AVFilterLink *p1, int p2, int p3, int p4))
   DEFINE_METHOD1(void, avfilter_unref_buffer, (AVFilterBufferRef *p1))
   DEFINE_METHOD4(int, avfilter_link, (AVFilterContext *p1, unsigned p2, AVFilterContext *p3, unsigned p4))
+  DEFINE_FUNC_ALIGNED3(int                , __cdecl, av_buffersink_get_buffer_ref, AVFilterContext *, AVFilterBufferRef **, int);
+  DEFINE_FUNC_ALIGNED0(AVBufferSinkParams*, __cdecl, av_buffersink_params_alloc);
+  DEFINE_FUNC_ALIGNED1(int                , __cdecl, av_buffersink_poll_frame, AVFilterContext *);
 
   BEGIN_METHOD_RESOLVE()
     RESOLVE_METHOD_RENAME(avfilter_open, avfilter_open_dont_call)
@@ -260,10 +186,8 @@ class DllAvFilter : public DllDynamic, DllAvFilterInterface
     RESOLVE_METHOD(avfilter_graph_create_filter)
     RESOLVE_METHOD(avfilter_get_by_name)
     RESOLVE_METHOD(avfilter_graph_alloc)
-#if LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,17,0)
     RESOLVE_METHOD_RENAME(avfilter_inout_alloc, avfilter_inout_alloc_dont_call)
     RESOLVE_METHOD_RENAME(avfilter_inout_free, avfilter_inout_free_dont_call)
-#endif
     RESOLVE_METHOD_RENAME(avfilter_graph_parse, avfilter_graph_parse_dont_call)
     RESOLVE_METHOD_RENAME(avfilter_graph_config, avfilter_graph_config_dont_call)
     RESOLVE_METHOD(avfilter_poll_frame)
@@ -272,10 +196,14 @@ class DllAvFilter : public DllDynamic, DllAvFilterInterface
     RESOLVE_METHOD(avfilter_get_video_buffer)
     RESOLVE_METHOD(avfilter_unref_buffer)
     RESOLVE_METHOD(avfilter_link)
+    RESOLVE_METHOD(av_buffersink_get_buffer_ref)
+    RESOLVE_METHOD(av_buffersink_params_alloc)
+    RESOLVE_METHOD(av_buffersink_poll_frame)
   END_METHOD_RESOLVE()
 
   /* dependencies of libavfilter */
   DllAvUtil m_dllAvUtil;
+  DllSwResample m_dllSwResample;
 
 public:
   int avfilter_open(AVFilterContext **filter_ctx, AVFilter *filter, const char *inst_name)
@@ -291,12 +219,7 @@ public:
   void avfilter_graph_free(AVFilterGraph **graph)
   {
     CSingleLock lock(DllAvCodec::m_critSection);
-#if LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(1,76,0)
     avfilter_graph_free_dont_call(graph);
-#else
-    avfilter_graph_free_dont_call(*graph);
-    m_dllAvUtil.av_freep(graph);
-#endif
   }
   void avfilter_register_all()
   {
@@ -306,45 +229,29 @@ public:
   AVFilterInOut* avfilter_inout_alloc()
   {
     CSingleLock lock(DllAvCodec::m_critSection);
-#if LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,17,0)
     return avfilter_inout_alloc_dont_call();
-#else
-    return (AVFilterInOut*)m_dllAvUtil.av_mallocz(sizeof(AVFilterInOut));
-#endif
   }
   int avfilter_graph_parse(AVFilterGraph *graph, const char *filters, AVFilterInOut **inputs, AVFilterInOut **outputs, void *log_ctx)
   {
     CSingleLock lock(DllAvCodec::m_critSection);
-#if LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,16,0)
     return avfilter_graph_parse_dont_call(graph, filters, inputs, outputs, log_ctx);
-#elif LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,15,1)
-    return avfilter_graph_parse_dont_call(graph, filters, *inputs, *outputs, log_ctx);
-#else
-    return avfilter_graph_parse_dont_call(graph, filters, *inputs, *outputs, (AVClass*)log_ctx);
-#endif
   }
   void avfilter_inout_free(AVFilterInOut **inout)
   {
     CSingleLock lock(DllAvCodec::m_critSection);
-#if LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,17,0)
     avfilter_inout_free_dont_call(inout);
-#else
-    *inout = NULL;
-#endif
   }
   int avfilter_graph_config(AVFilterGraph *graphctx, void *log_ctx)
   {
     CSingleLock lock(DllAvCodec::m_critSection);
-#if LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,15,1)
     return avfilter_graph_config_dont_call(graphctx, log_ctx);
-#else
-    return avfilter_graph_config_dont_call(graphctx, (AVClass*)log_ctx);
-#endif
   }
   virtual bool Load()
   {
     if (!m_dllAvUtil.Load())
       return false;
+    if (!m_dllSwResample.Load())
+      return false;
     return DllDynamic::Load();
   }
 };
diff --git a/lib/DllAvFormat.h b/lib/DllAvFormat.h
index 46a7481..72b8866 100644
--- a/lib/DllAvFormat.h
+++ b/lib/DllAvFormat.h
@@ -62,57 +62,45 @@ public:
   virtual ~DllAvFormatInterface() {}
   virtual void av_register_all_dont_call(void)=0;
   virtual AVInputFormat *av_find_input_format(const char *short_name)=0;
-  virtual int url_feof(ByteIOContext *s)=0;
-  virtual AVMetadataTag *av_metadata_get(AVMetadata *m, const char *key, const AVMetadataTag *prev, int flags)=0;
-  virtual void av_close_input_file(AVFormatContext *s)=0;
-  virtual void av_close_input_stream(AVFormatContext *s)=0;
+  virtual int url_feof(AVIOContext *s)=0;
+  virtual void avformat_close_input(AVFormatContext **s)=0;
   virtual int av_read_frame(AVFormatContext *s, AVPacket *pkt)=0;
   virtual void av_read_frame_flush(AVFormatContext *s)=0;
   virtual int av_read_play(AVFormatContext *s)=0;
   virtual int av_read_pause(AVFormatContext *s)=0;
   virtual int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)=0;
-#if (!defined USE_EXTERNAL_FFMPEG)
-  virtual int av_find_stream_info_dont_call(AVFormatContext *ic)=0;
+#if (!defined USE_EXTERNAL_FFMPEG) && (!defined TARGET_DARWIN)
+  virtual int avformat_find_stream_info_dont_call(AVFormatContext *ic, AVDictionary **options)=0;
 #endif
-  virtual int av_open_input_file(AVFormatContext **ic_ptr, const char *filename, AVInputFormat *fmt, int buf_size, AVFormatParameters *ap)=0;
-  virtual void url_set_interrupt_cb(URLInterruptCB *interrupt_cb)=0;
-  virtual int av_open_input_stream(AVFormatContext **ic_ptr, ByteIOContext *pb, const char *filename, AVInputFormat *fmt, AVFormatParameters *ap)=0;
-  virtual int init_put_byte(ByteIOContext *s, unsigned char *buffer, int buffer_size, int write_flag, void *opaque, 
+  virtual int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputFormat *fmt, AVDictionary **options)=0;
+  virtual AVIOContext *avio_alloc_context(unsigned char *buffer, int buffer_size, int write_flag, void *opaque,
                             int (*read_packet)(void *opaque, uint8_t *buf, int buf_size),
                             int (*write_packet)(void *opaque, uint8_t *buf, int buf_size),
                             offset_t (*seek)(void *opaque, offset_t offset, int whence))=0;
   virtual AVInputFormat *av_probe_input_format(AVProbeData *pd, int is_opened)=0;
   virtual AVInputFormat *av_probe_input_format2(AVProbeData *pd, int is_opened, int *score_max)=0;
-  virtual int av_probe_input_buffer(ByteIOContext *pb, AVInputFormat **fmt, const char *filename, void *logctx, unsigned int offset, unsigned int max_probe_size)=0;
-  virtual void dump_format(AVFormatContext *ic, int index, const char *url, int is_output)=0;
-  virtual int url_fdopen(ByteIOContext **s, URLContext *h)=0;
-  virtual int url_fopen(ByteIOContext **s, const char *filename, int flags)=0;
-  virtual int url_fclose(ByteIOContext *s)=0;
-  virtual int url_open_dyn_buf(ByteIOContext **s)=0;
-  virtual int url_close_dyn_buf(ByteIOContext *s, uint8_t **pbuffer)=0;
-  virtual offset_t url_fseek(ByteIOContext *s, offset_t offset, int whence)=0;
-  virtual int get_buffer(ByteIOContext *s, unsigned char *buf, int size)=0;
-  virtual int get_partial_buffer(ByteIOContext *s, unsigned char *buf, int size)=0;
-  virtual void put_byte(ByteIOContext *s, int b)=0;
-  virtual void put_buffer(ByteIOContext *s, const unsigned char *buf, int size)=0;
-  virtual void put_be24(ByteIOContext *s, unsigned int val)=0;
-  virtual void put_be32(ByteIOContext *s, unsigned int val)=0;
-  virtual void put_be16(ByteIOContext *s, unsigned int val)=0;
+  virtual int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt, const char *filename, void *logctx, unsigned int offset, unsigned int max_probe_size)=0;
+  virtual void av_dump_format(AVFormatContext *ic, int index, const char *url, int is_output)=0;
+  virtual int avio_open(AVIOContext **s, const char *filename, int flags)=0;
+  virtual int avio_close(AVIOContext *s)=0;
+  virtual int avio_open_dyn_buf(AVIOContext **s)=0;
+  virtual int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)=0;
+  virtual offset_t avio_seek(AVIOContext *s, offset_t offset, int whence)=0;
+  virtual int avio_read(AVIOContext *s, unsigned char *buf, int size)=0;
+  virtual void avio_w8(AVIOContext *s, int b)=0;
+  virtual void avio_write(AVIOContext *s, const unsigned char *buf, int size)=0;
+  virtual void avio_wb24(AVIOContext *s, unsigned int val)=0;
+  virtual void avio_wb32(AVIOContext *s, unsigned int val)=0;
+  virtual void avio_wb16(AVIOContext *s, unsigned int val)=0;
   virtual AVFormatContext *avformat_alloc_context(void)=0;
-  virtual AVStream *av_new_stream(AVFormatContext *s, int id)=0;
+  virtual AVStream *avformat_new_stream(AVFormatContext *s, AVCodec *c)=0;
   virtual AVOutputFormat *av_guess_format(const char *short_name, const char *filename, const char *mime_type)=0;
-  virtual int av_set_parameters(AVFormatContext *s, AVFormatParameters *ap)=0;
-  virtual ByteIOContext *av_alloc_put_byte(unsigned char *buffer, int buffer_size, int write_flag, void *opaque,
-                                           int (*read_packet)(void *opaque, uint8_t *buf, int buf_size),
-                                           int (*write_packet)(void *opaque, uint8_t *buf, int buf_size),
-                                           offset_t (*seek)(void *opaque, offset_t offset, int whence))=0;
-  virtual int av_write_header (AVFormatContext *s)=0;
+  virtual int avformat_write_header (AVFormatContext *s, AVDictionary **options)=0;
   virtual int av_write_trailer(AVFormatContext *s)=0;
   virtual int av_write_frame  (AVFormatContext *s, AVPacket *pkt)=0;
-  virtual int av_metadata_set2(AVMetadata **pm, const char *key, const char *value, int flags)=0;
 };
 
-#if (defined USE_EXTERNAL_FFMPEG)
+#if (defined USE_EXTERNAL_FFMPEG) || (defined TARGET_DARWIN) 
 
 // Use direct mapping
 class DllAvFormat : public DllDynamic, DllAvFormatInterface
@@ -126,78 +114,45 @@ public:
   } 
   virtual void av_register_all_dont_call() { *(int* )0x0 = 0; } 
   virtual AVInputFormat *av_find_input_format(const char *short_name) { return ::av_find_input_format(short_name); }
-  virtual int url_feof(ByteIOContext *s) { return ::url_feof(s); }
-#if LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(52,31,0)
-  // API added on: 2009-03-01
-  virtual AVMetadataTag *av_metadata_get(AVMetadata *m, const char *key, const AVMetadataTag *prev, int flags){ return ::av_metadata_get(m, key, prev, flags); }
-#else
-  virtual AVMetadataTag *av_metadata_get(AVMetadata *m, const char *key, const AVMetadataTag *prev, int flags){ return NULL; }
-#endif
-  virtual void av_close_input_file(AVFormatContext *s) { ::av_close_input_file(s); }
-  virtual void av_close_input_stream(AVFormatContext *s) { ::av_close_input_stream(s); }
+  virtual int url_feof(AVIOContext *s) { return ::url_feof(s); }
+  virtual void avformat_close_input(AVFormatContext **s) { ::avformat_close_input(s); }
   virtual int av_read_frame(AVFormatContext *s, AVPacket *pkt) { return ::av_read_frame(s, pkt); }
   virtual void av_read_frame_flush(AVFormatContext *s) { ::av_read_frame_flush(s); }
   virtual int av_read_play(AVFormatContext *s) { return ::av_read_play(s); }
   virtual int av_read_pause(AVFormatContext *s) { return ::av_read_pause(s); }
   virtual int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags) { return ::av_seek_frame(s, stream_index, timestamp, flags); }
-  virtual int av_find_stream_info(AVFormatContext *ic)
+  virtual int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
   {
     CSingleLock lock(DllAvCodec::m_critSection);
-    return ::av_find_stream_info(ic);
+    return ::avformat_find_stream_info(ic, options);
   }
-  virtual int av_open_input_file(AVFormatContext **ic_ptr, const char *filename, AVInputFormat *fmt, int buf_size, AVFormatParameters *ap) { return ::av_open_input_file(ic_ptr, filename, fmt, buf_size, ap); }
-  virtual void url_set_interrupt_cb(URLInterruptCB *interrupt_cb) { ::url_set_interrupt_cb(interrupt_cb); }
-  virtual int av_open_input_stream(AVFormatContext **ic_ptr, ByteIOContext *pb, const char *filename, AVInputFormat *fmt, AVFormatParameters *ap) { return ::av_open_input_stream(ic_ptr, pb, filename, fmt, ap); }
-  virtual int init_put_byte(ByteIOContext *s, unsigned char *buffer, int buffer_size, int write_flag, void *opaque, 
+  virtual int avformat_open_input(AVFormatContext **ps, const char *filename, AVInputFormat *fmt, AVDictionary **options)
+  { return ::avformat_open_input(ps, filename, fmt, options); }
+  virtual AVIOContext *avio_alloc_context(unsigned char *buffer, int buffer_size, int write_flag, void *opaque,
                             int (*read_packet)(void *opaque, uint8_t *buf, int buf_size),
                             int (*write_packet)(void *opaque, uint8_t *buf, int buf_size),
-                            offset_t (*seek)(void *opaque, offset_t offset, int whence)) { return ::init_put_byte(s, buffer, buffer_size, write_flag, opaque, read_packet, write_packet, seek); }
+                            offset_t (*seek)(void *opaque, offset_t offset, int whence)) { return ::avio_alloc_context(buffer, buffer_size, write_flag, opaque, read_packet, write_packet, seek); }
   virtual AVInputFormat *av_probe_input_format(AVProbeData *pd, int is_opened) {return ::av_probe_input_format(pd, is_opened); }
   virtual AVInputFormat *av_probe_input_format2(AVProbeData *pd, int is_opened, int *score_max) {*score_max = 100; return ::av_probe_input_format(pd, is_opened); } // Use av_probe_input_format, this is not exported by ffmpeg's headers
-#if LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(52,98,0)
-  // API added on: 2010-02-08
-  virtual int av_probe_input_buffer(ByteIOContext *pb, AVInputFormat **fmt, const char *filename, void *logctx, unsigned int offset, unsigned int max_probe_size) { return ::av_probe_input_buffer(pb, fmt, filename, logctx, offset, max_probe_size); }
-#else
-  virtual int av_probe_input_buffer(ByteIOContext *pb, AVInputFormat **fmt, const char *filename, void *logctx, unsigned int offset, unsigned int max_probe_size) { return -1; }
-#endif
-  virtual void dump_format(AVFormatContext *ic, int index, const char *url, int is_output) { ::dump_format(ic, index, url, is_output); }
-  virtual int url_fdopen(ByteIOContext **s, URLContext *h) { return ::url_fdopen(s, h); }
-  virtual int url_fopen(ByteIOContext **s, const char *filename, int flags) { return ::url_fopen(s, filename, flags); }
-  virtual int url_fclose(ByteIOContext *s) { return ::url_fclose(s); }
-  virtual int url_open_dyn_buf(ByteIOContext **s) { return ::url_open_dyn_buf(s); }
-  virtual int url_close_dyn_buf(ByteIOContext *s, uint8_t **pbuffer) { return ::url_close_dyn_buf(s, pbuffer); }
-  virtual offset_t url_fseek(ByteIOContext *s, offset_t offset, int whence) { return ::url_fseek(s, offset, whence); }
-  virtual int get_buffer(ByteIOContext *s, unsigned char *buf, int size) { return ::get_buffer(s, buf, size); }
-  virtual int get_partial_buffer(ByteIOContext *s, unsigned char *buf, int size) { return ::get_partial_buffer(s, buf, size); }
-  virtual void put_byte(ByteIOContext *s, int b) { ::put_byte(s, b); }
-  virtual void put_buffer(ByteIOContext *s, const unsigned char *buf, int size) { ::put_buffer(s, buf, size); }
-  virtual void put_be24(ByteIOContext *s, unsigned int val) { ::put_be24(s, val); }
-  virtual void put_be32(ByteIOContext *s, unsigned int val) { ::put_be32(s, val); }
-  virtual void put_be16(ByteIOContext *s, unsigned int val) { ::put_be16(s, val); }
+  virtual int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt, const char *filename, void *logctx, unsigned int offset, unsigned int max_probe_size) { return ::av_probe_input_buffer(pb, fmt, filename, logctx, offset, max_probe_size); }
+  virtual void av_dump_format(AVFormatContext *ic, int index, const char *url, int is_output) { ::av_dump_format(ic, index, url, is_output); }
+  virtual int avio_open(AVIOContext **s, const char *filename, int flags) { return ::avio_open(s, filename, flags); }
+  virtual int avio_close(AVIOContext *s) { return ::avio_close(s); }
+  virtual int avio_open_dyn_buf(AVIOContext **s) { return ::avio_open_dyn_buf(s); }
+  virtual int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer) { return ::avio_close_dyn_buf(s, pbuffer); }
+  virtual offset_t avio_seek(AVIOContext *s, offset_t offset, int whence) { return ::avio_seek(s, offset, whence); }
+  virtual int avio_read(AVIOContext *s, unsigned char *buf, int size) { return ::avio_read(s, buf, size); }
+  virtual void avio_w8(AVIOContext *s, int b) { ::avio_w8(s, b); }
+  virtual void avio_write(AVIOContext *s, const unsigned char *buf, int size) { ::avio_write(s, buf, size); }
+  virtual void avio_wb24(AVIOContext *s, unsigned int val) { ::avio_wb24(s, val); }
+  virtual void avio_wb32(AVIOContext *s, unsigned int val) { ::avio_wb32(s, val); }
+  virtual void avio_wb16(AVIOContext *s, unsigned int val) { ::avio_wb16(s, val); }
   virtual AVFormatContext *avformat_alloc_context() { return ::avformat_alloc_context(); }
-  virtual AVStream *av_new_stream(AVFormatContext *s, int id) { return ::av_new_stream(s, id); }
-#if LIBAVFORMAT_VERSION_INT < (52<<16 | 45<<8)
-  virtual AVOutputFormat *av_guess_format(const char *short_name, const char *filename, const char *mime_type) { return ::guess_format(short_name, filename, mime_type); }
-#else
+  virtual AVStream *avformat_new_stream(AVFormatContext *s, AVCodec *c) { return ::avformat_new_stream(s, c); }
   virtual AVOutputFormat *av_guess_format(const char *short_name, const char *filename, const char *mime_type) { return ::av_guess_format(short_name, filename, mime_type); }
-#endif
-  virtual int av_set_parameters(AVFormatContext *s, AVFormatParameters *ap) { return ::av_set_parameters(s, ap); }
-  virtual ByteIOContext *av_alloc_put_byte(unsigned char *buffer, int buffer_size, int write_flag, void *opaque,
-                                           int (*read_packet)(void *opaque, uint8_t *buf, int buf_size),
-                                           int (*write_packet)(void *opaque, uint8_t *buf, int buf_size),
-                                           offset_t (*seek)(void *opaque, offset_t offset, int whence)) { return ::av_alloc_put_byte(buffer, buffer_size, write_flag, opaque, read_packet, write_packet, seek); }
-  virtual int av_write_header (AVFormatContext *s) { return ::av_write_header (s); }
+  virtual int avformat_write_header (AVFormatContext *s, AVDictionary **options) { return ::avformat_write_header (s, options); }
   virtual int av_write_trailer(AVFormatContext *s) { return ::av_write_trailer(s); }
   virtual int av_write_frame  (AVFormatContext *s, AVPacket *pkt) { return ::av_write_frame(s, pkt); }
-#if LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(52,43,0)
-  // API added on: 2009-12-13
-  virtual int av_metadata_set2(AVMetadata **pm, const char *key, const char *value, int flags) { return ::av_metadata_set2(pm, key, value, flags); }
-#elif LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(52,31,0)
-  // API added on: 2009-03-01
-  virtual int av_metadata_set2(AVMetadata **pm, const char *key, const char *value, int flags) { return ::av_metadata_set(pm, key, value); }
-#else
-  virtual int av_metadata_set2(AVMetadata **pm, const char *key, const char *value, int flags) { return -1; }
-#endif
 
   // DLL faking.
   virtual bool ResolveExports() { return true; }
@@ -218,108 +173,78 @@ class DllAvFormat : public DllDynamic, DllAvFormatInterface
 
   DEFINE_METHOD0(void, av_register_all_dont_call)
   DEFINE_METHOD1(AVInputFormat*, av_find_input_format, (const char *p1))
-  DEFINE_METHOD1(int, url_feof, (ByteIOContext *p1))
-  DEFINE_METHOD4(AVMetadataTag*, av_metadata_get, (AVMetadata *p1, const char *p2, const AVMetadataTag *p3, int p4))
-  DEFINE_METHOD1(void, av_close_input_file, (AVFormatContext *p1))
-  DEFINE_METHOD1(void, av_close_input_stream, (AVFormatContext *p1))
+  DEFINE_METHOD1(int, url_feof, (AVIOContext *p1))
+  DEFINE_METHOD1(void, avformat_close_input, (AVFormatContext **p1))
   DEFINE_METHOD1(int, av_read_play, (AVFormatContext *p1))
   DEFINE_METHOD1(int, av_read_pause, (AVFormatContext *p1))
   DEFINE_METHOD1(void, av_read_frame_flush, (AVFormatContext *p1))
   DEFINE_FUNC_ALIGNED2(int, __cdecl, av_read_frame, AVFormatContext *, AVPacket *)
   DEFINE_FUNC_ALIGNED4(int, __cdecl, av_seek_frame, AVFormatContext*, int, int64_t, int)
-  DEFINE_FUNC_ALIGNED1(int, __cdecl, av_find_stream_info_dont_call, AVFormatContext*)
-  DEFINE_FUNC_ALIGNED5(int, __cdecl, av_open_input_file, AVFormatContext**, const char *, AVInputFormat *, int, AVFormatParameters *)
-  DEFINE_FUNC_ALIGNED5(int,__cdecl, av_open_input_stream, AVFormatContext **, ByteIOContext *, const char *, AVInputFormat *, AVFormatParameters *)
+  DEFINE_FUNC_ALIGNED2(int, __cdecl, avformat_find_stream_info_dont_call, AVFormatContext*, AVDictionary **)
+  DEFINE_FUNC_ALIGNED4(int, __cdecl, avformat_open_input, AVFormatContext **, const char *, AVInputFormat *, AVDictionary **)
   DEFINE_FUNC_ALIGNED2(AVInputFormat*, __cdecl, av_probe_input_format, AVProbeData*, int)
   DEFINE_FUNC_ALIGNED3(AVInputFormat*, __cdecl, av_probe_input_format2, AVProbeData*, int, int*)
-  DEFINE_FUNC_ALIGNED6(int, __cdecl, av_probe_input_buffer, ByteIOContext *, AVInputFormat **, const char *, void *, unsigned int, unsigned int)
-  DEFINE_FUNC_ALIGNED3(int, __cdecl, get_buffer, ByteIOContext*, unsigned char *, int)
-  DEFINE_FUNC_ALIGNED3(int, __cdecl, get_partial_buffer, ByteIOContext*, unsigned char *, int)
-  DEFINE_FUNC_ALIGNED2(void, __cdecl, put_byte, ByteIOContext*, int)
-  DEFINE_FUNC_ALIGNED3(void, __cdecl, put_buffer, ByteIOContext*, const unsigned char *, int)
-  DEFINE_FUNC_ALIGNED2(void, __cdecl, put_be24, ByteIOContext*, unsigned int)
-  DEFINE_FUNC_ALIGNED2(void, __cdecl, put_be32, ByteIOContext*, unsigned int)
-  DEFINE_FUNC_ALIGNED2(void, __cdecl, put_be16, ByteIOContext*, unsigned int)
-  DEFINE_METHOD1(void, url_set_interrupt_cb, (URLInterruptCB *p1))
-  DEFINE_METHOD8(int, init_put_byte, (ByteIOContext *p1, unsigned char *p2, int p3, int p4, void *p5, 
+  DEFINE_FUNC_ALIGNED6(int, __cdecl, av_probe_input_buffer, AVIOContext *, AVInputFormat **, const char *, void *, unsigned int, unsigned int)
+  DEFINE_FUNC_ALIGNED3(int, __cdecl, avio_read, AVIOContext*, unsigned char *, int)
+  DEFINE_FUNC_ALIGNED2(void, __cdecl, avio_w8, AVIOContext*, int)
+  DEFINE_FUNC_ALIGNED3(void, __cdecl, avio_write, AVIOContext*, const unsigned char *, int)
+  DEFINE_FUNC_ALIGNED2(void, __cdecl, avio_wb24, AVIOContext*, unsigned int)
+  DEFINE_FUNC_ALIGNED2(void, __cdecl, avio_wb32, AVIOContext*, unsigned int)
+  DEFINE_FUNC_ALIGNED2(void, __cdecl, avio_wb16, AVIOContext*, unsigned int)
+  DEFINE_METHOD7(AVIOContext *, avio_alloc_context, (unsigned char *p1, int p2, int p3, void *p4,
+                  int (*p5)(void *opaque, uint8_t *buf, int buf_size),
                   int (*p6)(void *opaque, uint8_t *buf, int buf_size),
-                  int (*p7)(void *opaque, uint8_t *buf, int buf_size),
-                  offset_t (*p8)(void *opaque, offset_t offset, int whence)))
-  DEFINE_METHOD4(void, dump_format, (AVFormatContext *p1, int p2, const char *p3, int p4))
-  DEFINE_METHOD2(int, url_fdopen, (ByteIOContext **p1, URLContext *p2))
-  DEFINE_METHOD3(int, url_fopen, (ByteIOContext **p1, const char *p2, int p3))
-  DEFINE_METHOD1(int, url_fclose, (ByteIOContext *p1))
-  DEFINE_METHOD1(int, url_open_dyn_buf, (ByteIOContext **p1))
-  DEFINE_METHOD2(int, url_close_dyn_buf, (ByteIOContext *p1, uint8_t **p2))
-  DEFINE_METHOD3(offset_t, url_fseek, (ByteIOContext *p1, offset_t p2, int p3))
+                  offset_t (*p7)(void *opaque, offset_t offset, int whence)))
+  DEFINE_METHOD4(void, av_dump_format, (AVFormatContext *p1, int p2, const char *p3, int p4))
+  DEFINE_METHOD3(int, avio_open, (AVIOContext **p1, const char *p2, int p3))
+  DEFINE_METHOD1(int, avio_close, (AVIOContext *p1))
+  DEFINE_METHOD1(int, avio_open_dyn_buf, (AVIOContext **p1))
+  DEFINE_METHOD2(int, avio_close_dyn_buf, (AVIOContext *p1, uint8_t **p2))
+  DEFINE_METHOD3(offset_t, avio_seek, (AVIOContext *p1, offset_t p2, int p3))
   DEFINE_METHOD0(AVFormatContext *, avformat_alloc_context)
-  DEFINE_METHOD2(AVStream *, av_new_stream, (AVFormatContext *p1, int p2))
-#if LIBAVFORMAT_VERSION_INT < (52<<16 | 45<<8)
-  DEFINE_METHOD3(AVOutputFormat *, guess_format, (const char *p1, const char *p2, const char *p3))
-#else
+  DEFINE_METHOD2(AVStream *, avformat_new_stream, (AVFormatContext *p1, AVCodec *p2))
   DEFINE_METHOD3(AVOutputFormat *, av_guess_format, (const char *p1, const char *p2, const char *p3))
-#endif
-  DEFINE_METHOD2(int, av_set_parameters, (AVFormatContext *p1, AVFormatParameters *p2));
-  DEFINE_METHOD7(ByteIOContext *, av_alloc_put_byte, (unsigned char *p1, int p2, int p3, void *p4,
-                  int(*p5)(void *opaque, uint8_t *buf, int buf_size),
-                  int(*p6)(void *opaque, uint8_t *buf, int buf_size),
-                  offset_t(*p7)(void *opaque, offset_t offset, int whence)))
-  DEFINE_METHOD1(int, av_write_header , (AVFormatContext *p1))
+  DEFINE_METHOD2(int, avformat_write_header , (AVFormatContext *p1, AVDictionary **p2))
   DEFINE_METHOD1(int, av_write_trailer, (AVFormatContext *p1))
   DEFINE_METHOD2(int, av_write_frame  , (AVFormatContext *p1, AVPacket *p2))
-  DEFINE_METHOD4(int, av_metadata_set2, (AVMetadata **p1, const char *p2, const char *p3, int p4));
   BEGIN_METHOD_RESOLVE()
     RESOLVE_METHOD_RENAME(av_register_all, av_register_all_dont_call)
     RESOLVE_METHOD(av_find_input_format)
     RESOLVE_METHOD(url_feof)
-    RESOLVE_METHOD(av_metadata_get)
-    RESOLVE_METHOD(av_close_input_file)
-    RESOLVE_METHOD(av_close_input_stream)
+    RESOLVE_METHOD(avformat_close_input)
     RESOLVE_METHOD(av_read_frame)
     RESOLVE_METHOD(av_read_play)
     RESOLVE_METHOD(av_read_pause)
-    RESOLVE_METHOD_RENAME(ff_read_frame_flush, av_read_frame_flush)
+    RESOLVE_METHOD(av_read_frame_flush)
     RESOLVE_METHOD(av_seek_frame)
-    RESOLVE_METHOD_RENAME(av_find_stream_info, av_find_stream_info_dont_call)
-    RESOLVE_METHOD(av_open_input_file)
-    RESOLVE_METHOD(url_set_interrupt_cb)
-    RESOLVE_METHOD(av_open_input_stream)
-    RESOLVE_METHOD(init_put_byte)
+    RESOLVE_METHOD_RENAME(avformat_find_stream_info, avformat_find_stream_info_dont_call)
+    RESOLVE_METHOD(avformat_open_input)
+    RESOLVE_METHOD(avio_alloc_context)
     RESOLVE_METHOD(av_probe_input_format)
     RESOLVE_METHOD(av_probe_input_format2)
     RESOLVE_METHOD(av_probe_input_buffer)
-    RESOLVE_METHOD(dump_format)
-    RESOLVE_METHOD(url_fdopen)
-    RESOLVE_METHOD(url_fopen)
-    RESOLVE_METHOD(url_fclose)
-    RESOLVE_METHOD(url_open_dyn_buf)
-    RESOLVE_METHOD(url_close_dyn_buf)
-    RESOLVE_METHOD(url_fseek)
-    RESOLVE_METHOD(get_buffer)
-    RESOLVE_METHOD(get_partial_buffer)
-    RESOLVE_METHOD(put_byte)
-    RESOLVE_METHOD(put_buffer)
-    RESOLVE_METHOD(put_be24)
-    RESOLVE_METHOD(put_be32)
-    RESOLVE_METHOD(put_be16)
+    RESOLVE_METHOD(av_dump_format)
+    RESOLVE_METHOD(avio_open)
+    RESOLVE_METHOD(avio_close)
+    RESOLVE_METHOD(avio_open_dyn_buf)
+    RESOLVE_METHOD(avio_close_dyn_buf)
+    RESOLVE_METHOD(avio_seek)
+    RESOLVE_METHOD(avio_read)
+    RESOLVE_METHOD(avio_w8)
+    RESOLVE_METHOD(avio_write)
+    RESOLVE_METHOD(avio_wb24)
+    RESOLVE_METHOD(avio_wb32)
+    RESOLVE_METHOD(avio_wb16)
     RESOLVE_METHOD(avformat_alloc_context)
-    RESOLVE_METHOD(av_new_stream)
-#if LIBAVFORMAT_VERSION_INT < (52<<16 | 45<<8)
-    RESOLVE_METHOD(guess_format)
-#else
+    RESOLVE_METHOD(avformat_new_stream)
     RESOLVE_METHOD(av_guess_format)
-#endif
-    RESOLVE_METHOD(av_set_parameters)
-    RESOLVE_METHOD(av_alloc_put_byte)
-    RESOLVE_METHOD(av_write_header)
+    RESOLVE_METHOD(avformat_write_header)
     RESOLVE_METHOD(av_write_trailer)
     RESOLVE_METHOD(av_write_frame)
-    RESOLVE_METHOD(av_metadata_set2)
   END_METHOD_RESOLVE()
 
   /* dependencies of libavformat */
   DllAvCodec m_dllAvCodec;
-  // DllAvCore loaded implicitely by m_dllAvCodec
   // DllAvUtil loaded implicitely by m_dllAvCodec
 
 public:
@@ -328,10 +253,10 @@ public:
     CSingleLock lock(DllAvCodec::m_critSection);
     av_register_all_dont_call();
   }
-  int av_find_stream_info(AVFormatContext *ic)
+  int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
   {
     CSingleLock lock(DllAvCodec::m_critSection);
-    return(av_find_stream_info_dont_call(ic));
+    return avformat_find_stream_info_dont_call(ic, options);
   }
 
   virtual bool Load()
diff --git a/lib/DllAvUtil.h b/lib/DllAvUtil.h
index b8bb2d6..2331777 100644
--- a/lib/DllAvUtil.h
+++ b/lib/DllAvUtil.h
@@ -69,6 +69,7 @@ extern "C" {
   #include "libavutil/opt.h"
   #include "libavutil/mem.h"
   #include "libavutil/fifo.h"
+  #include "libavutil/samplefmt.h"
 #endif
 }
 
@@ -93,7 +94,7 @@ public:
   virtual int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq)=0;
   virtual const AVCRC* av_crc_get_table(AVCRCId crc_id)=0;
   virtual uint32_t av_crc(const AVCRC *ctx, uint32_t crc, const uint8_t *buffer, size_t length)=0;
-  virtual int av_set_string3(void *obj, const char *name, const char *val, int alloc, const AVOption **o_out)=0;
+  virtual int av_opt_set(void *obj, const char *name, const char *val, int search_flags)=0;
   virtual AVFifoBuffer *av_fifo_alloc(unsigned int size) = 0;
   virtual void av_fifo_free(AVFifoBuffer *f) = 0;
   virtual void av_fifo_reset(AVFifoBuffer *f) = 0;
@@ -101,10 +102,13 @@ public:
   virtual int av_fifo_generic_read(AVFifoBuffer *f, void *dest, int buf_size, void (*func)(void*, void*, int)) = 0;
   virtual int av_fifo_generic_write(AVFifoBuffer *f, void *src, int size, int (*func)(void*, void*, int)) = 0;
   virtual char *av_strdup(const char *s)=0;
+  virtual int av_get_bytes_per_sample(enum AVSampleFormat p1) = 0;
+  virtual AVDictionaryEntry *av_dict_get(AVDictionary *m, const char *key, const AVDictionaryEntry *prev, int flags) = 0;
+  virtual int av_dict_set(AVDictionary **pm, const char *key, const char *value, int flags)=0;
+  virtual int av_samples_get_buffer_size (int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align) = 0;
 };
 
-#if (defined USE_EXTERNAL_FFMPEG)
-
+#if defined (USE_EXTERNAL_FFMPEG) || (defined TARGET_DARWIN)
 // Use direct layer
 class DllAvUtilBase : public DllDynamic, DllAvUtilInterface
 {
@@ -121,12 +125,7 @@ public:
    virtual int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq) { return ::av_rescale_q(a, bq, cq); }
    virtual const AVCRC* av_crc_get_table(AVCRCId crc_id) { return ::av_crc_get_table(crc_id); }
    virtual uint32_t av_crc(const AVCRC *ctx, uint32_t crc, const uint8_t *buffer, size_t length) { return ::av_crc(ctx, crc, buffer, length); }
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52,7,0)
-   // API added on: 2008-12-16
-   virtual int av_set_string3(void *obj, const char *name, const char *val, int alloc, const AVOption **o_out) { return ::av_set_string3(obj, name, val, alloc, o_out); }
-#else
-   virtual int av_set_string3(void *obj, const char *name, const char *val, int alloc, const AVOption **o_out) { return AVERROR(ENOENT); }
-#endif
+   virtual int av_opt_set(void *obj, const char *name, const char *val, int search_flags) { return ::av_opt_set(obj, name, val, search_flags); }
   virtual AVFifoBuffer *av_fifo_alloc(unsigned int size) {return ::av_fifo_alloc(size); }
   virtual void av_fifo_free(AVFifoBuffer *f) { ::av_fifo_free(f); }
   virtual void av_fifo_reset(AVFifoBuffer *f) { ::av_fifo_reset(f); }
@@ -136,6 +135,12 @@ public:
   virtual int av_fifo_generic_write(AVFifoBuffer *f, void *src, int size, int (*func)(void*, void*, int))
     { return ::av_fifo_generic_write(f, src, size, func); }
   virtual char *av_strdup(const char *s) { return ::av_strdup(s); }
+  virtual int av_get_bytes_per_sample(enum AVSampleFormat p1)
+    { return ::av_get_bytes_per_sample(p1); }
+  virtual AVDictionaryEntry *av_dict_get(AVDictionary *m, const char *key, const AVDictionaryEntry *prev, int flags){ return ::av_dict_get(m, key, prev, flags); }
+  virtual int av_dict_set(AVDictionary **pm, const char *key, const char *value, int flags) { return ::av_dict_set(pm, key, value, flags); }
+  virtual int av_samples_get_buffer_size (int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
+    { return ::av_samples_get_buffer_size(linesize, nb_channels, nb_samples, sample_fmt, align); }
 
    // DLL faking.
    virtual bool ResolveExports() { return true; }
@@ -164,7 +169,7 @@ class DllAvUtilBase : public DllDynamic, DllAvUtilInterface
   DEFINE_METHOD3(int64_t, av_rescale_q, (int64_t p1, AVRational p2, AVRational p3));
   DEFINE_METHOD1(const AVCRC*, av_crc_get_table, (AVCRCId p1))
   DEFINE_METHOD4(uint32_t, av_crc, (const AVCRC *p1, uint32_t p2, const uint8_t *p3, size_t p4));
-  DEFINE_METHOD5(int, av_set_string3, (void *p1, const char *p2, const char *p3, int p4, const AVOption **p5));
+  DEFINE_METHOD4(int, av_opt_set, (void *p1, const char *p2, const char *p3, int p4));
   DEFINE_METHOD1(AVFifoBuffer*, av_fifo_alloc, (unsigned int p1))
   DEFINE_METHOD1(void, av_fifo_free, (AVFifoBuffer *p1))
   DEFINE_METHOD1(void, av_fifo_reset, (AVFifoBuffer *p1))
@@ -172,6 +177,10 @@ class DllAvUtilBase : public DllDynamic, DllAvUtilInterface
   DEFINE_METHOD4(int, av_fifo_generic_read, (AVFifoBuffer *p1, void *p2, int p3, void (*p4)(void*, void*, int)))
   DEFINE_METHOD4(int, av_fifo_generic_write, (AVFifoBuffer *p1, void *p2, int p3, int (*p4)(void*, void*, int)))
   DEFINE_METHOD1(char*, av_strdup, (const char *p1))
+  DEFINE_METHOD1(int, av_get_bytes_per_sample, (enum AVSampleFormat p1))
+  DEFINE_METHOD4(AVDictionaryEntry *, av_dict_get, (AVDictionary *p1, const char *p2, const AVDictionaryEntry *p3, int p4))
+  DEFINE_METHOD4(int, av_dict_set, (AVDictionary **p1, const char *p2, const char *p3, int p4));
+  DEFINE_METHOD5(int, av_samples_get_buffer_size, (int *p1, int p2, int p3, enum AVSampleFormat p4, int p5))
 
   public:
   BEGIN_METHOD_RESOLVE()
@@ -185,7 +194,7 @@ class DllAvUtilBase : public DllDynamic, DllAvUtilInterface
     RESOLVE_METHOD(av_rescale_q)
     RESOLVE_METHOD(av_crc_get_table)
     RESOLVE_METHOD(av_crc)
-    RESOLVE_METHOD(av_set_string3)
+    RESOLVE_METHOD(av_opt_set)
     RESOLVE_METHOD(av_fifo_alloc)
     RESOLVE_METHOD(av_fifo_free)
     RESOLVE_METHOD(av_fifo_reset)
@@ -193,6 +202,10 @@ class DllAvUtilBase : public DllDynamic, DllAvUtilInterface
     RESOLVE_METHOD(av_fifo_generic_read)
     RESOLVE_METHOD(av_fifo_generic_write)
     RESOLVE_METHOD(av_strdup)
+    RESOLVE_METHOD(av_get_bytes_per_sample)
+    RESOLVE_METHOD(av_dict_get)
+    RESOLVE_METHOD(av_dict_set)
+    RESOLVE_METHOD(av_samples_get_buffer_size)
   END_METHOD_RESOLVE()
 };
 
diff --git a/lib/DllPostProc.h b/lib/DllPostProc.h
index b09a3f6..5465601 100644
--- a/lib/DllPostProc.h
+++ b/lib/DllPostProc.h
@@ -87,7 +87,7 @@ public:
   virtual void pp_free_context(pp_context *ppContext)=0;
 };
 
-#if (defined USE_EXTERNAL_FFMPEG)
+#if (defined USE_EXTERNAL_FFMPEG) || (defined TARGET_DARWIN) 
 
 // We call directly.
 class DllPostProc : public DllDynamic, DllPostProcInterface
diff --git a/lib/DllSwResample.h b/lib/DllSwResample.h
new file mode 100644
index 0000000..8a99072
--- /dev/null
+++ b/lib/DllSwResample.h
@@ -0,0 +1,87 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2010 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#if (defined HAVE_CONFIG_H) && (!defined WIN32)
+  #include "config.h"
+#endif
+#include "DynamicDll.h"
+
+extern "C" {
+#ifndef HAVE_MMX
+#define HAVE_MMX
+#endif
+#ifndef __STDC_CONSTANT_MACROS
+#define __STDC_CONSTANT_MACROS
+#endif
+#ifndef __GNUC__
+#pragma warning(disable:4244)
+#endif
+#if (defined USE_EXTERNAL_FFMPEG)
+  #include <libswresample/swresample.h>
+#else
+  #include "libswresample/swresample.h"
+#endif
+}
+
+
+#if (defined USE_EXTERNAL_FFMPEG) || (defined TARGET_DARWIN) 
+
+// Use direct mapping
+class DllSwResample : public DllDynamic
+{
+public:
+  virtual ~DllSwResample() {}
+
+  // DLL faking.
+  virtual bool ResolveExports() { return true; }
+  virtual bool Load() {
+    CLog::Log(LOGDEBUG, "DllAvFormat: Using libswresample system library");
+    return true;
+  }
+  virtual void Unload() {}
+};
+
+#else
+
+class DllSwResample : public DllDynamic
+{
+  DECLARE_DLL_WRAPPER(DllSwResample, DLL_PATH_LIBSWRESAMPLE)
+
+  LOAD_SYMBOLS()
+
+  BEGIN_METHOD_RESOLVE()
+  END_METHOD_RESOLVE()
+
+  /* dependencies of libavformat */
+  DllAvUtil m_dllAvUtil;
+
+public:
+
+  virtual bool Load()
+  {
+    if (!m_dllAvUtil.Load())
+      return false;
+    return DllDynamic::Load();
+  }
+};
+
+#endif
diff --git a/lib/DllSwScale.h b/lib/DllSwScale.h
index 0cfb654..0fe8184 100644
--- a/lib/DllSwScale.h
+++ b/lib/DllSwScale.h
@@ -92,7 +92,7 @@ public:
    virtual void sws_freeContext(struct SwsContext *context)=0;
 };
 
-#if (defined USE_EXTERNAL_FFMPEG)
+#if (defined USE_EXTERNAL_FFMPEG) || (defined TARGET_DARWIN) 
 
 // We call into this library directly.
 class DllSwScale : public DllDynamic, public DllSwScaleInterface
diff --git a/lib/Makefile.in b/lib/Makefile.in
index 3550582..2ea47fb 100644
--- a/lib/Makefile.in
+++ b/lib/Makefile.in
@@ -1,21 +1,18 @@
 ARCH=@ARCH@
 
+AR=@AR@
 LD=@LD@
 CC=@CC@
 CXX=@CXX@
-SHELL=@SHELL@
-ifeq ($(findstring osx,$(ARCH)),osx)
-ifeq ($(findstring arm,$(ARCH)),arm)
-LDFLAGS=-arch armv7 -iphoneos_version_min 4.1 -bundle -undefined dynamic_lookup -read_only_relocs suppress
-else
-LDFLAGS=-bundle -undefined dynamic_lookup -read_only_relocs suppress
-endif
-else
-LDFLAGS=-shared -fPIC -rdynamic
-endif
 SYSDIR=@abs_top_srcdir@/system/players/dvdplayer
-WRAPPER=@abs_top_srcdir@/xbmc/cores/DllLoader/exports/wrapper.o
-WRAPPER_MACH_ALIAS=@abs_top_srcdir@/xbmc/cores/DllLoader/exports/wrapper_mach_alias
+
+AVFORMAT_SO=avformat-53-$(ARCH).so
+AVCODEC_SO=avcodec-53-$(ARCH).so
+AVUTIL_SO=avutil-51-$(ARCH).so
+AVFILTER_SO=avfilter-2-$(ARCH).so
+SWSCALE_SO=swscale-2-$(ARCH).so
+POSTPROC_SO=postproc-52-$(ARCH).so
+SWRESAMPLE_SO=swresample-0-$(ARCH).so
 
 DIRS=
 ifneq (@USE_EXTERNAL_FFMPEG@,1)
@@ -24,123 +21,55 @@ endif
 
 LIBS=
 ifneq (@USE_EXTERNAL_FFMPEG@,1)
-  LIBS+=avutil-50-$(ARCH).so \
-	avcodec-52-$(ARCH).so \
-	avcore-0-$(ARCH).so \
-	avformat-52-$(ARCH).so \
-	postproc-51-$(ARCH).so \
-	avfilter-1-$(ARCH).so \
-	swscale-0-$(ARCH).so
-endif
-
-ifneq (,$(findstring powerpc,$(ARCH)))
-  ARCH_DIR=ppc
-else
-ifeq ($(findstring arm,$(ARCH)),arm)
-  ARCH_DIR=arm
-else
-  ARCH_DIR=x86
-endif
+  LIBS+=$(AVUTIL_SO) \
+	$(AVCODEC_SO) \
+	$(AVFORMAT_SO) \
+	$(POSTPROC_SO) \
+	$(AVFILTER_SO) \
+	$(SWSCALE_SO) \
+	$(SWRESAMPLE_SO)
 endif
 
 .PHONY: $(DIRS) codecs
 
-codecs: $(addprefix $(SYSDIR)/, $(LIBS));
-
-
-ifeq ($(findstring osx,$(ARCH)), osx)
-# Add -lbundle1.o for powerpc-osx
-ifeq ($(ARCH), powerpc-osx)
-BUNDLE1_O = -lbundle1.o
-endif
-
-$(SYSDIR)/avutil-50-$(ARCH).so: $(WRAPPER) ffmpeg/libavutil/libavutil.dylib
-	$(LD) $(LDFLAGS) -alias_list $(WRAPPER_MACH_ALIAS) -o $@ \
-		$(WRAPPER) ffmpeg/libavutil/*.o \
-		ffmpeg/libavutil/$(ARCH_DIR)/*.o $(BUNDLE1_O)
-
-$(SYSDIR)/avcodec-52-$(ARCH).so: $(WRAPPER) ffmpeg/libavcodec/libavcodec.dylib
-	$(LD) $(LDFLAGS) -alias_list $(WRAPPER_MACH_ALIAS) -o $@ \
-		$(WRAPPER) ffmpeg/libavcodec/*.o \
-		ffmpeg/libavcodec/$(ARCH_DIR)/*.o $(BUNDLE1_O)
-
-$(SYSDIR)/avcore-0-$(ARCH).so: $(WRAPPER) ffmpeg/libavcore/libavcore.dylib
-	$(LD) $(LDFLAGS) -alias_list $(WRAPPER_MACH_ALIAS)  -o $@ \
-		$(WRAPPER) ffmpeg/libavcore/*.o $(BUNDLE1_O)
-
-$(SYSDIR)/avformat-52-$(ARCH).so: $(WRAPPER) ffmpeg/libavformat/libavformat.dylib
-	$(LD) $(LDFLAGS) -alias_list $(WRAPPER_MACH_ALIAS)  -o $@ \
-		$(WRAPPER) ffmpeg/libavformat/*.o $(BUNDLE1_O)
-
-ifeq ($(findstring x86,$(ARCH_DIR)), x86)
-$(SYSDIR)/avfilter-1-$(ARCH).so: $(WRAPPER) ffmpeg/libavfilter/libavfilter.dylib
-	$(LD) $(LDFLAGS) -alias_list $(WRAPPER_MACH_ALIAS)  -o $@ \
-		$(WRAPPER) ffmpeg/libavfilter/$(ARCH_DIR)/*.o \
-		ffmpeg/libavfilter/*.o $(BUNDLE1_O)
-else # No libavfilter/ppc or libavfilter/arm
-$(SYSDIR)/avfilter-1-$(ARCH).so: $(WRAPPER) ffmpeg/libavfilter/libavfilter.dylib
-	$(LD) $(LDFLAGS) -alias_list $(WRAPPER_MACH_ALIAS)  -o $@ \
-		$(WRAPPER) ffmpeg/libavfilter/*.o $(BUNDLE1_O)
-endif
+ifneq ($(findstring osx,$(ARCH)), osx)
 
-ifneq ($(findstring arm,$(ARCH)), arm)
-$(SYSDIR)/swscale-0-$(ARCH).so: $(WRAPPER) ffmpeg/libswscale/libswscale.dylib
-	$(LD) $(LDFLAGS) -alias_list $(WRAPPER_MACH_ALIAS)  -o $@ \
-		$(WRAPPER) ffmpeg/libswscale/*.o \
-		ffmpeg/libswscale/$(ARCH_DIR)/*.o $(BUNDLE1_O)
-else # No ARM version of swscale available yet.
-$(SYSDIR)/swscale-0-$(ARCH).so: $(WRAPPER) ffmpeg/libswscale/libswscale.dylib
-	$(LD) $(LDFLAGS) -alias_list $(WRAPPER_MACH_ALIAS)  -o $@ \
-		$(WRAPPER) ffmpeg/libswscale/*.o
-endif
-
-$(SYSDIR)/postproc-51-$(ARCH).so: $(WRAPPER) ffmpeg/libpostproc/libpostproc.dylib
-	$(LD) $(LDFLAGS) -alias_list $(WRAPPER_MACH_ALIAS)  -o $@ \
-		$(WRAPPER) ffmpeg/libpostproc/*.o $(BUNDLE1_O)
-
-ffmpeg/libavutil/libavutil.dylib     : ffmpeg;
-ffmpeg/libavcodec/libavcodec.dylib   : ffmpeg;
-ffmpeg/libavcore/libavcore.dylib     : ffmpeg;
-ffmpeg/libavformat/libavformat.dylib : ffmpeg;
-ffmpeg/libavformat/libavfilter.dylib : ffmpeg;
-ffmpeg/libswscale/libswscale.dylib   : ffmpeg;
-ffmpeg/libpostproc/libpostproc.dylib : ffmpeg;
-ffmpeg:
-	$(MAKE) -C $@
-
-else
+codecs: $(addprefix $(SYSDIR)/, $(LIBS));
 
-$(SYSDIR)/avutil-50-$(ARCH).so: ffmpeg/libavutil/libavutil.so
+$(SYSDIR)/$(AVUTIL_SO): ffmpeg/libavutil/libavutil.so
 	cp ffmpeg/libavutil/libavutil.so $@
 
-$(SYSDIR)/avcodec-52-$(ARCH).so: $(WRAPPER) ffmpeg/libavcodec/libavcodec.so
+$(SYSDIR)/$(AVCODEC_SO): ffmpeg/libavcodec/libavcodec.so
 	cp ffmpeg/libavcodec/libavcodec.so $@
 
-$(SYSDIR)/avcore-0-$(ARCH).so: $(WRAPPER) ffmpeg/libavcore/libavcore.so
-	cp ffmpeg/libavcore/libavcore.so $@
-
-$(SYSDIR)/avformat-52-$(ARCH).so: $(WRAPPER) ffmpeg/libavformat/libavformat.so
+$(SYSDIR)/$(AVFORMAT_SO): ffmpeg/libavformat/libavformat.so
 	cp ffmpeg/libavformat/libavformat.so $@
 
-$(SYSDIR)/avfilter-1-$(ARCH).so: $(WRAPPER) ffmpeg/libavfilter/libavfilter.so
+$(SYSDIR)/$(AVFILTER_SO): ffmpeg/libavfilter/libavfilter.so
 	cp ffmpeg/libavfilter/libavfilter.so $@
 
-$(SYSDIR)/swscale-0-$(ARCH).so: $(WRAPPER) ffmpeg/libswscale/libswscale.so
+$(SYSDIR)/$(SWSCALE_SO): ffmpeg/libswscale/libswscale.so
 	cp ffmpeg/libswscale/libswscale.so $@
 
-$(SYSDIR)/postproc-51-$(ARCH).so: $(WRAPPER) ffmpeg/libpostproc/libpostproc.so
+$(SYSDIR)/$(POSTPROC_SO): ffmpeg/libpostproc/libpostproc.so
 	cp ffmpeg/libpostproc/libpostproc.so $@
 
+$(SYSDIR)/$(SWRESAMPLE_SO): ffmpeg/libswresample/libswresample.so
+	cp ffmpeg/libswresample/libswresample.so $@
+
 ffmpeg/libavutil/libavutil.so     : ffmpeg;
 ffmpeg/libavcodec/libavcodec.so   : ffmpeg;
-ffmpeg/libavcore/libavcore.so     : ffmpeg;
 ffmpeg/libavformat/libavformat.so : ffmpeg;
 ffmpeg/libavfilter/libavfilter.so : ffmpeg;
 ffmpeg/libswscale/libswscale.so   : ffmpeg;
 ffmpeg/libpostproc/libpostproc.so : ffmpeg;
+ffmpeg/libswresample/libswresample.so : ffmpeg;
+endif
+
 ffmpeg:
 	$(MAKE) -C $@
-
+ifeq ($(findstring osx,$(ARCH)), osx)
+	$(AR) d ffmpeg/libavcodec/libavcodec.a inverse.o
 endif
 
 clean:
diff --git a/xbmc/DllPaths_generated.h.in b/xbmc/DllPaths_generated.h.in
index a84dd52..10a7d87 100644
--- a/xbmc/DllPaths_generated.h.in
+++ b/xbmc/DllPaths_generated.h.in
@@ -74,13 +74,13 @@
 #define DLL_PATH_LIBMAD        "@MAD_SONAME@"
 
 /* ffmpeg */
-#define DLL_PATH_LIBAVCODEC    "special://xbmcbin/system/players/dvdplayer/avcodec-52-@ARCH@.so"
-#define DLL_PATH_LIBAVCORE     "special://xbmcbin/system/players/dvdplayer/avcore-0-@ARCH@.so"
-#define DLL_PATH_LIBAVFORMAT   "special://xbmcbin/system/players/dvdplayer/avformat-52-@ARCH@.so"
-#define DLL_PATH_LIBAVUTIL     "special://xbmcbin/system/players/dvdplayer/avutil-50-@ARCH@.so"
-#define DLL_PATH_LIBPOSTPROC   "special://xbmcbin/system/players/dvdplayer/postproc-51-@ARCH@.so"
-#define DLL_PATH_LIBSWSCALE    "special://xbmcbin/system/players/dvdplayer/swscale-0-@ARCH@.so"
-#define DLL_PATH_LIBAVFILTER   "special://xbmcbin/system/players/dvdplayer/avfilter-1-@ARCH@.so"
+#define DLL_PATH_LIBAVCODEC    "special://xbmcbin/system/players/dvdplayer/avcodec-53-@ARCH@.so"
+#define DLL_PATH_LIBAVFORMAT   "special://xbmcbin/system/players/dvdplayer/avformat-53-@ARCH@.so"
+#define DLL_PATH_LIBAVUTIL     "special://xbmcbin/system/players/dvdplayer/avutil-51-@ARCH@.so"
+#define DLL_PATH_LIBPOSTPROC   "special://xbmcbin/system/players/dvdplayer/postproc-52-@ARCH@.so"
+#define DLL_PATH_LIBSWSCALE    "special://xbmcbin/system/players/dvdplayer/swscale-2-@ARCH@.so"
+#define DLL_PATH_LIBAVFILTER   "special://xbmcbin/system/players/dvdplayer/avfilter-2-@ARCH@.so"
+#define DLL_PATH_LIBSWRESAMPLE "special://xbmcbin/system/players/dvdplayer/swresample-0-@ARCH@.so"
 
 /* cdrip */
 #if defined(_LINUX) && !defined(__APPLE__)
diff --git a/xbmc/DllPaths_win32.h b/xbmc/DllPaths_win32.h
index d39e2ea..fbd75a4 100644
--- a/xbmc/DllPaths_win32.h
+++ b/xbmc/DllPaths_win32.h
@@ -58,13 +58,13 @@
 #define DLL_PATH_LIBRTMP       "special://xbmcbin/system/players/dvdplayer/librtmp.dll"
 
 /* ffmpeg */
-#define DLL_PATH_LIBAVCODEC    "special://xbmcbin/system/players/dvdplayer/avcodec-52.dll"
-#define DLL_PATH_LIBAVCORE     "special://xbmcbin/system/players/dvdplayer/avcore-0.dll"
-#define DLL_PATH_LIBAVFORMAT   "special://xbmcbin/system/players/dvdplayer/avformat-52.dll"
-#define DLL_PATH_LIBAVUTIL     "special://xbmcbin/system/players/dvdplayer/avutil-50.dll"
-#define DLL_PATH_LIBAVFILTER   "special://xbmcbin/system/players/dvdplayer/avfilter-1.dll"
-#define DLL_PATH_LIBPOSTPROC   "special://xbmcbin/system/players/dvdplayer/postproc-51.dll"
-#define DLL_PATH_LIBSWSCALE    "special://xbmcbin/system/players/dvdplayer/swscale-0.dll"
+#define DLL_PATH_LIBAVCODEC    "special://xbmcbin/system/players/dvdplayer/avcodec-53.dll"
+#define DLL_PATH_LIBAVFORMAT   "special://xbmcbin/system/players/dvdplayer/avformat-53.dll"
+#define DLL_PATH_LIBAVUTIL     "special://xbmcbin/system/players/dvdplayer/avutil-51.dll"
+#define DLL_PATH_LIBAVFILTER   "special://xbmcbin/system/players/dvdplayer/avfilter-2.dll"
+#define DLL_PATH_LIBPOSTPROC   "special://xbmcbin/system/players/dvdplayer/postproc-52.dll"
+#define DLL_PATH_LIBSWSCALE    "special://xbmcbin/system/players/dvdplayer/swscale-2.dll"
+#define DLL_PATH_LIBSWRESAMPLE "special://xbmcbin/system/players/dvdplayer/swresample-0.dll"
 
 /* cdrip */
 #define DLL_PATH_LAME_ENC      "special://xbmcbin/system/cdrip/lame_enc.dll"
diff --git a/xbmc/cdrip/EncoderFFmpeg.cpp b/xbmc/cdrip/EncoderFFmpeg.cpp
index 1ec9805..bcedb0c 100644
--- a/xbmc/cdrip/EncoderFFmpeg.cpp
+++ b/xbmc/cdrip/EncoderFFmpeg.cpp
@@ -59,11 +59,7 @@ bool CEncoderFFmpeg::Init(const char* strFile, int iInChannels, int iInRate, int
 
   CStdString filename = URIUtils::GetFileName(strFile);
   AVOutputFormat *fmt = NULL;
-#if LIBAVFORMAT_VERSION_MAJOR < 52
-  fmt = m_dllAvFormat.guess_format(NULL, filename.c_str(), NULL);
-#else
   fmt = m_dllAvFormat.av_guess_format(NULL, filename.c_str(), NULL);
-#endif
   if (!fmt)
   {
     CLog::Log(LOGERROR, "CEncoderFFmpeg::Init - Unable to guess the output format for the file %s", filename.c_str());
@@ -82,7 +78,7 @@ bool CEncoderFFmpeg::Init(const char* strFile, int iInChannels, int iInRate, int
   }
 
   m_Format     = m_dllAvFormat.avformat_alloc_context();
-  m_Format->pb = m_dllAvFormat.av_alloc_put_byte(m_BCBuffer, sizeof(m_BCBuffer), URL_RDONLY, this,  NULL, MuxerReadPacket, NULL);
+  m_Format->pb = m_dllAvFormat.avio_alloc_context(m_BCBuffer, sizeof(m_BCBuffer), AVIO_FLAG_READ, this,  NULL, MuxerReadPacket, NULL);
   if (!m_Format->pb)
   {
     m_dllAvUtil.av_freep(&m_Format);
@@ -93,17 +89,8 @@ bool CEncoderFFmpeg::Init(const char* strFile, int iInChannels, int iInRate, int
   m_Format->oformat  = fmt;
   m_Format->bit_rate = g_guiSettings.GetInt("audiocds.bitrate") * 1000;
 
-  /* setup the muxer */
-  if (m_dllAvFormat.av_set_parameters(m_Format, NULL) != 0)
-  {
-    m_dllAvUtil.av_freep(&m_Format->pb);
-    m_dllAvUtil.av_freep(&m_Format);
-    CLog::Log(LOGERROR, "CEncoderFFmpeg::Init - Failed to set the muxer parameters");
-    return false;
-  }
-
   /* add a stream to it */
-  m_Stream = m_dllAvFormat.av_new_stream(m_Format, 1);
+  m_Stream = m_dllAvFormat.avformat_new_stream(m_Format, codec);
   if (!m_Stream)
   {
     m_dllAvUtil.av_freep(&m_Format->pb);
@@ -144,7 +131,7 @@ bool CEncoderFFmpeg::Init(const char* strFile, int iInChannels, int iInRate, int
       return false;
   }
 
-  if (m_dllAvCodec.avcodec_open(m_CodecCtx, codec))
+  if (m_dllAvCodec.avcodec_open2(m_CodecCtx, codec, NULL))
   {
     CLog::Log(LOGERROR, "CEncoderFFmpeg::Init - Failed to open the codec");
     m_dllAvUtil.av_freep(&m_Stream);
@@ -179,7 +166,7 @@ bool CEncoderFFmpeg::Init(const char* strFile, int iInChannels, int iInRate, int
   SetTag("encoder"     , "XBMC FFmpeg Encoder");
 
   /* write the header */
-  if (m_dllAvFormat.av_write_header(m_Format) != 0)
+  if (m_dllAvFormat.avformat_write_header(m_Format, NULL) != 0)
   {
     CLog::Log(LOGERROR, "CEncoderFFmpeg::Init - Failed to write the header");
     delete[] m_Buffer;
@@ -194,7 +181,7 @@ bool CEncoderFFmpeg::Init(const char* strFile, int iInChannels, int iInRate, int
 
 void CEncoderFFmpeg::SetTag(const CStdString tag, const CStdString value)
 {
-  m_dllAvFormat.av_metadata_set2(&m_Format->metadata, tag.c_str(), value.c_str(), 0);
+  m_dllAvUtil.av_dict_set(&m_Format->metadata, tag.c_str(), value.c_str(), 0);
 }
 
 int CEncoderFFmpeg::MuxerReadPacket(void *opaque, uint8_t *buf, int buf_size)
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp
index cebba1c..46fd47f 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp
@@ -29,10 +29,6 @@
 
 CDVDAudioCodecFFmpeg::CDVDAudioCodecFFmpeg() : CDVDAudioCodec()
 {
-  m_iBufferSize1 = 0;
-  m_pBuffer1     = (BYTE*)_aligned_malloc(AVCODEC_MAX_AUDIO_FRAME_SIZE + FF_INPUT_BUFFER_PADDING_SIZE, 16);
-  memset(m_pBuffer1, 0, AVCODEC_MAX_AUDIO_FRAME_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);
-
   m_iBufferSize2 = 0;
   m_pBuffer2     = (BYTE*)_aligned_malloc(AVCODEC_MAX_AUDIO_FRAME_SIZE + FF_INPUT_BUFFER_PADDING_SIZE, 16);
   memset(m_pBuffer2, 0, AVCODEC_MAX_AUDIO_FRAME_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);
@@ -45,11 +41,11 @@ CDVDAudioCodecFFmpeg::CDVDAudioCodecFFmpeg() : CDVDAudioCodec()
   m_channelMap[0] = PCM_INVALID;
   m_channels = 0;
   m_layout = 0;
+  m_pFrame1 = NULL;
 }
 
 CDVDAudioCodecFFmpeg::~CDVDAudioCodecFFmpeg()
 {
-  _aligned_free(m_pBuffer1);
   _aligned_free(m_pBuffer2);
   Dispose();
 }
@@ -59,12 +55,10 @@ bool CDVDAudioCodecFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options
   AVCodec* pCodec;
   m_bOpenedCodec = false;
 
-  if (!m_dllAvCore.Load() || !m_dllAvUtil.Load() || !m_dllAvCodec.Load())
+  if (!m_dllAvUtil.Load() || !m_dllAvCodec.Load())
     return false;
 
   m_dllAvCodec.avcodec_register_all();
-  m_pCodecContext = m_dllAvCodec.avcodec_alloc_context();
-  m_dllAvCodec.avcodec_get_context_defaults(m_pCodecContext);
 
   pCodec = m_dllAvCodec.avcodec_find_decoder(hints.codec);
   if (!pCodec)
@@ -73,6 +67,7 @@ bool CDVDAudioCodecFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options
     return false;
   }
 
+  m_pCodecContext = m_dllAvCodec.avcodec_alloc_context3(pCodec);
   m_pCodecContext->debug_mv = 0;
   m_pCodecContext->debug = 0;
   m_pCodecContext->workaround_bugs = 1;
@@ -97,13 +92,14 @@ bool CDVDAudioCodecFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options
     memcpy(m_pCodecContext->extradata, hints.extradata, hints.extrasize);
   }
 
-  if (m_dllAvCodec.avcodec_open(m_pCodecContext, pCodec) < 0)
+  if (m_dllAvCodec.avcodec_open2(m_pCodecContext, pCodec, NULL) < 0)
   {
     CLog::Log(LOGDEBUG,"CDVDAudioCodecFFmpeg::Open() Unable to open codec");
     Dispose();
     return false;
   }
 
+  m_pFrame1 = m_dllAvCodec.avcodec_alloc_frame();
   m_bOpenedCodec = true;
   m_iSampleFormat = AV_SAMPLE_FMT_NONE;
   return true;
@@ -111,6 +107,9 @@ bool CDVDAudioCodecFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options
 
 void CDVDAudioCodecFFmpeg::Dispose()
 {
+  if (m_pFrame1) m_dllAvUtil.av_free(m_pFrame1);
+  m_pFrame1 = NULL;
+
   if (m_pConvert)
   {
     m_dllAvCodec.av_audio_convert_free(m_pConvert);
@@ -135,7 +134,7 @@ void CDVDAudioCodecFFmpeg::Dispose()
 
 int CDVDAudioCodecFFmpeg::Decode(BYTE* pData, int iSize)
 {
-  int iBytesUsed;
+  int iBytesUsed, got_frame;
   if (!m_pCodecContext) return -1;
 
   m_iBufferSize1 = AVCODEC_MAX_AUDIO_FRAME_SIZE ;
@@ -145,10 +144,17 @@ int CDVDAudioCodecFFmpeg::Decode(BYTE* pData, int iSize)
   m_dllAvCodec.av_init_packet(&avpkt);
   avpkt.data = pData;
   avpkt.size = iSize;
-  iBytesUsed = m_dllAvCodec.avcodec_decode_audio3( m_pCodecContext
-                                                 , (int16_t*)m_pBuffer1
-                                                 , &m_iBufferSize1
+  iBytesUsed = m_dllAvCodec.avcodec_decode_audio4( m_pCodecContext
+                                                 , m_pFrame1
+                                                 , &got_frame
                                                  , &avpkt);
+  if (iBytesUsed < 0 || !got_frame)
+  {
+    m_iBufferSize1 = 0;
+    m_iBufferSize2 = 0;
+    return iBytesUsed;
+  }
+  m_iBufferSize1 = m_dllAvUtil.av_samples_get_buffer_size(NULL, m_pCodecContext->channels, m_pFrame1->nb_samples, m_pCodecContext->sample_fmt, 1);
 
   /* some codecs will attempt to consume more data than what we gave */
   if (iBytesUsed > iSize)
@@ -184,9 +190,9 @@ int CDVDAudioCodecFFmpeg::Decode(BYTE* pData, int iSize)
       return iBytesUsed;
     }
 
-    const void *ibuf[6] = { m_pBuffer1 };
+    const void *ibuf[6] = { m_pFrame1->data[0] };
     void       *obuf[6] = { m_pBuffer2 };
-    int         istr[6] = { m_dllAvCore.av_get_bits_per_sample_fmt(m_pCodecContext->sample_fmt)/8 };
+    int         istr[6] = { m_dllAvUtil.av_get_bytes_per_sample(m_pCodecContext->sample_fmt) };
     int         ostr[6] = { 2 };
     int         len     = m_iBufferSize1 / istr[0];
     if(m_dllAvCodec.av_audio_convert(m_pConvert, obuf, ostr, ibuf, istr, len) < 0)
@@ -208,7 +214,7 @@ int CDVDAudioCodecFFmpeg::GetData(BYTE** dst)
 {
   if(m_iBufferSize1)
   {
-    *dst = m_pBuffer1;
+    *dst = m_pFrame1->data[0];
     return m_iBufferSize1;
   }
   if(m_iBufferSize2)
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h
index dbd4948..4c01499 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h
@@ -23,7 +23,6 @@
 
 #include "DVDAudioCodec.h"
 #include "DllAvCodec.h"
-#include "DllAvCore.h"
 #include "DllAvFormat.h"
 #include "DllAvUtil.h"
 
@@ -51,7 +50,7 @@ protected:
   enum AVSampleFormat m_iSampleFormat;
   enum PCMChannels m_channelMap[PCM_MAX_CH + 1];
 
-  BYTE *m_pBuffer1;
+  AVFrame* m_pFrame1;
   int   m_iBufferSize1;
 
   BYTE *m_pBuffer2;
@@ -64,7 +63,6 @@ protected:
   int64_t m_layout;
 
   DllAvCodec m_dllAvCodec;
-  DllAvCore m_dllAvCore;
   DllAvUtil m_dllAvUtil;
 
   void BuildChannelMap();
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.cpp
index 34e93a4..c0c3c06 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.cpp
@@ -79,11 +79,7 @@ bool CDVDAudioCodecPassthroughFFmpeg::SetupMuxer(CDVDStreamInfo &hints, CStdStri
   /* get the muxer */
   AVOutputFormat *fOut = NULL;
 
-#if LIBAVFORMAT_VERSION_MAJOR < 52
-  fOut = m_dllAvFormat.guess_format(muxerName.c_str(), NULL, NULL);
-#else
   fOut = m_dllAvFormat.av_guess_format(muxerName.c_str(), NULL, NULL);
-#endif
   if (!fOut)
   {
     CLog::Log(LOGERROR, "CDVDAudioCodecPassthroughFFmpeg::SetupMuxer - Failed to get the FFmpeg %s muxer", muxerName.c_str());
@@ -103,7 +99,7 @@ bool CDVDAudioCodecPassthroughFFmpeg::SetupMuxer(CDVDStreamInfo &hints, CStdStri
   muxer.m_pFormat->oformat = fOut;
 
   /* allocate a put_byte struct so we can grab the output */
-  muxer.m_pFormat->pb = m_dllAvFormat.av_alloc_put_byte(muxer.m_BCBuffer, sizeof(muxer.m_BCBuffer), URL_RDONLY, &muxer,  NULL, MuxerReadPacket, NULL);
+  muxer.m_pFormat->pb = m_dllAvFormat.avio_alloc_context(muxer.m_BCBuffer, sizeof(muxer.m_BCBuffer), AVIO_FLAG_READ, &muxer,  NULL, MuxerReadPacket, NULL);
   if (!muxer.m_pFormat->pb)
   {
     CLog::Log(LOGERROR, "CDVDAudioCodecPassthroughFFmpeg::SetupMuxer - Failed to allocate ByteIOContext");
@@ -112,21 +108,10 @@ bool CDVDAudioCodecPassthroughFFmpeg::SetupMuxer(CDVDStreamInfo &hints, CStdStri
   }
 
   /* this is streamed, no file, and ignore the index */
-  muxer.m_pFormat->pb->is_streamed   = 1;
+  muxer.m_pFormat->pb->seekable      = 0;
   muxer.m_pFormat->flags            |= AVFMT_NOFILE | AVFMT_FLAG_IGNIDX;
   muxer.m_pFormat->bit_rate          = hints.bitrate;
 
-  /* setup the muxer */
-  if (m_dllAvFormat.av_set_parameters(muxer.m_pFormat, NULL) != 0)
-  {
-    CLog::Log(LOGERROR, "CDVDAudioCodecPassthroughFFmpeg::SetupMuxer - Failed to set the %s muxer parameters", muxerName.c_str());
-    Dispose();
-    return false;
-  }
-
-#if LIBAVFORMAT_VERSION_INT >= AV_VERSION_INT(52,92,0)
-  // API added on: 2011-01-02
-
   /* While this is strictly only needed on big-endian systems, we do it on
    * both to avoid as much dead code as possible.
    * CoreAudio (at least on the cases we've seen) wants IEC 61937 in
@@ -138,8 +123,7 @@ bool CDVDAudioCodecPassthroughFFmpeg::SetupMuxer(CDVDStreamInfo &hints, CStdStri
 #endif
 
   /* request output of wanted endianness */
-  if (!fOut->priv_class || m_dllAvUtil.av_set_string3(muxer.m_pFormat->priv_data, "spdif_flags", spdifFlags, 0, NULL) != 0)
-#endif
+  if (!fOut->priv_class || m_dllAvUtil.av_opt_set(muxer.m_pFormat->priv_data, "spdif_flags", spdifFlags, 0) != 0)
   {
 #if defined(WORDS_BIGENDIAN) && !defined(__APPLE__)
     CLog::Log(LOGERROR, "CDVDAudioCodecPassthroughFFmpeg::SetupMuxer - Unable to set big-endian stream mode (FFmpeg too old?), disabling passthrough");
@@ -149,7 +133,7 @@ bool CDVDAudioCodecPassthroughFFmpeg::SetupMuxer(CDVDStreamInfo &hints, CStdStri
   }
 
   /* add a stream to it */
-  muxer.m_pStream = m_dllAvFormat.av_new_stream(muxer.m_pFormat, 1);
+  muxer.m_pStream = m_dllAvFormat.avformat_new_stream(muxer.m_pFormat, NULL);
   if (!muxer.m_pStream)
   {
     CLog::Log(LOGERROR, "CDVDAudioCodecPassthroughFFmpeg::SetupMuxer - Failed to allocate AVStream context");
@@ -159,8 +143,6 @@ bool CDVDAudioCodecPassthroughFFmpeg::SetupMuxer(CDVDStreamInfo &hints, CStdStri
 
 
   /* set the stream's parameters */
-  muxer.m_pStream->stream_copy           = 1;
-
   m_SampleRate = hints.samplerate;
   if(!m_SampleRate && hints.codec == CODEC_ID_AC3)
     m_SampleRate = 48000;
@@ -176,7 +158,7 @@ bool CDVDAudioCodecPassthroughFFmpeg::SetupMuxer(CDVDStreamInfo &hints, CStdStri
   codec->extradata_size = hints.extrasize;
   memcpy(codec->extradata, hints.extradata, hints.extrasize);
 
-  muxer.m_WroteHeader = m_dllAvFormat.av_write_header(muxer.m_pFormat) == 0;
+  muxer.m_WroteHeader = m_dllAvFormat.avformat_write_header(muxer.m_pFormat, NULL) == 0;
   if (!muxer.m_WroteHeader)
   {
     CLog::Log(LOGERROR, "CDVDAudioCodecPassthrough::SetupMuxer - Failed to write the frame header");
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Audio/Encoders/DVDAudioEncoderFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Audio/Encoders/DVDAudioEncoderFFmpeg.cpp
index 77d4b64..0189e65 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/Encoders/DVDAudioEncoderFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/Encoders/DVDAudioEncoderFFmpeg.cpp
@@ -55,7 +55,7 @@ CDVDAudioEncoderFFmpeg::~CDVDAudioEncoderFFmpeg()
 bool CDVDAudioEncoderFFmpeg::Initialize(unsigned int channels, enum PCMChannels *channelMap, unsigned int bitsPerSample, unsigned int sampleRate)
 {
   Reset();
-  if (!channelMap || !m_dllAvUtil.Load() || !m_dllAvCore.Load() || !m_dllAvCodec.Load())
+  if (!channelMap || !m_dllAvUtil.Load() || !m_dllAvCodec.Load())
     return false;
 
   m_dllAvCodec.avcodec_register_all();
@@ -65,7 +65,7 @@ bool CDVDAudioEncoderFFmpeg::Initialize(unsigned int channels, enum PCMChannels
     return false;
 
   /* always assume 6 channels, 5.1... m_remap will give us what we want */
-  m_CodecCtx = m_dllAvCodec.avcodec_alloc_context();
+  m_CodecCtx = m_dllAvCodec.avcodec_alloc_context3(codec);
   m_CodecCtx->bit_rate       = AC3_ENCODE_BITRATE;
   m_CodecCtx->sample_rate    = sampleRate;
   m_CodecCtx->channels       = 6;
@@ -104,7 +104,7 @@ bool CDVDAudioEncoderFFmpeg::Initialize(unsigned int channels, enum PCMChannels
     }
   }
 
-  if (m_dllAvCodec.avcodec_open(m_CodecCtx, codec))
+  if (m_dllAvCodec.avcodec_open2(m_CodecCtx, codec, NULL))
   {
     m_dllAvUtil.av_freep(&m_CodecCtx);
     return false;
@@ -149,7 +149,7 @@ bool CDVDAudioEncoderFFmpeg::Initialize(unsigned int channels, enum PCMChannels
 
   if (m_AudioConvert)
       m_TmpBuffer2   = new uint8_t[m_NeededFrames * m_CodecCtx->channels *
-                                   m_dllAvCore.av_get_bits_per_sample_fmt(m_CodecCtx->sample_fmt) / 8];
+                                   m_dllAvUtil.av_get_bytes_per_sample(m_CodecCtx->sample_fmt)];
 
   return true;
 }
@@ -186,7 +186,7 @@ int CDVDAudioEncoderFFmpeg::Encode(uint8_t *data, int size)
     void *convInBuf[] = { m_TmpBuffer };
     int convInStr[] = { m_BitsPerSample / 8 };
     void *convOutBuf[] = { m_TmpBuffer2 };
-    int convOutStr[] = { m_dllAvCore.av_get_bits_per_sample_fmt(m_CodecCtx->sample_fmt) / 8 };
+    int convOutStr[] = { m_dllAvUtil.av_get_bytes_per_sample(m_CodecCtx->sample_fmt) };
     if (m_dllAvCodec.av_audio_convert(m_AudioConvert, convOutBuf, convOutStr,
                                       convInBuf, convInStr, m_NeededFrames * m_CodecCtx->channels) < 0) {
       CLog::Log(LOGERROR, "CDVDAudioEncoderFFmpeg: Audio conversion failed");
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Audio/Encoders/DVDAudioEncoderFFmpeg.h b/xbmc/cores/dvdplayer/DVDCodecs/Audio/Encoders/DVDAudioEncoderFFmpeg.h
index 93bd2c7..40be42b 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/Encoders/DVDAudioEncoderFFmpeg.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/Encoders/DVDAudioEncoderFFmpeg.h
@@ -43,7 +43,6 @@ public:
   virtual int GetData(uint8_t **data);
 private:
   DllAvCodec m_dllAvCodec;
-  DllAvCore  m_dllAvCore;
   DllAvUtil  m_dllAvUtil;
 
   AVCodecContext   *m_CodecCtx;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp
index 563ce78..238c855 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp
@@ -49,7 +49,14 @@ bool CDVDOverlayCodecFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &optio
 
   m_dllAvCodec.avcodec_register_all();
 
-  m_pCodecContext = m_dllAvCodec.avcodec_alloc_context();
+  AVCodec* pCodec = m_dllAvCodec.avcodec_find_decoder(hints.codec);
+  if (!pCodec)
+  {
+    CLog::Log(LOGDEBUG,"%s - Unable to find codec %d", __FUNCTION__, hints.codec);
+    return false;
+  }
+
+  m_pCodecContext = m_dllAvCodec.avcodec_alloc_context3(pCodec);
   m_pCodecContext->debug_mv = 0;
   m_pCodecContext->debug = 0;
   m_pCodecContext->workaround_bugs = FF_BUG_AUTODETECT;
@@ -100,14 +107,7 @@ bool CDVDOverlayCodecFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &optio
     delete[] parse_extra;
   }
 
-  AVCodec* pCodec = m_dllAvCodec.avcodec_find_decoder(hints.codec);
-  if (!pCodec)
-  {
-    CLog::Log(LOGDEBUG,"%s - Unable to find codec %d", __FUNCTION__, hints.codec);
-    return false;
-  }
-
-  if (m_dllAvCodec.avcodec_open(m_pCodecContext, pCodec) < 0)
+  if (m_dllAvCodec.avcodec_open2(m_pCodecContext, pCodec, NULL) < 0)
   {
     CLog::Log(LOGDEBUG,"CDVDVideoCodecFFmpeg::Open() Unable to open codec");
     return false;
@@ -134,19 +134,12 @@ void CDVDOverlayCodecFFmpeg::FreeSubtitle(AVSubtitle& sub)
 {
   for(unsigned i=0;i<sub.num_rects;i++)
   {
-#if LIBAVCODEC_VERSION_INT >= (52<<10)
     if(sub.rects[i])
     {
       m_dllAvUtil.av_free(sub.rects[i]->pict.data[0]);
       m_dllAvUtil.av_free(sub.rects[i]->pict.data[1]);
       m_dllAvUtil.av_freep(&sub.rects[i]);
     }
-#else
-    if(sub.rects[i].bitmap)
-      m_dllAvUtil.av_freep(&sub.rects[i].bitmap);
-    if(m_Subtitle.rects[i].rgba_palette)
-      m_dllAvUtil.av_freep(&sub.rects[i].rgba_palette);
-#endif
   }
   if(sub.rects)
     m_dllAvUtil.av_freep(&sub.rects);
@@ -294,7 +287,6 @@ CDVDOverlay* CDVDOverlayCodecFFmpeg::GetOverlay()
     overlay->source_width  = m_width;
     overlay->source_height = m_height;
 
-#if LIBAVCODEC_VERSION_INT >= (52<<10)
     BYTE* s = rect.pict.data[0];
     BYTE* t = overlay->data;
     for(int i=0;i<rect.h;i++)
@@ -310,21 +302,6 @@ CDVDOverlay* CDVDOverlayCodecFFmpeg::GetOverlay()
     m_dllAvUtil.av_free(rect.pict.data[0]);
     m_dllAvUtil.av_free(rect.pict.data[1]);
     m_dllAvUtil.av_freep(&m_Subtitle.rects[m_SubtitleIndex]);
-#else
-    BYTE* s = rect.bitmap;
-    BYTE* t = overlay->data;
-    for(int i=0;i<rect.h;i++)
-    {
-      memcpy(t, s, rect.w);
-      s += rect.linesize;
-      t += overlay->linesize;
-    }
-
-    memcpy(overlay->palette, rect.rgba_palette, rect.nb_colors*4);
-
-    m_dllAvUtil.av_freep(&rect.bitmap);
-    m_dllAvUtil.av_freep(&rect.rgba_palette);
-#endif
     m_SubtitleIndex++;
 
     return overlay;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
index 637a371..7ac6b6b 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
@@ -123,12 +123,11 @@ enum PixelFormat CDVDVideoCodecFFmpeg::GetFormat( struct AVCodecContext * avctx
 CDVDVideoCodecFFmpeg::CDVDVideoCodecFFmpeg() : CDVDVideoCodec()
 {
   m_pCodecContext = NULL;
-  m_pConvertFrame = NULL;
   m_pFrame = NULL;
   m_pFilterGraph  = NULL;
   m_pFilterIn     = NULL;
   m_pFilterOut    = NULL;
-  m_pFilterLink   = NULL;
+  m_pBufferRef    = NULL;
 
   m_iPictureWidth = 0;
   m_iPictureHeight = 0;
@@ -163,9 +162,13 @@ bool CDVDVideoCodecFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options
   m_dllAvFilter.avfilter_register_all();
 
   m_bSoftware     = hints.software;
-  m_pCodecContext = m_dllAvCodec.avcodec_alloc_context();
+
+  m_formats.push_back(PIX_FMT_YUV420P);
+  m_formats.push_back(PIX_FMT_YUVJ420P);
+  m_formats.push_back(PIX_FMT_NONE); /* always add none to get a terminated list in ffmpeg world */
 
   pCodec = NULL;
+  m_pCodecContext = NULL;
 
   if (hints.codec == CODEC_ID_H264)
   {
@@ -196,6 +199,7 @@ bool CDVDVideoCodecFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options
 
         CLog::Log(LOGNOTICE,"CDVDVideoCodecFFmpeg::Open() Creating VDPAU(%ix%i, %d)",hints.width, hints.height, hints.codec);
         CVDPAU* vdp = new CVDPAU();
+        m_pCodecContext = m_dllAvCodec.avcodec_alloc_context3(pCodec);
         m_pCodecContext->codec_id = hints.codec;
         m_pCodecContext->width    = hints.width;
         m_pCodecContext->height   = hints.height;
@@ -207,7 +211,7 @@ bool CDVDVideoCodecFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options
           m_pCodecContext->codec_id = CODEC_ID_NONE; // ffmpeg will complain if this has been set
           break;
         }
-        m_pCodecContext->codec_id = CODEC_ID_NONE; // ffmpeg will complain if this has been set
+        m_dllAvUtil.av_freep(&m_pCodecContext);
         CLog::Log(LOGNOTICE,"CDVDVideoCodecFFmpeg::Open() Failed to get VDPAU device");
         vdp->Release();
       }
@@ -226,21 +230,26 @@ bool CDVDVideoCodecFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options
 
   CLog::Log(LOGNOTICE,"CDVDVideoCodecFFmpeg::Open() Using codec: %s",pCodec->long_name ? pCodec->long_name : pCodec->name);
 
+  if(m_pCodecContext == NULL)
+    m_pCodecContext = m_dllAvCodec.avcodec_alloc_context3(pCodec);
+
   m_pCodecContext->opaque = (void*)this;
   m_pCodecContext->debug_mv = 0;
   m_pCodecContext->debug = 0;
   m_pCodecContext->workaround_bugs = FF_BUG_AUTODETECT;
   m_pCodecContext->get_format = GetFormat;
   m_pCodecContext->codec_tag = hints.codec_tag;
+  /* Only allow slice threading, since frame threading is more
+   * sensitive to changes in frame sizes, and it causes crashes
+   * during HW accell */
+  m_pCodecContext->thread_type = FF_THREAD_SLICE;
 
 #if defined(__APPLE__) && defined(__arm__)
   // ffmpeg with enabled neon will crash and burn if this is enabled
   m_pCodecContext->flags &= CODEC_FLAG_EMU_EDGE;
 #else
   if (pCodec->id != CODEC_ID_H264 && pCodec->capabilities & CODEC_CAP_DR1
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52,69,0)
       && pCodec->id != CODEC_ID_VP8
-#endif
      )
     m_pCodecContext->flags |= CODEC_FLAG_EMU_EDGE;
 #endif
@@ -272,16 +281,16 @@ bool CDVDVideoCodecFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options
     if (it->m_name == "surfaces")
       m_uSurfacesCount = std::atoi(it->m_value.c_str());
     else
-      m_dllAvUtil.av_set_string3(m_pCodecContext, it->m_name.c_str(), it->m_value.c_str(), 0, NULL);
+      m_dllAvUtil.av_opt_set(m_pCodecContext, it->m_name.c_str(), it->m_value.c_str(), 0);
   }
 
   int num_threads = std::min(8 /*MAX_THREADS*/, g_cpuInfo.getCPUCount());
   if( num_threads > 1 && !hints.software && m_pHardware == NULL // thumbnail extraction fails when run threaded
   && ( pCodec->id == CODEC_ID_H264
     || pCodec->id == CODEC_ID_MPEG4 ))
-    m_dllAvCodec.avcodec_thread_init(m_pCodecContext, num_threads);
+    m_pCodecContext->thread_count = num_threads;
 
-  if (m_dllAvCodec.avcodec_open(m_pCodecContext, pCodec) < 0)
+  if (m_dllAvCodec.avcodec_open2(m_pCodecContext, pCodec, NULL) < 0)
   {
     CLog::Log(LOGDEBUG,"CDVDVideoCodecFFmpeg::Open() Unable to open codec");
     return false;
@@ -290,14 +299,7 @@ bool CDVDVideoCodecFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options
   m_pFrame = m_dllAvCodec.avcodec_alloc_frame();
   if (!m_pFrame) return false;
 
-  if(pCodec->name)
-    m_name = CStdString("ff-") + pCodec->name;
-  else
-    m_name = "ffmpeg";
-
-  if(m_pHardware)
-    m_name += "-" + m_pHardware->Name();
-
+  UpdateName();
   return true;
 }
 
@@ -306,13 +308,6 @@ void CDVDVideoCodecFFmpeg::Dispose()
   if (m_pFrame) m_dllAvUtil.av_free(m_pFrame);
   m_pFrame = NULL;
 
-  if (m_pConvertFrame)
-  {
-    m_dllAvCodec.avpicture_free(m_pConvertFrame);
-    m_dllAvUtil.av_free(m_pConvertFrame);
-  }
-  m_pConvertFrame = NULL;
-
   if (m_pCodecContext)
   {
     if (m_pCodecContext->codec) m_dllAvCodec.avcodec_close(m_pCodecContext);
@@ -458,9 +453,6 @@ int CDVDVideoCodecFFmpeg::Decode(BYTE* pData, int iSize, double dts, double pts)
     return VC_ERROR;
   }
 
-  if (len != iSize && m_pCodecContext->skip_frame != AVDISCARD_NONREF)
-    CLog::Log(LOGWARNING, "%s - avcodec_decode_video didn't consume the full packet. size: %d, consumed: %d", __FUNCTION__, iSize, len);
-
   if (!iGotPicture)
     return VC_BUFFER;
 
@@ -478,67 +470,32 @@ int CDVDVideoCodecFFmpeg::Decode(BYTE* pData, int iSize, double dts, double pts)
   if(m_pCodecContext->codec_id == CODEC_ID_H264)
     m_started = true;
 
-  if(m_pCodecContext->pix_fmt != PIX_FMT_YUV420P
-  && m_pCodecContext->pix_fmt != PIX_FMT_YUVJ420P
-  && m_pHardware == NULL)
+  if(m_pHardware == NULL)
   {
-    if (!m_dllSwScale.IsLoaded() && !m_dllSwScale.Load())
-        return VC_ERROR;
+    bool need_scale = std::find( m_formats.begin()
+                               , m_formats.end()
+                               , m_pCodecContext->pix_fmt) == m_formats.end();
 
-    if (!m_pConvertFrame)
-    {
-      // Allocate an AVFrame structure
-      m_pConvertFrame = (AVPicture*)m_dllAvUtil.av_mallocz(sizeof(AVPicture));
-      // Due to a bug in swsscale we need to allocate one extra line of data
-      if(m_dllAvCodec.avpicture_alloc( m_pConvertFrame
-                                     , PIX_FMT_YUV420P
-                                     , m_pCodecContext->width
-                                     , m_pCodecContext->height+1) < 0)
-      {
-        m_dllAvUtil.av_free(m_pConvertFrame);
-        m_pConvertFrame = NULL;
-        return VC_ERROR;
-      }
-    }
+    bool need_reopen  = false;
+    if(!m_filters.Equals(m_filters_next))
+      need_reopen = true;
 
-    // convert the picture
-    struct SwsContext *context = m_dllSwScale.sws_getContext(m_pCodecContext->width, m_pCodecContext->height,
-                                         m_pCodecContext->pix_fmt, m_pCodecContext->width, m_pCodecContext->height,
-                                         PIX_FMT_YUV420P, SWS_FAST_BILINEAR | SwScaleCPUFlags(), NULL, NULL, NULL);
-
-    if(context == NULL)
+    if(m_pFilterIn)
     {
-      CLog::Log(LOGERROR, "CDVDVideoCodecFFmpeg::Decode - unable to obtain sws context for w:%i, h:%i, pixfmt: %i", m_pCodecContext->width, m_pCodecContext->height, m_pCodecContext->pix_fmt);
-      return VC_ERROR;
+      if(m_pFilterIn->outputs[0]->format != m_pCodecContext->pix_fmt
+      || m_pFilterIn->outputs[0]->w      != m_pCodecContext->width
+      || m_pFilterIn->outputs[0]->h      != m_pCodecContext->height)
+        need_reopen = true;
     }
 
-    m_dllSwScale.sws_scale(context
-                          , m_pFrame->data
-                          , m_pFrame->linesize
-                          , 0
-                          , m_pCodecContext->height
-                          , m_pConvertFrame->data
-                          , m_pConvertFrame->linesize);
-
-    m_dllSwScale.sws_freeContext(context);
-  }
-  else
-  {
-    // no need to convert, just free any existing convert buffers
-    if (m_pConvertFrame)
+    // try to setup new filters
+    if (need_reopen || (need_scale && m_pFilterGraph == NULL))
     {
-      m_dllAvCodec.avpicture_free(m_pConvertFrame);
-      m_dllAvUtil.av_free(m_pConvertFrame);
-      m_pConvertFrame = NULL;
-    }
-  }
+      m_filters = m_filters_next;
 
-  // try to setup new filters
-  if (!m_filters.Equals(m_filters_next))
-  {
-    m_filters = m_filters_next;
-    if(FilterOpen(m_filters) < 0)
-      FilterClose();
+      if(FilterOpen(m_filters, need_scale) < 0)
+        FilterClose();
+    }
   }
 
   int result;
@@ -564,12 +521,6 @@ void CDVDVideoCodecFFmpeg::Reset()
   if (m_pHardware)
     m_pHardware->Reset();
 
-  if (m_pConvertFrame)
-  {
-    m_dllAvCodec.avpicture_free(m_pConvertFrame);
-    m_dllAvUtil.av_free(m_pConvertFrame);
-    m_pConvertFrame = NULL;
-  }
   m_filters = "";
   FilterClose();
 }
@@ -579,10 +530,10 @@ bool CDVDVideoCodecFFmpeg::GetPictureCommon(DVDVideoPicture* pDvdVideoPicture)
   pDvdVideoPicture->iWidth = m_pCodecContext->width;
   pDvdVideoPicture->iHeight = m_pCodecContext->height;
 
-  if(m_pFilterLink)
+  if(m_pBufferRef)
   {
-    pDvdVideoPicture->iWidth  = m_pFilterLink->cur_buf->video->w;
-    pDvdVideoPicture->iHeight = m_pFilterLink->cur_buf->video->h;
+    pDvdVideoPicture->iWidth  = m_pBufferRef->video->w;
+    pDvdVideoPicture->iHeight = m_pBufferRef->video->h;
   }
 
   /* crop of 10 pixels if demuxer asked it */
@@ -598,12 +549,8 @@ bool CDVDVideoCodecFFmpeg::GetPictureCommon(DVDVideoPicture* pDvdVideoPicture)
 
   /* use variable in the frame */
   AVRational pixel_aspect = m_pCodecContext->sample_aspect_ratio;
-  if (m_pFilterLink)
-#ifdef HAVE_AVFILTERBUFFERREFVIDEOPROPS_SAMPLE_ASPECT_RATIO
-    pixel_aspect = m_pFilterLink->cur_buf->video->sample_aspect_ratio;
-#else
-    pixel_aspect = m_pFilterLink->cur_buf->video->pixel_aspect;
-#endif
+  if (m_pBufferRef)
+    pixel_aspect = m_pBufferRef->video->sample_aspect_ratio;
 
   if (pixel_aspect.num == 0)
     aspect_ratio = 0;
@@ -632,8 +579,6 @@ bool CDVDVideoCodecFFmpeg::GetPictureCommon(DVDVideoPicture* pDvdVideoPicture)
   pDvdVideoPicture->iFlags = DVP_FLAG_ALLOCATED;
   pDvdVideoPicture->iFlags |= m_pFrame->interlaced_frame ? DVP_FLAG_INTERLACED : 0;
   pDvdVideoPicture->iFlags |= m_pFrame->top_field_first ? DVP_FLAG_TOP_FIELD_FIRST: 0;
-  if(m_pCodecContext->pix_fmt == PIX_FMT_YUVJ420P)
-    pDvdVideoPicture->color_range = 1;
 
   pDvdVideoPicture->chroma_position = m_pCodecContext->chroma_sample_location;
   pDvdVideoPicture->color_primaries = m_pCodecContext->color_primaries;
@@ -677,14 +622,6 @@ bool CDVDVideoCodecFFmpeg::GetPicture(DVDVideoPicture* pDvdVideoPicture)
   if(!GetPictureCommon(pDvdVideoPicture))
     return false;
 
-  if(m_pConvertFrame)
-  {
-    for (int i = 0; i < 4; i++)
-      pDvdVideoPicture->data[i]      = m_pConvertFrame->data[i];
-    for (int i = 0; i < 4; i++)
-      pDvdVideoPicture->iLineSize[i] = m_pConvertFrame->linesize[i];
-  }
-  else
   {
     for (int i = 0; i < 4; i++)
       pDvdVideoPicture->data[i]      = m_pFrame->data[i];
@@ -693,20 +630,38 @@ bool CDVDVideoCodecFFmpeg::GetPicture(DVDVideoPicture* pDvdVideoPicture)
   }
 
   pDvdVideoPicture->iFlags |= pDvdVideoPicture->data[0] ? 0 : DVP_FLAG_DROPPED;
-  pDvdVideoPicture->format = DVDVideoPicture::FMT_YUV420P;
   pDvdVideoPicture->extended_format = 0;
+  pDvdVideoPicture->color_range = 0;
+
+  PixelFormat pix_fmt;
+  if(m_pBufferRef)
+    pix_fmt = (PixelFormat)m_pBufferRef->format;
+  else
+    pix_fmt = m_pCodecContext->pix_fmt;
+
+  switch(pix_fmt)
+  {
+    case PIX_FMT_YUVJ420P:
+      pDvdVideoPicture->format = DVDVideoPicture::FMT_YUV420P;
+      pDvdVideoPicture->color_range = 1;
+      break;
+    default:
+      pDvdVideoPicture->format = DVDVideoPicture::FMT_YUV420P;
+      break;
+  }
 
   return true;
 }
 
-int CDVDVideoCodecFFmpeg::FilterOpen(const CStdString& filters)
+int CDVDVideoCodecFFmpeg::FilterOpen(const CStdString& filters, bool scale)
 {
   int result;
+  AVBufferSinkParams *buffersink_params;
 
   if (m_pFilterGraph)
     FilterClose();
 
-  if (filters.IsEmpty())
+  if (filters.IsEmpty() && !scale)
     return 0;
 
   if (!(m_pFilterGraph = m_dllAvFilter.avfilter_graph_alloc()))
@@ -715,17 +670,8 @@ int CDVDVideoCodecFFmpeg::FilterOpen(const CStdString& filters)
     return -1;
   }
 
-  // CrHasher HACK (if an alternative becomes available use it!): In order to display the output
-  // produced by a combination of filters we insert "nullsink" as the last filter and we use
-  // its input pin as our output pin.
-  //
-  // input --> .. --> last_filter --> [in] nullsink [null]     [in] --> output
-  //                                   |                        |
-  //                                   |                        |
-  //                                   +------------------------+
-  //
   AVFilter* srcFilter = m_dllAvFilter.avfilter_get_by_name("buffer");
-  AVFilter* outFilter = m_dllAvFilter.avfilter_get_by_name("nullsink"); // should be last filter in the graph for now
+  AVFilter* outFilter = m_dllAvFilter.avfilter_get_by_name("buffersink"); // should be last filter in the graph for now
 
   CStdString args;
 
@@ -744,11 +690,19 @@ int CDVDVideoCodecFFmpeg::FilterOpen(const CStdString& filters)
     return result;
   }
 
-  if ((result = m_dllAvFilter.avfilter_graph_create_filter(&m_pFilterOut, outFilter, "out", NULL, NULL/*nullsink=>NULL*/, m_pFilterGraph)) < 0)
+  buffersink_params = m_dllAvFilter.av_buffersink_params_alloc();
+  buffersink_params->pixel_fmts = &m_formats[0];
+#ifdef FF_API_OLD_VSINK_API
+  if ((result = m_dllAvFilter.avfilter_graph_create_filter(&m_pFilterOut, outFilter, "out", NULL, (void*)buffersink_params->pixel_fmts, m_pFilterGraph)) < 0)
+#else
+  if ((result = m_dllAvFilter.avfilter_graph_create_filter(&m_pFilterOut, outFilter, "out", NULL, buffersink_params, m_pFilterGraph)) < 0)
+#endif
   {
+    m_dllAvUtil.av_freep(&buffersink_params);
     CLog::Log(LOGERROR, "CDVDVideoCodecFFmpeg::FilterOpen - avfilter_graph_create_filter: out");
     return result;
   }
+  m_dllAvUtil.av_freep(&buffersink_params);
 
   if (!filters.empty())
   {
@@ -794,6 +748,12 @@ int CDVDVideoCodecFFmpeg::FilterOpen(const CStdString& filters)
 
 void CDVDVideoCodecFFmpeg::FilterClose()
 {
+  if(m_pBufferRef)
+  {
+    m_dllAvFilter.avfilter_unref_buffer(m_pBufferRef);
+    m_pBufferRef = NULL;
+  }
+
   if (m_pFilterGraph)
   {
     m_dllAvFilter.avfilter_graph_free(&m_pFilterGraph);
@@ -801,7 +761,6 @@ void CDVDVideoCodecFFmpeg::FilterClose()
     // Disposed by above code
     m_pFilterIn   = NULL;
     m_pFilterOut  = NULL;
-    m_pFilterLink = NULL;
   }
 }
 
@@ -809,24 +768,9 @@ int CDVDVideoCodecFFmpeg::FilterProcess(AVFrame* frame)
 {
   int result, frames;
 
-  m_pFilterLink = m_pFilterOut->inputs[0];
-
   if (frame)
   {
-#if (defined USE_OLD_AV_VSRC_BUFFER_ADD_FRAME)
-    result = m_dllAvFilter.av_vsrc_buffer_add_frame(m_pFilterIn, frame, frame->pts, m_pCodecContext->sample_aspect_ratio);
-#else
-#if LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,13,0)
     result = m_dllAvFilter.av_vsrc_buffer_add_frame(m_pFilterIn, frame, 0);
-#elif LIBAVFILTER_VERSION_INT >= AV_VERSION_INT(2,7,0)
-    result = m_dllAvFilter.av_vsrc_buffer_add_frame(m_pFilterIn, frame);
-#elif LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(53,3,0)
-    result = m_dllAvFilter.av_vsrc_buffer_add_frame(m_pFilterIn, frame, frame->pts);
-#else
-    result = m_dllAvFilter.av_vsrc_buffer_add_frame(m_pFilterIn, frame, frame->pts, m_pCodecContext->sample_aspect_ratio);
-#endif
-#endif
-
     if (result < 0)
     {
       CLog::Log(LOGERROR, "CDVDVideoCodecFFmpeg::FilterProcess - av_vsrc_buffer_add_frame");
@@ -834,7 +778,13 @@ int CDVDVideoCodecFFmpeg::FilterProcess(AVFrame* frame)
     }
   }
 
-  if ((frames = m_dllAvFilter.avfilter_poll_frame(m_pFilterLink)) < 0)
+  if(m_pBufferRef)
+  {
+    m_dllAvFilter.avfilter_unref_buffer(m_pBufferRef);
+    m_pBufferRef = NULL;
+  }
+
+  if ((frames = m_dllAvFilter.av_buffersink_poll_frame(m_pFilterOut)) < 0)
   {
     CLog::Log(LOGERROR, "CDVDVideoCodecFFmpeg::FilterProcess - avfilter_poll_frame");
     return VC_ERROR;
@@ -842,19 +792,9 @@ int CDVDVideoCodecFFmpeg::FilterProcess(AVFrame* frame)
 
   if (frames > 0)
   {
-    if (m_pFilterLink->cur_buf)
-    {
-      m_dllAvFilter.avfilter_unref_buffer(m_pFilterLink->cur_buf);
-      m_pFilterLink->cur_buf = NULL;
-    }
-
-    if ((result = m_dllAvFilter.avfilter_request_frame(m_pFilterLink)) < 0)
-    {
-      CLog::Log(LOGERROR, "CDVDVideoCodecFFmpeg::FilterProcess - avfilter_request_frame");
-      return VC_ERROR;
-    }
 
-    if (!m_pFilterLink->cur_buf)
+    result = m_dllAvFilter.av_buffersink_get_buffer_ref(m_pFilterOut, &m_pBufferRef, 0);
+    if(!m_pBufferRef)
     {
       CLog::Log(LOGERROR, "CDVDVideoCodecFFmpeg::FilterProcess - cur_buf");
       return VC_ERROR;
@@ -865,11 +805,11 @@ int CDVDVideoCodecFFmpeg::FilterProcess(AVFrame* frame)
     else
       m_pFrame->repeat_pict      = -(frames - 1);
 
-    m_pFrame->interlaced_frame = m_pFilterLink->cur_buf->video->interlaced;
-    m_pFrame->top_field_first  = m_pFilterLink->cur_buf->video->top_field_first;
+    m_pFrame->interlaced_frame = m_pBufferRef->video->interlaced;
+    m_pFrame->top_field_first  = m_pBufferRef->video->top_field_first;
 
-    memcpy(m_pFrame->linesize, m_pFilterLink->cur_buf->linesize, 4*sizeof(int));
-    memcpy(m_pFrame->data    , m_pFilterLink->cur_buf->data    , 4*sizeof(uint8_t*));
+    memcpy(m_pFrame->linesize, m_pBufferRef->linesize, 4*sizeof(int));
+    memcpy(m_pFrame->data    , m_pBufferRef->data    , 4*sizeof(uint8_t*));
 
     if(frames > 1)
       return VC_PICTURE;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
index 53890cb..b958509 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
@@ -68,27 +68,36 @@ public:
   {
     SAFE_RELEASE(m_pHardware);
     m_pHardware = hardware;
-    m_name += "-";
-    m_name += m_pHardware->Name();
+    UpdateName();
   }
 
 protected:
   static enum PixelFormat GetFormat(struct AVCodecContext * avctx, const PixelFormat * fmt);
 
-  int  FilterOpen(const CStdString& filters);
+  int  FilterOpen(const CStdString& filters, bool scale);
   void FilterClose();
   int  FilterProcess(AVFrame* frame);
 
+  void UpdateName()
+  {
+    if(m_pCodecContext->codec->name)
+      m_name = CStdString("ff-") + m_pCodecContext->codec->name;
+    else
+      m_name = "ffmpeg";
+
+    if(m_pHardware)
+      m_name += "-" + m_pHardware->Name();
+  }
+
   AVFrame* m_pFrame;
   AVCodecContext* m_pCodecContext;
 
-  AVPicture* m_pConvertFrame;
   CStdString       m_filters;
   CStdString       m_filters_next;
   AVFilterGraph*   m_pFilterGraph;
   AVFilterContext* m_pFilterIn;
   AVFilterContext* m_pFilterOut;
-  AVFilterLink*    m_pFilterLink;
+  AVFilterBufferRef* m_pBufferRef;
 
   int m_iPictureWidth;
   int m_iPictureHeight;
@@ -109,4 +118,5 @@ protected:
   int m_iLastKeyframe;
   double m_dts;
   bool   m_started;
+  std::vector<PixelFormat> m_formats;
 };
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.cpp
index 0238864..c9f0650 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVDA.cpp
@@ -525,8 +525,8 @@ const int avc_parse_nal_units(DllAvFormat *av_format_ctx,
   {
     while (!*(nal_start++));
     nal_end = avc_find_startcode(nal_start, end);
-    av_format_ctx->put_be32(pb, nal_end - nal_start);
-    av_format_ctx->put_buffer(pb, nal_start, nal_end - nal_start);
+    av_format_ctx->avio_wb32(pb, nal_end - nal_start);
+    av_format_ctx->avio_write(pb, nal_start, nal_end - nal_start);
     size += 4 + nal_end - nal_start;
     nal_start = nal_end;
   }
@@ -537,14 +537,14 @@ const int avc_parse_nal_units_buf(DllAvUtil *av_util_ctx, DllAvFormat *av_format
   const uint8_t *buf_in, uint8_t **buf, int *size)
 {
   ByteIOContext *pb;
-  int ret = av_format_ctx->url_open_dyn_buf(&pb);
+  int ret = av_format_ctx->avio_open_dyn_buf(&pb);
   if (ret < 0)
     return ret;
 
   avc_parse_nal_units(av_format_ctx, pb, buf_in, *size);
 
   av_util_ctx->av_freep(buf);
-  *size = av_format_ctx->url_close_dyn_buf(pb, buf);
+  *size = av_format_ctx->avio_close_dyn_buf(pb, buf);
   return 0;
 }
 
@@ -590,26 +590,26 @@ const int isom_write_avcc(DllAvUtil *av_util_ctx, DllAvFormat *av_format_ctx,
       }
       assert(sps);
 
-      av_format_ctx->put_byte(pb, 1); /* version */
-      av_format_ctx->put_byte(pb, sps[1]); /* profile */
-      av_format_ctx->put_byte(pb, sps[2]); /* profile compat */
-      av_format_ctx->put_byte(pb, sps[3]); /* level */
-      av_format_ctx->put_byte(pb, 0xff); /* 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */
-      av_format_ctx->put_byte(pb, 0xe1); /* 3 bits reserved (111) + 5 bits number of sps (00001) */
+      av_format_ctx->avio_w8(pb, 1); /* version */
+      av_format_ctx->avio_w8(pb, sps[1]); /* profile */
+      av_format_ctx->avio_w8(pb, sps[2]); /* profile compat */
+      av_format_ctx->avio_w8(pb, sps[3]); /* level */
+      av_format_ctx->avio_w8(pb, 0xff); /* 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */
+      av_format_ctx->avio_w8(pb, 0xe1); /* 3 bits reserved (111) + 5 bits number of sps (00001) */
 
-      av_format_ctx->put_be16(pb, sps_size);
-      av_format_ctx->put_buffer(pb, sps, sps_size);
+      av_format_ctx->avio_wb16(pb, sps_size);
+      av_format_ctx->avio_write(pb, sps, sps_size);
       if (pps)
       {
-        av_format_ctx->put_byte(pb, 1); /* number of pps */
-        av_format_ctx->put_be16(pb, pps_size);
-        av_format_ctx->put_buffer(pb, pps, pps_size);
+        av_format_ctx->avio_w8(pb, 1); /* number of pps */
+        av_format_ctx->avio_wb16(pb, pps_size);
+        av_format_ctx->avio_write(pb, pps, pps_size);
       }
       av_util_ctx->av_free(start);
     }
     else
     {
-      av_format_ctx->put_buffer(pb, data, len);
+      av_format_ctx->avio_write(pb, data, len);
     }
   }
   return 0;
@@ -706,7 +706,7 @@ bool CDVDVideoCodecVDA::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
             }
 
             ByteIOContext *pb;
-            if (m_dllAvFormat->url_open_dyn_buf(&pb) < 0)
+            if (m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
             {
               return false;
             }
@@ -717,7 +717,7 @@ bool CDVDVideoCodecVDA::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
             // unhook from ffmpeg's extradata
             extradata = NULL;
             // extract the avcC atom data into extradata then write it into avcCData for VDADecoder
-            extrasize = m_dllAvFormat->url_close_dyn_buf(pb, &extradata);
+            extrasize = m_dllAvFormat->avio_close_dyn_buf(pb, &extradata);
             // CFDataCreate makes a copy of extradata contents
             avcCData = CFDataCreate(kCFAllocatorDefault, (const uint8_t*)extradata, extrasize);
             // done with the converted extradata, we MUST free using av_free
@@ -948,12 +948,12 @@ int CDVDVideoCodecVDA::Decode(BYTE* pData, int iSize, double dts, double pts)
       int demuxer_bytes;
       uint8_t *demuxer_content;
 
-      if(m_dllAvFormat->url_open_dyn_buf(&pb) < 0)
+      if(m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
       {
         return VC_ERROR;
       }
       demuxer_bytes = avc_parse_nal_units(m_dllAvFormat, pb, pData, iSize);
-      demuxer_bytes = m_dllAvFormat->url_close_dyn_buf(pb, &demuxer_content);
+      demuxer_bytes = m_dllAvFormat->avio_close_dyn_buf(pb, &demuxer_content);
       avc_demux = CFDataCreate(kCFAllocatorDefault, demuxer_content, demuxer_bytes);
       m_dllAvUtil->av_free(demuxer_content);
     }
@@ -961,7 +961,7 @@ int CDVDVideoCodecVDA::Decode(BYTE* pData, int iSize, double dts, double pts)
     {
       // convert demuxer packet from 3 byte NAL sizes to 4 byte
       ByteIOContext *pb;
-      if (m_dllAvFormat->url_open_dyn_buf(&pb) < 0)
+      if (m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
         return VC_ERROR;
 
       uint32_t nal_size;
@@ -970,14 +970,14 @@ int CDVDVideoCodecVDA::Decode(BYTE* pData, int iSize, double dts, double pts)
       while (nal_start < end)
       {
         nal_size = VDA_RB24(nal_start);
-        m_dllAvFormat->put_be32(pb, nal_size);
+        m_dllAvFormat->avio_wb32(pb, nal_size);
         nal_start += 3;
-        m_dllAvFormat->put_buffer(pb, nal_start, nal_size);
+        m_dllAvFormat->avio_write(pb, nal_start, nal_size);
         nal_start += nal_size;
       }
 
       uint8_t *demuxer_content;
-      int demuxer_bytes = m_dllAvFormat->url_close_dyn_buf(pb, &demuxer_content);
+      int demuxer_bytes = m_dllAvFormat->avio_close_dyn_buf(pb, &demuxer_content);
       avc_demux = CFDataCreate(kCFAllocatorDefault, demuxer_content, demuxer_bytes);
       m_dllAvUtil->av_free(demuxer_content);
     }
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.cpp
index 5f512fb..cca5318 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecVideoToolBox.cpp
@@ -474,7 +474,7 @@ int quicktime_write_mp4_descr_length(DllAvFormat *av_format_ctx, ByteIOContext *
     {
       b |= 0x80;
     }
-    av_format_ctx->put_byte(pb, b);
+    av_format_ctx->avio_w8(pb, b);
   }
 
   return numBytes; 
@@ -482,37 +482,37 @@ int quicktime_write_mp4_descr_length(DllAvFormat *av_format_ctx, ByteIOContext *
 
 void quicktime_write_esds(DllAvFormat *av_format_ctx, ByteIOContext *pb, quicktime_esds_t *esds)
 {
-  av_format_ctx->put_byte(pb, 0);     // Version
-  av_format_ctx->put_be24(pb, 0);     // Flags
+  av_format_ctx->avio_w8(pb, 0);     // Version
+  av_format_ctx->avio_wb24(pb, 0);     // Flags
 
   // elementary stream descriptor tag
-  av_format_ctx->put_byte(pb, 0x03);
+  av_format_ctx->avio_w8(pb, 0x03);
   quicktime_write_mp4_descr_length(av_format_ctx, pb,
     3 + 5 + (13 + 5 + esds->decoderConfigLen) + 3, false);
   // 3 bytes + 5 bytes for tag
-  av_format_ctx->put_be16(pb, esds->esid);
-  av_format_ctx->put_byte(pb, esds->stream_priority);
+  av_format_ctx->avio_wb16(pb, esds->esid);
+  av_format_ctx->avio_w8(pb, esds->stream_priority);
 
   // decoder configuration description tag
-  av_format_ctx->put_byte(pb, 0x04);
+  av_format_ctx->avio_w8(pb, 0x04);
   quicktime_write_mp4_descr_length(av_format_ctx, pb,
     13 + 5 + esds->decoderConfigLen, false);
   // 13 bytes + 5 bytes for tag
-  av_format_ctx->put_byte(pb, esds->objectTypeId); // objectTypeIndication
-  av_format_ctx->put_byte(pb, esds->streamType);   // streamType
-  av_format_ctx->put_be24(pb, esds->bufferSizeDB); // buffer size
-  av_format_ctx->put_be32(pb, esds->maxBitrate);   // max bitrate
-  av_format_ctx->put_be32(pb, esds->avgBitrate);   // average bitrate
+  av_format_ctx->avio_w8(pb, esds->objectTypeId); // objectTypeIndication
+  av_format_ctx->avio_w8(pb, esds->streamType);   // streamType
+  av_format_ctx->avio_wb24(pb, esds->bufferSizeDB); // buffer size
+  av_format_ctx->avio_wb32(pb, esds->maxBitrate);   // max bitrate
+  av_format_ctx->avio_wb32(pb, esds->avgBitrate);   // average bitrate
 
   // decoder specific description tag
-  av_format_ctx->put_byte(pb, 0x05);
+  av_format_ctx->avio_w8(pb, 0x05);
   quicktime_write_mp4_descr_length(av_format_ctx, pb, esds->decoderConfigLen, false);
-  av_format_ctx->put_buffer(pb, esds->decoderConfig, esds->decoderConfigLen);
+  av_format_ctx->avio_write(pb, esds->decoderConfig, esds->decoderConfigLen);
 
   // sync layer configuration descriptor tag
-  av_format_ctx->put_byte(pb, 0x06);  // tag
-  av_format_ctx->put_byte(pb, 0x01);  // length
-  av_format_ctx->put_byte(pb, 0x7F);  // no SL
+  av_format_ctx->avio_w8(pb, 0x06);  // tag
+  av_format_ctx->avio_w8(pb, 0x01);  // length
+  av_format_ctx->avio_w8(pb, 0x7F);  // no SL
 
   /* no IPI_DescrPointer */
 	/* no IP_IdentificationDataSet */
@@ -666,8 +666,8 @@ const int avc_parse_nal_units(DllAvFormat *av_format_ctx,
   {
     while (!*(nal_start++));
     nal_end = avc_find_startcode(nal_start, end);
-    av_format_ctx->put_be32(pb, nal_end - nal_start);
-    av_format_ctx->put_buffer(pb, nal_start, nal_end - nal_start);
+    av_format_ctx->avio_wb32(pb, nal_end - nal_start);
+    av_format_ctx->avio_write(pb, nal_start, nal_end - nal_start);
     size += 4 + nal_end - nal_start;
     nal_start = nal_end;
   }
@@ -678,14 +678,14 @@ const int avc_parse_nal_units_buf(DllAvUtil *av_util_ctx, DllAvFormat *av_format
   const uint8_t *buf_in, uint8_t **buf, int *size)
 {
   ByteIOContext *pb;
-  int ret = av_format_ctx->url_open_dyn_buf(&pb);
+  int ret = av_format_ctx->avio_open_dyn_buf(&pb);
   if (ret < 0)
     return ret;
 
   avc_parse_nal_units(av_format_ctx, pb, buf_in, *size);
 
   av_util_ctx->av_freep(buf);
-  *size = av_format_ctx->url_close_dyn_buf(pb, buf);
+  *size = av_format_ctx->avio_close_dyn_buf(pb, buf);
   return 0;
 }
 
@@ -770,26 +770,26 @@ const int isom_write_avcc(DllAvUtil *av_util_ctx, DllAvFormat *av_format_ctx,
       }
       assert(sps);
 
-      av_format_ctx->put_byte(pb, 1); /* version */
-      av_format_ctx->put_byte(pb, sps[1]); /* profile */
-      av_format_ctx->put_byte(pb, sps[2]); /* profile compat */
-      av_format_ctx->put_byte(pb, sps[3]); /* level */
-      av_format_ctx->put_byte(pb, 0xff); /* 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */
-      av_format_ctx->put_byte(pb, 0xe1); /* 3 bits reserved (111) + 5 bits number of sps (00001) */
+      av_format_ctx->avio_w8(pb, 1); /* version */
+      av_format_ctx->avio_w8(pb, sps[1]); /* profile */
+      av_format_ctx->avio_w8(pb, sps[2]); /* profile compat */
+      av_format_ctx->avio_w8(pb, sps[3]); /* level */
+      av_format_ctx->avio_w8(pb, 0xff); /* 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */
+      av_format_ctx->avio_w8(pb, 0xe1); /* 3 bits reserved (111) + 5 bits number of sps (00001) */
 
-      av_format_ctx->put_be16(pb, sps_size);
-      av_format_ctx->put_buffer(pb, sps, sps_size);
+      av_format_ctx->avio_wb16(pb, sps_size);
+      av_format_ctx->avio_write(pb, sps, sps_size);
       if (pps)
       {
-        av_format_ctx->put_byte(pb, 1); /* number of pps */
-        av_format_ctx->put_be16(pb, pps_size);
-        av_format_ctx->put_buffer(pb, pps, pps_size);
+        av_format_ctx->avio_w8(pb, 1); /* number of pps */
+        av_format_ctx->avio_wb16(pb, pps_size);
+        av_format_ctx->avio_write(pb, pps, pps_size);
       }
       av_util_ctx->av_free(start);
     }
     else
     {
-      av_format_ctx->put_buffer(pb, data, len);
+      av_format_ctx->avio_write(pb, data, len);
     }
   }
   return 0;
@@ -1086,7 +1086,7 @@ bool CDVDVideoCodecVideoToolBox::Open(CDVDStreamInfo &hints, CDVDCodecOptions &o
           ByteIOContext *pb;
           quicktime_esds_t *esds;
 
-          if (m_dllAvFormat->url_open_dyn_buf(&pb) < 0)
+          if (m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
             return false;
 
           esds = quicktime_set_esds(m_dllAvFormat, extradata, extrasize);
@@ -1095,7 +1095,7 @@ bool CDVDVideoCodecVideoToolBox::Open(CDVDStreamInfo &hints, CDVDCodecOptions &o
           // unhook from ffmpeg's extradata
           extradata = NULL;
           // extract the esds atom decoderConfig from extradata
-          extrasize = m_dllAvFormat->url_close_dyn_buf(pb, &extradata);
+          extrasize = m_dllAvFormat->avio_close_dyn_buf(pb, &extradata);
           free(esds->decoderConfig);
           free(esds);
 
@@ -1152,7 +1152,7 @@ bool CDVDVideoCodecVideoToolBox::Open(CDVDStreamInfo &hints, CDVDCodecOptions &o
             // NAL reformating to bitstream format required
 
             ByteIOContext *pb;
-            if (m_dllAvFormat->url_open_dyn_buf(&pb) < 0)
+            if (m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
               return false;
 
             m_convert_bytestream = true;
@@ -1161,7 +1161,7 @@ bool CDVDVideoCodecVideoToolBox::Open(CDVDStreamInfo &hints, CDVDCodecOptions &o
             // unhook from ffmpeg's extradata
             extradata = NULL;
             // extract the avcC atom data into extradata getting size into extrasize
-            extrasize = m_dllAvFormat->url_close_dyn_buf(pb, &extradata);
+            extrasize = m_dllAvFormat->avio_close_dyn_buf(pb, &extradata);
 
             // check for interlaced and get number of ref frames
             if (!validate_avcC_spc(extradata, extrasize, &m_max_ref_frames))
@@ -1301,17 +1301,17 @@ int CDVDVideoCodecVideoToolBox::Decode(BYTE* pData, int iSize, double dts, doubl
     if (m_convert_bytestream)
     {
       // convert demuxer packet from bytestream (AnnexB) to bitstream
-      if(m_dllAvFormat->url_open_dyn_buf(&pb) < 0)
+      if(m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
         return VC_ERROR;
 
       demux_size = avc_parse_nal_units(m_dllAvFormat, pb, pData, iSize);
-      demux_size = m_dllAvFormat->url_close_dyn_buf(pb, &demux_buff);
+      demux_size = m_dllAvFormat->avio_close_dyn_buf(pb, &demux_buff);
       sampleBuff = CreateSampleBufferFrom(m_fmt_desc, demux_buff, demux_size);
     }
     else if (m_convert_3byteTo4byteNALSize)
     {
       // convert demuxer packet from 3 byte NAL sizes to 4 byte
-      if (m_dllAvFormat->url_open_dyn_buf(&pb) < 0)
+      if (m_dllAvFormat->avio_open_dyn_buf(&pb) < 0)
         return VC_ERROR;
 
       uint32_t nal_size;
@@ -1320,13 +1320,13 @@ int CDVDVideoCodecVideoToolBox::Decode(BYTE* pData, int iSize, double dts, doubl
       while (nal_start < end)
       {
         nal_size = VDA_RB24(nal_start);
-        m_dllAvFormat->put_be32(pb, nal_size);
+        m_dllAvFormat->avio_wb32(pb, nal_size);
         nal_start += 3;
-        m_dllAvFormat->put_buffer(pb, nal_start, nal_size);
+        m_dllAvFormat->avio_write(pb, nal_start, nal_size);
         nal_start += nal_size;
       }
 
-      demux_size = m_dllAvFormat->url_close_dyn_buf(pb, &demux_buff);
+      demux_size = m_dllAvFormat->avio_close_dyn_buf(pb, &demux_buff);
       sampleBuff = CreateSampleBufferFrom(m_fmt_desc, demux_buff, demux_size);
     }
     else
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
index 18fe368..a4b8725 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
@@ -223,7 +223,6 @@ int CDecoder::GetBuffer(AVCodecContext *avctx, AVFrame *pic)
   }
 
   pic->type           = FF_BUFFER_TYPE_USER;
-  pic->age            = 1;
   pic->data[0]        = (uint8_t*)wrapper;
   pic->data[1]        = NULL;
   pic->data[2]        = NULL;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 0e67af3..7379d60 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -1211,14 +1211,12 @@ int CVDPAU::FFGetBuffer(AVCodecContext *avctx, AVFrame *pic)
 
   if(pic->reference)
   {
-    pic->age = pA->ip_age[0];
     pA->ip_age[0]= pA->ip_age[1]+1;
     pA->ip_age[1]= 1;
     pA->b_age++;
   }
   else
   {
-    pic->age = pA->b_age;
     pA->ip_age[0]++;
     pA->ip_age[1]++;
     pA->b_age = 1;
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index 55138fa..31b6634 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -161,7 +161,7 @@ static TLS g_tls;
 #define g_demuxer (*((CDVDDemuxFFmpeg**)g_tls.Get()))
 #endif
 
-static int interrupt_cb(void)
+static int interrupt_cb(void* unused)
 {
   if(g_demuxer && g_demuxer->Aborted())
     return 1;
@@ -179,7 +179,7 @@ static int dvd_file_open(URLContext *h, const char *filename, int flags)
 
 static int dvd_file_read(void *h, uint8_t* buf, int size)
 {
-  if(interrupt_cb())
+  if(interrupt_cb(NULL))
     return -1;
 
   CDVDInputStream* pInputStream = (CDVDInputStream*)h;
@@ -193,7 +193,7 @@ static int dvd_file_write(URLContext *h, BYTE* buf, int size)
 */
 static offset_t dvd_file_seek(void *h, offset_t pos, int whence)
 {
-  if(interrupt_cb())
+  if(interrupt_cb(NULL))
     return -1;
 
   CDVDInputStream* pInputStream = (CDVDInputStream*)h;
@@ -237,6 +237,7 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput)
   m_speed = DVD_PLAYSPEED_NORMAL;
   g_demuxer = this;
   m_program = UINT_MAX;
+  const AVIOInterruptCB int_cb = { interrupt_cb, NULL };
 
   if (!pInput) return false;
 
@@ -247,10 +248,6 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput)
 
   // register codecs
   m_dllAvFormat.av_register_all();
-  m_dllAvFormat.url_set_interrupt_cb(interrupt_cb);
-
-  // could be used for interupting ffmpeg while opening a file (eg internet streams)
-  // url_set_interrupt_cb(NULL);
 
   m_pInput = pInput;
   strFile = m_pInput->GetFileName();
@@ -285,14 +282,14 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput)
       // try mmsh, then mmst
       CStdString strFile2;
       strFile2.Format("mmsh://%s",strFile.substr(6,strFile.size()-6).c_str());
-      result = m_dllAvFormat.av_open_input_file(&m_pFormatContext, strFile2.c_str(), iformat, FFMPEG_FILE_BUFFER_SIZE, NULL);
+      result = m_dllAvFormat.avformat_open_input(&m_pFormatContext, strFile2.c_str(), iformat, NULL);
       if (result < 0)
       {
         strFile = "mmst://";
         strFile += strFile2.Mid(7).c_str();
       } 
     }
-    if (result < 0 && m_dllAvFormat.av_open_input_file(&m_pFormatContext, strFile.c_str(), iformat, FFMPEG_FILE_BUFFER_SIZE, NULL) < 0 )
+    if (result < 0 && m_dllAvFormat.avformat_open_input(&m_pFormatContext, strFile.c_str(), iformat, NULL) < 0 )
     {
       CLog::Log(LOGDEBUG, "Error, could not open file %s", strFile.c_str());
       Dispose();
@@ -302,24 +299,16 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput)
   else
   {
     unsigned char* buffer = (unsigned char*)m_dllAvUtil.av_malloc(FFMPEG_FILE_BUFFER_SIZE);
-    m_ioContext = m_dllAvFormat.av_alloc_put_byte(buffer, FFMPEG_FILE_BUFFER_SIZE, 0, m_pInput, dvd_file_read, NULL, dvd_file_seek);
+    m_ioContext = m_dllAvFormat.avio_alloc_context(buffer, FFMPEG_FILE_BUFFER_SIZE, 0, m_pInput, dvd_file_read, NULL, dvd_file_seek);
     m_ioContext->max_packet_size = m_pInput->GetBlockSize();
     if(m_ioContext->max_packet_size)
       m_ioContext->max_packet_size *= FFMPEG_FILE_BUFFER_SIZE / m_ioContext->max_packet_size;
 
     if(m_pInput->Seek(0, SEEK_POSSIBLE) == 0)
-      m_ioContext->is_streamed = 1;
+      m_ioContext->seekable = 0;
 
     if( iformat == NULL )
     {
-#if defined(USE_EXTERNAL_FFMPEG) && LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(52,98,0)
-      // API added on: 2011-02-09
-      // Old versions of ffmpeg do not have av_probe_input_format, so we need
-      // to always probe using the lower-level functions as well.
-      const bool legacyProbing = true;
-#else
-      const bool legacyProbing = false;
-#endif
       // let ffmpeg decide which demuxer we have to open
 
       bool trySPDIFonly = (m_pInput->GetContent() == "audio/x-spdif-compressed");
@@ -332,7 +321,7 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput)
       // want to probe for spdif (DTS or IEC 61937) compressed audio
       // specifically, or in case the file is a wav which may contain DTS or
       // IEC 61937 (e.g. ac3-in-wav) and we want to check for those formats.
-      if (legacyProbing || trySPDIFonly || (iformat && strcmp(iformat->name, "wav") == 0))
+      if (trySPDIFonly || (iformat && strcmp(iformat->name, "wav") == 0))
       {
         AVProbeData pd;
         BYTE probe_buffer[FFMPEG_FILE_BUFFER_SIZE + AVPROBE_PADDING_SIZE];
@@ -342,7 +331,7 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput)
         pd.filename = strFile.c_str();
 
         // read data using avformat's buffers
-        pd.buf_size = m_dllAvFormat.get_buffer(m_ioContext, pd.buf, m_ioContext->max_packet_size ? m_ioContext->max_packet_size : m_ioContext->buffer_size);
+        pd.buf_size = m_dllAvFormat.avio_read(m_ioContext, pd.buf, m_ioContext->max_packet_size ? m_ioContext->max_packet_size : m_ioContext->buffer_size);
         if (pd.buf_size <= 0)
         {
           CLog::Log(LOGERROR, "%s - error reading from input stream, %s", __FUNCTION__, strFile.c_str());
@@ -351,10 +340,7 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput)
         memset(pd.buf+pd.buf_size, 0, AVPROBE_PADDING_SIZE);
 
         // restore position again
-        m_dllAvFormat.url_fseek(m_ioContext , 0, SEEK_SET);
-
-        if (legacyProbing && !trySPDIFonly)
-          iformat = m_dllAvFormat.av_probe_input_format(&pd, 1);
+        m_dllAvFormat.avio_seek(m_ioContext , 0, SEEK_SET);
 
         // the advancedsetting is for allowing the user to force outputting the
         // 44.1 kHz DTS wav file as PCM, so that an A/V receiver can decode
@@ -425,7 +411,10 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput)
 
 
     // open the demuxer
-    if (m_dllAvFormat.av_open_input_stream(&m_pFormatContext, m_ioContext, strFile.c_str(), iformat, NULL) < 0)
+    m_pFormatContext     = m_dllAvFormat.avformat_alloc_context();
+    m_pFormatContext->pb = m_ioContext;
+
+    if (m_dllAvFormat.avformat_open_input(&m_pFormatContext, strFile.c_str(), iformat, NULL) < 0)
     {
       CLog::Log(LOGERROR, "%s - Error, could not open file %s", __FUNCTION__, strFile.c_str());
       Dispose();
@@ -433,8 +422,11 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput)
     }
   }
 
+  // set the interrupt callback, appeared in libavformat 53.15.0
+  m_pFormatContext->interrupt_callback = int_cb;
+
   // analyse very short to speed up mjpeg playback start
-  if (iformat && (strcmp(iformat->name, "mjpeg") == 0) && m_ioContext->is_streamed)
+  if (iformat && (strcmp(iformat->name, "mjpeg") == 0) && m_ioContext->seekable == 0)
     m_pFormatContext->max_analyze_duration = 500000;
 
   // we need to know if this is matroska or avi later
@@ -448,8 +440,8 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput)
       m_pFormatContext->max_analyze_duration = 500000;
 
 
-    CLog::Log(LOGDEBUG, "%s - av_find_stream_info starting", __FUNCTION__);
-    int iErr = m_dllAvFormat.av_find_stream_info(m_pFormatContext);
+    CLog::Log(LOGDEBUG, "%s - avformat_find_stream_info starting", __FUNCTION__);
+    int iErr = m_dllAvFormat.avformat_find_stream_info(m_pFormatContext, NULL);
     if (iErr < 0)
     {
       CLog::Log(LOGWARNING,"could not find codec parameters for %s", strFile.c_str());
@@ -472,7 +464,7 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput)
   m_pFormatContext->flags |= AVFMT_FLAG_NONBLOCK;
 
   // print some extra information
-  m_dllAvFormat.dump_format(m_pFormatContext, 0, strFile.c_str(), 0);
+  m_dllAvFormat.av_dump_format(m_pFormatContext, 0, strFile.c_str(), 0);
 
   UpdateCurrentPTS();
 
@@ -511,20 +503,12 @@ void CDVDDemuxFFmpeg::Dispose()
 
   if (m_pFormatContext)
   {
-    if (m_ioContext)
+    if (m_ioContext && m_pFormatContext->pb && m_pFormatContext->pb != m_ioContext)
     {
-      if(m_pFormatContext->pb && m_pFormatContext->pb != m_ioContext)
-      {
-        CLog::Log(LOGWARNING, "CDVDDemuxFFmpeg::Dispose - demuxer changed our byte context behind our back, possible memleak");
-        m_ioContext = m_pFormatContext->pb;
-      }
-      m_dllAvFormat.av_close_input_stream(m_pFormatContext);
-      if (m_ioContext->buffer)
-        m_dllAvUtil.av_free(m_ioContext->buffer);
-      m_dllAvUtil.av_free(m_ioContext);
+      CLog::Log(LOGWARNING, "CDVDDemuxFFmpeg::Dispose - demuxer changed our byte context behind our back, possible memleak");
+      m_ioContext = m_pFormatContext->pb;
     }
-    else
-      m_dllAvFormat.av_close_input_file(m_pFormatContext);
+    m_dllAvFormat.avformat_close_input(&m_pFormatContext);
   }
   m_ioContext = NULL;
   m_pFormatContext = NULL;
@@ -774,19 +758,12 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
           {
             stream->duration = duration;
             duration = m_dllAvUtil.av_rescale_rnd(stream->duration, (int64_t)stream->time_base.num * AV_TIME_BASE, stream->time_base.den, AV_ROUND_NEAR_INF);
-            if ((m_pFormatContext->duration == (int64_t)AV_NOPTS_VALUE && m_pFormatContext->file_size > 0)
+            if ((m_pFormatContext->duration == (int64_t)AV_NOPTS_VALUE)
                 ||  (m_pFormatContext->duration != (int64_t)AV_NOPTS_VALUE && duration > m_pFormatContext->duration))
               m_pFormatContext->duration = duration;
           }
         }
 
-        // check if stream seem to have grown since start
-        if(m_pFormatContext->file_size > 0 && m_pFormatContext->pb)
-        {
-          if(m_pFormatContext->pb->pos > m_pFormatContext->file_size)
-            m_pFormatContext->file_size = m_pFormatContext->pb->pos;
-        }
-
         pPacket->iStreamId = pkt.stream_index; // XXX just for now
       }
       m_dllAvCodec.av_free_packet(&pkt);
@@ -924,19 +901,6 @@ int CDVDDemuxFFmpeg::GetStreamLength()
   if (!m_pFormatContext)
     return 0;
 
-  /* apperently ffmpeg messes up sometimes, so check for negative value too */
-  if (m_pFormatContext->duration == (int64_t)AV_NOPTS_VALUE || m_pFormatContext->duration < 0LL)
-  {
-    // no duration is available for us
-    // try to calculate it
-    int iLength = 0;
-    if (m_iCurrentPts != DVD_NOPTS_VALUE && m_pFormatContext->file_size > 0 && m_pFormatContext->pb && m_pFormatContext->pb->pos > 0)
-    {
-      iLength = (int)(((m_iCurrentPts * m_pFormatContext->file_size) / m_pFormatContext->pb->pos) / 1000) & 0xFFFFFFFF;
-    }
-    return iLength;
-  }
-
   return (int)(m_pFormatContext->duration / (AV_TIME_BASE / 1000));
 }
 
@@ -971,6 +935,12 @@ static double SelectAspect(AVStream* st, bool* forced)
 
 void CDVDDemuxFFmpeg::AddStream(int iId)
 {
+  if(iId >= MAX_STREAMS)
+  {
+    CLog::Log(LOGWARNING, "%s - streams id %d exeeds maximum supported", __FUNCTION__, iId);
+    return;
+  }
+
   AVStream* pStream = m_pFormatContext->streams[iId];
   if (pStream)
   {
@@ -988,8 +958,8 @@ void CDVDDemuxFFmpeg::AddStream(int iId)
         st->iBitRate = pStream->codec->bit_rate;
         st->iBitsPerSample = pStream->codec->bits_per_coded_sample;
 	
-        if(m_dllAvFormat.av_metadata_get(pStream->metadata, "title", NULL, 0))
-          st->m_description = m_dllAvFormat.av_metadata_get(pStream->metadata, "title", NULL, 0)->value;
+        if(m_dllAvUtil.av_dict_get(pStream->metadata, "title", NULL, 0))
+          st->m_description = m_dllAvUtil.av_dict_get(pStream->metadata, "title", NULL, 0)->value;
 
         break;
       }
@@ -1078,8 +1048,8 @@ void CDVDDemuxFFmpeg::AddStream(int iId)
           if(pStream->codec)
             st->identifier = pStream->codec->sub_id;
 	    
-          if(m_dllAvFormat.av_metadata_get(pStream->metadata, "title", NULL, 0))
-            st->m_description = m_dllAvFormat.av_metadata_get(pStream->metadata, "title", NULL, 0)->value;
+          if(m_dllAvUtil.av_dict_get(pStream->metadata, "title", NULL, 0))
+            st->m_description = m_dllAvUtil.av_dict_get(pStream->metadata, "title", NULL, 0)->value;
 	
           break;
         }
@@ -1090,7 +1060,7 @@ void CDVDDemuxFFmpeg::AddStream(int iId)
         {
           std::string fileName = "special://temp/fonts/";
           XFILE::CDirectory::Create(fileName);
-          AVMetadataTag *nameTag = m_dllAvFormat.av_metadata_get(pStream->metadata, "filename", NULL, 0);
+          AVDictionaryEntry *nameTag = m_dllAvUtil.av_dict_get(pStream->metadata, "filename", NULL, 0);
           if (!nameTag) {
             CLog::Log(LOGERROR, "%s: TTF attachment has no name", __FUNCTION__);
             break;
@@ -1139,7 +1109,7 @@ void CDVDDemuxFFmpeg::AddStream(int iId)
     // API added on: 2010-10-15
     // (Note that while the function was available earlier, the generic
     // metadata tags were not populated by default)
-    AVMetadataTag *langTag = m_dllAvFormat.av_metadata_get(pStream->metadata, "language", NULL, 0);
+    AVDictionaryEntry *langTag = m_dllAvUtil.av_dict_get(pStream->metadata, "language", NULL, 0);
     if (langTag)
       strncpy(m_streams[iId]->language, langTag->value, 3);
 #else
@@ -1249,7 +1219,7 @@ void CDVDDemuxFFmpeg::GetChapterName(std::string& strChapterName)
       // API added on: 2010-10-15
       // (Note that while the function was available earlier, the generic
       // metadata tags were not populated by default)
-      AVMetadataTag *titleTag = m_dllAvFormat.av_metadata_get(m_pFormatContext->chapters[chapterIdx-1]->metadata,
+      AVDictionaryEntry *titleTag = m_dllAvUtil.av_dict_get(m_pFormatContext->chapters[chapterIdx-1]->metadata,
                                                               "title", NULL, 0);
       if (titleTag)
         strChapterName = titleTag->value;
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
index 018d9b3..84ea4b7 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
@@ -128,7 +128,7 @@ protected:
   #define MAX_STREAMS 100
   CDemuxStream* m_streams[MAX_STREAMS]; // maximum number of streams that ffmpeg can handle
 
-  ByteIOContext* m_ioContext;
+  AVIOContext* m_ioContext;
 
   DllAvFormat m_dllAvFormat;
   DllAvCodec  m_dllAvCodec;
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index e28faaf..eb51038 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -413,6 +413,7 @@ void CDVDPlayerVideo::Process()
     {
       if(m_pVideoCodec)
         m_pVideoCodec->Reset();
+      picture.iFlags &= ~DVP_FLAG_ALLOCATED;
       m_packets.clear();
       m_started = false;
     }
@@ -420,6 +421,7 @@ void CDVDPlayerVideo::Process()
     {
       if(m_pVideoCodec)
         m_pVideoCodec->Reset();
+      picture.iFlags &= ~DVP_FLAG_ALLOCATED;
       m_packets.clear();
 
       m_pullupCorrection.Flush();
