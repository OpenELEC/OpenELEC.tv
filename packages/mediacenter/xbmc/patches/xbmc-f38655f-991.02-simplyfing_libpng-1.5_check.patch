From d6d1dd650bbe94fc2b106af239e7d476879feaff Mon Sep 17 00:00:00 2001
From: bobo1on1 <bob-nospam-@xbmc.org>
Date: Sun, 18 Mar 2012 01:02:12 +0100
Subject: [PATCH] fixed: do the libpng version check in only one place

---
 lib/cximage-6.0/CxImage/ximapng.cpp |   90 +++++++++++++++++-----------------
 lib/cximage-6.0/CxImage/ximapng.h   |    6 ++-
 2 files changed, 50 insertions(+), 46 deletions(-)

diff --git a/lib/cximage-6.0/CxImage/ximapng.cpp b/lib/cximage-6.0/CxImage/ximapng.cpp
index 3e0cf73..adadeea 100644
--- a/lib/cximage-6.0/CxImage/ximapng.cpp
+++ b/lib/cximage-6.0/CxImage/ximapng.cpp
@@ -15,7 +15,7 @@
 void CxImagePNG::ima_png_error(png_struct *png_ptr, char *message)
 {
 	strcpy(info.szLastError,message);
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 	longjmp(png_jmpbuf(png_ptr), 1);
 #else
 	longjmp(png_ptr->jmpbuf, 1);
@@ -66,7 +66,7 @@ bool CxImagePNG::Decode(CxFile *hFile)
     /* Set error handling if you are using the setjmp/longjmp method (this is
     * the normal method of doing things with libpng).  REQUIRED unless you
     * set up your own error handlers in the png_create_read_struct() earlier. */
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 	if (setjmp(png_jmpbuf(png_ptr))) {
 #else
 	if (setjmp(png_ptr->jmpbuf)) {
@@ -84,7 +84,7 @@ bool CxImagePNG::Decode(CxFile *hFile)
 	/* read the file information */
 	png_read_info(png_ptr, info_ptr);
 
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 	png_uint_32 _width,_height;
 	int _bit_depth,_color_type,_interlace_type,_compression_type,_filter_type;
 	png_get_IHDR(png_ptr,info_ptr,&_width,&_height,&_bit_depth,&_color_type,
@@ -107,7 +107,7 @@ bool CxImagePNG::Decode(CxFile *hFile)
 
 	/* calculate new number of channels */
 	int channels=0;
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 	switch(_color_type){
 #else
 	switch(info_ptr->color_type){
@@ -127,7 +127,7 @@ bool CxImagePNG::Decode(CxFile *hFile)
 		break;
 	default:
 		strcpy(info.szLastError,"unknown PNG color type");
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 		longjmp(png_jmpbuf(png_ptr), 1);
 #else
 		longjmp(png_ptr->jmpbuf, 1);
@@ -135,7 +135,7 @@ bool CxImagePNG::Decode(CxFile *hFile)
 	}
 
 	//find the right pixel depth used for cximage
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 	int pixel_depth = _bit_depth * png_get_channels(png_ptr,info_ptr);
 #else
 	int pixel_depth = info_ptr->pixel_depth;
@@ -144,7 +144,7 @@ bool CxImagePNG::Decode(CxFile *hFile)
 	if (channels == 2) pixel_depth=8;
 	if (channels >= 3) pixel_depth=24;
 
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 	if (!Create(_width, _height, pixel_depth, CXIMAGE_FORMAT_PNG)){
 		longjmp(png_jmpbuf(png_ptr), 1);
 #else
@@ -154,7 +154,7 @@ bool CxImagePNG::Decode(CxFile *hFile)
 	}
 
 	/* get metrics */
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 	png_uint_32 _x_pixels_per_unit,_y_pixels_per_unit;
 	int _phys_unit_type;
 	png_get_pHYs(png_ptr,info_ptr,&_x_pixels_per_unit,&_y_pixels_per_unit,&_phys_unit_type);
@@ -183,7 +183,7 @@ bool CxImagePNG::Decode(CxFile *hFile)
 	}
 #endif
 
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 	int _num_palette;
 	png_colorp _palette;
 	png_uint_32 _palette_ret;
@@ -204,13 +204,13 @@ bool CxImagePNG::Decode(CxFile *hFile)
 		SetPaletteColor(3,255,255,255);
 	} else SetGrayPalette(); //<DP> needed for grayscale PNGs
 	
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 	int nshift = max(0,(_bit_depth>>3)-1)<<3;
 #else
 	int nshift = max(0,(info_ptr->bit_depth>>3)-1)<<3;
 #endif
 
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 	png_bytep _trans_alpha;
 	int _num_trans;
 	png_color_16p _trans_color;
@@ -224,7 +224,7 @@ bool CxImagePNG::Decode(CxFile *hFile)
 		if (info_ptr->num_trans==1){
 			if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE){
 #endif
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 				info.nBkgndIndex = _trans_color->index;
 #else
 #if PNG_LIBPNG_VER > 10399
@@ -234,7 +234,7 @@ bool CxImagePNG::Decode(CxFile *hFile)
 #endif
 #endif
 			} else{
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 				info.nBkgndIndex = _trans_color->gray>>nshift;
 #else
 #if PNG_LIBPNG_VER > 10399
@@ -245,7 +245,7 @@ bool CxImagePNG::Decode(CxFile *hFile)
 #endif
 			}
 		}
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 		if (_num_trans>1 && _trans_alpha!=NULL){
 #else
 		if (info_ptr->num_trans>1){
@@ -253,7 +253,7 @@ bool CxImagePNG::Decode(CxFile *hFile)
 			RGBQUAD* pal=GetPalette();
 			if (pal){
 				DWORD ip;
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 				for (ip=0;ip<min(head.biClrUsed,(unsigned long)_num_trans);ip++)
 					pal[ip].rgbReserved=_trans_alpha[ip];
 #else
@@ -264,7 +264,7 @@ bool CxImagePNG::Decode(CxFile *hFile)
 					pal[ip].rgbReserved=info_ptr->trans[ip];
 #endif
 #endif
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 				for (ip=_num_trans;ip<head.biClrUsed;ip++){
 #else
 				for (ip=info_ptr->num_trans;ip<head.biClrUsed;ip++){
@@ -281,7 +281,7 @@ bool CxImagePNG::Decode(CxFile *hFile)
 		int num_trans;
 		png_color_16 *image_background;
 		if (png_get_tRNS(png_ptr, info_ptr, &trans, &num_trans, &image_background)){
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 			info.nBkgndColor.rgbRed   = (BYTE)(_trans_color->red>>nshift);
 			info.nBkgndColor.rgbGreen = (BYTE)(_trans_color->green>>nshift);
 			info.nBkgndColor.rgbBlue  = (BYTE)(_trans_color->blue>>nshift);
@@ -311,7 +311,7 @@ bool CxImagePNG::Decode(CxFile *hFile)
 	}
 
 	// <vho> - flip the RGB pixels to BGR (or RGBA to BGRA)
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 	if (_color_type & PNG_COLOR_MASK_COLOR){
 #else
 	if (info_ptr->color_type & PNG_COLOR_MASK_COLOR){
@@ -320,14 +320,14 @@ bool CxImagePNG::Decode(CxFile *hFile)
 	}
 
 	// <vho> - handle cancel
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 	if (info.nEscape) longjmp(png_jmpbuf(png_ptr), 1);
 #else
 	if (info.nEscape) longjmp(png_ptr->jmpbuf, 1);
 #endif
 
 	// row_bytes is the width x number of channels x (bit-depth / 8)
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 	row_pointers = new BYTE[png_get_rowbytes(png_ptr,info_ptr) + 8];
 #else
 	row_pointers = new BYTE[info_ptr->rowbytes + 8];
@@ -342,12 +342,12 @@ bool CxImagePNG::Decode(CxFile *hFile)
 		SetCodecOption(0);
 	}
 
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 	int chan_offset = _bit_depth >> 3;
 #else
 	int chan_offset = info_ptr->bit_depth >> 3;
 #endif
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 	int pixel_offset = (_bit_depth * png_get_channels(png_ptr,info_ptr)) >> 3;
 #else
 	int pixel_offset = info_ptr->pixel_depth >> 3;
@@ -359,7 +359,7 @@ bool CxImagePNG::Decode(CxFile *hFile)
 		do	{
 
 			// <vho> - handle cancel
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 			if (info.nEscape) longjmp(png_jmpbuf(png_ptr), 1);
 #else
 			if (info.nEscape) longjmp(png_ptr->jmpbuf, 1);
@@ -374,7 +374,7 @@ bool CxImagePNG::Decode(CxFile *hFile)
 				BYTE* prow= iter.GetRow(ay);
 
 				//recover data from previous scan
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 				if (_interlace_type && pass>0 && pass!=7){
 #else
 				if (info_ptr->interlace_type && pass>0 && pass!=7){
@@ -415,7 +415,7 @@ bool CxImagePNG::Decode(CxFile *hFile)
 #endif // CXIMAGE_SUPPORT_ALPHA		// vho
 			{
 				//recover data from previous scan
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 				if (_interlace_type && pass>0){
 					iter.GetRow(row_pointers, png_get_rowbytes(png_ptr,info_ptr));
 					//re-expand buffer for images with bit depth > 8
@@ -435,7 +435,7 @@ bool CxImagePNG::Decode(CxFile *hFile)
 				png_read_row(png_ptr, row_pointers, NULL);
 
 				//shrink 16 bit depth images down to 8 bits
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 				if (_bit_depth > 8){
 #else
 				if (info_ptr->bit_depth > 8){
@@ -445,13 +445,13 @@ bool CxImagePNG::Decode(CxFile *hFile)
 				}
 
 				//copy the pixels
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 				iter.SetRow(row_pointers, png_get_rowbytes(png_ptr,info_ptr));
 #else
 				iter.SetRow(row_pointers, info_ptr->rowbytes);
 #endif
 				//<DP> expand 2 bpp images only in the last pass
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 				if (_bit_depth==2 && pass==(number_passes-1))
 #else
 				if (info_ptr->bit_depth==2 && pass==(number_passes-1))
@@ -517,7 +517,7 @@ bool CxImagePNG::Encode(CxFile *hFile)
    /* Set error handling.  REQUIRED if you aren't supplying your own
     * error hadnling functions in the png_create_write_struct() call.
     */
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 	if (setjmp(png_jmpbuf(png_ptr))){
 #else
 	if (setjmp(png_ptr->jmpbuf)){
@@ -535,7 +535,7 @@ bool CxImagePNG::Encode(CxFile *hFile)
 	png_set_write_fn(png_ptr,hFile,/*(png_rw_ptr)*/user_write_data,/*(png_flush_ptr)*/user_flush_data);
 
 	/* set the file information here */
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 	/* use variables to hold the values so it isnt necessary to png_get them later */
 	png_uint_32 _width,_height;
 	int _bit_depth,_color_type,_interlace_type,_compression_type,_filter_type;
@@ -560,14 +560,14 @@ bool CxImagePNG::Encode(CxFile *hFile)
 
 	switch(GetCodecOption(CXIMAGE_FORMAT_PNG)){
 	case 1:
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 		_interlace_type = PNG_INTERLACE_ADAM7;
 #else
 		info_ptr->interlace_type = PNG_INTERLACE_ADAM7;
 #endif
 		break;
 	default:
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 		_interlace_type = PNG_INTERLACE_NONE;
 #else
 		info_ptr->interlace_type = PNG_INTERLACE_NONE;
@@ -581,20 +581,20 @@ bool CxImagePNG::Encode(CxFile *hFile)
 
 	if (GetNumColors()){
 		if (bGrayScale){
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 			_color_type = PNG_COLOR_TYPE_GRAY;
 #else
 			info_ptr->color_type = PNG_COLOR_TYPE_GRAY;
 #endif
 		} else {
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 			_color_type = PNG_COLOR_TYPE_PALETTE;
 #else
 			info_ptr->color_type = PNG_COLOR_TYPE_PALETTE;
 #endif
 		}
 	} else {
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 		_color_type = PNG_COLOR_TYPE_RGB;
 #else
 		info_ptr->color_type = PNG_COLOR_TYPE_RGB;
@@ -602,7 +602,7 @@ bool CxImagePNG::Encode(CxFile *hFile)
 	}
 #if CXIMAGE_SUPPORT_ALPHA
 	if (AlphaIsValid()){
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 		_color_type |= PNG_COLOR_MASK_ALPHA;
 		_channels++;
 		_bit_depth = 8;
@@ -629,7 +629,7 @@ bool CxImagePNG::Encode(CxFile *hFile)
 	/* set metrics */
 	png_set_pHYs(png_ptr, info_ptr, head.biXPelsPerMeter, head.biYPelsPerMeter, PNG_RESOLUTION_METER);
 
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 	png_set_IHDR(png_ptr,info_ptr,_width,_height,_bit_depth,_color_type,_interlace_type,
 		_compression_type,_filter_type);
 #else
@@ -644,7 +644,7 @@ bool CxImagePNG::Encode(CxFile *hFile)
 		info_ptr->num_trans = 1;
 		info_ptr->valid |= PNG_INFO_tRNS;
 #endif
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 		png_color_16 _trans_color;
 		_trans_color.index = (BYTE)info.nBkgndIndex;
 		_trans_color.red   = tc.rgbRed;
@@ -676,7 +676,7 @@ bool CxImagePNG::Encode(CxFile *hFile)
 	}
 
 	/* set the palette if there is one */
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 	png_colorp _palette = NULL;
 	if (GetPalette()){
 		/* png_set_PLTE() will be called once the palette is ready */
@@ -697,7 +697,7 @@ bool CxImagePNG::Encode(CxFile *hFile)
 			info_ptr->num_trans = (WORD)nc;
 			info_ptr->valid |= PNG_INFO_tRNS;
 #endif
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 			png_set_tRNS(png_ptr,info_ptr,(png_bytep)trans,nc,NULL);
 #else
 #if PNG_LIBPNG_VER > 10399
@@ -709,7 +709,7 @@ bool CxImagePNG::Encode(CxFile *hFile)
 		}
 
 		// copy the palette colors
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 		_palette = new png_color[nc];
 		for (int i=0; i<nc; i++)
 			GetPaletteColor(i, &_palette[i].red, &_palette[i].green, &_palette[i].blue);
@@ -734,7 +734,7 @@ bool CxImagePNG::Encode(CxFile *hFile)
 	}	}	}
 #endif // CXIMAGE_SUPPORT_ALPHA	// <vho>
 
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 	int row_size = max(info.dwEffWidth, (_width * _channels * _bit_depth / 8));
 #else
 	int row_size = max(info.dwEffWidth, info_ptr->width*info_ptr->channels*(info_ptr->bit_depth/8));
@@ -757,7 +757,7 @@ bool CxImagePNG::Encode(CxFile *hFile)
 			if (AlphaIsValid()){
 				for (long ax=head.biWidth-1; ax>=0;ax--){
 					c = BlindGetPixelColor(ax,ay);
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 					int px = ax * _channels;
 #else
 					int px = ax * info_ptr->channels;
@@ -776,7 +776,7 @@ bool CxImagePNG::Encode(CxFile *hFile)
 #endif //CXIMAGE_SUPPORT_ALPHA	// <vho>
 			{
 				iter.GetRow(row_pointers, row_size);
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 				if (_color_type == PNG_COLOR_TYPE_RGB) //HACK BY OP
 #else
 				if (info_ptr->color_type == PNG_COLOR_TYPE_RGB) //HACK BY OP
@@ -797,7 +797,7 @@ bool CxImagePNG::Encode(CxFile *hFile)
 	png_write_end(png_ptr, info_ptr);
 
 	/* if you malloced the palette, free it here */
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 	if (_palette){
 		delete [] (_palette);
 #else
diff --git a/lib/cximage-6.0/CxImage/ximapng.h b/lib/cximage-6.0/CxImage/ximapng.h
index 68d8ddb..7d1611b 100644
--- a/lib/cximage-6.0/CxImage/ximapng.h
+++ b/lib/cximage-6.0/CxImage/ximapng.h
@@ -30,6 +30,10 @@
 #endif
 }
 
+#if PNG_LIBPNG_VER > 10499
+  #define USE_NEW_LIBPNG_API
+#endif
+
 class CxImagePNG: public CxImage
 {
 public:
@@ -69,7 +73,7 @@ class CxImagePNG: public CxImage
 
     static void PNGAPI user_error_fn(png_structp png_ptr,png_const_charp error_msg)
 	{
-#if PNG_LIBPNG_VER > 10499
+#ifdef USE_NEW_LIBPNG_API
 		strncpy((char*)png_get_error_ptr(png_ptr),error_msg,255);
 		longjmp(png_jmpbuf(png_ptr), 1);
 #else
-- 
1.7.5.4

