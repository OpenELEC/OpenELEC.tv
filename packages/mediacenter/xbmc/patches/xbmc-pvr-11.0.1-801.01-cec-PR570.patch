diff -Naur xbmc-pvr-11.0.1/configure.in xbmc-pvr-11.0.1.patch/configure.in
--- xbmc-pvr-11.0.1/configure.in	2012-03-27 17:55:54.000000000 +0200
+++ xbmc-pvr-11.0.1.patch/configure.in	2012-04-17 14:03:25.176271190 +0200
@@ -1173,7 +1173,7 @@
 
   # libcec is dyloaded, so we need to check for its headers and link any depends.
   if test "x$use_libcec" != "xno"; then
-    PKG_CHECK_MODULES([CEC],[libcec >= 1.1.0],,[use_libcec="no";AC_MSG_RESULT($libcec_disabled)])
+    PKG_CHECK_MODULES([CEC],[libcec >= 1.5.0],,[use_libcec="no";AC_MSG_RESULT($libcec_disabled)])
 
     if test "x$use_libcec" != "xno"; then
       INCLUDES="$INCLUDES $CEC_CFLAGS"
diff -Naur xbmc-pvr-11.0.1/language/English/strings.xml xbmc-pvr-11.0.1.patch/language/English/strings.xml
--- xbmc-pvr-11.0.1/language/English/strings.xml	2012-03-27 17:55:51.000000000 +0200
+++ xbmc-pvr-11.0.1.patch/language/English/strings.xml	2012-04-17 14:03:25.195271549 +0200
@@ -2831,6 +2831,7 @@
   <string id="35006">Device removed</string>
   <string id="35007">Keymap to use for this device</string>
   <string id="35008">Keymap enabled</string>
+  <string id="35009">Do not use the custom keymap for this device</string>
 
   <string id="35500">Location</string>
   <string id="35501">Class</string>
@@ -2845,16 +2846,23 @@
   <string id="36004">Press "user" button command</string>
   <string id="36005">Enable switch side commands</string>
   <string id="36006">Could not open the adapter</string>
-  <string id="36007">Power on the TV when starting XBMC</string>
-  <string id="36008">Power off devices when stopping XBMC</string>
+  <string id="36007">Devices to power on the TV when starting XBMC</string>
+  <string id="36008">Devices to power off devices when stopping XBMC</string>
   <string id="36009">Put devices in standby mode when activating screensaver</string>
   <string id="36010"></string>
   <string id="36011">Could not detect the CEC port. Set it up manually.</string>
-  <string id="36012">Could not detect the CEC adapter.</string>
-  <string id="36013">Unsupported libcec interface version. %d is greater than the version XBMC supports (%d)</string>
+  <string id="36012">Could not initialise the CEC adapter. Check your settings.</string>
+  <string id="36013">Unsupported libCEC interface version. %d is greater than the version XBMC supports (%d)</string>
   <string id="36014">Put this PC in standby mode when the TV is switched off</string>
   <string id="36015">HDMI port number</string>
   <string id="36016">Connected</string> <!-- max. 13 characters -->
-  <string id="36017">Adapter found, but libcec is not available</string>
+  <string id="36017">Adapter found, but libCEC is not available</string>
   <string id="36018">Use the TV's language setting</string>
+  <string id="36019">Connected to HDMI device</string>
+  <string id="36020">Make XBMC the active source when starting</string>
+  <string id="36021">Physical address (overrules HDMI port)</string>
+  <string id="36022">COM port (leave empty unless needed)</string>
+  <string id="36023">Configuration updated</string>
+  <string id="36024">Failed to set the new configuration. Please check your settings.</string>
+  <string id="36025">Send 'inactive source' command when stopping XBMC</string>
 </strings>
diff -Naur xbmc-pvr-11.0.1/lib/libcec/Makefile xbmc-pvr-11.0.1.patch/lib/libcec/Makefile
--- xbmc-pvr-11.0.1/lib/libcec/Makefile	2012-03-27 17:55:40.000000000 +0200
+++ xbmc-pvr-11.0.1.patch/lib/libcec/Makefile	2012-04-17 14:03:25.202271682 +0200
@@ -7,17 +7,17 @@
 
 # lib name, version
 LIBNAME=libcec
-VERSION=1.2.0
+VERSION=latest
 SOURCE=$(LIBNAME)-$(VERSION)
 
 # download location and format
-BASE_URL=http://mirrors.xbmc.org/build-deps/darwin-libs
-ARCHIVE=$(SOURCE).tar.gz 
+BASE_URL=http://packages.pulse-eight.net/pulse/sources/libcec
+ARCHIVE=$(SOURCE).tar.bz2 
 TARBALLS_LOCATION=.
 RETRIEVE_TOOL=/usr/bin/curl
 RETRIEVE_TOOL_FLAGS=-Ls --create-dirs --output $(TARBALLS_LOCATION)/$(ARCHIVE)
 ARCHIVE_TOOL=tar
-ARCHIVE_TOOL_FLAGS=xf
+ARCHIVE_TOOL_FLAGS=jxf
 
 PREFIX ?= /usr/local
 LIBCEC_CONFIGOPTS ?= --prefix=$(PREFIX)
@@ -25,30 +25,30 @@
 # configuration settings
 CONFIGURE=./configure CFLAGS=-D_FILE_OFFSET_BITS=64 $(LIBCEC_CONFIGOPTS)
 
-SO_NAME=$(SOURCE)/.libs/$(LIBNAME).so
+SO_NAME=$(LIBNAME)/.libs/$(LIBNAME).so
 
 all: $(SO_NAME)
 
 $(TARBALLS_LOCATION)/$(ARCHIVE):
 	$(RETRIEVE_TOOL) $(RETRIEVE_TOOL_FLAGS) $(BASE_URL)/$(ARCHIVE)
 
-$(SOURCE): $(TARBALLS_LOCATION)/$(ARCHIVE)
-	rm -rf $(SOURCE)
+$(LIBNAME): $(TARBALLS_LOCATION)/$(ARCHIVE)
+	rm -rf $(LIBNAME)
 	$(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
-	echo $(SOURCE) > .gitignore
-	cd $(SOURCE); autoreconf -vif
-	cd $(SOURCE); $(CONFIGURE)
+	echo $(LIBNAME) > .gitignore
+	cd $(LIBNAME); autoreconf -vif
+	cd $(LIBNAME); $(CONFIGURE)
 
-$(SO_NAME): $(SOURCE)
-	make -j 1 -C $(SOURCE)
+$(SO_NAME): $(LIBNAME)
+	make -j 1 -C $(LIBNAME)
 
 install:
-	make -C $(SOURCE) install
+	make -C $(LIBNAME) install
 	ldconfig
 
 clean:
-	rm -rf $(SOURCE)
+	rm -rf $(LIBNAME)
 
 distclean::
-	rm -rf $(SOURCE)
+	rm -rf $(LIBNAME)
 
diff -Naur xbmc-pvr-11.0.1/system/peripherals.xml xbmc-pvr-11.0.1.patch/system/peripherals.xml
--- xbmc-pvr-11.0.1/system/peripherals.xml	2012-03-27 17:55:54.000000000 +0200
+++ xbmc-pvr-11.0.1.patch/system/peripherals.xml	2012-04-17 14:03:25.196271568 +0200
@@ -1,22 +1,29 @@
 <peripherals>
   <peripheral vendor_product="1915:003B,22B8:003B" bus="usb" name="Motorola Nyxboard Hybrid" mapTo="nyxboard">
-    <setting key="keymap_enabled" type="bool" value="1" label="35008" />
+    <setting key="do_not_use_custom_keymap" type="bool" value="0" label="35009" order="1" />
     <setting key="keymap" value="nyxboard" label="35007" configurable="0" />
-    <setting key="enable_flip_commands" type="bool" value="1" label="36005" />
-    <setting key="flip_keyboard" value="XBMC.VideoLibrary.Search" label="36002" />
-    <setting key="flip_remote" value="Dialog.Close(virtualkeyboard)" label="36003" />
-    <setting key="key_user" value="" label="36004" />
+    <setting key="enable_flip_commands" type="bool" value="1" label="36005" order="2" />
+    <setting key="flip_keyboard" value="XBMC.VideoLibrary.Search" label="36002" order="3" />
+    <setting key="flip_remote" value="Dialog.Close(virtualkeyboard)" label="36003" order="4" />
+    <setting key="key_user" value="" label="36004" order="5" />
   </peripheral>
 
-  <peripheral vendor_product="2548:1001" bus="usb" name="Pulse-Eight CEC Adaptor" mapTo="cec">
-    <setting key="enabled" type="bool" value="1" label="305" />
-    <setting key="port" type="string" value="" label="792" />
-    <setting key="cec_hdmi_port" type="int" value="1" min="1" max="16" label="36015" />
-    <setting key="cec_power_on_startup" type="bool" value="1" label="36007" />
-    <setting key="cec_power_off_shutdown" type="bool" value="1" label="36008" />
-    <setting key="cec_standby_screensaver" type="bool" value="1" label="36009" />
-    <setting key="standby_pc_on_tv_standby" type="bool" value="1" label="36014" />
-    <setting key="cec_debug_logging" type="bool" value="0" label="20191" />
-    <setting key="use_tv_menu_language" type="bool" value="1" label="36018" />
+  <peripheral vendor_product="2548:1001" bus="usb" name="Pulse-Eight CEC Adapter" mapTo="cec">
+    <setting key="enabled" type="bool" value="1" label="305" order="1" />
+    <setting key="activate_source" type="bool" value="1" label="36020" order="2" />
+    <setting key="wake_devices" type="string" value="0" label="36007" order="3" />
+    <setting key="standby_devices" type="string" value="0" label="36008" order="4" />
+    <setting key="cec_standby_screensaver" type="bool" value="1" label="36009" order="5" />
+    <setting key="standby_pc_on_tv_standby" type="bool" value="1" label="36014" order="6" />
+    <setting key="send_inactive_source" type="bool" value="1" label="36025" order="7" />
+    <setting key="use_tv_menu_language" type="bool" value="1" label="36018" order="8" />
+    <setting key="physical_address" type="string" label="36021" value="0" order="9" />
+    <setting key="cec_hdmi_port" type="int" value="1" min="1" max="16" label="36015" order="10" />
+    <setting key="connected_device" type="int" label="36019" value="0" min="0" max="15" step="1" order="11" />
+    <setting key="port" type="string" value="" label="36022" order="12" />
+
+    <setting key="tv_vendor" type="int" value="0" configurable="0" />
+    <setting key="device_name" type="string" value="XBMC" configurable="0" />
+    <setting key="device_type" type="int" value="1" configurable="0" />
   </peripheral>
 </peripherals>
diff -Naur xbmc-pvr-11.0.1/xbmc/Application.cpp xbmc-pvr-11.0.1.patch/xbmc/Application.cpp
--- xbmc-pvr-11.0.1/xbmc/Application.cpp	2012-03-27 17:55:35.000000000 +0200
+++ xbmc-pvr-11.0.1.patch/xbmc/Application.cpp	2012-04-17 14:06:37.605914462 +0200
@@ -160,9 +160,6 @@
 #endif
 #include "interfaces/AnnouncementManager.h"
 #include "peripherals/Peripherals.h"
-#ifdef HAVE_LIBCEC
-#include "peripherals/devices/PeripheralCecAdapter.h"
-#endif
 #include "peripherals/dialogs/GUIDialogPeripheralManager.h"
 #include "peripherals/dialogs/GUIDialogPeripheralSettings.h"
 
@@ -2618,6 +2615,9 @@
     }
   }
 
+  if (g_peripherals.OnAction(action))
+    return true;
+
   if (action.GetID() == ACTION_MUTE)
   {
     ToggleMute();
@@ -2893,23 +2893,9 @@
 
 bool CApplication::ProcessPeripherals(float frameTime)
 {
-#ifdef HAVE_LIBCEC
-  vector<CPeripheral *> peripherals;
-  if (g_peripherals.GetPeripheralsWithFeature(peripherals, FEATURE_CEC))
-  {
-    for (unsigned int iPeripheralPtr = 0; iPeripheralPtr < peripherals.size(); iPeripheralPtr++)
-    {
-      CPeripheralCecAdapter *cecDevice = (CPeripheralCecAdapter *) peripherals.at(iPeripheralPtr);
-      if (cecDevice && cecDevice->GetButton())
-      {
-        CKey key(cecDevice->GetButton(), cecDevice->GetHoldTime());
-        cecDevice->ResetButton();
-        return OnKey(key);
-      }
-    }
-  }
-#endif
-
+  CKey key;
+  if (g_peripherals.GetNextKeypress(frameTime, key))
+    return OnKey(key);
   return false;
 }
 
@@ -3365,7 +3351,8 @@
 {
   try
   {
-    CAnnouncementManager::Announce(System, "xbmc", "OnQuit");
+    CVariant vExitCode(exitCode);
+    CAnnouncementManager::Announce(System, "xbmc", "OnQuit", vExitCode);
 
     // cancel any jobs from the jobmanager
     CJobManager::GetInstance().CancelJobs();
@@ -5123,6 +5110,8 @@
 
 bool CApplication::IsMuted() const
 {
+  if (g_peripherals.IsMuted())
+    return true;
   return g_settings.m_bMute;
 }
 
@@ -5136,6 +5125,9 @@
 
 void CApplication::Mute()
 {
+  if (g_peripherals.Mute())
+    return;
+
   g_settings.m_iPreMuteVolumeLevel = GetVolume();
   SetVolume(0);
   g_settings.m_bMute = true;
@@ -5143,6 +5135,9 @@
 
 void CApplication::UnMute()
 {
+  if (g_peripherals.UnMute())
+    return;
+
   SetVolume(g_settings.m_iPreMuteVolumeLevel);
   g_settings.m_iPreMuteVolumeLevel = 0;
   g_settings.m_bMute = false;
diff -Naur xbmc-pvr-11.0.1/xbmc/peripherals/devices/PeripheralCecAdapter.cpp xbmc-pvr-11.0.1.patch/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
--- xbmc-pvr-11.0.1/xbmc/peripherals/devices/PeripheralCecAdapter.cpp	2012-03-27 17:55:34.000000000 +0200
+++ xbmc-pvr-11.0.1.patch/xbmc/peripherals/devices/PeripheralCecAdapter.cpp	2012-04-17 14:03:25.211271852 +0200
@@ -18,8 +18,8 @@
  *  http://www.gnu.org/copyleft/gpl.html
  *
  */
-#include "system.h"
 
+#include "system.h"
 #if defined(HAVE_LIBCEC)
 #include "PeripheralCecAdapter.h"
 #include "input/XBIRRemote.h"
@@ -31,36 +31,40 @@
 #include "peripherals/Peripherals.h"
 #include "peripherals/bus/PeripheralBus.h"
 #include "settings/GUISettings.h"
+#include "settings/Settings.h"
 #include "utils/log.h"
+#include "utils/Variant.h"
 
-#include <cec.h>
+#include <libcec/cec.h>
 
 using namespace PERIPHERALS;
 using namespace ANNOUNCEMENT;
 using namespace CEC;
 
-#define CEC_LIB_SUPPORTED_VERSION 1
+#define CEC_LIB_SUPPORTED_VERSION 0x1500
 
 /* time in seconds to ignore standby commands from devices after the screensaver has been activated */
 #define SCREENSAVER_TIMEOUT       10
+#define VOLUME_CHANGE_TIMEOUT     250
+#define VOLUME_REFRESH_TIMEOUT    100
 
 class DllLibCECInterface
 {
 public:
   virtual ~DllLibCECInterface() {}
-  virtual ICECAdapter* CECInit(const char *interfaceName, cec_device_type_list types)=0;
-  virtual void* CECDestroy(ICECAdapter *adapter)=0;
+  virtual ICECAdapter* CECInitialise(libcec_configuration *configuration)=0;
+  virtual void*        CECDestroy(ICECAdapter *adapter)=0;
 };
 
 class DllLibCEC : public DllDynamic, DllLibCECInterface
 {
   DECLARE_DLL_WRAPPER(DllLibCEC, DLL_PATH_LIBCEC)
 
-  DEFINE_METHOD2(ICECAdapter*, CECInit,   (const char *p1, cec_device_type_list p2))
-  DEFINE_METHOD1(void*       , CECDestroy,  (ICECAdapter *p1))
+  DEFINE_METHOD1(ICECAdapter*, CECInitialise, (libcec_configuration *p1))
+  DEFINE_METHOD1(void*       , CECDestroy,    (ICECAdapter *p1))
 
   BEGIN_METHOD_RESOLVE()
-    RESOLVE_METHOD_RENAME(CECInit,  CECInit)
+    RESOLVE_METHOD_RENAME(CECInitialise,  CECInitialise)
     RESOLVE_METHOD_RENAME(CECDestroy, CECDestroy)
   END_METHOD_RESOLVE()
 };
@@ -71,41 +75,19 @@
   m_bStarted(false),
   m_bHasButton(false),
   m_bIsReady(false),
+  m_bHasConnectedAudioSystem(false),
   m_strMenuLanguage("???"),
-  m_lastKeypress(0)
+  m_lastKeypress(0),
+  m_lastChange(VOLUME_CHANGE_NONE),
+  m_iExitCode(0),
+  m_bIsMuted(false) // TODO fetch the correct initial value when system audiostatus is implemented in libCEC
 {
   m_button.iButton = 0;
   m_button.iDuration = 0;
   m_screensaverLastActivated.SetValid(false);
-  m_dll = new DllLibCEC;
-  if (m_dll->Load() && m_dll->IsLoaded())
-  {
-    cec_device_type_list typeList;
-    typeList.clear();
-    typeList.add(CEC_DEVICE_TYPE_RECORDING_DEVICE);
-    m_cecAdapter = m_dll->CECInit("XBMC", typeList);
-  }
-  else
-    m_cecAdapter = NULL;
-
-  if (!m_cecAdapter || m_cecAdapter->GetMinLibVersion() > CEC_LIB_SUPPORTED_VERSION)
-  {
-    /* unsupported libcec version */
-    CLog::Log(LOGERROR, g_localizeStrings.Get(36013).c_str(), CEC_LIB_SUPPORTED_VERSION, m_cecAdapter ? m_cecAdapter->GetMinLibVersion() : -1);
 
-    CStdString strMessage;
-    strMessage.Format(g_localizeStrings.Get(36013).c_str(), CEC_LIB_SUPPORTED_VERSION, m_cecAdapter ? m_cecAdapter->GetMinLibVersion() : -1);
-    CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Error, g_localizeStrings.Get(36000), strMessage);
-    m_bError = true;
-    if (m_cecAdapter)
-      m_dll->CECDestroy(m_cecAdapter);
-    m_cecAdapter = NULL;
-  }
-  else
-  {
-    CLog::Log(LOGDEBUG, "%s - using libCEC v%d.%d", __FUNCTION__, m_cecAdapter->GetLibVersionMajor(), m_cecAdapter->GetLibVersionMinor());
-    m_features.push_back(FEATURE_CEC);
-  }
+  m_configuration.Clear();
+  m_features.push_back(FEATURE_CEC);
 }
 
 CPeripheralCecAdapter::~CPeripheralCecAdapter(void)
@@ -117,7 +99,6 @@
 
   if (m_dll && m_cecAdapter)
   {
-    FlushLog();
     m_dll->CECDestroy(m_cecAdapter);
     m_cecAdapter = NULL;
     delete m_dll;
@@ -129,60 +110,94 @@
 {
   if (flag == System && !strcmp(sender, "xbmc") && !strcmp(message, "OnQuit") && m_bIsReady)
   {
-    m_cecAdapter->SetInactiveView();
-    if (GetSettingBool("cec_power_off_shutdown"))
-      m_cecAdapter->StandbyDevices();
+    m_iExitCode = data.asInteger(0);
+    StopThread(false);
   }
-  else if (flag == GUI && !strcmp(sender, "xbmc") && !strcmp(message, "OnScreensaverDeactivated") && GetSettingBool("cec_standby_screensaver") && m_bIsReady)
+  else if (flag == GUI && !strcmp(sender, "xbmc") && !strcmp(message, "OnScreensaverDeactivated") && m_bIsReady)
   {
-    m_cecAdapter->PowerOnDevices();
+    if (m_configuration.bPowerOffScreensaver == 1)
+    {
+      // power off/on on screensaver is set, and devices to wake are set
+      if (!m_configuration.wakeDevices.IsEmpty())
+        m_cecAdapter->PowerOnDevices(CECDEVICE_BROADCAST);
+
+      // the option to make XBMC the active source is set
+      if (m_configuration.bActivateSource == 1)
+        m_cecAdapter->SetActiveSource();
+    }
   }
-  else if (flag == GUI && !strcmp(sender, "xbmc") && !strcmp(message, "OnScreensaverActivated") && GetSettingBool("cec_standby_screensaver"))
+  else if (flag == GUI && !strcmp(sender, "xbmc") && !strcmp(message, "OnScreensaverActivated") && m_bIsReady)
   {
     // Don't put devices to standby if application is currently playing
-    if (!g_application.IsPlaying() || g_application.IsPaused())
+    if ((!g_application.IsPlaying() || g_application.IsPaused()) && m_configuration.bPowerOffScreensaver == 1)
     {
       m_screensaverLastActivated = CDateTime::GetCurrentDateTime();
-      m_cecAdapter->StandbyDevices();
+      // only power off when we're the active source
+      if (m_cecAdapter->IsLibCECActiveSource())
+        m_cecAdapter->StandbyDevices(CECDEVICE_BROADCAST);
     }
   }
   else if (flag == System && !strcmp(sender, "xbmc") && !strcmp(message, "OnSleep"))
   {
-    if (GetSettingBool("cec_power_off_shutdown") && m_bIsReady)
-      m_cecAdapter->StandbyDevices();
+    // this will also power off devices when we're the active source
     CSingleLock lock(m_critSection);
     m_bStop = true;
     WaitForThreadExit(0);
   }
   else if (flag == System && !strcmp(sender, "xbmc") && !strcmp(message, "OnWake"))
   {
+    // reconnect to the device
     CSingleLock lock(m_critSection);
     CLog::Log(LOGDEBUG, "%s - reconnecting to the CEC adapter after standby mode", __FUNCTION__);
+
+    // close the previous connection
     m_cecAdapter->Close();
 
-    CStdString strPort = GetComPort();
-    if (!strPort.empty())
-    {
-      if (!m_cecAdapter->Open(strPort.c_str(), 10000))
-      {
-        CLog::Log(LOGERROR, "%s - failed to reconnect to the CEC adapter", __FUNCTION__);
-        FlushLog();
-        m_bStop = true;
-      }
-      else
-      {
-        if (GetSettingBool("cec_power_on_startup"))
-          PowerOnCecDevices(CECDEVICE_TV);
-        m_cecAdapter->SetActiveView();
-      }
-    }
+    // and open a new one
+    m_bStop = false;
+    Create();
   }
 }
 
 bool CPeripheralCecAdapter::InitialiseFeature(const PeripheralFeature feature)
 {
-  if (feature == FEATURE_CEC && !m_bStarted)
+  if (feature == FEATURE_CEC && !m_bStarted && GetSettingBool("enabled"))
   {
+    SetConfigurationFromSettings();
+    m_callbacks.CBCecLogMessage           = &CecLogMessage;
+    m_callbacks.CBCecKeyPress             = &CecKeyPress;
+    m_callbacks.CBCecCommand              = &CecCommand;
+    m_callbacks.CBCecConfigurationChanged = &CecConfiguration;
+    m_configuration.callbackParam         = this;
+    m_configuration.callbacks             = &m_callbacks;
+
+    m_dll = new DllLibCEC;
+    if (m_dll->Load() && m_dll->IsLoaded())
+      m_cecAdapter = m_dll->CECInitialise(&m_configuration);
+    else
+      return false;
+
+    if (m_configuration.serverVersion < CEC_LIB_SUPPORTED_VERSION)
+    {
+      /* unsupported libcec version */
+      CLog::Log(LOGERROR, g_localizeStrings.Get(36013).c_str(), CEC_LIB_SUPPORTED_VERSION, m_cecAdapter ? m_configuration.serverVersion : -1);
+
+      CStdString strMessage;
+      strMessage.Format(g_localizeStrings.Get(36013).c_str(), CEC_LIB_SUPPORTED_VERSION, m_cecAdapter ? m_configuration.serverVersion : -1);
+      CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Error, g_localizeStrings.Get(36000), strMessage);
+      m_bError = true;
+      if (m_cecAdapter)
+        m_dll->CECDestroy(m_cecAdapter);
+      m_cecAdapter = NULL;
+
+      m_features.clear();
+      return false;
+    }
+    else
+    {
+      CLog::Log(LOGDEBUG, "%s - using libCEC v%s", __FUNCTION__, m_cecAdapter->ToString((cec_server_version)m_configuration.serverVersion));
+    }
+
     m_bStarted = true;
     Create();
   }
@@ -221,23 +236,20 @@
   return strPort;
 }
 
-void CPeripheralCecAdapter::Process(void)
+bool CPeripheralCecAdapter::OpenConnection(void)
 {
+  bool bIsOpen(false);
+
   if (!GetSettingBool("enabled"))
   {
     CLog::Log(LOGDEBUG, "%s - CEC adapter is disabled in peripheral settings", __FUNCTION__);
     m_bStarted = false;
-    return;
+    return bIsOpen;
   }
   
   CStdString strPort = GetComPort();
   if (strPort.empty())
-    return;
-
-  // set correct physical address from peripheral settings
-  int iHdmiPort = GetSettingInt("cec_hdmi_port");
-  SetHdmiPort(iHdmiPort);
-  FlushLog();
+    return bIsOpen;
 
   // open the CEC adapter
   CLog::Log(LOGDEBUG, "%s - opening a connection to the CEC adapter: %s", __FUNCTION__, strPort.c_str());
@@ -247,100 +259,221 @@
   strMessage.Format(g_localizeStrings.Get(21336), g_localizeStrings.Get(36000));
   CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, g_localizeStrings.Get(36000), strMessage);
 
-  if (!m_cecAdapter->Open(strPort.c_str(), 10000))
-  {
-    FlushLog();
-    CLog::Log(LOGERROR, "%s - could not opening a connection to the CEC adapter", __FUNCTION__);
-    CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Error, g_localizeStrings.Get(36000), g_localizeStrings.Get(36012));
-    m_bStarted = false;
-    return;
-  }
+  bool bConnectionFailedDisplayed(false);
 
-  CLog::Log(LOGDEBUG, "%s - connection to the CEC adapter opened", __FUNCTION__);
-  m_bIsReady = true;
-  CAnnouncementManager::AddAnnouncer(this);
-
-  if (GetSettingBool("cec_power_on_startup"))
+  while (!m_bStop && !bIsOpen)
   {
-    PowerOnCecDevices(CECDEVICE_TV);
-    FlushLog();
+    if ((bIsOpen = m_cecAdapter->Open(strPort.c_str(), 10000)) == false)
+    {
+      CLog::Log(LOGERROR, "%s - could not opening a connection to the CEC adapter", __FUNCTION__);
+      if (!bConnectionFailedDisplayed)
+        CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Error, g_localizeStrings.Get(36000), g_localizeStrings.Get(36012));
+      bConnectionFailedDisplayed = true;
+
+      Sleep(10000);
+    }
   }
 
-  if (GetSettingBool("use_tv_menu_language"))
+  if (bIsOpen)
   {
-    cec_menu_language language;
-    if (m_cecAdapter->GetDeviceMenuLanguage(CECDEVICE_TV, &language))
-      SetMenuLanguage(language.language);
+    CLog::Log(LOGDEBUG, "%s - connection to the CEC adapter opened", __FUNCTION__);
+
+    if (!m_configuration.wakeDevices.IsEmpty())
+      m_cecAdapter->PowerOnDevices(CECDEVICE_BROADCAST);
+
+    if (m_configuration.bActivateSource == 1)
+      m_cecAdapter->SetActiveSource();
   }
 
-  m_cecAdapter->SetOSDString(CECDEVICE_TV, CEC_DISPLAY_CONTROL_DISPLAY_FOR_DEFAULT_TIME, g_localizeStrings.Get(36016).c_str());
-  CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, g_localizeStrings.Get(36000), g_localizeStrings.Get(36016));
+  return bIsOpen;
+}
+
+void CPeripheralCecAdapter::Process(void)
+{
+  if (!OpenConnection())
+    return;
+
+  CAnnouncementManager::AddAnnouncer(this);
+
+  m_queryThread = new CPeripheralCecAdapterUpdateThread(this, &m_configuration);
+  m_queryThread->Create(false);
 
   while (!m_bStop)
   {
-    FlushLog();
     if (!m_bStop)
-      ProcessNextCommand();
+      ProcessVolumeChange();
+
     if (!m_bStop)
       Sleep(5);
   }
 
+  delete m_queryThread;
+
+  if (m_iExitCode != EXITCODE_REBOOT)
+  {
+    if (m_cecAdapter->IsLibCECActiveSource())
+    {
+      if (!m_configuration.powerOffDevices.IsEmpty())
+      {
+        CLog::Log(LOGDEBUG, "%s - sending standby commands", __FUNCTION__);
+        m_cecAdapter->StandbyDevices();
+      }
+      else if (m_configuration.bSendInactiveSource == 1)
+      {
+        CLog::Log(LOGDEBUG, "%s - sending inactive source commands", __FUNCTION__);
+        m_cecAdapter->SetInactiveView();
+      }
+    }
+    else
+    {
+      CLog::Log(LOGDEBUG, "%s - XBMC is not the active source, not sending any standby commands", __FUNCTION__);
+    }
+  }
+
   m_cecAdapter->Close();
 
   CLog::Log(LOGDEBUG, "%s - CEC adapter processor thread ended", __FUNCTION__);
   m_bStarted = false;
 }
 
-bool CPeripheralCecAdapter::PowerOnCecDevices(cec_logical_address iLogicalAddress)
+bool CPeripheralCecAdapter::HasConnectedAudioSystem(void)
 {
-  bool bReturn(false);
+  CSingleLock lock(m_critSection);
+  return m_bHasConnectedAudioSystem;
+}
 
-  if (m_cecAdapter && m_bIsReady)
+void CPeripheralCecAdapter::SetAudioSystemConnected(bool bSetTo)
+{
+  CSingleLock lock(m_critSection);
+  m_bHasConnectedAudioSystem = bSetTo;
+}
+
+void CPeripheralCecAdapter::ScheduleVolumeUp(void)
+{
   {
-    CLog::Log(LOGDEBUG, "%s - powering on CEC capable device with address %1x", __FUNCTION__, iLogicalAddress);
-    bReturn = m_cecAdapter->PowerOnDevices(iLogicalAddress);
+    CSingleLock lock(m_critSection);
+    m_volumeChangeQueue.push(VOLUME_CHANGE_UP);
   }
+  Sleep(5);
+}
 
-  return bReturn;
+void CPeripheralCecAdapter::ScheduleVolumeDown(void)
+{
+  {
+    CSingleLock lock(m_critSection);
+    m_volumeChangeQueue.push(VOLUME_CHANGE_DOWN);
+  }
+  Sleep(5);
 }
 
-bool CPeripheralCecAdapter::StandbyCecDevices(cec_logical_address iLogicalAddress)
+void CPeripheralCecAdapter::ScheduleMute(void)
 {
-  bool bReturn(false);
+  {
+    CSingleLock lock(m_critSection);
+    m_volumeChangeQueue.push(VOLUME_CHANGE_MUTE);
+  }
+  Sleep(5);
+}
 
-  if (m_cecAdapter && m_bIsReady)
+void CPeripheralCecAdapter::ProcessVolumeChange(void)
+{
+  bool bSendRelease(false);
+  CecVolumeChange pendingVolumeChange = VOLUME_CHANGE_NONE;
   {
-    CLog::Log(LOGDEBUG, "%s - putting CEC capable devices with address %1x in standby mode", __FUNCTION__, iLogicalAddress);
-    bReturn = m_cecAdapter->StandbyDevices(iLogicalAddress);
+    CSingleLock lock(m_critSection);
+    if (m_volumeChangeQueue.size() > 0)
+    {
+      /* get the first change from the queue */
+      pendingVolumeChange = m_volumeChangeQueue.front();
+      m_volumeChangeQueue.pop();
+
+      /* remove all dupe entries */
+      while (m_volumeChangeQueue.size() > 0 && m_volumeChangeQueue.front() == pendingVolumeChange)
+        m_volumeChangeQueue.pop();
+
+      /* send another keypress after VOLUME_REFRESH_TIMEOUT ms */
+      bool bRefresh(m_lastKeypress + VOLUME_REFRESH_TIMEOUT < XbmcThreads::SystemClockMillis());
+
+      /* only send the keypress when it hasn't been sent yet */
+      if (pendingVolumeChange != m_lastChange)
+      {
+        m_lastKeypress = XbmcThreads::SystemClockMillis();
+        m_lastChange = pendingVolumeChange;
+      }
+      else if (bRefresh)
+      {
+        m_lastKeypress = XbmcThreads::SystemClockMillis();
+        pendingVolumeChange = m_lastChange;
+      }
+      else
+        pendingVolumeChange = VOLUME_CHANGE_NONE;
+    }
+    else if (m_lastKeypress > 0 && m_lastKeypress + VOLUME_CHANGE_TIMEOUT < XbmcThreads::SystemClockMillis())
+    {
+      /* send a key release */
+      m_lastKeypress = 0;
+      bSendRelease = true;
+      m_lastChange = VOLUME_CHANGE_NONE;
+    }
   }
 
-  return bReturn;
+  switch (pendingVolumeChange)
+  {
+  case VOLUME_CHANGE_UP:
+    m_cecAdapter->SendKeypress(CECDEVICE_AUDIOSYSTEM, CEC_USER_CONTROL_CODE_VOLUME_UP, false);
+    break;
+  case VOLUME_CHANGE_DOWN:
+    m_cecAdapter->SendKeypress(CECDEVICE_AUDIOSYSTEM, CEC_USER_CONTROL_CODE_VOLUME_DOWN, false);
+    break;
+  case VOLUME_CHANGE_MUTE:
+    m_cecAdapter->SendKeypress(CECDEVICE_AUDIOSYSTEM, CEC_USER_CONTROL_CODE_MUTE, false);
+    {
+      CSingleLock lock(m_critSection);
+      m_bIsMuted = !m_bIsMuted;
+    }
+    break;
+  case VOLUME_CHANGE_NONE:
+    if (bSendRelease)
+      m_cecAdapter->SendKeyRelease(CECDEVICE_AUDIOSYSTEM, false);
+    break;
+  }
 }
 
-bool CPeripheralCecAdapter::SendPing(void)
+void CPeripheralCecAdapter::VolumeUp(void)
 {
-  bool bReturn(false);
-  if (m_cecAdapter && m_bIsReady)
+  if (HasConnectedAudioSystem())
   {
-    CLog::Log(LOGDEBUG, "%s - sending ping to the CEC adapter", __FUNCTION__);
-    bReturn = m_cecAdapter->PingAdapter();
+    CSingleLock lock(m_critSection);
+    m_volumeChangeQueue.push(VOLUME_CHANGE_UP);
   }
+}
 
-  return bReturn;
+void CPeripheralCecAdapter::VolumeDown(void)
+{
+  if (HasConnectedAudioSystem())
+  {
+    CSingleLock lock(m_critSection);
+    m_volumeChangeQueue.push(VOLUME_CHANGE_DOWN);
+  }
 }
 
-bool CPeripheralCecAdapter::SetHdmiPort(int iHdmiPort)
+void CPeripheralCecAdapter::Mute(void)
 {
-  bool bReturn(false);
-  if (m_cecAdapter && m_bIsReady)
+  if (HasConnectedAudioSystem())
   {
-    if (iHdmiPort <= 0 || iHdmiPort > 16)
-      iHdmiPort = 1;
-    CLog::Log(LOGDEBUG, "%s - changing active HDMI port to %d", __FUNCTION__, iHdmiPort);
-    bReturn = m_cecAdapter->SetPhysicalAddress(iHdmiPort << 12);
+    CSingleLock lock(m_critSection);
+    m_volumeChangeQueue.push(VOLUME_CHANGE_MUTE);
   }
+}
 
-  return bReturn;
+bool CPeripheralCecAdapter::IsMuted(void)
+{
+  if (HasConnectedAudioSystem())
+  {
+    CSingleLock lock(m_critSection);
+    return m_bIsMuted;
+  }
+  return false;
 }
 
 void CPeripheralCecAdapter::SetMenuLanguage(const char *strLanguage)
@@ -404,10 +537,13 @@
     CLog::Log(LOGWARNING, "%s - TV menu language set to unknown value '%s'", __FUNCTION__, strLanguage);
 }
 
-void CPeripheralCecAdapter::ProcessNextCommand(void)
+int CPeripheralCecAdapter::CecCommand(void *cbParam, const cec_command &command)
 {
-  cec_command command;
-  if (m_cecAdapter && m_bIsReady && m_cecAdapter->GetNextCommand(&command))
+  CPeripheralCecAdapter *adapter = (CPeripheralCecAdapter *)cbParam;
+  if (!adapter)
+    return 0;
+
+  if (adapter->m_bIsReady)
   {
     CLog::Log(LOGDEBUG, "%s - processing command: initiator=%1x destination=%1x opcode=%02x", __FUNCTION__, command.initiator, command.destination, command.opcode);
 
@@ -416,21 +552,21 @@
     case CEC_OPCODE_STANDBY:
       /* a device was put in standby mode */
       CLog::Log(LOGDEBUG, "%s - device %1x was put in standby mode", __FUNCTION__, command.initiator);
-      if (command.initiator == CECDEVICE_TV && GetSettingBool("standby_pc_on_tv_standby") &&
-          (!m_screensaverLastActivated.IsValid() || CDateTime::GetCurrentDateTime() - m_screensaverLastActivated > CDateTimeSpan(0, 0, 0, SCREENSAVER_TIMEOUT)))
+      if (command.initiator == CECDEVICE_TV && adapter->m_configuration.bPowerOffOnStandby == 1 &&
+          (!adapter->m_screensaverLastActivated.IsValid() || CDateTime::GetCurrentDateTime() - adapter->m_screensaverLastActivated > CDateTimeSpan(0, 0, 0, SCREENSAVER_TIMEOUT)))
       {
-        m_bStarted = false;
+        adapter->m_bStarted = false;
         g_application.getApplicationMessenger().Suspend();
       }
       break;
     case CEC_OPCODE_SET_MENU_LANGUAGE:
-      if (GetSettingBool("use_tv_menu_language") && command.initiator == CECDEVICE_TV && command.parameters.size == 3)
+      if (adapter->m_configuration.bUseTVMenuLanguage == 1 && command.initiator == CECDEVICE_TV && command.parameters.size == 3)
       {
         char strNewLanguage[4];
         for (int iPtr = 0; iPtr < 3; iPtr++)
           strNewLanguage[iPtr] = command.parameters[iPtr];
         strNewLanguage[3] = 0;
-        SetMenuLanguage(strNewLanguage);
+        adapter->SetMenuLanguage(strNewLanguage);
       }
       break;
     case CEC_OPCODE_DECK_CONTROL:
@@ -438,11 +574,11 @@
           command.parameters.size == 1 &&
           command.parameters[0] == CEC_DECK_CONTROL_MODE_STOP)
       {
-        CSingleLock lock(m_critSection);
+        CSingleLock lock(adapter->m_critSection);
         cec_keypress key;
         key.duration = 500;
         key.keycode = CEC_USER_CONTROL_CODE_STOP;
-        m_buttonQueue.push(key);
+        adapter->m_buttonQueue.push(key);
       }
       break;
     case CEC_OPCODE_PLAY:
@@ -451,26 +587,58 @@
       {
         if (command.parameters[0] == CEC_PLAY_MODE_PLAY_FORWARD)
         {
-          CSingleLock lock(m_critSection);
+          CSingleLock lock(adapter->m_critSection);
           cec_keypress key;
           key.duration = 500;
           key.keycode = CEC_USER_CONTROL_CODE_PLAY;
-          m_buttonQueue.push(key);
+          adapter->m_buttonQueue.push(key);
         }
         else if (command.parameters[0] == CEC_PLAY_MODE_PLAY_STILL)
         {
-          CSingleLock lock(m_critSection);
+          CSingleLock lock(adapter->m_critSection);
           cec_keypress key;
           key.duration = 500;
           key.keycode = CEC_USER_CONTROL_CODE_PAUSE;
-          m_buttonQueue.push(key);
+          adapter->m_buttonQueue.push(key);
         }
       }
       break;
+    case CEC_OPCODE_REPORT_POWER_STATUS:
+      if (command.initiator == CECDEVICE_TV &&
+          command.parameters.size == 1 &&
+          command.parameters[0] == CEC_POWER_STATUS_ON &&
+          adapter->m_queryThread)
+      {
+        adapter->m_queryThread->Signal();
+      }
+      break;
     default:
       break;
     }
   }
+  return 1;
+}
+
+int CPeripheralCecAdapter::CecConfiguration(void *cbParam, const libcec_configuration &config)
+{
+  CPeripheralCecAdapter *adapter = (CPeripheralCecAdapter *)cbParam;
+  if (!adapter)
+    return 0;
+
+  CSingleLock lock(adapter->m_critSection);
+  adapter->SetConfigurationFromLibCEC(config);
+  return 1;
+}
+
+int CPeripheralCecAdapter::CecKeyPress(void *cbParam, const cec_keypress &key)
+{
+  CPeripheralCecAdapter *adapter = (CPeripheralCecAdapter *)cbParam;
+  if (!adapter)
+    return 0;
+
+  CSingleLock lock(adapter->m_critSection);
+  adapter->m_buttonQueue.push(key);
+  return 1;
 }
 
 bool CPeripheralCecAdapter::GetNextCecKey(cec_keypress &key)
@@ -483,10 +651,6 @@
     m_buttonQueue.pop();
     bReturn = true;
   }
-  else if (m_cecAdapter->GetNextKeypress(&key))
-  {
-    bReturn = true;
-  }
 
   return bReturn;
 }
@@ -726,41 +890,43 @@
     else if (bEnabled && !m_cecAdapter && m_bStarted)
       InitialiseFeature(FEATURE_CEC);
   }
-  else if (strChangedSetting.Equals("cec_hdmi_port"))
+  else
   {
-    SetHdmiPort(GetSettingInt("cec_hdmi_port"));
+    SetConfigurationFromSettings();
+    m_queryThread->UpdateConfiguration(&m_configuration);
   }
 }
 
-void CPeripheralCecAdapter::FlushLog(void)
+int CPeripheralCecAdapter::CecLogMessage(void *cbParam, const cec_log_message &message)
 {
-  cec_log_message message;
-  while (m_cecAdapter && m_cecAdapter->GetNextLogMessage(&message))
-  {
-    int iLevel = -1;
-    switch (message.level)
-    {
-    case CEC_LOG_ERROR:
-      iLevel = LOGERROR;
-      break;
-    case CEC_LOG_WARNING:
-      iLevel = LOGWARNING;
-      break;
-    case CEC_LOG_NOTICE:
-      iLevel = LOGDEBUG;
-      break;
-    case CEC_LOG_TRAFFIC:
-    case CEC_LOG_DEBUG:
-      if (GetSettingBool("cec_debug_logging"))
-        iLevel = LOGDEBUG;
-      break;
-    default:
-      break;
-    }
+  CPeripheralCecAdapter *adapter = (CPeripheralCecAdapter *)cbParam;
+  if (!adapter)
+    return 0;
 
-    if (iLevel >= 0)
-      CLog::Log(iLevel, "%s - %s", __FUNCTION__, message.message);
+  int iLevel = -1;
+  switch (message.level)
+  {
+  case CEC_LOG_ERROR:
+    iLevel = LOGERROR;
+    break;
+  case CEC_LOG_WARNING:
+    iLevel = LOGWARNING;
+    break;
+  case CEC_LOG_NOTICE:
+    iLevel = LOGDEBUG;
+    break;
+  case CEC_LOG_TRAFFIC:
+  case CEC_LOG_DEBUG:
+    iLevel = LOGDEBUG;
+    break;
+  default:
+    break;
   }
+
+  if (iLevel >= 0)
+    CLog::Log(iLevel, "%s - %s", __FUNCTION__, message.message);
+
+  return 1;
 }
 
 bool CPeripheralCecAdapter::TranslateComPort(CStdString &strLocation)
@@ -774,4 +940,301 @@
 
   return false;
 }
+
+void CPeripheralCecAdapter::SetConfigurationFromLibCEC(const CEC::libcec_configuration &config)
+{
+  // set the primary device type
+  m_configuration.deviceTypes.Clear();
+  m_configuration.deviceTypes.Add(config.deviceTypes[0]);
+  SetSetting("device_type", (int)config.deviceTypes[0]);
+
+  // set the connected device
+  m_configuration.baseDevice = config.baseDevice;
+  SetSetting("connected_device", (int)config.baseDevice);
+
+  // set the HDMI port number
+  m_configuration.iHDMIPort = config.iHDMIPort;
+  SetSetting("cec_hdmi_port", config.iHDMIPort);
+
+  // set the physical address, when baseDevice or iHDMIPort are not set
+  if (m_configuration.baseDevice == CECDEVICE_UNKNOWN ||
+      m_configuration.iHDMIPort == 0 || m_configuration.iHDMIPort > 4)
+  {
+    m_configuration.iPhysicalAddress = config.iPhysicalAddress;
+    CStdString strPhysicalAddress;
+    strPhysicalAddress.Format("%x", config.iPhysicalAddress);
+    SetSetting("physical_address", strPhysicalAddress);
+  }
+
+  // set the tv vendor override
+  m_configuration.tvVendor = config.tvVendor;
+  SetSetting("tv_vendor", (int)config.tvVendor);
+
+  // set the devices to wake when starting
+  m_configuration.wakeDevices = config.wakeDevices;
+  CStdString strWakeDevices;
+  for (unsigned int iPtr = 0; iPtr <= 16; iPtr++)
+    if (config.wakeDevices[iPtr])
+      strWakeDevices.AppendFormat(" %X", iPtr);
+  SetSetting("wake_devices", strWakeDevices.Trim());
+
+  // set the devices to power off when stopping
+  m_configuration.powerOffDevices = config.powerOffDevices;
+  CStdString strPowerOffDevices;
+  for (unsigned int iPtr = 0; iPtr <= 16; iPtr++)
+    if (config.powerOffDevices[iPtr])
+      strPowerOffDevices.AppendFormat(" %X", iPtr);
+  SetSetting("wake_devices", strPowerOffDevices.Trim());
+
+  // set the boolean settings
+  m_configuration.bUseTVMenuLanguage = config.bUseTVMenuLanguage;
+  SetSetting("use_tv_menu_language", m_configuration.bUseTVMenuLanguage == 1);
+
+  m_configuration.bActivateSource = config.bActivateSource;
+  SetSetting("activate_source", m_configuration.bActivateSource == 1);
+
+  m_configuration.bPowerOffScreensaver = config.bPowerOffScreensaver;
+  SetSetting("cec_standby_screensaver", m_configuration.bPowerOffScreensaver == 1);
+
+  m_configuration.bPowerOffOnStandby = config.bPowerOffOnStandby;
+  SetSetting("standby_pc_on_tv_standby", m_configuration.bPowerOffOnStandby == 1);
+
+  if (config.serverVersion >= CEC_SERVER_VERSION_1_5_1)
+    m_configuration.bSendInactiveSource = config.bSendInactiveSource;
+  SetSetting("send_inactive_source", m_configuration.bSendInactiveSource == 1);
+}
+
+void CPeripheralCecAdapter::SetConfigurationFromSettings(void)
+{
+  // client version 1.5.0
+  m_configuration.clientVersion = CEC_CLIENT_VERSION_1_5_1;
+
+  // device name 'XBMC'
+  snprintf(m_configuration.strDeviceName, 13, "%s", GetSettingString("device_name").c_str());
+
+  // set the primary device type
+  m_configuration.deviceTypes.Clear();
+  int iDeviceType = GetSettingInt("device_type");
+  if (iDeviceType != (int)CEC_DEVICE_TYPE_RECORDING_DEVICE &&
+      iDeviceType != (int)CEC_DEVICE_TYPE_PLAYBACK_DEVICE &&
+      iDeviceType != (int)CEC_DEVICE_TYPE_TUNER)
+    iDeviceType = (int)CEC_DEVICE_TYPE_RECORDING_DEVICE;
+  m_configuration.deviceTypes.Add((cec_device_type)iDeviceType);
+
+  // always try to autodetect the address.
+  // when the firmware supports this, it will override the physical address, connected device and hdmi port settings
+  m_configuration.bAutodetectAddress = 1;
+
+  // set the physical address
+  // when set, it will override the connected device and hdmi port settings
+  CStdString strPhysicalAddress = GetSettingString("physical_address");
+  int iPhysicalAddress;
+  if (sscanf(strPhysicalAddress.c_str(), "%x", &iPhysicalAddress) == 1 && iPhysicalAddress > 0 && iPhysicalAddress < 0xFFFF)
+    m_configuration.iPhysicalAddress = iPhysicalAddress;
+
+  // set the connected device
+  int iConnectedDevice = GetSettingInt("connected_device");
+  if (iConnectedDevice == 0 || iConnectedDevice == 5)
+    m_configuration.baseDevice = (cec_logical_address)iConnectedDevice;
+
+  // set the HDMI port number
+  int iHDMIPort = GetSettingInt("cec_hdmi_port");
+  if (iHDMIPort >= 0 && iHDMIPort <= 4)
+    m_configuration.iHDMIPort = iHDMIPort;
+
+  // set the tv vendor override
+  int iVendor = GetSettingInt("tv_vendor");
+  if (iVendor > 0 && iVendor < 0xFFFFFF)
+    m_configuration.tvVendor = iVendor;
+
+  // read the devices to wake when starting
+  CStdString strWakeDevices = CStdString(GetSettingString("wake_devices")).Trim();
+  m_configuration.wakeDevices.Clear();
+  ReadLogicalAddresses(strWakeDevices, m_configuration.wakeDevices);
+
+  // read the devices to power off when stopping
+  CStdString strStandbyDevices = CStdString(GetSettingString("standby_devices")).Trim();
+  m_configuration.powerOffDevices.Clear();
+  ReadLogicalAddresses(strStandbyDevices, m_configuration.powerOffDevices);
+
+  // always get the settings from the rom, when supported by the firmware
+  m_configuration.bGetSettingsFromROM = 1;
+
+  // read the boolean settings
+  m_configuration.bUseTVMenuLanguage   = GetSettingBool("use_tv_menu_language") ? 1 : 0;
+  m_configuration.bActivateSource      = GetSettingBool("activate_source") ? 1 : 0;
+  m_configuration.bPowerOffScreensaver = GetSettingBool("cec_standby_screensaver") ? 1 : 0;
+  m_configuration.bPowerOffOnStandby   = GetSettingBool("standby_pc_on_tv_standby") ? 1 : 0;
+  m_configuration.bSendInactiveSource  = GetSettingBool("send_inactive_source") ? 1 : 0;
+}
+
+void CPeripheralCecAdapter::ReadLogicalAddresses(const CStdString &strString, cec_logical_addresses &addresses)
+{
+  for (size_t iPtr = 0; iPtr < strString.size(); iPtr++)
+  {
+    CStdString strDevice = CStdString(strString.substr(iPtr, 1)).Trim();
+    if (!strDevice.IsEmpty())
+    {
+      int iDevice(0);
+      if (sscanf(strDevice.c_str(), "%x", &iDevice) == 1 && iDevice >= 0 && iDevice <= 0xF)
+        addresses.Set((cec_logical_address)iDevice);
+    }
+  }
+}
+
+CPeripheralCecAdapterUpdateThread::CPeripheralCecAdapterUpdateThread(CPeripheralCecAdapter *adapter, libcec_configuration *configuration) :
+    CThread("CEC Adapter Update Thread"),
+    m_adapter(adapter),
+    m_configuration(*configuration),
+    m_bNextConfigurationScheduled(false),
+    m_bIsUpdating(true)
+{
+  m_nextConfiguration.Clear();
+  m_event.Reset();
+}
+
+CPeripheralCecAdapterUpdateThread::~CPeripheralCecAdapterUpdateThread(void)
+{
+  StopThread(false);
+  m_event.Set();
+  StopThread(true);
+}
+
+void CPeripheralCecAdapterUpdateThread::Signal(void)
+{
+  m_event.Set();
+}
+
+bool CPeripheralCecAdapterUpdateThread::UpdateConfiguration(libcec_configuration *configuration)
+{
+  CSingleLock lock(m_critSection);
+  if (m_bIsUpdating)
+  {
+    m_bNextConfigurationScheduled = true;
+    m_nextConfiguration = *configuration;
+  }
+  else
+  {
+    m_configuration = *configuration;
+    m_event.Set();
+  }
+  return true;
+}
+
+bool CPeripheralCecAdapterUpdateThread::WaitReady(void)
+{
+  // don't wait if we're not powering up anything
+  if (m_configuration.wakeDevices.IsEmpty() && m_configuration.bActivateSource == 0)
+    return true;
+
+  // wait for the TV if we're configured to become the active source.
+  // wait for the first device in the wake list otherwise.
+  cec_logical_address waitFor = (m_configuration.bActivateSource == 1) ?
+      CECDEVICE_TV :
+      m_configuration.wakeDevices.primary;
+
+  cec_power_status powerStatus(CEC_POWER_STATUS_UNKNOWN);
+  bool bContinue(true);
+  while (bContinue && !m_adapter->m_bStop && !m_bStop && powerStatus != CEC_POWER_STATUS_ON)
+  {
+    powerStatus = m_adapter->m_cecAdapter->GetDevicePowerStatus(waitFor);
+    if (powerStatus != CEC_POWER_STATUS_ON)
+      bContinue = !m_event.WaitMSec(1000);
+  }
+
+  return powerStatus == CEC_POWER_STATUS_ON;
+}
+
+bool CPeripheralCecAdapterUpdateThread::SetInitialConfiguration(void)
+{
+  // devices to wake are set
+  if (!m_configuration.wakeDevices.IsEmpty())
+    m_adapter->m_cecAdapter->PowerOnDevices(CECDEVICE_BROADCAST);
+
+  // the option to make XBMC the active source is set
+  if (m_configuration.bActivateSource == 1)
+    m_adapter->m_cecAdapter->SetActiveSource();
+
+  // wait until devices are powered up
+  if (!WaitReady())
+    return false;
+
+  // request the menu language of the TV
+  if (m_configuration.bUseTVMenuLanguage == 1)
+  {
+    cec_menu_language language;
+    if (m_adapter->m_cecAdapter->GetDeviceMenuLanguage(CECDEVICE_TV, &language))
+      m_adapter->SetMenuLanguage(language.language);
+  }
+
+  // request the OSD name of the TV
+  CStdString strNotification;
+  cec_osd_name tvName = m_adapter->m_cecAdapter->GetDeviceOSDName(CECDEVICE_TV);
+  strNotification.Format("%s: %s", g_localizeStrings.Get(36016), tvName.name);
+
+  /* disable the mute setting when an amp is found, because the amp handles the mute setting and
+     set PCM output to 100% */
+  if (m_adapter->m_cecAdapter->IsActiveDeviceType(CEC_DEVICE_TYPE_AUDIO_SYSTEM))
+  {
+    // request the OSD name of the amp
+    cec_osd_name ampName = m_adapter->m_cecAdapter->GetDeviceOSDName(CECDEVICE_AUDIOSYSTEM);
+    CLog::Log(LOGDEBUG, "%s - CEC capable amplifier found (%s). volume will be controlled on the amp", __FUNCTION__, ampName.name);
+    strNotification.AppendFormat(" - %s", ampName.name);
+
+    // set amp present
+    m_adapter->SetAudioSystemConnected(true);
+    g_settings.m_bMute = false;
+    g_settings.m_nVolumeLevel = VOLUME_MAXIMUM;
+  }
+
+  m_adapter->m_bIsReady = true;
+
+  // try to send an OSD string to the TV
+  m_adapter->m_cecAdapter->SetOSDString(CECDEVICE_TV, CEC_DISPLAY_CONTROL_DISPLAY_FOR_DEFAULT_TIME, g_localizeStrings.Get(36016).c_str());
+  // and let the gui know that we're done
+  CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, g_localizeStrings.Get(36000), strNotification);
+
+  CSingleLock lock(m_critSection);
+  m_bIsUpdating = false;
+  return true;
+}
+
+void CPeripheralCecAdapterUpdateThread::Process(void)
+{
+  // set the initial configuration
+  if (!SetInitialConfiguration())
+    return;
+
+  // and wait for updates
+  bool bUpdate(false);
+  while (!m_bStop)
+  {
+    // update received
+    if (m_event.WaitMSec(500) || bUpdate)
+    {
+      if (m_bStop)
+        return;
+      // set the new configuration
+      bool bConfigSet(m_adapter->m_cecAdapter->SetConfiguration(&m_configuration));
+      CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, g_localizeStrings.Get(36000), g_localizeStrings.Get(bConfigSet ? 36023 : 36024));
+      {
+        CSingleLock lock(m_critSection);
+        bUpdate = m_bNextConfigurationScheduled;
+        if (bUpdate)
+        {
+          // another update is scheduled
+          m_bNextConfigurationScheduled = false;
+          m_configuration = m_nextConfiguration;
+        }
+        else
+        {
+          // nothing left to do, wait for updates
+          m_bIsUpdating = false;
+          m_event.Reset();
+        }
+      }
+    }
+  }
+}
+
 #endif
diff -Naur xbmc-pvr-11.0.1/xbmc/peripherals/devices/PeripheralCecAdapter.h xbmc-pvr-11.0.1.patch/xbmc/peripherals/devices/PeripheralCecAdapter.h
--- xbmc-pvr-11.0.1/xbmc/peripherals/devices/PeripheralCecAdapter.h	2012-03-27 17:55:34.000000000 +0200
+++ xbmc-pvr-11.0.1.patch/xbmc/peripherals/devices/PeripheralCecAdapter.h	2012-04-17 14:05:05.882177854 +0200
@@ -20,7 +20,28 @@
  *
  */
 
-#if defined(HAVE_LIBCEC)
+#if !defined(HAVE_LIBCEC)
+#include "Peripheral.h"
+
+// an empty implementation, so CPeripherals can be compiled without a bunch of #ifdef's when libCEC is not available
+namespace PERIPHERALS
+{
+  class CPeripheralCecAdapter : public CPeripheral
+  {
+  public:
+    bool HasConnectedAudioSystem(void) { return false; }
+    void ScheduleVolumeUp(void) {}
+    void ScheduleVolumeDown(void) {}
+    bool IsMuted(void) { return false; }
+    void ScheduleMute(void) {}
+
+    WORD GetButton(void) { return 0; }
+    unsigned int GetHoldTime(void) { return 0; }
+    void ResetButton(void) {}
+  };
+}
+
+#else
 
 #include "PeripheralHID.h"
 #include "interfaces/AnnouncementManager.h"
@@ -32,7 +53,7 @@
 #ifdef isset
 #undef isset
 #endif
-#include <cectypes.h>
+#include <libcec/cectypes.h>
 
 class DllLibCEC;
 
@@ -43,25 +64,40 @@
 
 namespace PERIPHERALS
 {
+  class CPeripheralCecAdapterUpdateThread;
+
   typedef struct
   {
     WORD         iButton;
     unsigned int iDuration;
   } CecButtonPress;
 
+  typedef enum
+  {
+    VOLUME_CHANGE_NONE,
+    VOLUME_CHANGE_UP,
+    VOLUME_CHANGE_DOWN,
+    VOLUME_CHANGE_MUTE
+  } CecVolumeChange;
 
   class CPeripheralCecAdapter : public CPeripheralHID, public ANNOUNCEMENT::IAnnouncer, private CThread
   {
+    friend class CPeripheralCecAdapterUpdateThread;
+
   public:
     CPeripheralCecAdapter(const PeripheralType type, const PeripheralBusType busType, const CStdString &strLocation, const CStdString &strDeviceName, int iVendorId, int iProductId);
     virtual ~CPeripheralCecAdapter(void);
 
     virtual void Announce(ANNOUNCEMENT::EAnnouncementFlag flag, const char *sender, const char *message, const CVariant &data);
-    virtual bool PowerOnCecDevices(CEC::cec_logical_address iLogicalAddress);
-    virtual bool StandbyCecDevices(CEC::cec_logical_address iLogicalAddress);
-
-    virtual bool SendPing(void);
-    virtual bool SetHdmiPort(int iHdmiPort);
+    virtual bool HasConnectedAudioSystem(void);
+    virtual void SetAudioSystemConnected(bool bSetTo);
+    virtual void ScheduleVolumeUp(void);
+    virtual void VolumeUp(void);
+    virtual void ScheduleVolumeDown(void);
+    virtual void VolumeDown(void);
+    virtual void ScheduleMute(void);
+    virtual void Mute(void);
+    virtual bool IsMuted(void);
 
     virtual void OnSettingChanged(const CStdString &strChangedSetting);
 
@@ -71,27 +107,66 @@
     virtual CStdString GetComPort(void);
 
   protected:
-    virtual void FlushLog(void);
-    virtual bool GetNextCecKey(CEC::cec_keypress &key);
+    virtual bool OpenConnection(void);
+    virtual void SetConfigurationFromSettings(void);
+    virtual void SetConfigurationFromLibCEC(const CEC::libcec_configuration &config);
+    static void ReadLogicalAddresses(const CStdString &strString, CEC::cec_logical_addresses &addresses);
+    static int CecKeyPress(void *cbParam, const CEC::cec_keypress &key);
+    static int CecLogMessage(void *cbParam, const CEC::cec_log_message &message);
+    static int CecCommand(void *cbParam, const CEC::cec_command &command);
+    static int CecConfiguration(void *cbParam, const CEC::libcec_configuration &config);
+
     virtual bool GetNextKey(void);
+    virtual bool GetNextCecKey(CEC::cec_keypress &key);
     virtual bool InitialiseFeature(const PeripheralFeature feature);
     virtual void Process(void);
-    virtual void ProcessNextCommand(void);
+    virtual void ProcessVolumeChange(void);
     virtual void SetMenuLanguage(const char *strLanguage);
     static bool FindConfigLocation(CStdString &strString);
     static bool TranslateComPort(CStdString &strPort);
 
-    DllLibCEC*                    m_dll;
-    CEC::ICECAdapter*             m_cecAdapter;
-    bool                          m_bStarted;
-    bool                          m_bHasButton;
-    bool                          m_bIsReady;
-    CStdString                    m_strMenuLanguage;
-    CDateTime                     m_screensaverLastActivated;
-    CecButtonPress                m_button;
-    std::queue<CEC::cec_keypress> m_buttonQueue;
-    unsigned int                  m_lastKeypress;
-    CCriticalSection              m_critSection;
+    DllLibCEC*                        m_dll;
+    CEC::ICECAdapter*                 m_cecAdapter;
+    bool                              m_bStarted;
+    bool                              m_bHasButton;
+    bool                              m_bIsReady;
+    bool                              m_bHasConnectedAudioSystem;
+    CStdString                        m_strMenuLanguage;
+    CDateTime                         m_screensaverLastActivated;
+    CecButtonPress                    m_button;
+    std::queue<CEC::cec_keypress>     m_buttonQueue;
+    std::queue<CecVolumeChange>       m_volumeChangeQueue;
+    unsigned int                      m_lastKeypress;
+    CecVolumeChange                   m_lastChange;
+    int                               m_iExitCode;
+    bool                              m_bIsMuted;
+    CPeripheralCecAdapterUpdateThread*m_queryThread;
+    CEC::ICECCallbacks                m_callbacks;
+    CCriticalSection                  m_critSection;
+    CEC::libcec_configuration         m_configuration;
+  };
+
+  class CPeripheralCecAdapterUpdateThread : public CThread
+  {
+  public:
+    CPeripheralCecAdapterUpdateThread(CPeripheralCecAdapter *adapter, CEC::libcec_configuration *configuration);
+    virtual ~CPeripheralCecAdapterUpdateThread(void);
+
+    virtual void Signal(void);
+    virtual bool UpdateConfiguration(CEC::libcec_configuration *configuration);
+
+  protected:
+    virtual bool WaitReady(void);
+    virtual bool SetInitialConfiguration(void);
+    virtual void Process(void);
+
+    CPeripheralCecAdapter *    m_adapter;
+    CEvent                     m_event;
+    CCriticalSection           m_critSection;
+    CEC::libcec_configuration  m_configuration;
+    CEC::libcec_configuration  m_nextConfiguration;
+    bool                       m_bNextConfigurationScheduled;
+    bool                       m_bIsUpdating;
   };
 }
 
diff -Naur xbmc-pvr-11.0.1/xbmc/peripherals/devices/Peripheral.cpp xbmc-pvr-11.0.1.patch/xbmc/peripherals/devices/Peripheral.cpp
--- xbmc-pvr-11.0.1/xbmc/peripherals/devices/Peripheral.cpp	2012-03-27 17:55:34.000000000 +0200
+++ xbmc-pvr-11.0.1.patch/xbmc/peripherals/devices/Peripheral.cpp	2012-04-17 14:03:25.174271152 +0200
@@ -30,6 +30,14 @@
 using namespace PERIPHERALS;
 using namespace std;
 
+struct SortBySettingsOrder
+{
+  bool operator()(const CSetting *left, const CSetting *right)
+  {
+    return left->GetOrder() < right->GetOrder();
+  }
+};
+
 CPeripheral::CPeripheral(const PeripheralType type, const PeripheralBusType busType, const CStdString &strLocation, const CStdString &strDeviceName, int iVendorId, int iProductId) :
   m_type(type),
   m_busType(busType),
@@ -168,6 +176,15 @@
   return m_subDevices.size() > 0;
 }
 
+vector<CSetting *> CPeripheral::GetSettings(void) const
+{
+  vector<CSetting *> settings;
+  for (map<CStdString, CSetting *>::const_iterator it = m_settings.begin(); it != m_settings.end(); it++)
+    settings.push_back(it->second);
+  sort(settings.begin(), settings.end(), SortBySettingsOrder());
+  return settings;
+}
+
 void CPeripheral::AddSetting(const CStdString &strKey, const CSetting *setting)
 {
   if (!setting)
@@ -183,7 +200,7 @@
     case SETTINGS_TYPE_BOOL:
       {
         const CSettingBool *mappedSetting = (const CSettingBool *) setting;
-        CSettingBool *boolSetting = new CSettingBool(0, strKey.c_str(), mappedSetting->GetLabel(), mappedSetting->GetData(), mappedSetting->GetControlType());
+        CSettingBool *boolSetting = new CSettingBool(mappedSetting->GetOrder(), strKey.c_str(), mappedSetting->GetLabel(), mappedSetting->GetData(), mappedSetting->GetControlType());
         if (boolSetting)
         {
           boolSetting->SetVisible(mappedSetting->IsVisible());
@@ -194,7 +211,7 @@
     case SETTINGS_TYPE_INT:
       {
         const CSettingInt *mappedSetting = (const CSettingInt *) setting;
-        CSettingInt *intSetting = new CSettingInt(0, strKey.c_str(), mappedSetting->GetLabel(), mappedSetting->GetData(), mappedSetting->m_iMin, mappedSetting->m_iStep, mappedSetting->m_iMax, mappedSetting->GetControlType(), mappedSetting->m_strFormat);
+        CSettingInt *intSetting = new CSettingInt(mappedSetting->GetOrder(), strKey.c_str(), mappedSetting->GetLabel(), mappedSetting->GetData(), mappedSetting->m_iMin, mappedSetting->m_iStep, mappedSetting->m_iMax, mappedSetting->GetControlType(), mappedSetting->m_strFormat);
         if (intSetting)
         {
           intSetting->SetVisible(mappedSetting->IsVisible());
@@ -205,7 +222,7 @@
     case SETTINGS_TYPE_FLOAT:
       {
         const CSettingFloat *mappedSetting = (const CSettingFloat *) setting;
-        CSettingFloat *floatSetting = new CSettingFloat(0, strKey.c_str(), mappedSetting->GetLabel(), mappedSetting->GetData(), mappedSetting->m_fMin, mappedSetting->m_fStep, mappedSetting->m_fMax, mappedSetting->GetControlType());
+        CSettingFloat *floatSetting = new CSettingFloat(mappedSetting->GetOrder(), strKey.c_str(), mappedSetting->GetLabel(), mappedSetting->GetData(), mappedSetting->m_fMin, mappedSetting->m_fStep, mappedSetting->m_fMax, mappedSetting->GetControlType());
         if (floatSetting)
         {
           floatSetting->SetVisible(mappedSetting->IsVisible());
@@ -216,7 +233,7 @@
     case SETTINGS_TYPE_STRING:
       {
         const CSettingString *mappedSetting = (const CSettingString *) setting;
-        CSettingString *stringSetting = new CSettingString(0, strKey.c_str(), mappedSetting->GetLabel(), mappedSetting->GetData().c_str(), mappedSetting->GetControlType(), mappedSetting->m_bAllowEmpty, mappedSetting->m_iHeadingString);
+        CSettingString *stringSetting = new CSettingString(mappedSetting->GetOrder(), strKey.c_str(), mappedSetting->GetLabel(), mappedSetting->GetData().c_str(), mappedSetting->GetControlType(), mappedSetting->m_bAllowEmpty, mappedSetting->m_iHeadingString);
         if (stringSetting)
         {
           stringSetting->SetVisible(mappedSetting->IsVisible());
@@ -323,7 +340,7 @@
       bool bChanged(boolSetting->GetData() != bValue);
       boolSetting->SetData(bValue);
       if (bChanged && m_bInitialised)
-        m_changedSettings.push_back(strKey);
+        m_changedSettings.insert(strKey);
     }
   }
 }
@@ -339,7 +356,7 @@
       bool bChanged(intSetting->GetData() != iValue);
       intSetting->SetData(iValue);
       if (bChanged && m_bInitialised)
-        m_changedSettings.push_back(strKey);
+        m_changedSettings.insert(strKey);
     }
   }
 }
@@ -355,11 +372,26 @@
       bool bChanged(floatSetting->GetData() != fValue);
       floatSetting->SetData(fValue);
       if (bChanged && m_bInitialised)
-        m_changedSettings.push_back(strKey);
+        m_changedSettings.insert(strKey);
     }
   }
 }
 
+void CPeripheral::SetSettingVisible(const CStdString &strKey, bool bSetTo)
+{
+  map<CStdString, CSetting *>::iterator it = m_settings.find(strKey);
+  if (it != m_settings.end())
+    (*it).second->SetVisible(bSetTo);
+}
+
+bool CPeripheral::IsSettingVisible(const CStdString &strKey) const
+{
+  map<CStdString, CSetting *>::const_iterator it = m_settings.find(strKey);
+  if (it != m_settings.end())
+    return (*it).second->IsVisible();
+  return false;
+}
+
 void CPeripheral::SetSetting(const CStdString &strKey, const CStdString &strValue)
 {
   map<CStdString, CSetting *>::iterator it = m_settings.find(strKey);
@@ -373,7 +405,7 @@
         bool bChanged(!stringSetting->GetData().Equals(strValue));
         stringSetting->SetData(strValue);
         if (bChanged && m_bInitialised)
-          m_changedSettings.push_back(strKey);
+          m_changedSettings.insert(strKey);
       }
     }
     else if ((*it).second->GetType() == SETTINGS_TYPE_INT)
@@ -436,7 +468,7 @@
 
   if (!bExiting)
   {
-    for (vector<CStdString>::iterator it = m_changedSettings.begin(); it != m_changedSettings.end(); it++)
+    for (set<CStdString>::const_iterator it = m_changedSettings.begin(); it != m_changedSettings.end(); it++)
       OnSettingChanged(*it);
   }
   m_changedSettings.clear();
@@ -467,7 +499,7 @@
   map<CStdString, CSetting *>::iterator it = m_settings.begin();
   while (it != m_settings.end())
   {
-    m_changedSettings.push_back((*it).first);
+    m_changedSettings.insert((*it).first);
     ++it;
   }
 
diff -Naur xbmc-pvr-11.0.1/xbmc/peripherals/devices/Peripheral.h xbmc-pvr-11.0.1.patch/xbmc/peripherals/devices/Peripheral.h
--- xbmc-pvr-11.0.1/xbmc/peripherals/devices/Peripheral.h	2012-03-27 17:55:34.000000000 +0200
+++ xbmc-pvr-11.0.1.patch/xbmc/peripherals/devices/Peripheral.h	2012-04-17 14:03:25.174271152 +0200
@@ -20,7 +20,7 @@
  *
  */
 
-#include <vector>
+#include <set>
 #include "utils/StdString.h"
 #include "peripherals/PeripheralTypes.h"
 
@@ -128,6 +128,8 @@
      */
     virtual const CStdString GetSettingString(const CStdString &strKey) const;
     virtual void SetSetting(const CStdString &strKey, const CStdString &strValue);
+    virtual void SetSettingVisible(const CStdString &strKey, bool bSetTo);
+    virtual bool IsSettingVisible(const CStdString &strKey) const;
 
     virtual int GetSettingInt(const CStdString &strKey) const;
     virtual void SetSetting(const CStdString &strKey, int iValue);
@@ -142,6 +144,8 @@
     virtual void LoadPersistedSettings(void);
     virtual void ResetDefaultSettings(void);
 
+    virtual std::vector<CSetting *> GetSettings(void) const;
+
     virtual bool ErrorOccured(void) const { return m_bError; }
 
   protected:
@@ -163,6 +167,6 @@
     std::vector<PeripheralFeature>   m_features;
     std::vector<CPeripheral *>       m_subDevices;
     std::map<CStdString, CSetting *> m_settings;
-    std::vector<CStdString>          m_changedSettings;
+    std::set<CStdString>             m_changedSettings;
   };
 }
diff -Naur xbmc-pvr-11.0.1/xbmc/peripherals/devices/PeripheralHID.cpp xbmc-pvr-11.0.1.patch/xbmc/peripherals/devices/PeripheralHID.cpp
--- xbmc-pvr-11.0.1/xbmc/peripherals/devices/PeripheralHID.cpp	2012-03-27 17:55:34.000000000 +0200
+++ xbmc-pvr-11.0.1.patch/xbmc/peripherals/devices/PeripheralHID.cpp	2012-04-17 14:03:25.173271133 +0200
@@ -37,7 +37,7 @@
 
 CPeripheralHID::~CPeripheralHID(void)
 {
-  if (!m_strKeymap.IsEmpty() && GetSettingBool("keymap_enabled"))
+  if (!m_strKeymap.IsEmpty() && !GetSettingBool("do_not_use_custom_keymap"))
   {
     CLog::Log(LOGDEBUG, "%s - switching active keymapping to: default", __FUNCTION__);
     CButtonTranslator::GetInstance().RemoveDevice(m_strKeymap);
@@ -59,9 +59,12 @@
       SetSetting("keymap", m_strKeymap);
     }
 
+    if (!IsSettingVisible("keymap"))
+      SetSettingVisible("do_not_use_custom_keymap", false);
+
     if (!m_strKeymap.IsEmpty())
     {
-      bool bKeymapEnabled(GetSettingBool("keymap_enabled"));
+      bool bKeymapEnabled(!GetSettingBool("do_not_use_custom_keymap"));
       if (bKeymapEnabled)
       {
         CLog::Log(LOGDEBUG, "%s - adding keymapping for: %s", __FUNCTION__, m_strKeymap.c_str());
@@ -82,7 +85,7 @@
 
 void CPeripheralHID::OnSettingChanged(const CStdString &strChangedSetting)
 {
-  if (m_bInitialised && ((strChangedSetting.Equals("keymap") && GetSettingBool("keymap_enabled")) || strChangedSetting.Equals("keymap_enabled")))
+  if (m_bInitialised && ((strChangedSetting.Equals("keymap") && !GetSettingBool("do_not_use_custom_keymap")) || strChangedSetting.Equals("keymap_enabled")))
   {
     m_bInitialised = false;
     InitialiseFeature(FEATURE_HID);
diff -Naur xbmc-pvr-11.0.1/xbmc/peripherals/dialogs/GUIDialogPeripheralSettings.cpp xbmc-pvr-11.0.1.patch/xbmc/peripherals/dialogs/GUIDialogPeripheralSettings.cpp
--- xbmc-pvr-11.0.1/xbmc/peripherals/dialogs/GUIDialogPeripheralSettings.cpp	2012-03-27 17:55:34.000000000 +0200
+++ xbmc-pvr-11.0.1.patch/xbmc/peripherals/dialogs/GUIDialogPeripheralSettings.cpp	2012-04-17 14:03:25.169271055 +0200
@@ -66,17 +66,15 @@
 
   if (m_item)
   {
-    int iIndex = 1;
     CPeripheral *peripheral = g_peripherals.GetByPath(m_item->GetPath());
     if (peripheral)
     {
-      map<CStdString, CSetting *>::iterator it = peripheral->m_settings.begin();
-      while (it != peripheral->m_settings.end())
+      vector<CSetting *> settings = peripheral->GetSettings();
+      for (size_t iPtr = 0; iPtr < settings.size(); iPtr++)
       {
-        CSetting *setting = (*it).second;
+        CSetting *setting = settings[iPtr];
         if (!setting->IsVisible())
         {
-          ++it;
           CLog::Log(LOGDEBUG, "%s - invisible", __FUNCTION__);
           continue;
         }
@@ -89,7 +87,7 @@
             if (boolSetting)
             {
               m_boolSettings.insert(make_pair(CStdString(boolSetting->GetSetting()), boolSetting->GetData()));
-              AddBool(iIndex++, boolSetting->GetLabel(), &m_boolSettings[boolSetting->GetSetting()], true);
+              AddBool(boolSetting->GetOrder(), boolSetting->GetLabel(), &m_boolSettings[boolSetting->GetSetting()], true);
             }
           }
           break;
@@ -99,7 +97,7 @@
             if (intSetting)
             {
               m_intSettings.insert(make_pair(CStdString(intSetting->GetSetting()), (float) intSetting->GetData()));
-              AddSlider(iIndex++, intSetting->GetLabel(), &m_intSettings[intSetting->GetSetting()], (float)intSetting->m_iMin, (float)intSetting->m_iStep, (float)intSetting->m_iMax, CGUIDialogVideoSettings::FormatInteger, false);
+              AddSlider(intSetting->GetOrder(), intSetting->GetLabel(), &m_intSettings[intSetting->GetSetting()], (float)intSetting->m_iMin, (float)intSetting->m_iStep, (float)intSetting->m_iMax, CGUIDialogVideoSettings::FormatInteger, false);
             }
           }
           break;
@@ -109,7 +107,7 @@
             if (floatSetting)
             {
               m_floatSettings.insert(make_pair(CStdString(floatSetting->GetSetting()), floatSetting->GetData()));
-              AddSlider(iIndex++, floatSetting->GetLabel(), &m_floatSettings[floatSetting->GetSetting()], floatSetting->m_fMin, floatSetting->m_fStep, floatSetting->m_fMax, CGUIDialogVideoSettings::FormatFloat, false);
+              AddSlider(floatSetting->GetOrder(), floatSetting->GetLabel(), &m_floatSettings[floatSetting->GetSetting()], floatSetting->m_fMin, floatSetting->m_fStep, floatSetting->m_fMax, CGUIDialogVideoSettings::FormatFloat, false);
             }
           }
           break;
@@ -119,7 +117,7 @@
             if (stringSetting)
             {
               m_stringSettings.insert(make_pair(CStdString(stringSetting->GetSetting()), stringSetting->GetData()));
-              AddString(iIndex, stringSetting->GetLabel(), &m_stringSettings[stringSetting->GetSetting()]);
+              AddString(stringSetting->GetOrder(), stringSetting->GetLabel(), &m_stringSettings[stringSetting->GetSetting()]);
             }
           }
           break;
@@ -128,7 +126,6 @@
           CLog::Log(LOGDEBUG, "%s - unknown type", __FUNCTION__);
           break;
         }
-        ++it;
       }
     }
     else
diff -Naur xbmc-pvr-11.0.1/xbmc/peripherals/Peripherals.cpp xbmc-pvr-11.0.1.patch/xbmc/peripherals/Peripherals.cpp
--- xbmc-pvr-11.0.1/xbmc/peripherals/Peripherals.cpp	2012-03-27 17:55:34.000000000 +0200
+++ xbmc-pvr-11.0.1.patch/xbmc/peripherals/Peripherals.cpp	2012-04-17 14:03:25.213271888 +0200
@@ -27,9 +27,7 @@
 #include "devices/PeripheralNIC.h"
 #include "devices/PeripheralNyxboard.h"
 #include "devices/PeripheralTuner.h"
-#if defined(HAVE_LIBCEC)
 #include "devices/PeripheralCecAdapter.h"
-#endif
 #include "bus/PeripheralBusUSB.h"
 #include "dialogs/GUIDialogPeripheralManager.h"
 
@@ -43,6 +41,7 @@
 #include "guilib/LocalizeStrings.h"
 #include "dialogs/GUIDialogKaiToast.h"
 #include "utils/StringUtils.h"
+#include "guilib/Key.h"
 
 using namespace PERIPHERALS;
 using namespace XFILE;
@@ -447,6 +446,8 @@
 void CPeripherals::GetSettingsFromMappingsFile(TiXmlElement *xmlNode, map<CStdString, CSetting *> &m_settings)
 {
   TiXmlElement *currentNode = xmlNode->FirstChildElement("setting");
+  int iMaxOrder(0);
+
   while (currentNode)
   {
     CSetting *setting = NULL;
@@ -492,10 +493,32 @@
     }
 
     //TODO add more types if needed
+
+    /* set the visibility */
     setting->SetVisible(bConfigurable);
+
+    /* set the order */
+    int iOrder(0);
+    currentNode->Attribute("order", &iOrder);
+    /* if the order attribute is invalid or 0, then the setting will be added at the end */
+    if (iOrder < 0)
+      iOrder = 0;
+    setting->SetOrder(iOrder);
+    if (iOrder > iMaxOrder)
+      iMaxOrder = iOrder;
+
+    /* and add this new setting */
     m_settings[strKey] = setting;
+
     currentNode = currentNode->NextSiblingElement("setting");
   }
+
+  /* add the settings without an order attribute or an invalid order attribute set at the end */
+  for (map<CStdString, CSetting *>::iterator it = m_settings.begin(); it != m_settings.end(); it++)
+  {
+    if (it->second->GetOrder() == 0)
+      it->second->SetOrder(++iMaxOrder);
+  }
 }
 
 void CPeripherals::GetDirectory(const CStdString &strPath, CFileItemList &items) const
@@ -531,3 +554,89 @@
 
   return NULL;
 }
+
+bool CPeripherals::OnAction(const CAction &action)
+{
+  if (action.GetID() == ACTION_MUTE)
+  {
+    return ToggleMute();
+  }
+
+  if (SupportsCEC() && action.GetAmount() && (action.GetID() == ACTION_VOLUME_UP || action.GetID() == ACTION_VOLUME_DOWN))
+  {
+    vector<CPeripheral *> peripherals;
+    if (GetPeripheralsWithFeature(peripherals, FEATURE_CEC))
+    {
+      for (unsigned int iPeripheralPtr = 0; iPeripheralPtr < peripherals.size(); iPeripheralPtr++)
+      {
+        CPeripheralCecAdapter *cecDevice = (CPeripheralCecAdapter *) peripherals.at(iPeripheralPtr);
+        if (cecDevice && cecDevice->HasConnectedAudioSystem())
+        {
+          if (action.GetID() == ACTION_VOLUME_UP)
+            cecDevice->ScheduleVolumeUp();
+          else
+            cecDevice->ScheduleVolumeDown();
+          return true;
+        }
+      }
+    }
+  }
+
+  return false;
+}
+
+bool CPeripherals::IsMuted(void)
+{
+  vector<CPeripheral *> peripherals;
+  if (SupportsCEC() && GetPeripheralsWithFeature(peripherals, FEATURE_CEC))
+  {
+    for (unsigned int iPeripheralPtr = 0; iPeripheralPtr < peripherals.size(); iPeripheralPtr++)
+    {
+      CPeripheralCecAdapter *cecDevice = (CPeripheralCecAdapter *) peripherals.at(iPeripheralPtr);
+      if (cecDevice && cecDevice->IsMuted())
+        return true;
+    }
+  }
+
+  return false;
+}
+
+bool CPeripherals::ToggleMute(void)
+{
+  vector<CPeripheral *> peripherals;
+  if (SupportsCEC() && GetPeripheralsWithFeature(peripherals, FEATURE_CEC))
+  {
+    for (unsigned int iPeripheralPtr = 0; iPeripheralPtr < peripherals.size(); iPeripheralPtr++)
+    {
+      CPeripheralCecAdapter *cecDevice = (CPeripheralCecAdapter *) peripherals.at(iPeripheralPtr);
+      if (cecDevice && cecDevice->HasConnectedAudioSystem())
+      {
+        cecDevice->ScheduleMute();
+        return true;
+      }
+    }
+  }
+
+  return false;
+}
+
+bool CPeripherals::GetNextKeypress(float frameTime, CKey &key)
+{
+  vector<CPeripheral *> peripherals;
+  if (SupportsCEC() && GetPeripheralsWithFeature(peripherals, FEATURE_CEC))
+  {
+    for (unsigned int iPeripheralPtr = 0; iPeripheralPtr < peripherals.size(); iPeripheralPtr++)
+    {
+      CPeripheralCecAdapter *cecDevice = (CPeripheralCecAdapter *) peripherals.at(iPeripheralPtr);
+      if (cecDevice && cecDevice->GetButton())
+      {
+        CKey newKey(cecDevice->GetButton(), cecDevice->GetHoldTime());
+        cecDevice->ResetButton();
+        key = newKey;
+        return true;
+      }
+    }
+  }
+
+  return false;
+}
diff -Naur xbmc-pvr-11.0.1/xbmc/peripherals/Peripherals.h xbmc-pvr-11.0.1.patch/xbmc/peripherals/Peripherals.h
--- xbmc-pvr-11.0.1/xbmc/peripherals/Peripherals.h	2012-03-27 17:55:34.000000000 +0200
+++ xbmc-pvr-11.0.1.patch/xbmc/peripherals/Peripherals.h	2012-04-17 14:03:25.213271888 +0200
@@ -29,6 +29,8 @@
 class CSetting;
 class CSettingsCategory;
 class TiXmlElement;
+class CAction;
+class CKey;
 
 namespace PERIPHERALS
 {
@@ -147,6 +149,54 @@
      */
     virtual CPeripheral *GetByPath(const CStdString &strPath) const;
 
+    /*!
+     * @brief Try to let one of the peripherals handle an action.
+     * @param action The change to handle.
+     * @return True when this change was handled by a peripheral (and should not be handled by anything else), false otherwise.
+     */
+    virtual bool OnAction(const CAction &action);
+
+    /*!
+     * @brief Check whether there's a peripheral that reports to be muted.
+     * @return True when at least one peripheral reports to be muted, false otherwise.
+     */
+    virtual bool IsMuted(void);
+
+    /*!
+     * @brief Try to toggle the mute status via a peripheral.
+     * @return True when this change was handled by a peripheral (and should not be handled by anything else), false otherwise.
+     */
+    virtual bool ToggleMute(void);
+
+    /*!
+     * @brief Try to mute the audio via a peripheral.
+     * @return True when this change was handled by a peripheral (and should not be handled by anything else), false otherwise.
+     */
+    virtual bool Mute(void) { return ToggleMute(); } // TODO CEC only supports toggling the mute status at this time
+
+    /*!
+     * @brief Try to unmute the audio via a peripheral.
+     * @return True when this change was handled by a peripheral (and should not be handled by anything else), false otherwise.
+     */
+    virtual bool UnMute(void) { return ToggleMute(); } // TODO CEC only supports toggling the mute status at this time
+
+    /*!
+     * @brief Try to get a keypress from a peripheral.
+     * @param frameTime The current frametime.
+     * @param key The fetched key.
+     * @return True when a keypress was fetched, false otherwise.
+     */
+    virtual bool GetNextKeypress(float frameTime, CKey &key);
+
+    bool SupportsCEC(void) const
+    {
+#if defined(HAVE_LIBCEC)
+      return true;
+#else
+      return false;
+#endif
+    }
+
   private:
     CPeripherals(void);
     bool LoadMappings(void);
