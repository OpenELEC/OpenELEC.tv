From e9ba481689355c1d67e2e6097c1fe8a60af28d14 Mon Sep 17 00:00:00 2001
From: jdembski <htpc@htpc.speedport.ip>
Date: Sun, 19 Feb 2012 19:55:20 +0100
Subject: [PATCH] vuplus add-on: New PVR add-on for using Vu+ settop boxes as
 PVR backend.

---
 Makefile.in                                        |    2 +
 addons/pvr.vuplus/addon.xml                        |   23 +
 .../resources/language/English/strings.xml         |   18 +
 addons/pvr.vuplus/resources/settings.xml           |   12 +
 configure.in                                       |    1 +
 xbmc/pvrclients/vuplus/Makefile.in                 |   24 +
 xbmc/pvrclients/vuplus/README                      |   24 +
 xbmc/pvrclients/vuplus/VuData.cpp                  |  943 +++++++
 xbmc/pvrclients/vuplus/VuData.h                    |  135 +
 xbmc/pvrclients/vuplus/client.cpp                  |  482 ++++
 xbmc/pvrclients/vuplus/client.h                    |   48 +
 xbmc/pvrclients/vuplus/thread.cpp                  |  418 +++
 xbmc/pvrclients/vuplus/thread.h                    |  168 ++
 xbmc/pvrclients/vuplus/tools.cpp                   |   96 +
 xbmc/pvrclients/vuplus/tools.h                     |   63 +
 xbmc/pvrclients/vuplus/xmlParser.cpp               | 2940 ++++++++++++++++++++
 xbmc/pvrclients/vuplus/xmlParser.h                 |  733 +++++
 17 files changed, 6130 insertions(+), 0 deletions(-)
 create mode 100644 addons/pvr.vuplus/addon.xml
 create mode 100644 addons/pvr.vuplus/resources/language/English/strings.xml
 create mode 100644 addons/pvr.vuplus/resources/settings.xml
 create mode 100644 xbmc/pvrclients/vuplus/Makefile.in
 create mode 100644 xbmc/pvrclients/vuplus/README
 create mode 100644 xbmc/pvrclients/vuplus/VuData.cpp
 create mode 100644 xbmc/pvrclients/vuplus/VuData.h
 create mode 100644 xbmc/pvrclients/vuplus/client.cpp
 create mode 100644 xbmc/pvrclients/vuplus/client.h
 create mode 100644 xbmc/pvrclients/vuplus/thread.cpp
 create mode 100644 xbmc/pvrclients/vuplus/thread.h
 create mode 100644 xbmc/pvrclients/vuplus/tools.cpp
 create mode 100644 xbmc/pvrclients/vuplus/tools.h
 create mode 100644 xbmc/pvrclients/vuplus/xmlParser.cpp
 create mode 100644 xbmc/pvrclients/vuplus/xmlParser.h

diff --git a/Makefile.in b/Makefile.in
index cc2e9a6..6b9ecbf 100755
--- a/Makefile.in
+++ b/Makefile.in
@@ -171,6 +171,7 @@ PVR_DIRS=\
 	xbmc/pvrclients/mythtv \
 	xbmc/pvrclients/vdr-vnsi \
 	xbmc/pvrclients/tvheadend \
+	xbmc/pvrclients/vuplus \
 	xbmc/pvrclients/pvr-demo
 
 LIBADDON_DIRS=\
@@ -275,6 +276,7 @@ pvrclients: exports
 	$(MAKE) -C xbmc/pvrclients/mythtv
 	$(MAKE) -C xbmc/pvrclients/vdr-vnsi
 	$(MAKE) -C xbmc/pvrclients/tvheadend
+	$(MAKE) -C xbmc/pvrclients/vuplus
 	$(MAKE) -C xbmc/pvrclients/pvr-demo
 libaddon: exports
 	$(MAKE) -C lib/addons/library.xbmc.addon
diff --git a/addons/pvr.vuplus/addon.xml b/addons/pvr.vuplus/addon.xml
new file mode 100644
index 0000000..aff4206
--- /dev/null
+++ b/addons/pvr.vuplus/addon.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<addon
+  id="pvr.vuplus"
+  version="1.0.0"
+  name="VU+ Client"
+  provider-name="Joerg Dembski">
+  <requires>
+    <c-pluff version="0.1"/>
+  </requires>
+  <extension
+    point="xbmc.pvrclient"
+    library_linux="XBMC_vuplus.pvr"
+    library_osx="XBMC_vuplus.pvr"
+    library_wingl="XBMC_vuplus_win32.pvr"
+    library_windx="XBMC_vuplus_win32.pvr"/>
+  <extension point="xbmc.addon.metadata">
+    <summary>XBMC's frontend for VU+</summary>
+    <description>VU+ frontend; supporting streaming of Live TV &amp; Recordings, EPG, Timers. For parsing the XML output from the VU+ webinterface it uses the xmlParser library developed by Frank Vanden Berghen (http://www.applied-mathematics.net/tools/xmlParser.html). Many thanks for this!
+</description>
+    <disclaimer>This is unstable software! The authors are in no way responsible for failed recordings, incorrect timers, wasted hours, or any other undesirable effects..</disclaimer>
+    <platform>all</platform>
+  </extension>
+</addon>
diff --git a/addons/pvr.vuplus/resources/language/English/strings.xml b/addons/pvr.vuplus/resources/language/English/strings.xml
new file mode 100644
index 0000000..c728ac7
--- /dev/null
+++ b/addons/pvr.vuplus/resources/language/English/strings.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8" standalone="yes"?>
+<strings>
+    <!-- settings labels -->
+    <string id="30000">VU+ hostname or IP address</string>
+    <string id="30002">Streaming Port</string>
+    <string id="30003">Username</string>
+    <string id="30004">Password</string>
+    <string id="30006">Connect timeout in seconds</string>
+    <string id="30007">Response timeout in seconds</string>
+    <string id="30008">Icon Path</string>
+    <string id="30009">Show completed timers</string>
+    <string id="30010">Update Interval in minutes</string>
+
+
+    <!-- notifications -->
+    <string id="30500">Disconnected from '%s'</string>
+    <string id="30501">Reconnected to '%s'</string>
+</strings>
diff --git a/addons/pvr.vuplus/resources/settings.xml b/addons/pvr.vuplus/resources/settings.xml
new file mode 100644
index 0000000..de7b6fd
--- /dev/null
+++ b/addons/pvr.vuplus/resources/settings.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="utf-8" standalone="yes"?>
+<settings>
+    <setting id="host" type="text" label="30000" default="127.0.0.1" />
+    <setting id="streamport" type="number" label="30002" default="8001" />
+    <setting id="user" type="text" label="30003" default="" />
+    <setting id="pass" type="text" label="30004" option="hidden" default="" />
+    <setting id="connect_timeout" type="enum" label="30006" values="1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52|53|54|55|56|57|58|59|60" default="29" />
+    <setting id="response_timeout" type="enum" label="30007" values="1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52|53|54|55|56|57|58|59|60" default="1" />
+    <setting id="iconpath" type="folder" label="30008" default="" />
+    <setting label="30009" type="bool" id="showcompleted" default="false"/>
+    <setting id="updateint" type="number" label="30010" default="2" />
+</settings>
diff --git a/configure.in b/configure.in
index e1cc9d2..e4b46f8 100755
--- a/configure.in
+++ b/configure.in
@@ -1899,6 +1899,7 @@ OUTPUT_FILES="Makefile \
     xbmc/pvrclients/mythtv/Makefile \
     xbmc/pvrclients/pvr-demo/Makefile \
     xbmc/pvrclients/tvheadend/Makefile \
+    xbmc/pvrclients/vuplus/Makefile \
     xbmc/pvrclients/vdr-vnsi/Makefile \
     lib/addons/library.xbmc.addon/Makefile \
     lib/addons/library.xbmc.gui/Makefile \
diff --git a/xbmc/pvrclients/vuplus/Makefile.in b/xbmc/pvrclients/vuplus/Makefile.in
new file mode 100644
index 0000000..32e5261
--- /dev/null
+++ b/xbmc/pvrclients/vuplus/Makefile.in
@@ -0,0 +1,24 @@
+#
+# Makefile for the XBMC vuplus PVR AddOn
+#
+# See the README for copyright information and
+# how to reach the author.
+#
+
+LIBS   = -ldl -lcurl
+LIBDIR = @abs_top_srcdir@/addons/pvr.vuplus
+LIB    = @abs_top_srcdir@/addons/pvr.vuplus/XBMC_vuplus.pvr
+
+SRCS=client.cpp \
+     xmlParser.cpp \
+     VuData.cpp \
+     thread.cpp \
+     tools.cpp
+
+include ../Makefile.include
+
+clean:
+	-rm -f $(OBJS) $(LIB) *.P *~
+
+$(LIB): $(OBJS)
+	$(CXX) $(CXXFLAGS) $(LDFLAGS) -shared -g $(OBJS) $(LIBS) $(LIBDIRS) $(SILIB) -o $(LIB)
diff --git a/xbmc/pvrclients/vuplus/README b/xbmc/pvrclients/vuplus/README
new file mode 100644
index 0000000..4def8db
--- /dev/null
+++ b/xbmc/pvrclients/vuplus/README
@@ -0,0 +1,24 @@
+XBMC Vu+ PVR Add-on
+------------------------------------------
+
+THIS IS A PRELIMINARY README AND IS SUBJECT TO CHANGE!!!
+
+Written by:                  Joerg Dembski
+
+Project's homepage:          
+
+Latest version available at: 
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+------------------------------------------
+
+This is a PVR Add-on for XBMC to add vu+ DVRs as a TV/PVR Backend to XBMC.
+
+It want to add support for Live TV watching, replaying of Recordings, programming Timers and
+EPG TV Guide to use over the Network.
+
+For parsing the XML output from the VU+ webinterface it uses the xmlParser library developed by Frank Vanden Berghen (http://www.applied-mathematics.net/tools/xmlParser.html). Many thanks for this!    
diff --git a/xbmc/pvrclients/vuplus/VuData.cpp b/xbmc/pvrclients/vuplus/VuData.cpp
new file mode 100644
index 0000000..7053b0c
--- /dev/null
+++ b/xbmc/pvrclients/vuplus/VuData.cpp
@@ -0,0 +1,943 @@
+#include "VuData.h"
+
+#include <curl/curl.h>
+#include "client.h" 
+
+using namespace ADDON;
+
+#define CMD_LOCK cMutexLock CmdLock((cMutex*)&m_Mutex)
+
+
+Vu::Vu() 
+{
+  m_bIsConnected = false;
+  m_strServerName = "Vu";
+  CStdString strURL = "";
+
+  // simply add user@pass in front of the URL if username/password is set
+  if ((g_strUsername.length() > 0) && (g_strPassword.length() > 0))
+    strURL.Format("%s:%s@", g_strUsername.c_str(), g_strPassword.c_str());
+  strURL.Format("http://%s%s/", strURL.c_str(), g_strHostname.c_str());
+  m_strURL = strURL.c_str();
+  m_iNumChannels = 0;
+  m_iNumTimers = 0; 
+  m_iNumRecordings = 0;
+  m_iNumChannelGroups = 0;
+}
+
+// Curl callback
+int Vu::VuWebResponseCallback(void *contents, int iLength, int iSize, void *memPtr)
+{
+  int iRealSize = iSize * iLength;
+  struct VuWebResponse *resp = (struct VuWebResponse*) memPtr;
+
+  resp->response = (char*) realloc(resp->response, resp->iSize + iRealSize + 1);
+
+  if (resp->response == NULL)
+  {
+    XBMC->Log(LOG_ERROR, "%s Could not allocate memeory!", __FUNCTION__);
+    return 0;
+  }
+
+  memcpy(&(resp->response[resp->iSize]), contents, iRealSize);
+  resp->iSize += iRealSize;
+  resp->response[resp->iSize] = 0;
+
+  return iRealSize;
+}
+
+bool Vu::Open()
+{
+  m_bIsConnected = false;
+
+  // Load the TV channels - close connection if no channels are found
+  if (!LoadChannelGroups())
+    return false;
+
+  // Load Channels
+  for (int i = 0;i<m_iNumChannelGroups;  i++) 
+  {
+    VuChannelGroup &myGroup = m_groups.at(i);
+    LoadChannels(myGroup.strServiceReference, myGroup.strGroupName);
+  }
+
+  // Load the radio channels - continue if no channels are found 
+  CStdString strTmp;
+  strTmp.Format("1:7:1:0:0:0:0:0:0:0:FROM BOUQUET \"userbouquet.favourites.radio\" ORDER BY bouquet");
+  LoadChannels(strTmp, "radio");
+
+  XBMC->Log(LOG_INFO, "%s Starting separate client update thread...", __FUNCTION__);
+
+  SetDescription("VU+ Updater");
+  Start(); 
+  m_bIsConnected = true;
+
+  return Running(); 
+}
+
+void  Vu::Action()
+{
+  XBMC->Log(LOG_DEBUG, "%s - starting", __FUNCTION__);
+
+  while(Running())
+  {
+    CMD_LOCK;
+    // Trigger Timer and Recording updates acording to the addon settings
+    cCondWait::SleepMs(1000 * g_iUpdateInterval * 60);
+    XBMC->Log(LOG_INFO, "%s Perform Updates!", __FUNCTION__);
+    PVR->TriggerTimerUpdate();
+    PVR->TriggerRecordingUpdate();
+
+  }
+  XBMC->Log(LOG_DEBUG, "%s - exiting", __FUNCTION__);
+}
+
+void Vu::Close()
+{
+  m_bIsConnected = false;
+}
+
+bool Vu::LoadChannelGroups() 
+{
+  CStdString strTmp; 
+
+  strTmp.Format("%sweb/getservices", m_strURL.c_str());
+
+  CStdString strXML = GetHttpXML(strTmp);  
+
+  XMLResults xe;
+  XMLNode xMainNode = XMLNode::parseString(strXML.c_str(), NULL, &xe);  
+
+  if(xe.error != 0)  {    
+    XBMC->Log(LOG_ERROR, "%s Unable to parse XML. Error: '%s' ", __FUNCTION__, XMLNode::getError(xe.error));    
+    return false;  
+  }  
+
+  m_groups.clear();
+  m_iNumChannelGroups = 0;
+
+  XMLNode xNode = xMainNode.getChildNode("e2servicelist");
+  int n = xNode.nChildNode("e2service");
+
+  XBMC->Log(LOG_INFO, "%s Number of elements: '%d'", __FUNCTION__, n);
+
+  for (int i = 0; i<n; i++)
+  {
+    XMLNode xTmp = xNode.getChildNode("e2service", i);
+
+    CStdString strTmp;
+    
+    if (!GetString(xTmp, "e2servicereference", strTmp))
+      continue;
+    
+    // Check whether the current element is not just a label
+    if (strTmp.compare(0,5,"1:64:") == 0)
+      continue;
+
+    VuChannelGroup newGroup;
+    newGroup.strServiceReference = strTmp;
+
+    if (!GetString(xTmp, "e2servicename", strTmp)) 
+      continue;
+
+    newGroup.strGroupName = strTmp;
+ 
+    m_groups.push_back(newGroup);
+
+    XBMC->Log(LOG_INFO, "%s Loaded channelgroup: %s", __FUNCTION__, newGroup.strGroupName.c_str());
+    m_iNumChannelGroups++; 
+  }
+
+  XBMC->Log(LOG_INFO, "%s Loaded %d Channelsgroups", __FUNCTION__, m_iNumChannelGroups);
+  return true;
+}
+
+bool Vu::LoadChannels(CStdString strServiceReference, CStdString strGroupName) 
+{
+  XBMC->Log(LOG_INFO, "%s loading channel group: '%s'", __FUNCTION__, strGroupName.c_str());
+
+  CStdString strTmp;
+  strTmp.Format("%sweb/getservices?sRef=%s", m_strURL.c_str(), URLEncodeInline(strServiceReference.c_str()));
+
+  CStdString strXML = GetHttpXML(strTmp);  
+
+  XMLResults xe;
+  XMLNode xMainNode = XMLNode::parseString(strXML.c_str(), NULL, &xe);  
+
+  if(xe.error != 0)  {    
+    XBMC->Log(LOG_ERROR, "%s Unable to parse XML. Error: '%s' ", __FUNCTION__, XMLNode::getError(xe.error));    
+    return false;  
+  }  
+
+  XMLNode xNode = xMainNode.getChildNode("e2servicelist");
+  int n = xNode.nChildNode("e2service");
+
+  XBMC->Log(LOG_INFO, "%s Number of elements: '%d'", __FUNCTION__, n);
+  bool bRadio;
+
+  bRadio = !strGroupName.compare("radio");
+
+  for (int i = 0; i<n; i++)
+  {
+    XMLNode xTmp = xNode.getChildNode("e2service", i);
+    CStdString strTmp;
+    
+    if (!GetString(xTmp, "e2servicereference", strTmp))
+      continue;
+    
+    // Check whether the current element is not just a label
+    if (strTmp.compare(0,5,"1:64:") == 0)
+      continue;
+
+    VuChannel newChannel;
+    newChannel.bRadio = bRadio;
+    newChannel.strGroupName = strGroupName;
+    newChannel.iUniqueId = m_iNumChannels+1;
+    newChannel.iChannelNumber = m_iNumChannels;
+    newChannel.strServiceReference = strTmp;
+
+    if (!GetString(xTmp, "e2servicename", strTmp)) 
+      continue;
+
+    newChannel.strChannelName = strTmp;
+ 
+    CStdString strIcon;
+    strIcon.Format("%s", newChannel.strServiceReference);
+
+    std::replace(strIcon.begin(), strIcon.end(), ':','_');
+    if (strIcon.size()>2)
+      strIcon.erase(strIcon.size() - 1); 
+    strTmp.Format("%s%s.png", g_strIconPath, strIcon.c_str());
+    newChannel.strIconPath = strTmp;
+    
+    strTmp.Format("http://%s:%d/%s", g_strHostname, g_iPortStream, newChannel.strServiceReference);
+    newChannel.strStreamURL = strTmp;
+
+    m_channels.push_back(newChannel);
+    XBMC->Log(LOG_INFO, "%s Loaded channel: %s, Icon: %s", __FUNCTION__, newChannel.strChannelName.c_str(), newChannel.strIconPath.c_str());
+
+
+    m_iNumChannels++; 
+  }
+
+  XBMC->Log(LOG_INFO, "%s Loaded %d Channels", __FUNCTION__, m_iNumChannels);
+  return true;
+}
+
+bool Vu::IsConnected() 
+{
+  return m_bIsConnected;
+}
+
+CStdString Vu::GetHttpXML(CStdString& url) 
+{
+  CURL* curl_handle;
+
+  XBMC->Log(LOG_INFO, "%s Open webAPI with URL: '%s'", __FUNCTION__, url.c_str());
+
+  struct VuWebResponse response;
+
+  response.response = (char*) malloc(1);
+  response.iSize = 0;
+
+  // retrieve the webpage and store it in memory
+  curl_global_init(CURL_GLOBAL_ALL);
+  curl_handle = curl_easy_init();
+  curl_easy_setopt(curl_handle, CURLOPT_URL, url.c_str());
+  curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, &VuWebResponseCallback);
+  curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&response);
+  curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, "vuplus-pvraddon-agent/1.0");
+  curl_easy_perform(curl_handle);
+
+  if (response.iSize == 0)
+  {
+    XBMC->Log(LOG_INFO, "%s Could not open webAPI", __FUNCTION__);
+    return "";
+  }
+
+  CStdString strTmp;
+  strTmp.Format("%s", response.response);
+
+  XBMC->Log(LOG_INFO, "%s Got result. Length: %u", __FUNCTION__, strTmp.length());
+  
+  free(response.response);
+  curl_easy_cleanup(curl_handle);
+
+  return strTmp;
+}
+
+const char * Vu::GetServerName() 
+{
+  return m_strServerName.c_str();  
+}
+
+int Vu::GetChannelsAmount()
+{
+  return m_iNumChannels;
+}
+
+int Vu::GetTimersAmount()
+{
+  return m_iNumTimers;
+}
+
+unsigned int Vu::GetRecordingsAmount() {
+  return m_iNumRecordings;
+}
+
+PVR_ERROR Vu::GetChannels(PVR_HANDLE handle, bool bRadio) 
+{
+    for (unsigned int iChannelPtr = 0; iChannelPtr < m_channels.size(); iChannelPtr++)
+  {
+    VuChannel &channel = m_channels.at(iChannelPtr);
+    if (channel.bRadio == bRadio)
+    {
+      PVR_CHANNEL xbmcChannel;
+      memset(&xbmcChannel, 0, sizeof(PVR_CHANNEL));
+
+      xbmcChannel.iUniqueId         = channel.iUniqueId;
+      xbmcChannel.bIsRadio          = channel.bRadio;
+      xbmcChannel.iChannelNumber    = channel.iChannelNumber;
+      xbmcChannel.strChannelName    = channel.strChannelName.c_str();
+      xbmcChannel.strInputFormat    = ""; // unused
+      xbmcChannel.strStreamURL      = channel.strStreamURL.c_str();
+      xbmcChannel.iEncryptionSystem = 0;
+      
+      xbmcChannel.strIconPath = channel.strIconPath.c_str();
+      xbmcChannel.bIsHidden         = false;
+
+      PVR->TransferChannelEntry(handle, &xbmcChannel);
+    }
+  }
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+Vu::~Vu() 
+{
+  m_channels.clear();  
+  m_timers.clear();
+  m_recordings.clear();
+  m_groups.clear();
+}
+
+PVR_ERROR Vu::GetEPGForChannel(PVR_HANDLE handle, const PVR_CHANNEL &channel, time_t iStart, time_t iEnd)
+{
+  VuChannel &myChannel = m_channels.at(channel.iUniqueId-1);
+
+  CStdString url;
+  url.Format("%s%s%s",  m_strURL.c_str(), "web/epgservice?sRef=",  myChannel.strServiceReference); 
+ 
+  CStdString strXML;
+  strXML = GetHttpXML(url);
+
+  int iNumEPG = 0;
+
+  XMLResults xe;
+  XMLNode xMainNode = XMLNode::parseString(strXML.c_str(), NULL, &xe);
+
+  if(xe.error != 0)  {
+    XBMC->Log(LOG_ERROR, "%s Unable to parse XML. Error: '%s' ", __FUNCTION__, XMLNode::getError(xe.error));
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  XMLNode xNode = xMainNode.getChildNode("e2eventlist");
+  int n = xNode.nChildNode("e2event");
+
+  XBMC->Log(LOG_INFO, "%s Number of elements: '%d'", __FUNCTION__, n);
+
+  for (int i = 0; i<n; i++)
+  {
+    XMLNode xTmp = xNode.getChildNode("e2event", i);
+
+    CStdString strTmp;
+    int iTmpStart;
+    int iTmp;
+
+    // check and set event starttime and endtimes
+    if (!GetInt(xTmp, "e2eventstart", iTmpStart)) 
+      continue;
+ 
+    if (!GetInt(xTmp, "e2eventduration", iTmp))
+      continue;
+
+    if ((iEnd > 1) && (iEnd < (iTmpStart + iTmp)))
+       continue;
+    
+    VuEPGEntry entry;
+    entry.startTime = iTmpStart;
+    entry.endTime = iTmpStart + iTmp;
+
+    if (!GetInt(xTmp, "e2eventid", entry.iEventId))  
+      continue;
+
+    entry.iChannelId = channel.iUniqueId;
+    
+    if(!GetString(xTmp, "e2eventtitle", strTmp))
+      continue;
+
+    entry.strTitle = strTmp;
+    
+    VuChannel &myChannel = m_channels.at(channel.iUniqueId-1);
+    entry.strServiceReference = myChannel.strServiceReference;
+
+    if (GetString(xTmp, "e2eventdescriptionextended", strTmp))
+      entry.strPlot = strTmp;
+
+    if (GetString(xTmp, "e2eventdescription", strTmp))
+       entry.strPlotOutline = strTmp;
+
+    EPG_TAG broadcast;
+    memset(&broadcast, 0, sizeof(EPG_TAG));
+
+    broadcast.iUniqueBroadcastId  = entry.iEventId;
+    broadcast.strTitle            = entry.strTitle.c_str();
+    broadcast.iChannelNumber      = channel.iChannelNumber;
+    broadcast.startTime           = entry.startTime;
+    broadcast.endTime             = entry.endTime;
+    broadcast.strPlotOutline      = entry.strPlotOutline.c_str();
+    broadcast.strPlot             = entry.strPlot.c_str();
+    broadcast.strIconPath         = ""; // unused
+    broadcast.iGenreType          = 0; // unused
+    broadcast.iGenreSubType       = 0; // unused
+    broadcast.strGenreDescription = "";
+    broadcast.firstAired          = 0;  // unused
+    broadcast.iParentalRating     = 0;  // unused
+    broadcast.iStarRating         = 0;  // unused
+    broadcast.bNotify             = false;
+    broadcast.iSeriesNumber       = 0;  // unused
+    broadcast.iEpisodeNumber      = 0;  // unused
+    broadcast.iEpisodePartNumber  = 0;  // unused
+    broadcast.strEpisodeName      = ""; // unused
+
+    PVR->TransferEpgEntry(handle, &broadcast);
+
+    iNumEPG++; 
+
+    XBMC->Log(LOG_INFO, "%s loaded EPG entry '%d:%s' channel '%d' start '%d' end '%d'", __FUNCTION__, broadcast.iUniqueBroadcastId, broadcast.strTitle, entry.iChannelId, entry.startTime, entry.endTime);
+  }
+
+  XBMC->Log(LOG_INFO, "%s Loaded %u EPG Entries for channel '%s'", __FUNCTION__, iNumEPG, channel.strChannelName);
+  return PVR_ERROR_NO_ERROR;
+}
+
+int Vu::GetChannelNumber(CStdString strServiceReference)  
+{
+  for (int i = 0;i<m_iNumChannels;  i++) 
+  {
+    VuChannel &myChannel = m_channels.at(i);
+    if (!strServiceReference.compare(myChannel.strServiceReference))
+      return i+1;
+  }
+  return -1;
+}
+
+PVR_ERROR Vu::GetTimers(PVR_HANDLE handle)
+{
+  CStdString url; 
+  url.Format("%s%s", m_strURL.c_str(), "web/timerlist"); 
+
+  CStdString strXML;
+  strXML = GetHttpXML(url);
+
+  XMLResults xe;
+  XMLNode xMainNode = XMLNode::parseString(strXML.c_str(), NULL, &xe);
+
+  if(xe.error != 0)  {
+    XBMC->Log(LOG_ERROR, "%s Unable to parse XML. Error: '%s' ", __FUNCTION__, XMLNode::getError(xe.error));
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  XMLNode xNode = xMainNode.getChildNode("e2timerlist");
+  int n = xNode.nChildNode("e2timer");
+
+  XBMC->Log(LOG_INFO, "%s Number of elements: '%d'", __FUNCTION__, n);
+  
+  m_iNumTimers = 0;
+  m_timers.clear();
+
+  while(n>0)
+  {
+    int i = n-1;
+    n--;
+    XMLNode xTmp = xNode.getChildNode("e2timer", i);
+
+    CStdString strTmp;
+    int iTmp;
+    bool bTmp;
+
+    if (((!g_bShowTimersCompleted) && (GetInt(xTmp, "e2state", iTmp))) && (iTmp == 3))
+      continue;
+
+    if ((!GetInt(xTmp, "e2disabled", iTmp)) || (iTmp != 0))
+      continue;
+
+    VuTimer timer;
+
+    if (GetString(xTmp, "e2servicereference", strTmp))
+      timer.iChannelId = GetChannelNumber(strTmp.c_str());
+
+    if (!GetInt(xTmp, "e2timebegin", iTmp)) 
+      continue; 
+ 
+    timer.startTime         = iTmp;
+    
+    if (!GetInt(xTmp, "e2timeend", iTmp)) 
+      continue; 
+ 
+    timer.endTime           = iTmp;
+    
+    if (GetString(xTmp, "e2name", strTmp)) {
+      timer.strTitle          = strTmp;
+    }
+
+    if (GetString(xTmp, "e2description", strTmp))
+      timer.strPlot        = strTmp.c_str();
+ 
+    if (GetInt(xTmp, "e2repeated", iTmp))
+      timer.iWeekdays         = iTmp;
+    else 
+      timer.iWeekdays = 0;
+
+    if (timer.iWeekdays != 0)
+      timer.bRepeating      = true; 
+    else
+      timer.bRepeating = false;
+    
+    if (GetInt(xTmp, "e2eit", iTmp))
+      timer.iEpgID = iTmp;
+    else 
+      timer.iEpgID = 0;
+
+    timer.state = PVR_TIMER_STATE_INVALID;
+
+    if (!GetInt(xTmp, "e2state", iTmp))
+      continue;
+
+    XBMC->Log(LOG_INFO, "%s e2state is: %d ", __FUNCTION__, iTmp);
+  
+    if (iTmp == 0) {
+      timer.state = PVR_TIMER_STATE_SCHEDULED;
+      XBMC->Log(LOG_INFO, "%s Timer state is: SCHEDULED", __FUNCTION__);
+    }
+    
+    if (iTmp == 2) {
+      timer.state = PVR_TIMER_STATE_RECORDING;
+      XBMC->Log(LOG_INFO, "%s Timer state is: RECORDING", __FUNCTION__);
+    }
+    
+    if (iTmp == 3) {
+      timer.state = PVR_TIMER_STATE_COMPLETED;
+      XBMC->Log(LOG_INFO, "%s Timer state is: COMPLETED", __FUNCTION__);
+    }
+
+    if (GetBoolean(xTmp, "e2cancled", bTmp)) {
+      if (bTmp)  {
+        timer.state = PVR_TIMER_STATE_CANCELLED;
+        XBMC->Log(LOG_INFO, "%s Timer state is: CANCELLED", __FUNCTION__);
+      }
+    }
+
+    PVR_TIMER tag;
+    memset(&tag, 0, sizeof(PVR_TIMER));
+    tag.iClientChannelUid = timer.iChannelId;
+    tag.startTime         = timer.startTime;
+    tag.endTime           = timer.endTime;
+    tag.strTitle          = timer.strTitle.c_str();
+    tag.strDirectory      = "/";   // unused
+    tag.strSummary        = timer.strPlot.c_str();
+    tag.state             = timer.state;
+    tag.iPriority         = 0;     // unused
+    tag.iLifetime         = 0;     // unused
+    tag.bIsRepeating      = timer.bRepeating;
+    tag.firstDay          = 0;     // unused
+    tag.iWeekdays         = timer.iWeekdays;
+    tag.iEpgUid           = timer.iEpgID;
+    tag.iMarginStart      = 0;     // unused
+    tag.iMarginEnd        = 0;     // unused
+    tag.iGenreType        = 0;     // unused
+    tag.iGenreSubType     = 0;     // unused
+    tag.iClientIndex = m_iNumTimers;
+
+    PVR->TransferTimerEntry(handle, &tag);
+
+    m_iNumTimers++; 
+    m_timers.push_back(timer);
+
+    XBMC->Log(LOG_INFO, "%s loaded Timer entry '%s'", __FUNCTION__, tag.strTitle);
+  }
+
+  XBMC->Log(LOG_INFO, "%s Loaded %u Timer Entries", __FUNCTION__, m_iNumTimers);
+  return PVR_ERROR_NO_ERROR; 
+}
+
+CStdString Vu::URLEncodeInline(const CStdString& strData)
+{
+  CStdString buffer = strData;
+  CURL* handle = curl_easy_init();
+  char* encodedURL = curl_easy_escape(handle, strData.c_str(), strlen(strData.c_str()));
+
+  buffer.Format("%s", encodedURL);
+  curl_free(encodedURL);
+  curl_easy_cleanup(handle);
+
+  return buffer;
+}
+
+bool Vu::SendSimpleCommand(const CStdString& strCommandURL, CStdString& strResultText)
+{
+  CStdString url; 
+  url.Format("%s%s", m_strURL.c_str(), strCommandURL.c_str()); 
+
+  CStdString strXML;
+  strXML = GetHttpXML(url);
+
+  XMLResults xe;
+  XMLNode xMainNode = XMLNode::parseString(strXML.c_str(), NULL, &xe);
+
+  if(xe.error != 0)  {
+    XBMC->Log(LOG_ERROR, "%s Unable to parse XML. Error: '%s' ", __FUNCTION__, XMLNode::getError(xe.error));
+    return false;
+  }
+
+  XMLNode xNode = xMainNode.getChildNode("e2simplexmlresult");
+
+  bool bTmp;
+
+  if (!GetBoolean(xNode, "e2state", bTmp)) {
+    XBMC->Log(LOG_ERROR, "%s Could not parse e2state from result!", __FUNCTION__);
+    strResultText.Format("Could not parse e2state!");
+    return false;
+  }
+
+  if (!GetString(xNode, "e2statetext", strResultText)) {
+    XBMC->Log(LOG_ERROR, "%s Could not parse e2state from result!", __FUNCTION__);
+    return false;
+  }
+
+  if (!bTmp)
+    XBMC->Log(LOG_ERROR, "%s Error message from backend: '%s'", __FUNCTION__, strResultText.c_str());
+
+  return bTmp;
+}
+
+
+PVR_ERROR Vu::AddTimer(const PVR_TIMER &timer)
+{
+  XBMC->Log(LOG_DEBUG, "%s - channelUid=%d title=%s epgid=%d", __FUNCTION__, timer.iClientChannelUid, timer.strTitle, timer.iEpgUid);
+
+  CStdString strTmp;
+  CStdString strServiceReference = m_channels.at(timer.iClientChannelUid-1).strServiceReference.c_str();
+
+  // check if we got a event id
+  //if (timer.iEpgUid > 0) 
+  //  strTmp.Format("web/timeraddbyeventid?sRef=%s&eventid=%d", strServiceReference, timer.iEpgUid);
+  //else
+  strTmp.Format("web/timeradd?sRef=%s&repeated=%d&begin=%d&end=%d&name=%s&description=%s&eit=%d", strServiceReference, timer.iWeekdays, timer.startTime, timer.endTime, URLEncodeInline(timer.strTitle), URLEncodeInline(timer.strSummary),timer.iEpgUid);
+
+  CStdString strResult;
+  if(!SendSimpleCommand(strTmp, strResult)) 
+    return PVR_ERROR_SERVER_ERROR;
+  
+  PVR->TriggerTimerUpdate();
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR Vu::DeleteTimer(const PVR_TIMER &timer) 
+{
+  CStdString strTmp;
+  CStdString strServiceReference = m_channels.at(timer.iClientChannelUid-1).strServiceReference.c_str();
+
+  strTmp.Format("web/timerdelete?sRef=%s&begin=%d&end=%d", strServiceReference, timer.startTime, timer.endTime);
+
+  CStdString strResult;
+  if(!SendSimpleCommand(strTmp, strResult)) 
+    return PVR_ERROR_SERVER_ERROR;
+
+  PVR->TriggerTimerUpdate();
+  if (timer.state == PVR_TIMER_STATE_RECORDING)
+    PVR->TriggerRecordingUpdate();
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR Vu::GetRecordings(PVR_HANDLE handle)
+{
+  CStdString url;
+  url.Format("%s%s", m_strURL.c_str(), "web/movielist"); 
+ 
+  CStdString strXML;
+  strXML = GetHttpXML(url);
+
+  XMLResults xe;
+  XMLNode xMainNode = XMLNode::parseString(strXML.c_str(), NULL, &xe);
+
+  if(xe.error != 0)  {
+    XBMC->Log(LOG_ERROR, "%s Unable to parse XML. Error: '%s' ", __FUNCTION__, XMLNode::getError(xe.error));
+    return PVR_ERROR_SERVER_ERROR;
+  }
+
+  XMLNode xNode = xMainNode.getChildNode("e2movielist");
+  int n = xNode.nChildNode("e2movie");
+
+  XBMC->Log(LOG_INFO, "%s Number of elements: '%d'", __FUNCTION__, n);
+  
+  m_iNumRecordings = 0;
+  m_recordings.clear();
+
+  while(n>0)
+  {
+    int i = n-1;
+    n--;
+    XMLNode xTmp = xNode.getChildNode("e2movie", i);
+    CStdString strTmp;
+    int iTmp;
+
+    VuRecording recording;
+    if (GetString(xTmp, "e2servicereference", strTmp))
+      recording.strRecordingId = strTmp;
+
+    if (GetString(xTmp, "e2title", strTmp))
+      recording.strTitle = strTmp;
+    
+    if (GetString(xTmp, "e2description", strTmp))
+      recording.strPlotOutline = strTmp;
+
+    if (GetString(xTmp, "e2descriptionextended", strTmp))
+      recording.strPlot = strTmp;
+    
+    if (GetString(xTmp, "e2servicename", strTmp))
+      recording.strChannelName = strTmp;
+
+    if (GetInt(xTmp, "e2time", iTmp)) 
+      recording.startTime = iTmp;
+
+    if (GetString(xTmp, "e2length", strTmp)) {
+      iTmp = TimeStringToSeconds(strTmp.c_str());
+      recording.iDuration = iTmp;
+    }
+    else
+      recording.iDuration = 0;
+
+    if (GetString(xTmp, "e2filename", strTmp)) {
+      strTmp.Format("http://%s/file?file=%s", g_strHostname, URLEncodeInline(strTmp.c_str()));
+      recording.strStreamURL = strTmp;
+    }
+    
+    PVR_RECORDING tag;
+    memset(&tag, 0, sizeof(PVR_RECORDING));
+    tag.strRecordingId    = recording.strRecordingId.c_str();
+    tag.strTitle          = recording.strTitle.c_str();
+    tag.strStreamURL      = recording.strStreamURL.c_str();
+    tag.strPlotOutline    = recording.strPlotOutline.c_str();
+    tag.strPlot           = recording.strPlot.c_str();
+    tag.strChannelName    = recording.strChannelName.c_str();
+    tag.recordingTime     = recording.startTime;
+    tag.iDuration         = recording.iDuration;
+    tag.strDirectory      = "/";   // unused
+
+    PVR->TransferRecordingEntry(handle, &tag);
+
+    m_iNumRecordings++; 
+    m_recordings.push_back(recording);
+
+    XBMC->Log(LOG_INFO, "%s loaded Recording entry '%s', start '%d', length '%d'", __FUNCTION__, tag.strTitle, recording.startTime, recording.iDuration);
+  }
+
+  XBMC->Log(LOG_INFO, "%s Loaded %u Recording Entries", __FUNCTION__, m_iNumRecordings);
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR Vu::DeleteRecording(const PVR_RECORDING &recinfo) 
+{
+  CStdString strTmp;
+
+  strTmp.Format("web/moviedelete?sRef=%s", URLEncodeInline(recinfo.strRecordingId));
+
+  CStdString strResult;
+  if(!SendSimpleCommand(strTmp, strResult)) 
+    return PVR_ERROR_NOT_DELETED;
+
+  PVR->TriggerRecordingUpdate();
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+PVR_ERROR Vu::UpdateTimer(const PVR_TIMER &timer)
+{
+  PVR->TriggerTimerUpdate();
+
+  return PVR_ERROR_NOT_IMPLEMENTED;
+}
+
+bool Vu::GetInt(XMLNode xRootNode, const char* strTag, int& iIntValue)
+{
+  XMLNode xNode = xRootNode.getChildNode(strTag );
+  if (xNode.isEmpty())
+     return false;
+  iIntValue = atoi(xNode.getText());
+  return true;
+}
+
+bool Vu::GetBoolean(XMLNode xRootNode, const char* strTag, bool& bBoolValue)
+{
+  XMLNode xNode = xRootNode.getChildNode(strTag );
+  if (xNode.isEmpty()) 
+    return false;
+
+  CStdString strEnabled = xNode.getText();
+
+  strEnabled.ToLower();
+  if (strEnabled == "off" || strEnabled == "no" || strEnabled == "disabled" || strEnabled == "false" || strEnabled == "0" )
+    bBoolValue = false;
+  else
+  {
+    bBoolValue = true;
+    if (strEnabled != "on" && strEnabled != "yes" && strEnabled != "enabled" && strEnabled != "true")
+      return false; // invalid bool switch - it's probably some other string.
+  }
+  return true;
+}
+
+bool Vu::GetString(XMLNode xRootNode, const char* strTag, CStdString& strStringValue)
+{
+  XMLNode xNode = xRootNode.getChildNode(strTag );
+  if (!xNode.isEmpty())
+  {
+    strStringValue = xNode.getText();
+    return true;
+  }
+  strStringValue.Empty();
+  return false;
+}
+
+long Vu::TimeStringToSeconds(const CStdString &timeString)
+{
+  CStdStringArray secs;
+  SplitString(timeString, ":", secs);
+  int timeInSecs = 0;
+  for (unsigned int i = 0; i < secs.size(); i++)
+  {
+    timeInSecs *= 60;
+    timeInSecs += atoi(secs[i]);
+  }
+  return timeInSecs;
+}
+
+int Vu::SplitString(const CStdString& input, const CStdString& delimiter, CStdStringArray &results, unsigned int iMaxStrings)
+{
+  int iPos = -1;
+  int newPos = -1;
+  int sizeS2 = delimiter.GetLength();
+  int isize = input.GetLength();
+
+  results.clear();
+  std::vector<unsigned int> positions;
+
+  newPos = input.Find (delimiter, 0);
+
+  if ( newPos < 0 )
+  {
+    results.push_back(input);
+    return 1;
+  }
+
+  while ( newPos > iPos )
+  {
+    positions.push_back(newPos);
+    iPos = newPos;
+    newPos = input.Find (delimiter, iPos + sizeS2);
+  }
+
+  // numFound is the number of delimeters which is one less
+  // than the number of substrings
+  unsigned int numFound = positions.size();
+  if (iMaxStrings > 0 && numFound >= iMaxStrings)
+    numFound = iMaxStrings - 1;
+
+  for ( unsigned int i = 0; i <= numFound; i++ )
+  {
+    CStdString s;
+    if ( i == 0 )
+    {
+      if ( i == numFound )
+        s = input;
+      else
+        s = input.Mid( i, positions[i] );
+    }
+    else
+    {
+      int offset = positions[i - 1] + sizeS2;
+      if ( offset < isize )
+      {
+        if ( i == numFound )
+          s = input.Mid(offset);
+        else if ( i > 0 )
+          s = input.Mid( positions[i - 1] + sizeS2,
+                         positions[i] - positions[i - 1] - sizeS2 );
+      }
+    }
+    results.push_back(s);
+  }
+  // return the number of substrings
+  return results.size();
+}
+
+PVR_ERROR Vu::GetChannelGroups(PVR_HANDLE handle)
+{
+  for(unsigned int iTagPtr = 0; iTagPtr < m_groups.size(); iTagPtr++)
+  {
+    PVR_CHANNEL_GROUP tag;
+    memset(&tag, 0 , sizeof(PVR_CHANNEL_GROUP));
+
+    tag.bIsRadio     = false;
+    tag.strGroupName = m_groups[iTagPtr].strGroupName.c_str();
+
+    PVR->TransferChannelGroup(handle, &tag);
+  }
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+
+unsigned int Vu::GetNumChannelGroups() {
+  return m_iNumChannelGroups;
+}
+
+CStdString Vu::GetGroupServiceReference(CStdString strGroupName)  
+{
+  for (int i = 0;i<m_iNumChannelGroups;  i++) 
+  {
+    VuChannelGroup &myGroup = m_groups.at(i);
+    if (!strGroupName.compare(myGroup.strGroupName))
+      return myGroup.strServiceReference;
+  }
+  return "error";
+}
+
+PVR_ERROR Vu::GetChannelGroupMembers(PVR_HANDLE handle, const PVR_CHANNEL_GROUP &group)
+{
+  XBMC->Log(LOG_DEBUG, "%s - group '%s'", __FUNCTION__, group.strGroupName);
+  CStdString strTmp = group.strGroupName;
+  for (int i = 0;i<m_iNumChannels;  i++) 
+  {
+    VuChannel &myChannel = m_channels.at(i);
+    if (!strTmp.compare(myChannel.strGroupName)) 
+    {
+      PVR_CHANNEL_GROUP_MEMBER tag;
+      memset(&tag,0 , sizeof(PVR_CHANNEL_GROUP_MEMBER));
+
+      tag.strGroupName     = group.strGroupName;
+      tag.iChannelUniqueId = myChannel.iUniqueId;
+      tag.iChannelNumber   = myChannel.iChannelNumber;
+
+      XBMC->Log(LOG_DEBUG, "%s - add channel %s (%d) to group '%s' channel number %d",
+          __FUNCTION__, myChannel.strChannelName.c_str(), tag.iChannelUniqueId, group.strGroupName, myChannel.iChannelNumber);
+
+      PVR->TransferChannelGroupMember(handle, &tag);
+    }
+  }
+  return PVR_ERROR_NO_ERROR;
+}
diff --git a/xbmc/pvrclients/vuplus/VuData.h b/xbmc/pvrclients/vuplus/VuData.h
new file mode 100644
index 0000000..481db70
--- /dev/null
+++ b/xbmc/pvrclients/vuplus/VuData.h
@@ -0,0 +1,135 @@
+#pragma once 
+
+#include "utils/StdString.h"
+#include "xmlParser.h"
+#include "client.h"
+#include "thread.h"
+    
+#include "../../../addons/library.xbmc.addon/libXBMC_addon.h"
+
+struct VuWebResponse {
+  char *response;
+  int iSize;
+};
+
+struct VuChannelGroup {
+  std::string strServiceReference;
+  std::string strGroupName;
+};
+
+struct VuEPGEntry 
+{
+  int iEventId;
+  std::string strServiceReference;
+  std::string strTitle;
+  int iChannelId;
+  time_t startTime;
+  time_t endTime;
+  std::string strPlotOutline;
+  std::string strPlot;
+};
+
+struct VuTimer
+{
+  std::string strTitle;
+  std::string strPlot;
+  int iChannelId;
+  time_t startTime;
+  time_t endTime;
+  bool bRepeating; 
+  int iWeekdays;
+  int iEpgID;
+  PVR_TIMER_STATE state; 
+};
+
+struct VuRecording
+{
+  std::string strRecordingId;
+  time_t startTime;
+  int iDuration;
+  std::string strTitle;
+  std::string strStreamURL;
+  std::string strPlot;
+  std::string strPlotOutline;
+  std::string strChannelName;
+};
+ 
+struct VuChannel
+{
+  bool bRadio;
+  int iUniqueId;
+  int iChannelNumber;
+  std::string strGroupName;
+  std::string strChannelName;
+  std::string strServiceReference;
+  std::string strStreamURL;
+  std::string strIconPath;
+};
+
+class Vu  : public cThread
+{
+private:
+
+  // members
+  bool  m_bIsConnected;
+  std::string m_strServerName;
+  std::string m_strURL;
+  int m_iNumChannels;
+  int m_iNumTimers;
+  int m_iNumRecordings;
+  int m_iNumChannelGroups;
+  std::vector<VuChannel> m_channels;
+  std::vector<VuTimer> m_timers;
+  std::vector<VuRecording> m_recordings;
+  std::vector<VuChannelGroup> m_groups;
+ 
+  cMutex m_Mutex;
+
+  // functions
+
+  CStdString GetHttpXML(CStdString& url);
+  int GetChannelNumber(CStdString strServiceReference);
+  CStdString URLEncodeInline(const CStdString& strData);
+  bool SendSimpleCommand(const CStdString& strCommandURL, CStdString& strResult);
+  static int VuWebResponseCallback(void *contents, int iLength, int iSize, void *memPtr); 
+  CStdString GetGroupServiceReference(CStdString strGroupName);
+  bool LoadChannels(CStdString strServerReference, CStdString strGroupName);
+  bool LoadChannelGroups();
+
+  // helper functions
+  static bool GetInt(XMLNode xRootNode, const char* strTag, int& iIntValue);
+  static bool GetBoolean(XMLNode xRootNode, const char* strTag, bool& bBoolValue);
+  static bool GetString(XMLNode xRootNode, const char* strTag, CStdString& strStringValue);
+  static long TimeStringToSeconds(const CStdString &timeString);
+  static int SplitString(const CStdString& input, const CStdString& delimiter, CStdStringArray &results, unsigned int iMaxStrings = 0);
+
+
+
+public:
+  Vu(void);
+  ~Vu();
+
+  const char * GetServerName();
+  bool IsConnected(); 
+  int GetChannelsAmount(void);
+  PVR_ERROR GetChannels(PVR_HANDLE handle, bool bRadio);
+  PVR_ERROR GetEPGForChannel(PVR_HANDLE handle, const PVR_CHANNEL &channel, time_t iStart, time_t iEnd);
+  int GetTimersAmount(void);
+  PVR_ERROR GetTimers(PVR_HANDLE handle);
+  PVR_ERROR AddTimer(const PVR_TIMER &timer);
+  PVR_ERROR UpdateTimer(const PVR_TIMER &timer);
+  PVR_ERROR DeleteTimer(const PVR_TIMER &timer);
+  unsigned int GetRecordingsAmount();
+  PVR_ERROR    GetRecordings(PVR_HANDLE handle);
+  PVR_ERROR    DeleteRecording(const PVR_RECORDING &recinfo);
+  unsigned int GetNumChannelGroups(void);
+  PVR_ERROR    GetChannelGroups(PVR_HANDLE handle);
+  PVR_ERROR    GetChannelGroupMembers(PVR_HANDLE handle, const PVR_CHANNEL_GROUP &group);
+
+  bool Open();
+  void Action();
+  void Close();
+
+
+};
+
diff --git a/xbmc/pvrclients/vuplus/client.cpp b/xbmc/pvrclients/vuplus/client.cpp
new file mode 100644
index 0000000..4bb18e6
--- /dev/null
+++ b/xbmc/pvrclients/vuplus/client.cpp
@@ -0,0 +1,482 @@
+/*
+ *      Copyright (C) 2005-2011 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "client.h"
+#include "xbmc_pvr_dll.h"
+#include <stdlib.h>
+#include "VuData.h"
+
+using namespace std;
+using namespace ADDON;
+
+bool         m_bCreated  = false;
+ADDON_STATUS m_CurStatus = ADDON_STATUS_UNKNOWN;
+int          g_iClientId = -1;
+
+/* User adjustable settings are saved here.
+ * Default values are defined inside client.h
+ * and exported to the other source files.
+ */
+std::string g_strHostname             = DEFAULT_HOST;
+int         g_iConnectTimeout         = DEFAULT_CONNECT_TIMEOUT;
+int         g_iResponseTimeout        = DEFAULT_RESPONSE_TIMEOUT;
+int         g_iPortStream             = DEFAULT_STREAM_PORT;
+int         g_iUpdateInterval         = DEFAULT_UPDATE_INTERVAL;
+std::string g_strUsername             = "";
+std::string g_strPassword             = "";
+std::string g_strUserPath             = "";
+std::string g_strClientPath           = "";
+std::string g_strIconPath             = "";
+bool        g_bShowTimersCompleted    = false;
+
+CHelper_libXBMC_addon *XBMC           = NULL;
+CHelper_libXBMC_pvr   *PVR            = NULL;
+Vu                *VuData             = NULL;
+
+extern "C" {
+
+void ADDON_ReadSettings(void)
+{
+  /* read setting "host" from settings.xml */
+  char * buffer;
+  buffer = (char*) malloc (1024);
+  buffer[0] = 0; /* Set the end of string */
+
+  if (XBMC->GetSetting("host", buffer))
+    g_strHostname = buffer;
+  else
+    g_strHostname = DEFAULT_HOST;
+  buffer[0] = 0; /* Set the end of string */
+
+  /* read setting "user" from settings.xml */
+  if (XBMC->GetSetting("user", buffer))
+    g_strUsername = buffer;
+  else
+    g_strUsername = "";
+  buffer[0] = 0; /* Set the end of string */
+
+  /* read setting "pass" from settings.xml */
+  if (XBMC->GetSetting("pass", buffer))
+    g_strPassword = buffer;
+  else
+    g_strPassword = "";
+
+  /* read setting "streamport" from settings.xml */
+  if (!XBMC->GetSetting("streamport", &g_iPortStream))
+    g_iPortStream = DEFAULT_STREAM_PORT;
+  
+  /* read setting "showcompleted" from settings.xml */
+  if (!XBMC->GetSetting("showcompleted", &g_bShowTimersCompleted))
+    g_bShowTimersCompleted = false;
+
+  /* read setting "updateint" from settings.xml */
+  if (!XBMC->GetSetting("updateint", &g_iUpdateInterval))
+    g_iConnectTimeout = DEFAULT_UPDATE_INTERVAL;
+
+  /* read setting "connect_timeout" from settings.xml */
+  if (!XBMC->GetSetting("connect_timeout", &g_iConnectTimeout))
+    g_iConnectTimeout = DEFAULT_CONNECT_TIMEOUT;
+
+  /* read setting "read_timeout" from settings.xml */
+  if (!XBMC->GetSetting("response_timeout", &g_iResponseTimeout))
+    g_iResponseTimeout = DEFAULT_RESPONSE_TIMEOUT;
+  
+  /* read setting "iconpath" from settings.xml */
+  if (XBMC->GetSetting("iconpath", buffer))
+    g_strIconPath = buffer;
+  else
+    g_strIconPath = "";
+  
+  free (buffer);
+}
+
+ADDON_STATUS ADDON_Create(void* hdl, void* props)
+{
+  if (!hdl || !props)
+    return ADDON_STATUS_UNKNOWN;
+
+  PVR_PROPERTIES* pvrprops = (PVR_PROPERTIES*)props;
+
+  XBMC = new CHelper_libXBMC_addon;
+  if (!XBMC->RegisterMe(hdl))
+  {
+    delete XBMC;
+    XBMC = NULL;
+    return ADDON_STATUS_UNKNOWN;
+  }
+
+  PVR = new CHelper_libXBMC_pvr;
+  if (!PVR->RegisterMe(hdl))
+  {
+    delete PVR;
+    delete XBMC;
+    PVR = NULL;
+    XBMC = NULL;
+    return ADDON_STATUS_UNKNOWN;
+  }
+
+  XBMC->Log(LOG_DEBUG, "%s - Creating VU+ PVR-Client", __FUNCTION__);
+
+  m_CurStatus     = ADDON_STATUS_UNKNOWN;
+  g_iClientId     = pvrprops->iClientId;
+  g_strUserPath   = pvrprops->strUserPath;
+  g_strClientPath = pvrprops->strClientPath;
+
+  ADDON_ReadSettings();
+
+  VuData = new Vu;
+  if (!VuData->Open()) 
+  {
+    delete VuData;
+    delete PVR;
+    delete XBMC;
+    VuData = NULL;
+    PVR = NULL;
+    XBMC = NULL;
+    m_CurStatus = ADDON_STATUS_LOST_CONNECTION;
+    return m_CurStatus;
+  }
+
+  m_CurStatus = ADDON_STATUS_OK;
+  m_bCreated = true;
+  return m_CurStatus;
+}
+
+ADDON_STATUS ADDON_GetStatus()
+{
+  /* check whether we're still connected */
+  if (m_CurStatus == ADDON_STATUS_OK && !VuData->IsConnected())
+    m_CurStatus = ADDON_STATUS_LOST_CONNECTION;
+
+  return m_CurStatus;
+}
+
+void ADDON_Destroy()
+{
+  if (m_bCreated)
+  {
+    m_bCreated = false;
+  }
+
+  if (PVR)
+  {
+    delete PVR;
+    PVR = NULL;
+  }
+
+  if (XBMC)
+  {
+    delete XBMC;
+    XBMC = NULL;
+  }
+
+  if (VuData)
+  {
+    delete VuData;
+    VuData = NULL;
+  }
+
+  m_CurStatus = ADDON_STATUS_UNKNOWN;
+}
+
+bool ADDON_HasSettings()
+{
+  return true;
+}
+
+unsigned int ADDON_GetSettings(ADDON_StructSetting ***sSet)
+{
+  return 0;
+}
+
+ADDON_STATUS ADDON_SetSetting(const char *settingName, const void *settingValue)
+{
+  string str = settingName;
+  if (str == "host")
+  {
+    string tmp_sHostname;
+    XBMC->Log(LOG_INFO, "%s - Changed Setting 'host' from %s to %s", __FUNCTION__, g_strHostname.c_str(), (const char*) settingValue);
+    tmp_sHostname = g_strHostname;
+    g_strHostname = (const char*) settingValue;
+    if (tmp_sHostname != g_strHostname)
+      return ADDON_STATUS_NEED_RESTART;
+  }
+  else if (str == "user")
+  {
+    string tmp_sUsername = g_strUsername;
+    g_strUsername = (const char*) settingValue;
+    if (tmp_sUsername != g_strUsername)
+    {
+      XBMC->Log(LOG_INFO, "%s - Changed Setting 'user'", __FUNCTION__);
+      return ADDON_STATUS_NEED_RESTART;
+    }
+  }
+  else if (str == "pass")
+  {
+    string tmp_sPassword = g_strPassword;
+    g_strPassword = (const char*) settingValue;
+    if (tmp_sPassword != g_strPassword)
+    {
+      XBMC->Log(LOG_INFO, "%s - Changed Setting 'pass'", __FUNCTION__);
+      return ADDON_STATUS_NEED_RESTART;
+    }
+  }
+  else if (str == "connect_timeout")
+  {
+    int iNewValue = *(int*) settingValue + 1;
+    if (g_iConnectTimeout != iNewValue)
+    {
+      XBMC->Log(LOG_INFO, "%s - Changed Setting 'connect_timeout' from %u to %u", __FUNCTION__, g_iConnectTimeout, iNewValue);
+      g_iConnectTimeout = iNewValue;
+      return ADDON_STATUS_OK;
+    }
+  }
+  else if (str == "response_timeout")
+  {
+    int iNewValue = *(int*) settingValue + 1;
+    if (g_iResponseTimeout != iNewValue)
+    {
+      XBMC->Log(LOG_INFO, "%s - Changed Setting 'response_timeout' from %u to %u", __FUNCTION__, g_iResponseTimeout, iNewValue);
+      g_iResponseTimeout = iNewValue;
+      return ADDON_STATUS_OK;
+    }
+  }
+  return ADDON_STATUS_OK;
+}
+
+void ADDON_Stop()
+{
+}
+
+void ADDON_FreeSettings()
+{
+}
+
+/***********************************************************
+ * PVR Client AddOn specific public library functions
+ ***********************************************************/
+
+PVR_ERROR GetAddonCapabilities(PVR_ADDON_CAPABILITIES* pCapabilities)
+{
+  pCapabilities->bSupportsChannelSettings = false;
+  pCapabilities->bSupportsTimeshift       = false;
+  pCapabilities->bSupportsEPG             = true;
+  pCapabilities->bSupportsTV              = true;
+  pCapabilities->bSupportsRadio           = true;
+  pCapabilities->bSupportsRecordings      = true;
+  pCapabilities->bSupportsTimers          = true;
+  pCapabilities->bSupportsChannelGroups   = true;
+  pCapabilities->bSupportsChannelScan     = false;
+  pCapabilities->bHandlesInputStream      = false;
+  pCapabilities->bHandlesDemuxing         = false;
+
+  return PVR_ERROR_NO_ERROR;
+}
+
+const char *GetBackendName(void)
+{
+  static const char *strBackendName = VuData ? VuData->GetServerName() : "unknown";
+  return strBackendName;
+}
+
+const char *GetBackendVersion(void)
+{
+  static const char *strBackendVersion = "UNKNOWN";
+  return strBackendVersion;
+}
+
+const char *GetConnectionString(void)
+{
+  static CStdString strConnectionString;
+  if (VuData)
+    strConnectionString.Format("%s%s", g_strHostname.c_str(), VuData->IsConnected() ? "" : " (Not connected!)");
+  else
+    strConnectionString.Format("%s (addon error!)", g_strHostname.c_str());
+  return strConnectionString.c_str();
+}
+
+PVR_ERROR GetDriveSpace(long long *iTotal, long long *iUsed)
+{
+  return PVR_ERROR_SERVER_ERROR;
+}
+
+PVR_ERROR GetEPGForChannel(PVR_HANDLE handle, const PVR_CHANNEL &channel, time_t iStart, time_t iEnd)
+{
+  if (!VuData || !VuData->IsConnected())
+    return PVR_ERROR_SERVER_ERROR;
+
+  return VuData->GetEPGForChannel(handle, channel, iStart, iEnd);
+}
+
+int GetChannelsAmount(void)
+{
+  if (!VuData || !VuData->IsConnected())
+    return 0;
+
+  return VuData->GetChannelsAmount();
+}
+
+PVR_ERROR GetChannels(PVR_HANDLE handle, bool bRadio)
+{
+  if (!VuData || !VuData->IsConnected())
+    return PVR_ERROR_SERVER_ERROR;
+
+  return VuData->GetChannels(handle, bRadio);
+}
+
+int GetRecordingsAmount(void)
+{
+  if (!VuData || !VuData->IsConnected())
+    return PVR_ERROR_SERVER_ERROR;
+
+  return VuData->GetRecordingsAmount();
+}
+
+PVR_ERROR GetRecordings(PVR_HANDLE handle)
+{
+  if (!VuData || !VuData->IsConnected())
+    return PVR_ERROR_SERVER_ERROR;
+
+  return VuData->GetRecordings(handle);
+}
+
+PVR_ERROR DeleteRecording(const PVR_RECORDING &recording)
+{
+  if (!VuData || !VuData->IsConnected())
+    return PVR_ERROR_SERVER_ERROR;
+
+  return VuData->DeleteRecording(recording);
+}
+
+PVR_ERROR RenameRecording(const PVR_RECORDING &recording)
+{
+  return PVR_ERROR_NOT_IMPLEMENTED;
+}
+
+int GetTimersAmount(void)
+{
+  if (!VuData || !VuData->IsConnected())
+    return 0;
+
+  return VuData->GetTimersAmount();
+}
+
+PVR_ERROR GetTimers(PVR_HANDLE handle)
+{
+  if (!VuData || !VuData->IsConnected())
+    return PVR_ERROR_SERVER_ERROR;
+
+  return VuData->GetTimers(handle);
+}
+
+PVR_ERROR AddTimer(const PVR_TIMER &timer)
+{
+  if (!VuData || !VuData->IsConnected())
+    return PVR_ERROR_SERVER_ERROR;
+
+  return VuData->AddTimer(timer);
+}
+
+PVR_ERROR DeleteTimer(const PVR_TIMER &timer, bool bForceDelete)
+{
+  if (!VuData || !VuData->IsConnected())
+    return PVR_ERROR_SERVER_ERROR;
+
+  return VuData->DeleteTimer(timer);
+}
+
+PVR_ERROR UpdateTimer(const PVR_TIMER &timer)
+{
+  if (!VuData || !VuData->IsConnected())
+    return PVR_ERROR_SERVER_ERROR;
+
+  return VuData->UpdateTimer(timer);
+}
+
+int GetCurrentClientChannel(void)
+{
+  return -1;
+}
+
+bool SwitchChannel(const PVR_CHANNEL &channel)
+{
+  return false;
+}
+
+int GetChannelGroupsAmount(void)
+{
+  if (!VuData || !VuData->IsConnected())
+    return PVR_ERROR_SERVER_ERROR;
+
+  return VuData->GetNumChannelGroups();
+}
+
+PVR_ERROR GetChannelGroups(PVR_HANDLE handle, bool bRadio)
+{
+  if (bRadio)
+    return PVR_ERROR_NO_ERROR;
+
+  if (!VuData || !VuData->IsConnected())
+    return PVR_ERROR_SERVER_ERROR;
+
+  return VuData->GetChannelGroups(handle);
+}
+
+PVR_ERROR GetChannelGroupMembers(PVR_HANDLE handle, const PVR_CHANNEL_GROUP &group)
+{
+  if (group.bIsRadio)
+    return PVR_ERROR_NO_ERROR;
+
+  if (!VuData || !VuData->IsConnected())
+    return PVR_ERROR_SERVER_ERROR;
+
+  return VuData->GetChannelGroupMembers(handle, group);
+}
+
+
+/** UNUSED API FUNCTIONS */
+void CloseLiveStream(void) { return; };
+bool OpenLiveStream(const PVR_CHANNEL &channel) { return false; }
+PVR_ERROR SignalStatus(PVR_SIGNAL_STATUS &signalStatus) { return PVR_ERROR_NO_ERROR; }
+PVR_ERROR GetStreamProperties(PVR_STREAM_PROPERTIES* pProperties) { return PVR_ERROR_NOT_IMPLEMENTED; } 
+void DemuxAbort(void) { return; }
+DemuxPacket* DemuxRead(void) { return NULL; }
+PVR_ERROR DialogChannelScan(void) { return PVR_ERROR_NOT_IMPLEMENTED; }
+PVR_ERROR CallMenuHook(const PVR_MENUHOOK &menuhook) { return PVR_ERROR_NOT_IMPLEMENTED; }
+PVR_ERROR DeleteChannel(const PVR_CHANNEL &channel) { return PVR_ERROR_NOT_IMPLEMENTED; }
+PVR_ERROR RenameChannel(const PVR_CHANNEL &channel) { return PVR_ERROR_NOT_IMPLEMENTED; }
+PVR_ERROR MoveChannel(const PVR_CHANNEL &channel) { return PVR_ERROR_NOT_IMPLEMENTED; }
+PVR_ERROR DialogChannelSettings(const PVR_CHANNEL &channel) { return PVR_ERROR_NOT_IMPLEMENTED; }
+PVR_ERROR DialogAddChannel(const PVR_CHANNEL &channel) { return PVR_ERROR_NOT_IMPLEMENTED; }
+bool OpenRecordedStream(const PVR_RECORDING &recording) { return false; }
+void CloseRecordedStream(void) {}
+int ReadRecordedStream(unsigned char *pBuffer, unsigned int iBufferSize) { return 0; }
+long long SeekRecordedStream(long long iPosition, int iWhence /* = SEEK_SET */) { return 0; }
+long long PositionRecordedStream(void) { return -1; }
+long long LengthRecordedStream(void) { return 0; }
+void DemuxReset(void) {}
+void DemuxFlush(void) {}
+int ReadLiveStream(unsigned char *pBuffer, unsigned int iBufferSize) { return 0; }
+long long SeekLiveStream(long long iPosition, int iWhence /* = SEEK_SET */) { return -1; }
+long long PositionLiveStream(void) { return -1; }
+long long LengthLiveStream(void) { return -1; }
+const char * GetLiveStreamURL(const PVR_CHANNEL &channel) { return ""; }
+}
diff --git a/xbmc/pvrclients/vuplus/client.h b/xbmc/pvrclients/vuplus/client.h
new file mode 100644
index 0000000..d7dcf5f
--- /dev/null
+++ b/xbmc/pvrclients/vuplus/client.h
@@ -0,0 +1,48 @@
+#pragma once
+/*
+ *      Copyright (C) 2005-2011 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "../../../addons/library.xbmc.addon/libXBMC_addon.h"
+#include "../../../addons/library.xbmc.pvr/libXBMC_pvr.h"
+
+#define DEFAULT_HOST             "127.0.0.1"
+#define DEFAULT_CONNECT_TIMEOUT  30
+#define DEFAULT_RESPONSE_TIMEOUT 3
+#define DEFAULT_STREAM_PORT      8001 
+#define DEFAULT_UPDATE_INTERVAL  2
+
+extern bool                      m_bCreated;
+extern std::string               g_strHostname;
+extern int                       g_iPortStream;
+extern std::string               g_strUsername;
+extern std::string               g_strPassword;
+extern std::string               g_strIconPath;
+extern int                       g_iConnectTimeout;
+extern int                       g_iResponseTimeout;
+extern int 			 g_iUpdateInterval;
+extern int                       g_iClientId;
+extern unsigned int              g_iPacketSequence;
+extern bool                      g_bShowTimerNotifications;
+extern bool 	                 g_bShowTimersCompleted;
+extern std::string               g_szUserPath;
+extern std::string               g_szClientPath;
+extern ADDON::CHelper_libXBMC_addon *   XBMC;
+extern CHelper_libXBMC_pvr *     PVR;
diff --git a/xbmc/pvrclients/vuplus/thread.cpp b/xbmc/pvrclients/vuplus/thread.cpp
new file mode 100644
index 0000000..a07c9d9
--- /dev/null
+++ b/xbmc/pvrclients/vuplus/thread.cpp
@@ -0,0 +1,418 @@
+/*
+ *      Copyright (C) 2005-2009 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+/*
+ * Most of this code is taken from thread.c in the Video Disk Recorder ('VDR')
+ */
+
+#include "thread.h"
+#include <errno.h>
+#ifndef __APPLE__
+#include <malloc.h>
+#endif
+
+#if !defined(__WINDOWS__)
+#include <sys/signal.h>
+#endif
+
+#include <stdarg.h>
+#include <stdlib.h>
+
+using namespace ADDON;
+
+static bool GetAbsTime(struct timespec *Abstime, int MillisecondsFromNow)
+{
+  struct timeval now;
+  if (gettimeofday(&now, NULL) == 0) {           // get current time
+     now.tv_sec  += MillisecondsFromNow / 1000;  // add full seconds
+     now.tv_usec += (MillisecondsFromNow % 1000) * 1000;  // add microseconds
+     if (now.tv_usec >= 1000000) {               // take care of an overflow
+        now.tv_sec++;
+        now.tv_usec -= 1000000;
+        }
+     Abstime->tv_sec = now.tv_sec;          // seconds
+     Abstime->tv_nsec = now.tv_usec * 1000; // nano seconds
+     return true;
+     }
+  return false;
+}
+
+// --- cCondWait -------------------------------------------------------------
+
+cCondWait::cCondWait(void)
+{
+  signaled = false;
+  pthread_mutex_init(&mutex, NULL);
+  pthread_cond_init(&cond, NULL);
+}
+
+cCondWait::~cCondWait()
+{
+  pthread_cond_broadcast(&cond); // wake up any sleepers
+  pthread_cond_destroy(&cond);
+  pthread_mutex_destroy(&mutex);
+}
+
+void cCondWait::SleepMs(int TimeoutMs)
+{
+  cCondWait w;
+  w.Wait(max(TimeoutMs, 3)); // making sure the time is >2ms to avoid a possible busy wait
+}
+
+bool cCondWait::Wait(int TimeoutMs)
+{
+  pthread_mutex_lock(&mutex);
+  if (!signaled)
+  {
+    if (TimeoutMs)
+	{
+      struct timespec abstime;
+      if (GetAbsTime(&abstime, TimeoutMs))
+	  {
+        while (!signaled)
+        {
+		  int iResult = pthread_cond_timedwait(&cond, &mutex, &abstime);
+		  if (iResult != 0)
+            break;
+        }
+      }
+     }
+     else
+        pthread_cond_wait(&cond, &mutex);
+     }
+  bool r = signaled;
+  signaled = false;
+  pthread_mutex_unlock(&mutex);
+  return r;
+}
+
+void cCondWait::Signal(void)
+{
+  pthread_mutex_lock(&mutex);
+  signaled = true;
+  pthread_cond_broadcast(&cond);
+  pthread_mutex_unlock(&mutex);
+}
+
+// --- cCondVar --------------------------------------------------------------
+
+cCondVar::cCondVar(void)
+{
+  pthread_cond_init(&cond, 0);
+}
+
+cCondVar::~cCondVar()
+{
+  pthread_cond_broadcast(&cond); // wake up any sleepers
+  pthread_cond_destroy(&cond);
+}
+
+void cCondVar::Wait(cMutex &Mutex)
+{
+  if (Mutex.locked) {
+     int locked = Mutex.locked;
+     Mutex.locked = 0; // have to clear the locked count here, as pthread_cond_wait
+                       // does an implicit unlock of the mutex
+     pthread_cond_wait(&cond, &Mutex.mutex);
+     Mutex.locked = locked;
+     }
+}
+
+bool cCondVar::TimedWait(cMutex &Mutex, int TimeoutMs)
+{
+  bool r = true; // true = condition signaled, false = timeout
+
+  if (Mutex.locked) {
+     struct timespec abstime;
+     if (GetAbsTime(&abstime, TimeoutMs)) {
+        int locked = Mutex.locked;
+        Mutex.locked = 0; // have to clear the locked count here, as pthread_cond_timedwait
+                          // does an implicit unlock of the mutex.
+        if (pthread_cond_timedwait(&cond, &Mutex.mutex, &abstime) == ETIMEDOUT)
+           r = false;
+        Mutex.locked = locked;
+        }
+     }
+  return r;
+}
+
+void cCondVar::Broadcast(void)
+{
+  pthread_cond_broadcast(&cond);
+}
+
+// --- cMutex ----------------------------------------------------------------
+
+cMutex::cMutex(void)
+{
+  locked = 0;
+  pthread_mutexattr_t attr;
+  pthread_mutexattr_init(&attr);
+#ifndef __APPLE__
+  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK_NP);
+#else
+  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK);
+#endif
+  pthread_mutex_init(&mutex, &attr);
+}
+
+cMutex::~cMutex()
+{
+  pthread_mutex_destroy(&mutex);
+}
+
+void cMutex::Lock(void)
+{
+  pthread_mutex_lock(&mutex);
+  locked++;
+}
+
+void cMutex::Unlock(void)
+{
+ if (!--locked)
+    pthread_mutex_unlock(&mutex);
+}
+
+// --- cThread ---------------------------------------------------------------
+
+tThreadId cThread::mainThreadId = 0;
+
+cThread::cThread(const char *Description)
+{
+  active = running = false;
+#if !defined(__WINDOWS__)
+  childTid = 0;
+#endif
+  childThreadId = 0;
+  description = NULL;
+  if (Description)
+     SetDescription("%s", Description);
+}
+
+cThread::~cThread()
+{
+  Cancel(); // just in case the derived class didn't call it
+  free(description);
+}
+
+void cThread::SetPriority(int Priority)
+{
+#if !defined(__WINDOWS__)
+  if (setpriority(PRIO_PROCESS, 0, Priority) < 0)
+     XBMC->Log(LOG_ERROR, "ERROR (%s,%d): %m", __FILE__, __LINE__);
+#endif
+}
+
+void cThread::SetIOPriority(int Priority)
+{
+#if !defined(__WINDOWS__)
+#ifdef HAVE_LINUXIOPRIO
+  if (syscall(SYS_ioprio_set, 1, 0, (Priority & 0xff) | (2 << 13)) < 0) // best effort class
+     XBMC->Log(LOG_ERROR, "ERROR (%s,%d): %m", __FILE__, __LINE__);
+#endif
+#endif
+}
+
+void cThread::SetDescription(const char *Description, ...)
+{
+  free(description);
+  description = NULL;
+  if (Description)
+  {
+     va_list ap;
+     va_start(ap, Description);
+     CStdString desc;
+     desc.FormatV(Description, ap);
+     description = strdup(desc.c_str());
+     va_end(ap);
+  }
+}
+
+void *cThread::StartThread(cThread *Thread)
+{
+  Thread->childThreadId = ThreadId();
+  if (Thread->description) {
+     XBMC->Log(LOG_DEBUG, "%s thread started (pid=%d, tid=%d)", Thread->description, getpid(), Thread->childThreadId);
+#ifdef PR_SET_NAME
+     if (prctl(PR_SET_NAME, Thread->description, 0, 0, 0) < 0)
+        XBMC->Log(LOG_ERROR, "%s thread naming failed (pid=%d, tid=%d)", Thread->description, getpid(), Thread->childThreadId);
+#endif
+     }
+  Thread->Action();
+  if (Thread->description)
+     XBMC->Log(LOG_DEBUG, "%s thread ended (pid=%d, tid=%d)", Thread->description, getpid(), Thread->childThreadId);
+  Thread->running = false;
+  Thread->active = false;
+  return NULL;
+}
+
+#define THREAD_STOP_TIMEOUT  3000 // ms to wait for a thread to stop before newly starting it
+#define THREAD_STOP_SLEEP      30 // ms to sleep while waiting for a thread to stop
+
+bool cThread::Start(void)
+{
+  if (!running) {
+     if (active) {
+        // Wait until the previous incarnation of this thread has completely ended
+        // before starting it newly:
+        cTimeMs RestartTimeout;
+        while (!running && active && RestartTimeout.Elapsed() < THREAD_STOP_TIMEOUT)
+              cCondWait::SleepMs(THREAD_STOP_SLEEP);
+        }
+     if (!active) {
+        active = running = true;
+        if (pthread_create(&childTid, NULL, (void *(*) (void *))&StartThread, (void *)this) == 0) {
+           pthread_detach(childTid); // auto-reap
+           }
+        else {
+           XBMC->Log(LOG_ERROR, "ERROR (%s,%d): %m", __FILE__, __LINE__);
+           active = running = false;
+           return false;
+           }
+        }
+     }
+  return true;
+}
+
+bool cThread::Active(void)
+{
+  if (active) {
+     //
+     // Single UNIX Spec v2 says:
+     //
+     // The pthread_kill() function is used to request
+     // that a signal be delivered to the specified thread.
+     //
+     // As in kill(), if sig is zero, error checking is
+     // performed but no signal is actually sent.
+     //
+     int err;
+     if ((err = pthread_kill(childTid, 0)) != 0) {
+        if (err != ESRCH)
+           XBMC->Log(LOG_ERROR, "ERROR (%s,%d): %m", __FILE__, __LINE__);
+#if !defined(__WINDOWS__)
+        childTid = 0;
+#endif
+        active = running = false;
+        }
+     else
+        return true;
+     }
+  return false;
+}
+
+void cThread::Cancel(int WaitSeconds)
+{
+  running = false;
+  if (active && WaitSeconds > -1)
+  {
+    if (WaitSeconds > 0)
+    {
+      for (time_t t0 = time(NULL) + WaitSeconds; time(NULL) < t0; )
+      {
+        if (!Active())
+          return;
+        cCondWait::SleepMs(10);
+      }
+      XBMC->Log(LOG_ERROR, "ERROR: %s thread %d won't end (waited %d seconds) - canceling it...", description ? description : "", childThreadId, WaitSeconds);
+    }
+    pthread_cancel(childTid);
+#if !defined(__WINDOWS__)
+    childTid = 0;
+#endif
+    active = false;
+  }
+}
+
+tThreadId cThread::ThreadId(void)
+{
+#ifdef __APPLE__
+    return (int)pthread_self();
+#else
+#ifdef __WINDOWS__
+  return GetCurrentThreadId();
+#else
+  return syscall(__NR_gettid);
+#endif
+#endif
+}
+
+void cThread::SetMainThreadId(void)
+{
+  if (mainThreadId == 0)
+     mainThreadId = ThreadId();
+  else
+     XBMC->Log(LOG_ERROR, "ERROR: attempt to set main thread id to %d while it already is %d", ThreadId(), mainThreadId);
+}
+
+// --- cMutexLock ------------------------------------------------------------
+
+cMutexLock::cMutexLock(cMutex *Mutex)
+{
+  mutex = NULL;
+  locked = false;
+  Lock(Mutex);
+}
+
+cMutexLock::~cMutexLock()
+{
+  if (mutex && locked)
+    mutex->Unlock();
+}
+
+bool cMutexLock::Lock(cMutex *Mutex)
+{
+  if (Mutex && !mutex)
+  {
+    mutex = Mutex;
+    Mutex->Lock();
+    locked = true;
+    return true;
+  }
+  return false;
+}
+
+// --- cThreadLock -----------------------------------------------------------
+
+cThreadLock::cThreadLock(cThread *Thread)
+{
+  thread = NULL;
+  locked = false;
+  Lock(Thread);
+}
+
+cThreadLock::~cThreadLock()
+{
+  if (thread && locked)
+    thread->Unlock();
+}
+
+bool cThreadLock::Lock(cThread *Thread)
+{
+  if (Thread && !thread)
+  {
+  thread = Thread;
+  Thread->Lock();
+  locked = true;
+  return true;
+  }
+  return false;
+}
diff --git a/xbmc/pvrclients/vuplus/thread.h b/xbmc/pvrclients/vuplus/thread.h
new file mode 100644
index 0000000..f0c594d
--- /dev/null
+++ b/xbmc/pvrclients/vuplus/thread.h
@@ -0,0 +1,168 @@
+/*
+ *      Copyright (C) 2005-2009 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#ifndef __THREAD_H
+#define __THREAD_H
+
+#include <stdio.h>
+#include <sys/types.h>
+#include "tools.h"
+#include "utils/StdString.h"
+#include "libPlatform/os-dependent.h"
+
+class cCondWait {
+private:
+  pthread_mutex_t mutex;
+  pthread_cond_t cond;
+  bool signaled;
+public:
+  cCondWait(void);
+  ~cCondWait();
+  static void SleepMs(int TimeoutMs);
+       ///< Creates a cCondWait object and uses it to sleep for TimeoutMs
+       ///< milliseconds, immediately giving up the calling thread's time
+       ///< slice and thus avoiding a "busy wait".
+       ///< In order to avoid a possible busy wait, TimeoutMs will be automatically
+       ///< limited to values >2.
+  bool Wait(int TimeoutMs = 0);
+       ///< Waits at most TimeoutMs milliseconds for a call to Signal(), or
+       ///< forever if TimeoutMs is 0.
+       ///< \return Returns true if Signal() has been called, false it the given
+       ///< timeout has expired.
+  void Signal(void);
+       ///< Signals a caller of Wait() that the condition it is waiting for is met.
+  };
+
+class cMutex;
+
+class cCondVar {
+private:
+  pthread_cond_t cond;
+public:
+  cCondVar(void);
+  ~cCondVar();
+  void Wait(cMutex &Mutex);
+  bool TimedWait(cMutex &Mutex, int TimeoutMs);
+  void Broadcast(void);
+  };
+
+class cMutex {
+  friend class cCondVar;
+private:
+  pthread_mutex_t mutex;
+  int locked;
+public:
+  cMutex(void);
+  ~cMutex();
+  void Lock(void);
+  void Unlock(void);
+  };
+
+typedef pid_t tThreadId;
+
+class cThread {
+  friend class cThreadLock;
+private:
+  bool active;
+  bool running;
+  pthread_t childTid;
+  tThreadId childThreadId;
+  cMutex mutex;
+  char *description;
+  static tThreadId mainThreadId;
+  static void *StartThread(cThread *Thread);
+protected:
+  void SetPriority(int Priority);
+  void SetIOPriority(int Priority);
+  void Lock(void) { mutex.Lock(); }
+  void Unlock(void) { mutex.Unlock(); }
+  virtual void Action(void) = 0;
+       ///< A derived cThread class must implement the code it wants to
+       ///< execute as a separate thread in this function. If this is
+       ///< a loop, it must check Running() repeatedly to see whether
+       ///< it's time to stop.
+  bool Running(void) { return running; }
+       ///< Returns false if a derived cThread object shall leave its Action()
+       ///< function.
+  void Cancel(int WaitSeconds = 0);
+       ///< Cancels the thread by first setting 'running' to false, so that
+       ///< the Action() loop can finish in an orderly fashion and then waiting
+       ///< up to WaitSeconds seconds for the thread to actually end. If the
+       ///< thread doesn't end by itself, it is killed.
+       ///< If WaitSeconds is -1, only 'running' is set to false and Cancel()
+       ///< returns immediately, without killing the thread.
+public:
+  cThread(const char *Description = NULL);
+       ///< Creates a new thread.
+       ///< If Description is present, a log file entry will be made when
+       ///< the thread starts and stops. The Start() function must be called
+       ///< to actually start the thread.
+  virtual ~cThread();
+#ifdef __WINDOWS__
+  void SetDescription(const char *Description, ...);
+#else
+  void SetDescription(const char *Description, ...) __attribute__ ((format (printf, 2, 3)));
+#endif
+  bool Start(void);
+       ///< Actually starts the thread.
+       ///< If the thread is already running, nothing happens.
+  bool Active(void);
+       ///< Checks whether the thread is still alive.
+  static tThreadId ThreadId(void);
+  static tThreadId IsMainThread(void) { return ThreadId() == mainThreadId; }
+  static void SetMainThreadId(void);
+  };
+
+// cMutexLock can be used to easily set a lock on mutex and make absolutely
+// sure that it will be unlocked when the block will be left. Several locks can
+// be stacked, so a function that makes many calls to another function which uses
+// cMutexLock may itself use a cMutexLock to make one longer lock instead of many
+// short ones.
+
+class cMutexLock {
+private:
+  cMutex *mutex;
+  bool locked;
+public:
+  cMutexLock(cMutex *Mutex = NULL);
+  ~cMutexLock();
+  bool Lock(cMutex *Mutex);
+  };
+
+// cThreadLock can be used to easily set a lock in a thread and make absolutely
+// sure that it will be unlocked when the block will be left. Several locks can
+// be stacked, so a function that makes many calls to another function which uses
+// cThreadLock may itself use a cThreadLock to make one longer lock instead of many
+// short ones.
+
+class cThreadLock {
+private:
+  cThread *thread;
+  bool locked;
+public:
+  cThreadLock(cThread *Thread = NULL);
+  ~cThreadLock();
+  bool Lock(cThread *Thread);
+  };
+
+#define LOCK_THREAD cThreadLock ThreadLock(this)
+
+#endif //__THREAD_H
diff --git a/xbmc/pvrclients/vuplus/tools.cpp b/xbmc/pvrclients/vuplus/tools.cpp
new file mode 100644
index 0000000..395b959
--- /dev/null
+++ b/xbmc/pvrclients/vuplus/tools.cpp
@@ -0,0 +1,96 @@
+/*
+ *      Copyright (C) 2005-2009 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+/*
+ * Most of this code is taken from tools.c in the Video Disk Recorder ('VDR')
+ */
+
+#include "tools.h"
+#include "libPlatform/os-dependent.h"
+
+using namespace ADDON;
+
+// --- cTimeMs ---------------------------------------------------------------
+
+cTimeMs::cTimeMs(int Ms)
+{
+  Set(Ms);
+}
+
+uint64_t cTimeMs::Now(void)
+{
+#if _POSIX_TIMERS > 0 && defined(_POSIX_MONOTONIC_CLOCK)
+#define MIN_RESOLUTION 5 // ms
+  static bool initialized = false;
+  static bool monotonic = false;
+  struct timespec tp;
+  if (!initialized) {
+     // check if monotonic timer is available and provides enough accurate resolution:
+     if (clock_getres(CLOCK_MONOTONIC, &tp) == 0) {
+        long Resolution = tp.tv_nsec;
+        // require a minimum resolution:
+        if (tp.tv_sec == 0 && tp.tv_nsec <= MIN_RESOLUTION * 1000000) {
+           if (clock_gettime(CLOCK_MONOTONIC, &tp) == 0) {
+              XBMC->Log(LOG_DEBUG, "cTimeMs: using monotonic clock (resolution is %ld ns)", Resolution);
+              monotonic = true;
+              }
+           else
+              XBMC->Log(LOG_ERROR, "cTimeMs: clock_gettime(CLOCK_MONOTONIC) failed");
+           }
+        else
+           XBMC->Log(LOG_DEBUG, "cTimeMs: not using monotonic clock - resolution is too bad (%ld s %ld ns)", tp.tv_sec, tp.tv_nsec);
+        }
+     else
+        XBMC->Log(LOG_ERROR, "cTimeMs: clock_getres(CLOCK_MONOTONIC) failed");
+     initialized = true;
+     }
+  if (monotonic) {
+     if (clock_gettime(CLOCK_MONOTONIC, &tp) == 0)
+        return (uint64_t(tp.tv_sec)) * 1000 + tp.tv_nsec / 1000000;
+     XBMC->Log(LOG_ERROR, "cTimeMs: clock_gettime(CLOCK_MONOTONIC) failed");
+     monotonic = false;
+     // fall back to gettimeofday()
+     }
+#else
+#if !defined(__WINDOWS__)
+#  warning Posix monotonic clock not available
+#endif
+#endif
+  struct timeval t;
+  if (gettimeofday(&t, NULL) == 0)
+     return (uint64_t(t.tv_sec)) * 1000 + t.tv_usec / 1000;
+  return 0;
+}
+
+void cTimeMs::Set(int Ms)
+{
+  begin = Now() + Ms;
+}
+
+bool cTimeMs::TimedOut(void)
+{
+  return Now() >= begin;
+}
+
+uint64_t cTimeMs::Elapsed(void)
+{
+  return Now() - begin;
+}
diff --git a/xbmc/pvrclients/vuplus/tools.h b/xbmc/pvrclients/vuplus/tools.h
new file mode 100644
index 0000000..8bf1060
--- /dev/null
+++ b/xbmc/pvrclients/vuplus/tools.h
@@ -0,0 +1,63 @@
+/*
+ *      Copyright (C) 2005-2009 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#ifndef __TOOLS_H
+#define __TOOLS_H
+
+#include "client.h"
+#include "utils/StdString.h"
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#define ERRNUL(e) {errno=e;return 0;}
+#define ERRSYS(e) {errno=e;return -1;}
+
+#define SECSINDAY  86400
+
+#define KILOBYTE(n) ((n) * 1024)
+#define MEGABYTE(n) ((n) * 1024LL * 1024LL)
+
+#define MALLOC(type, size)  (type *)malloc(sizeof(type) * (size))
+
+#define DELETENULL(p) (delete (p), p = NULL)
+//
+//#define CHECK(s) { if ((s) < 0) LOG_ERROR; } // used for 'ioctl()' calls
+#define FATALERRNO (errno && errno != EAGAIN && errno != EINTR)
+
+class cTimeMs
+{
+private:
+  uint64_t begin;
+public:
+  cTimeMs(int Ms = 0);
+      ///< Creates a timer with ms resolution and an initial timeout of Ms.
+  static uint64_t Now(void);
+  void Set(int Ms = 0);
+  bool TimedOut(void);
+  uint64_t Elapsed(void);
+};
+
+
+#endif //__TOOLS_H
diff --git a/xbmc/pvrclients/vuplus/xmlParser.cpp b/xbmc/pvrclients/vuplus/xmlParser.cpp
new file mode 100644
index 0000000..af769de
--- /dev/null
+++ b/xbmc/pvrclients/vuplus/xmlParser.cpp
@@ -0,0 +1,2940 @@
+/**
+ ****************************************************************************
+ * <P> XML.c - implementation file for basic XML parser written in ANSI C++
+ * for portability. It works by using recursion and a node tree for breaking
+ * down the elements of an XML document.  </P>
+ *
+ * @version     V2.43
+ * @author      Frank Vanden Berghen
+ *
+ * NOTE:
+ *
+ *   If you add "#define STRICT_PARSING", on the first line of this file
+ *   the parser will see the following XML-stream:
+ *      <a><b>some text</b><b>other text    </a>
+ *   as an error. Otherwise, this tring will be equivalent to:
+ *      <a><b>some text</b><b>other text</b></a>
+ *
+ * NOTE:
+ *
+ *   If you add "#define APPROXIMATE_PARSING" on the first line of this file
+ *   the parser will see the following XML-stream:
+ *     <data name="n1">
+ *     <data name="n2">
+ *     <data name="n3" />
+ *   as equivalent to the following XML-stream:
+ *     <data name="n1" />
+ *     <data name="n2" />
+ *     <data name="n3" />
+ *   This can be useful for badly-formed XML-streams but prevent the use
+ *   of the following XML-stream (problem is: tags at contiguous levels
+ *   have the same names):
+ *     <data name="n1">
+ *        <data name="n2">
+ *            <data name="n3" />
+ *        </data>
+ *     </data>
+ *
+ * NOTE:
+ *
+ *   If you add "#define _XMLPARSER_NO_MESSAGEBOX_" on the first line of this file
+ *   the "openFileHelper" function will always display error messages inside the
+ *   console instead of inside a message-box-window. Message-box-windows are
+ *   available on windows 9x/NT/2000/XP/Vista only.
+ *
+ * Copyright (c) 2002, Business-Insight
+ * <a href="http://www.Business-Insight.com">Business-Insight</a>
+ * All rights reserved.
+ * See the file "AFPL-license.txt" about the licensing terms
+ *
+ ****************************************************************************
+ */
+#ifndef _CRT_SECURE_NO_DEPRECATE
+#define _CRT_SECURE_NO_DEPRECATE
+#endif
+#include "xmlParser.h"
+#ifdef _XMLWINDOWS
+//#ifdef _DEBUG
+//#define _CRTDBG_MAP_ALLOC
+//#include <crtdbg.h>
+//#endif
+#define WIN32_LEAN_AND_MEAN
+#include <Windows.h> // to have IsTextUnicode, MultiByteToWideChar, WideCharToMultiByte to handle unicode files
+                     // to have "MessageBoxA" to display error messages for openFilHelper
+#endif
+
+#include <memory.h>
+#include <assert.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+XMLCSTR XMLNode::getVersion() { return _CXML("v2.43"); }
+void freeXMLString(XMLSTR t){if(t)free(t);}
+
+static XMLNode::XMLCharEncoding characterEncoding=XMLNode::char_encoding_UTF8;
+static char guessWideCharChars=1, dropWhiteSpace=1, removeCommentsInMiddleOfText=1;
+
+inline int mmin( const int t1, const int t2 ) { return t1 < t2 ? t1 : t2; }
+
+// You can modify the initialization of the variable "XMLClearTags" below
+// to change the clearTags that are currently recognized by the library.
+// The number on the second columns is the length of the string inside the
+// first column.
+// The "<!DOCTYPE" declaration must be the second in the list.
+// The "<!--" declaration must be the third in the list.
+// All ClearTag Strings must start with the '<' character.
+typedef struct { XMLCSTR lpszOpen; int openTagLen; XMLCSTR lpszClose;} ALLXMLClearTag;
+static ALLXMLClearTag XMLClearTags[] =
+{
+    {    _CXML("<![CDATA["),9,  _CXML("]]>")      },
+    {    _CXML("<!DOCTYPE"),9,  _CXML(">")        },
+    {    _CXML("<!--")     ,4,  _CXML("-->")      },
+    {    _CXML("<PRE>")    ,5,  _CXML("</PRE>")   },
+//  {    _CXML("<Script>") ,8,  _CXML("</Script>")},
+    {    NULL              ,0,  NULL           }
+};
+
+// You can modify the initialization of the variable "XMLEntities" below
+// to change the character entities that are currently recognized by the library.
+// The number on the second columns is the length of the string inside the
+// first column. Additionally, the syntaxes "&#xA0;" and "&#160;" are recognized.
+typedef struct { XMLCSTR s; int l; XMLCHAR c;} XMLCharacterEntity;
+static XMLCharacterEntity XMLEntities[] =
+{
+    { _CXML("&amp;" ), 5, _CXML('&' )},
+    { _CXML("&lt;"  ), 4, _CXML('<' )},
+    { _CXML("&gt;"  ), 4, _CXML('>' )},
+    { _CXML("&quot;"), 6, _CXML('\"')},
+    { _CXML("&apos;"), 6, _CXML('\'')},
+    { NULL           , 0, '\0'    }
+};
+
+// When rendering the XMLNode to a string (using the "createXMLString" function),
+// you can ask for a beautiful formatting. This formatting is using the
+// following indentation character:
+#define INDENTCHAR _CXML('\t')
+
+// The following function parses the XML errors into a user friendly string.
+// You can edit this to change the output language of the library to something else.
+XMLCSTR XMLNode::getError(XMLError xerror)
+{
+    switch (xerror)
+    {
+    case eXMLErrorNone:                  return _CXML("No error");
+    case eXMLErrorMissingEndTag:         return _CXML("Warning: Unmatched end tag");
+    case eXMLErrorNoXMLTagFound:         return _CXML("Warning: No XML tag found");
+    case eXMLErrorEmpty:                 return _CXML("Error: No XML data");
+    case eXMLErrorMissingTagName:        return _CXML("Error: Missing start tag name");
+    case eXMLErrorMissingEndTagName:     return _CXML("Error: Missing end tag name");
+    case eXMLErrorUnmatchedEndTag:       return _CXML("Error: Unmatched end tag");
+    case eXMLErrorUnmatchedEndClearTag:  return _CXML("Error: Unmatched clear tag end");
+    case eXMLErrorUnexpectedToken:       return _CXML("Error: Unexpected token found");
+    case eXMLErrorNoElements:            return _CXML("Error: No elements found");
+    case eXMLErrorFileNotFound:          return _CXML("Error: File not found");
+    case eXMLErrorFirstTagNotFound:      return _CXML("Error: First Tag not found");
+    case eXMLErrorUnknownCharacterEntity:return _CXML("Error: Unknown character entity");
+    case eXMLErrorCharacterCodeAbove255: return _CXML("Error: Character code above 255 is forbidden in MultiByte char mode.");
+    case eXMLErrorCharConversionError:   return _CXML("Error: unable to convert between WideChar and MultiByte chars");
+    case eXMLErrorCannotOpenWriteFile:   return _CXML("Error: unable to open file for writing");
+    case eXMLErrorCannotWriteFile:       return _CXML("Error: cannot write into file");
+
+    case eXMLErrorBase64DataSizeIsNotMultipleOf4: return _CXML("Warning: Base64-string length is not a multiple of 4");
+    case eXMLErrorBase64DecodeTruncatedData:      return _CXML("Warning: Base64-string is truncated");
+    case eXMLErrorBase64DecodeIllegalCharacter:   return _CXML("Error: Base64-string contains an illegal character");
+    case eXMLErrorBase64DecodeBufferTooSmall:     return _CXML("Error: Base64 decode output buffer is too small");
+    };
+    return _CXML("Unknown");
+}
+
+/////////////////////////////////////////////////////////////////////////
+//      Here start the abstraction layer to be OS-independent          //
+/////////////////////////////////////////////////////////////////////////
+
+// Here is an abstraction layer to access some common string manipulation functions.
+// The abstraction layer is currently working for gcc, Microsoft Visual Studio 6.0,
+// Microsoft Visual Studio .NET, CC (sun compiler) and Borland C++.
+// If you plan to "port" the library to a new system/compiler, all you have to do is
+// to edit the following lines.
+#ifdef XML_NO_WIDE_CHAR
+char myIsTextWideChar(const void *b, int len) { return FALSE; }
+#else
+    #if defined (UNDER_CE) || !defined(_XMLWINDOWS)
+    char myIsTextWideChar(const void *b, int len) // inspired by the Wine API: RtlIsTextUnicode
+    {
+#ifdef sun
+        // for SPARC processors: wchar_t* buffers must always be alligned, otherwise it's a char* buffer.
+        if ((((unsigned long)b)%sizeof(wchar_t))!=0) return FALSE;
+#endif
+        const wchar_t *s=(const wchar_t*)b;
+
+        // buffer too small:
+        if (len<(int)sizeof(wchar_t)) return FALSE;
+
+        // odd length test
+        if (len&1) return FALSE;
+
+        /* only checks the first 256 characters */
+        len=mmin(256,len/sizeof(wchar_t));
+
+        // Check for the special byte order:
+        if (*((unsigned short*)s) == 0xFFFE) return TRUE;     // IS_TEXT_UNICODE_REVERSE_SIGNATURE;
+        if (*((unsigned short*)s) == 0xFEFF) return TRUE;      // IS_TEXT_UNICODE_SIGNATURE
+
+        // checks for ASCII characters in the UNICODE stream
+        int i,stats=0;
+        for (i=0; i<len; i++) if (s[i]<=(unsigned short)255) stats++;
+        if (stats>len/2) return TRUE;
+
+        // Check for UNICODE NULL chars
+        for (i=0; i<len; i++) if (!s[i]) return TRUE;
+
+        return FALSE;
+    }
+    #else
+    char myIsTextWideChar(const void *b,int l) { return (char)IsTextUnicode((CONST LPVOID)b,l,NULL); }
+    #endif
+#endif
+
+#ifdef _XMLWINDOWS
+// for Microsoft Visual Studio 6.0 and Microsoft Visual Studio .NET and Borland C++ Builder 6.0
+    #ifdef _XMLWIDECHAR
+        wchar_t *myMultiByteToWideChar(const char *s, XMLNode::XMLCharEncoding ce)
+        {
+            int i;
+            if (ce==XMLNode::char_encoding_UTF8) i=(int)MultiByteToWideChar(CP_UTF8,0             ,s,-1,NULL,0);
+            else                            i=(int)MultiByteToWideChar(CP_ACP ,MB_PRECOMPOSED,s,-1,NULL,0);
+            if (i<0) return NULL;
+            wchar_t *d=(wchar_t *)malloc((i+1)*sizeof(XMLCHAR));
+            if (ce==XMLNode::char_encoding_UTF8) i=(int)MultiByteToWideChar(CP_UTF8,0             ,s,-1,d,i);
+            else                            i=(int)MultiByteToWideChar(CP_ACP ,MB_PRECOMPOSED,s,-1,d,i);
+            d[i]=0;
+            return d;
+        }
+        static inline FILE *xfopen(XMLCSTR filename,XMLCSTR mode) { return _wfopen(filename,mode); }
+        static inline int xstrlen(XMLCSTR c)   { return (int)wcslen(c); }
+        static inline int xstrnicmp(XMLCSTR c1, XMLCSTR c2, int l) { return _wcsnicmp(c1,c2,l);}
+        static inline int xstrncmp(XMLCSTR c1, XMLCSTR c2, int l) { return wcsncmp(c1,c2,l);}
+        static inline int xstricmp(XMLCSTR c1, XMLCSTR c2) { return _wcsicmp(c1,c2); }
+        static inline XMLSTR xstrstr(XMLCSTR c1, XMLCSTR c2) { return (XMLSTR)wcsstr(c1,c2); }
+        static inline XMLSTR xstrcpy(XMLSTR c1, XMLCSTR c2) { return (XMLSTR)wcscpy(c1,c2); }
+    #else
+        char *myWideCharToMultiByte(const wchar_t *s)
+        {
+            UINT codePage=CP_ACP; if (characterEncoding==XMLNode::char_encoding_UTF8) codePage=CP_UTF8;
+            int i=(int)WideCharToMultiByte(codePage,  // code page
+                0,                       // performance and mapping flags
+                s,                       // wide-character string
+                -1,                       // number of chars in string
+                NULL,                       // buffer for new string
+                0,                       // size of buffer
+                NULL,                    // default for unmappable chars
+                NULL                     // set when default char used
+                );
+            if (i<0) return NULL;
+            char *d=(char*)malloc(i+1);
+            WideCharToMultiByte(codePage,  // code page
+                0,                       // performance and mapping flags
+                s,                       // wide-character string
+                -1,                       // number of chars in string
+                d,                       // buffer for new string
+                i,                       // size of buffer
+                NULL,                    // default for unmappable chars
+                NULL                     // set when default char used
+                );
+            d[i]=0;
+            return d;
+        }
+        static inline FILE *xfopen(XMLCSTR filename,XMLCSTR mode) { return fopen(filename,mode); }
+        static inline int xstrlen(XMLCSTR c)   { return (int)strlen(c); }
+        #ifdef __BORLANDC__
+            static inline int xstrnicmp(XMLCSTR c1, XMLCSTR c2, int l) { return strnicmp(c1,c2,l);}
+            static inline int xstricmp(XMLCSTR c1, XMLCSTR c2) { return stricmp(c1,c2); }
+        #else
+            static inline int xstrnicmp(XMLCSTR c1, XMLCSTR c2, int l) { return _strnicmp(c1,c2,l);}
+            static inline int xstricmp(XMLCSTR c1, XMLCSTR c2) { return _stricmp(c1,c2); }
+        #endif
+        static inline int xstrncmp(XMLCSTR c1, XMLCSTR c2, int l) { return strncmp(c1,c2,l);}
+        static inline XMLSTR xstrstr(XMLCSTR c1, XMLCSTR c2) { return (XMLSTR)strstr(c1,c2); }
+        static inline XMLSTR xstrcpy(XMLSTR c1, XMLCSTR c2) { return (XMLSTR)strcpy(c1,c2); }
+    #endif
+#else
+// for gcc and CC
+    #ifdef XML_NO_WIDE_CHAR
+        char *myWideCharToMultiByte(const wchar_t *s) { return NULL; }
+    #else
+        char *myWideCharToMultiByte(const wchar_t *s)
+        {
+            const wchar_t *ss=s;
+            int i=(int)wcsrtombs(NULL,&ss,0,NULL);
+            if (i<0) return NULL;
+            char *d=(char *)malloc(i+1);
+            wcsrtombs(d,&s,i,NULL);
+            d[i]=0;
+            return d;
+        }
+    #endif
+    #ifdef _XMLWIDECHAR
+        wchar_t *myMultiByteToWideChar(const char *s, XMLNode::XMLCharEncoding ce)
+        {
+            const char *ss=s;
+            int i=(int)mbsrtowcs(NULL,&ss,0,NULL);
+            if (i<0) return NULL;
+            wchar_t *d=(wchar_t *)malloc((i+1)*sizeof(wchar_t));
+            mbsrtowcs(d,&s,i,NULL);
+            d[i]=0;
+            return d;
+        }
+        int xstrlen(XMLCSTR c)   { return wcslen(c); }
+        #ifdef sun
+        // for CC
+           #include <widec.h>
+           static inline int xstrnicmp(XMLCSTR c1, XMLCSTR c2, int l) { return wsncasecmp(c1,c2,l);}
+           static inline int xstrncmp(XMLCSTR c1, XMLCSTR c2, int l) { return wsncmp(c1,c2,l);}
+           static inline int xstricmp(XMLCSTR c1, XMLCSTR c2) { return wscasecmp(c1,c2); }
+        #else
+        static inline int xstrncmp(XMLCSTR c1, XMLCSTR c2, int l) { return wcsncmp(c1,c2,l);}
+            #ifdef __linux__
+            // for gcc/linux
+            static inline int xstrnicmp(XMLCSTR c1, XMLCSTR c2, int l) { return wcsncasecmp(c1,c2,l);}
+            static inline int xstricmp(XMLCSTR c1, XMLCSTR c2) { return wcscasecmp(c1,c2); }
+            #else
+            #include <wctype.h>
+            // for gcc/non-linux (MacOS X 10.3, FreeBSD 6.0, NetBSD 3.0, OpenBSD 3.8, AIX 4.3.2, HP-UX 11, IRIX 6.5, OSF/1 5.1, Cygwin, mingw)
+            static inline int xstricmp(XMLCSTR c1, XMLCSTR c2)
+            {
+                wchar_t left,right;
+                do
+                {
+                    left=towlower(*c1++); right=towlower(*c2++);
+                } while (left&&(left==right));
+                return (int)left-(int)right;
+            }
+            static inline int xstrnicmp(XMLCSTR c1, XMLCSTR c2, int l)
+            {
+                wchar_t left,right;
+                while(l--)
+                {
+                    left=towlower(*c1++); right=towlower(*c2++);
+                    if ((!left)||(left!=right)) return (int)left-(int)right;
+                }
+                return 0;
+            }
+            #endif
+        #endif
+        static inline XMLSTR xstrstr(XMLCSTR c1, XMLCSTR c2) { return (XMLSTR)wcsstr(c1,c2); }
+        static inline XMLSTR xstrcpy(XMLSTR c1, XMLCSTR c2) { return (XMLSTR)wcscpy(c1,c2); }
+        static inline FILE *xfopen(XMLCSTR filename,XMLCSTR mode)
+        {
+            char *filenameAscii=myWideCharToMultiByte(filename);
+            FILE *f;
+            if (mode[0]==_CXML('r')) f=fopen(filenameAscii,"rb");
+            else                     f=fopen(filenameAscii,"wb");
+            free(filenameAscii);
+            return f;
+        }
+    #else
+        static inline FILE *xfopen(XMLCSTR filename,XMLCSTR mode) { return fopen(filename,mode); }
+        static inline int xstrlen(XMLCSTR c)   { return strlen(c); }
+        static inline int xstrnicmp(XMLCSTR c1, XMLCSTR c2, int l) { return strncasecmp(c1,c2,l);}
+        static inline int xstrncmp(XMLCSTR c1, XMLCSTR c2, int l) { return strncmp(c1,c2,l);}
+        static inline int xstricmp(XMLCSTR c1, XMLCSTR c2) { return strcasecmp(c1,c2); }
+        static inline XMLSTR xstrstr(XMLCSTR c1, XMLCSTR c2) { return (XMLSTR)strstr(c1,c2); }
+        static inline XMLSTR xstrcpy(XMLSTR c1, XMLCSTR c2) { return (XMLSTR)strcpy(c1,c2); }
+    #endif
+    static inline int _strnicmp(const char *c1,const char *c2, int l) { return strncasecmp(c1,c2,l);}
+#endif
+
+
+///////////////////////////////////////////////////////////////////////////////
+//            the "xmltoc,xmltob,xmltoi,xmltol,xmltof,xmltoa" functions      //
+///////////////////////////////////////////////////////////////////////////////
+// These 6 functions are not used inside the XMLparser.
+// There are only here as "convenience" functions for the user.
+// If you don't need them, you can delete them without any trouble.
+#ifdef _XMLWIDECHAR
+    #ifdef _XMLWINDOWS
+    // for Microsoft Visual Studio 6.0 and Microsoft Visual Studio .NET and Borland C++ Builder 6.0
+        char    xmltob(XMLCSTR t,char    v){ if (t&&(*t)) return (char)_wtoi(t); return v; }
+        int     xmltoi(XMLCSTR t,int     v){ if (t&&(*t)) return _wtoi(t); return v; }
+        long    xmltol(XMLCSTR t,long    v){ if (t&&(*t)) return _wtol(t); return v; }
+        double  xmltof(XMLCSTR t,double  v){ if (t&&(*t)) swscanf(t, L"%lf", &v); /*v=_wtof(t);*/ return v; }
+    #else
+        #ifdef sun
+        // for CC
+           #include <widec.h>
+           char    xmltob(XMLCSTR t,char    v){ if (t) return (char)wstol(t,NULL,10); return v; }
+           int     xmltoi(XMLCSTR t,int     v){ if (t) return (int)wstol(t,NULL,10); return v; }
+           long    xmltol(XMLCSTR t,long    v){ if (t) return wstol(t,NULL,10); return v; }
+        #else
+        // for gcc
+           char    xmltob(XMLCSTR t,char    v){ if (t) return (char)wcstol(t,NULL,10); return v; }
+           int     xmltoi(XMLCSTR t,int     v){ if (t) return (int)wcstol(t,NULL,10); return v; }
+           long    xmltol(XMLCSTR t,long    v){ if (t) return wcstol(t,NULL,10); return v; }
+        #endif
+		double  xmltof(XMLCSTR t,double  v){ if (t&&(*t)) swscanf(t, L"%lf", &v); /*v=_wtof(t);*/ return v; }
+    #endif
+#else
+    char    xmltob(XMLCSTR t,char    v){ if (t&&(*t)) return (char)atoi(t); return v; }
+    int     xmltoi(XMLCSTR t,int     v){ if (t&&(*t)) return atoi(t); return v; }
+    long    xmltol(XMLCSTR t,long    v){ if (t&&(*t)) return atol(t); return v; }
+    double  xmltof(XMLCSTR t,double  v){ if (t&&(*t)) return atof(t); return v; }
+#endif
+XMLCSTR xmltoa(XMLCSTR t,      XMLCSTR v){ if (t)       return  t; return v; }
+XMLCHAR xmltoc(XMLCSTR t,const XMLCHAR v){ if (t&&(*t)) return *t; return v; }
+
+/////////////////////////////////////////////////////////////////////////
+//                    the "openFileHelper" function                    //
+/////////////////////////////////////////////////////////////////////////
+
+// Since each application has its own way to report and deal with errors, you should modify & rewrite
+// the following "openFileHelper" function to get an "error reporting mechanism" tailored to your needs.
+XMLNode XMLNode::openFileHelper(XMLCSTR filename, XMLCSTR tag)
+{
+    // guess the value of the global parameter "characterEncoding"
+    // (the guess is based on the first 200 bytes of the file).
+    FILE *f=xfopen(filename,_CXML("rb"));
+    if (f)
+    {
+        char bb[205];
+        int l=(int)fread(bb,1,200,f);
+        setGlobalOptions(guessCharEncoding(bb,l),guessWideCharChars,dropWhiteSpace,removeCommentsInMiddleOfText);
+        fclose(f);
+    }
+
+    // parse the file
+    XMLResults pResults;
+    XMLNode xnode=XMLNode::parseFile(filename,tag,&pResults);
+
+    // display error message (if any)
+    if (pResults.error != eXMLErrorNone)
+    {
+        // create message
+        char message[2000],*s1=(char*)"",*s3=(char*)""; XMLCSTR s2=_CXML("");
+        if (pResults.error==eXMLErrorFirstTagNotFound) { s1=(char*)"First Tag should be '"; s2=tag; s3=(char*)"'.\n"; }
+        sprintf(message,
+#ifdef _XMLWIDECHAR
+            "XML Parsing error inside file '%S'.\n%S\nAt line %i, column %i.\n%s%S%s"
+#else
+            "XML Parsing error inside file '%s'.\n%s\nAt line %i, column %i.\n%s%s%s"
+#endif
+            ,filename,XMLNode::getError(pResults.error),pResults.nLine,pResults.nColumn,s1,s2,s3);
+
+        // display message
+#if defined(_XMLWINDOWS) && !defined(UNDER_CE) && !defined(_XMLPARSER_NO_MESSAGEBOX_)
+        MessageBoxA(NULL,message,"XML Parsing error",MB_OK|MB_ICONERROR|MB_TOPMOST);
+#else
+        printf("%s",message);
+#endif
+        exit(255);
+    }
+    return xnode;
+}
+
+/////////////////////////////////////////////////////////////////////////
+//      Here start the core implementation of the XMLParser library    //
+/////////////////////////////////////////////////////////////////////////
+
+// You should normally not change anything below this point.
+
+#ifndef _XMLWIDECHAR
+// If "characterEncoding=ascii" then we assume that all characters have the same length of 1 byte.
+// If "characterEncoding=UTF8" then the characters have different lengths (from 1 byte to 4 bytes).
+// If "characterEncoding=ShiftJIS" then the characters have different lengths (from 1 byte to 2 bytes).
+// This table is used as lookup-table to know the length of a character (in byte) based on the
+// content of the first byte of the character.
+// (note: if you modify this, you must always have XML_utf8ByteTable[0]=0 ).
+static const char XML_utf8ByteTable[256] =
+{
+    //  0 1 2 3 4 5 6 7 8 9 a b c d e f
+    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x00
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x10
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x20
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x30
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x40
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x50
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x60
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x70 End of ASCII range
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x80 0x80 to 0xc1 invalid
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x90
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0xa0
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0xb0
+    1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,// 0xc0 0xc2 to 0xdf 2 byte
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,// 0xd0
+    3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,// 0xe0 0xe0 to 0xef 3 byte
+    4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1 // 0xf0 0xf0 to 0xf4 4 byte, 0xf5 and higher invalid
+};
+static const char XML_legacyByteTable[256] =
+{
+    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
+};
+static const char XML_sjisByteTable[256] =
+{
+    //  0 1 2 3 4 5 6 7 8 9 a b c d e f
+    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x00
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x10
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x20
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x30
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x40
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x50
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x60
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x70
+    1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,// 0x80 0x81 to 0x9F 2 bytes
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,// 0x90
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0xa0
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0xb0
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0xc0
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0xd0
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,// 0xe0 0xe0 to 0xef 2 bytes
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 // 0xf0
+};
+static const char XML_gb2312ByteTable[256] =
+{
+//  0 1 2 3 4 5 6 7 8 9 a b c d e f
+    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x00
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x10
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x20
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x30
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x40
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x50
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x60
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x70
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x80
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x90
+    1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,// 0xa0 0xa1 to 0xf7 2 bytes
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,// 0xb0
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,// 0xc0
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,// 0xd0
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,// 0xe0
+    2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1 // 0xf0
+};
+static const char XML_gbk_big5_ByteTable[256] =
+{
+    //  0 1 2 3 4 5 6 7 8 9 a b c d e f
+    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x00
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x10
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x20
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x30
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x40
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x50
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x60
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,// 0x70
+    1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,// 0x80 0x81 to 0xfe 2 bytes
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,// 0x90
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,// 0xa0
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,// 0xb0
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,// 0xc0
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,// 0xd0
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,// 0xe0
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1 // 0xf0
+};
+static const char *XML_ByteTable=(const char *)XML_utf8ByteTable; // the default is "characterEncoding=XMLNode::encoding_UTF8"
+#endif
+
+
+XMLNode XMLNode::emptyXMLNode;
+XMLClear XMLNode::emptyXMLClear={ NULL, NULL, NULL};
+XMLAttribute XMLNode::emptyXMLAttribute={ NULL, NULL};
+
+// Enumeration used to decipher what type a token is
+typedef enum XMLTokenTypeTag
+{
+    eTokenText = 0,
+    eTokenQuotedText,
+    eTokenTagStart,         /* "<"            */
+    eTokenTagEnd,           /* "</"           */
+    eTokenCloseTag,         /* ">"            */
+    eTokenEquals,           /* "="            */
+    eTokenDeclaration,      /* "<?"           */
+    eTokenShortHandClose,   /* "/>"           */
+    eTokenClear,
+    eTokenError
+} XMLTokenType;
+
+// Main structure used for parsing XML
+typedef struct XML
+{
+    XMLCSTR                lpXML;
+    XMLCSTR                lpszText;
+    int                    nIndex,nIndexMissigEndTag;
+    enum XMLError          error;
+    XMLCSTR                lpEndTag;
+    int                    cbEndTag;
+    XMLCSTR                lpNewElement;
+    int                    cbNewElement;
+    int                    nFirst;
+} XML;
+
+typedef struct
+{
+    ALLXMLClearTag *pClr;
+    XMLCSTR     pStr;
+} NextToken;
+
+// Enumeration used when parsing attributes
+typedef enum Attrib
+{
+    eAttribName = 0,
+    eAttribEquals,
+    eAttribValue
+} Attrib;
+
+// Enumeration used when parsing elements to dictate whether we are currently
+// inside a tag
+typedef enum XMLStatus
+{
+    eInsideTag = 0,
+    eOutsideTag
+} XMLStatus;
+
+XMLError XMLNode::writeToFile(XMLCSTR filename, const char *encoding, char nFormat) const
+{
+    if (!d) return eXMLErrorNone;
+    FILE *f=xfopen(filename,_CXML("wb"));
+    if (!f) return eXMLErrorCannotOpenWriteFile;
+#ifdef _XMLWIDECHAR
+    unsigned char h[2]={ 0xFF, 0xFE };
+    if (!fwrite(h,2,1,f)) 
+    {
+    	fclose(f);
+    	return eXMLErrorCannotWriteFile;
+    }
+    if ((!isDeclaration())&&((d->lpszName)||(!getChildNode().isDeclaration())))
+    {
+        if (!fwrite(L"<?xml version=\"1.0\" encoding=\"utf-16\"?>\n",sizeof(wchar_t)*40,1,f))
+        {
+        	fclose(f);
+            return eXMLErrorCannotWriteFile;
+        }
+    }
+#else
+    if ((!isDeclaration())&&((d->lpszName)||(!getChildNode().isDeclaration())))
+    {
+        if (characterEncoding==char_encoding_UTF8)
+        {
+            // header so that windows recognize the file as UTF-8:
+            unsigned char h[3]={0xEF,0xBB,0xBF}; 
+            if (!fwrite(h,3,1,f)) 
+            {
+            	fclose(f);
+                return eXMLErrorCannotWriteFile;
+            }
+            encoding="utf-8";
+        } else if (characterEncoding==char_encoding_ShiftJIS) encoding="SHIFT-JIS";
+
+        if (!encoding) encoding="ISO-8859-1";
+        if (fprintf(f,"<?xml version=\"1.0\" encoding=\"%s\"?>\n",encoding)<0) 
+        {
+        	fclose(f);
+            return eXMLErrorCannotWriteFile;
+        }
+    } else
+    {
+        if (characterEncoding==char_encoding_UTF8)
+        {
+            unsigned char h[3]={0xEF,0xBB,0xBF}; 
+            if (!fwrite(h,3,1,f)) 
+            {
+            	fclose(f);
+                return eXMLErrorCannotWriteFile;
+            }
+        }
+    }
+#endif
+    int i;
+    XMLSTR t=createXMLString(nFormat,&i);
+    if (!fwrite(t,sizeof(XMLCHAR)*i,1,f)) 
+    {
+       free(t);
+       fclose(f);
+       return eXMLErrorCannotWriteFile;
+    }
+    if (fclose(f)!=0) 
+    {
+   	    free(t);
+        return eXMLErrorCannotWriteFile;
+    }
+    free(t);
+    return eXMLErrorNone;
+}
+
+// Duplicate a given string.
+XMLSTR stringDup(XMLCSTR lpszData, int cbData)
+{
+    if (lpszData==NULL) return NULL;
+
+    XMLSTR lpszNew;
+    if (cbData==-1) cbData=(int)xstrlen(lpszData);
+    lpszNew = (XMLSTR)malloc((cbData+1) * sizeof(XMLCHAR));
+    if (lpszNew)
+    {
+        memcpy(lpszNew, lpszData, (cbData) * sizeof(XMLCHAR));
+        lpszNew[cbData] = (XMLCHAR)NULL;
+    }
+    return lpszNew;
+}
+
+XMLSTR ToXMLStringTool::toXMLUnSafe(XMLSTR dest,XMLCSTR source)
+{
+    XMLSTR dd=dest;
+    XMLCHAR ch;
+    XMLCharacterEntity *entity;
+    while ((ch=*source))
+    {
+        entity=XMLEntities;
+        do
+        {
+            if (ch==entity->c) {xstrcpy(dest,entity->s); dest+=entity->l; source++; goto out_of_loop1; }
+            entity++;
+        } while(entity->s);
+#ifdef _XMLWIDECHAR
+        *(dest++)=*(source++);
+#else
+        switch(XML_ByteTable[(unsigned char)ch])
+        {
+        case 4: *(dest++)=*(source++);
+        case 3: *(dest++)=*(source++);
+        case 2: *(dest++)=*(source++);
+        case 1: *(dest++)=*(source++);
+        }
+#endif
+out_of_loop1:
+        ;
+    }
+    *dest=0;
+    return dd;
+}
+
+// private (used while rendering):
+int ToXMLStringTool::lengthXMLString(XMLCSTR source)
+{
+    int r=0;
+    XMLCharacterEntity *entity;
+    XMLCHAR ch;
+    while ((ch=*source))
+    {
+        entity=XMLEntities;
+        do
+        {
+            if (ch==entity->c) { r+=entity->l; source++; goto out_of_loop1; }
+            entity++;
+        } while(entity->s);
+#ifdef _XMLWIDECHAR
+        r++; source++;
+#else
+        ch=XML_ByteTable[(unsigned char)ch]; r+=ch; source+=ch;
+#endif
+out_of_loop1:
+        ;
+    }
+    return r;
+}
+
+ToXMLStringTool::~ToXMLStringTool(){ freeBuffer(); }
+void ToXMLStringTool::freeBuffer(){ if (buf) free(buf); buf=NULL; buflen=0; }
+XMLSTR ToXMLStringTool::toXML(XMLCSTR source)
+{
+    if (!source)
+    {
+		if (buflen<1) { buflen=1; buf=(XMLSTR)malloc(sizeof(XMLCHAR)); }
+		*buf=0;
+		return buf;
+	}
+    int l=lengthXMLString(source)+1;
+    if (l>buflen) { freeBuffer(); buflen=l; buf=(XMLSTR)malloc(l*sizeof(XMLCHAR)); }
+    return toXMLUnSafe(buf,source);
+}
+
+// private:
+XMLSTR fromXMLString(XMLCSTR s, int lo, XML *pXML)
+{
+    // This function is the opposite of the function "toXMLString". It decodes the escape
+    // sequences &amp;, &quot;, &apos;, &lt;, &gt; and replace them by the characters
+    // &,",',<,>. This function is used internally by the XML Parser. All the calls to
+    // the XML library will always gives you back "decoded" strings.
+    //
+    // in: string (s) and length (lo) of string
+    // out:  new allocated string converted from xml
+    if (!s) return NULL;
+
+    int ll=0,j;
+    XMLSTR d;
+    XMLCSTR ss=s;
+    XMLCharacterEntity *entity;
+    while ((lo>0)&&(*s))
+    {
+        if (*s==_CXML('&'))
+        {
+            if ((lo>2)&&(s[1]==_CXML('#')))
+            {
+                s+=2; lo-=2;
+                if ((*s==_CXML('X'))||(*s==_CXML('x'))) { s++; lo--; }
+                while ((*s)&&(*s!=_CXML(';'))&&((lo--)>0)) s++;
+                if (*s!=_CXML(';'))
+                {
+                    pXML->error=eXMLErrorUnknownCharacterEntity;
+                    return NULL;
+                }
+                s++; lo--;
+            } else
+            {
+                entity=XMLEntities;
+                do
+                {
+                    if ((lo>=entity->l)&&(xstrnicmp(s,entity->s,entity->l)==0)) { s+=entity->l; lo-=entity->l; break; }
+                    entity++;
+                } while(entity->s);
+                if (!entity->s)
+                {
+                    pXML->error=eXMLErrorUnknownCharacterEntity;
+                    return NULL;
+                }
+            }
+        } else
+        {
+#ifdef _XMLWIDECHAR
+            s++; lo--;
+#else
+            j=XML_ByteTable[(unsigned char)*s]; s+=j; lo-=j; ll+=j-1;
+#endif
+        }
+        ll++;
+    }
+
+    d=(XMLSTR)malloc((ll+1)*sizeof(XMLCHAR));
+    s=d;
+    while (ll-->0)
+    {
+        if (*ss==_CXML('&'))
+        {
+            if (ss[1]==_CXML('#'))
+            {
+                ss+=2; j=0;
+                if ((*ss==_CXML('X'))||(*ss==_CXML('x')))
+                {
+                    ss++;
+                    while (*ss!=_CXML(';'))
+                    {
+                        if ((*ss>=_CXML('0'))&&(*ss<=_CXML('9'))) j=(j<<4)+*ss-_CXML('0');
+                        else if ((*ss>=_CXML('A'))&&(*ss<=_CXML('F'))) j=(j<<4)+*ss-_CXML('A')+10;
+                        else if ((*ss>=_CXML('a'))&&(*ss<=_CXML('f'))) j=(j<<4)+*ss-_CXML('a')+10;
+                        else { free((void*)s); pXML->error=eXMLErrorUnknownCharacterEntity;return NULL;}
+                        ss++;
+                    }
+                } else
+                {
+                    while (*ss!=_CXML(';'))
+                    {
+                        if ((*ss>=_CXML('0'))&&(*ss<=_CXML('9'))) j=(j*10)+*ss-_CXML('0');
+                        else { free((void*)s); pXML->error=eXMLErrorUnknownCharacterEntity;return NULL;}
+                        ss++;
+                    }
+                }
+#ifndef _XMLWIDECHAR
+                if (j>255) { free((void*)s); pXML->error=eXMLErrorCharacterCodeAbove255;return NULL;}
+#endif
+                (*d++)=(XMLCHAR)j; ss++;
+            } else
+            {
+                entity=XMLEntities;
+                do
+                {
+                    if (xstrnicmp(ss,entity->s,entity->l)==0) { *(d++)=entity->c; ss+=entity->l; break; }
+                    entity++;
+                } while(entity->s);
+            }
+        } else
+        {
+#ifdef _XMLWIDECHAR
+            *(d++)=*(ss++);
+#else
+            switch(XML_ByteTable[(unsigned char)*ss])
+            {
+            case 4: *(d++)=*(ss++); ll--;
+            case 3: *(d++)=*(ss++); ll--;
+            case 2: *(d++)=*(ss++); ll--;
+            case 1: *(d++)=*(ss++);
+            }
+#endif
+        }
+    }
+    *d=0;
+    return (XMLSTR)s;
+}
+
+#define XML_isSPACECHAR(ch) ((ch==_CXML('\n'))||(ch==_CXML(' '))||(ch== _CXML('\t'))||(ch==_CXML('\r')))
+
+// private:
+char myTagCompare(XMLCSTR cclose, XMLCSTR copen)
+// !!!! WARNING strange convention&:
+// return 0 if equals
+// return 1 if different
+{
+    if (!cclose) return 1;
+    int l=(int)xstrlen(cclose);
+    if (xstrnicmp(cclose, copen, l)!=0) return 1;
+    const XMLCHAR c=copen[l];
+    if (XML_isSPACECHAR(c)||
+        (c==_CXML('/' ))||
+        (c==_CXML('<' ))||
+        (c==_CXML('>' ))||
+        (c==_CXML('=' ))) return 0;
+    return 1;
+}
+
+// Obtain the next character from the string.
+static inline XMLCHAR getNextChar(XML *pXML)
+{
+    XMLCHAR ch = pXML->lpXML[pXML->nIndex];
+#ifdef _XMLWIDECHAR
+    if (ch!=0) pXML->nIndex++;
+#else
+    pXML->nIndex+=XML_ByteTable[(unsigned char)ch];
+#endif
+    return ch;
+}
+
+// Find the next token in a string.
+// pcbToken contains the number of characters that have been read.
+static NextToken GetNextToken(XML *pXML, int *pcbToken, enum XMLTokenTypeTag *pType)
+{
+    NextToken        result;
+    XMLCHAR            ch;
+    XMLCHAR            chTemp;
+    int              indexStart,nFoundMatch,nIsText=FALSE;
+    result.pClr=NULL; // prevent warning
+
+    // Find next non-white space character
+    do { indexStart=pXML->nIndex; ch=getNextChar(pXML); } while XML_isSPACECHAR(ch);
+
+    if (ch)
+    {
+        // Cache the current string pointer
+        result.pStr = &pXML->lpXML[indexStart];
+
+        // check for standard tokens
+        switch(ch)
+        {
+        // Check for quotes
+        case _CXML('\''):
+        case _CXML('\"'):
+            // Type of token
+            *pType = eTokenQuotedText;
+            chTemp = ch;
+
+            // Set the size
+            nFoundMatch = FALSE;
+
+            // Search through the string to find a matching quote
+            while((ch = getNextChar(pXML)))
+            {
+                if (ch==chTemp) { nFoundMatch = TRUE; break; }
+                if (ch==_CXML('<')) break;
+            }
+
+            // If we failed to find a matching quote
+            if (nFoundMatch == FALSE)
+            {
+                pXML->nIndex=indexStart+1;
+                nIsText=TRUE;
+                break;
+            }
+
+//  4.02.2002
+//            if (FindNonWhiteSpace(pXML)) pXML->nIndex--;
+
+            break;
+
+        // Equals (used with attribute values)
+        case _CXML('='):
+            *pType = eTokenEquals;
+            break;
+
+        // Close tag
+        case _CXML('>'):
+            *pType = eTokenCloseTag;
+            break;
+
+        // Check for tag start and tag end
+        case _CXML('<'):
+
+			{
+				// First check whether the token is in the clear tag list (meaning it
+				// does not need formatting).
+				ALLXMLClearTag *ctag=XMLClearTags;
+				do
+				{
+				   if (!xstrncmp(ctag->lpszOpen, result.pStr, ctag->openTagLen))
+				   {
+						result.pClr=ctag;
+						pXML->nIndex+=ctag->openTagLen-1;
+						*pType=eTokenClear;
+						return result;
+					}
+					ctag++;
+				} while(ctag->lpszOpen);
+
+				// Peek at the next character to see if we have an end tag '</',
+				// or an xml declaration '<?'
+				chTemp = pXML->lpXML[pXML->nIndex];
+
+				// If we have a tag end...
+				if (chTemp == _CXML('/'))
+				{
+					// Set the type and ensure we point at the next character
+					getNextChar(pXML);
+					*pType = eTokenTagEnd;
+				}
+
+				// If we have an XML declaration tag
+				else if (chTemp == _CXML('?'))
+				{
+
+					// Set the type and ensure we point at the next character
+					getNextChar(pXML);
+					*pType = eTokenDeclaration;
+				}
+
+				// Otherwise we must have a start tag
+				else
+				{
+					*pType = eTokenTagStart;
+				}
+				break;
+			}
+
+        // Check to see if we have a short hand type end tag ('/>').
+        case _CXML('/'):
+
+            // Peek at the next character to see if we have a short end tag '/>'
+            chTemp = pXML->lpXML[pXML->nIndex];
+
+            // If we have a short hand end tag...
+            if (chTemp == _CXML('>'))
+            {
+                // Set the type and ensure we point at the next character
+                getNextChar(pXML);
+                *pType = eTokenShortHandClose;
+                break;
+            }
+
+            // If we haven't found a short hand closing tag then drop into the
+            // text process
+
+        // Other characters
+        default:
+            nIsText = TRUE;
+        }
+
+        // If this is a TEXT node
+        if (nIsText)
+        {
+            // Indicate we are dealing with text
+            *pType = eTokenText;
+            while((ch = getNextChar(pXML)))
+            {
+                if XML_isSPACECHAR(ch)
+                {
+                    indexStart++; break;
+
+                } else if (ch==_CXML('/'))
+                {
+                    // If we find a slash then this maybe text or a short hand end tag
+                    // Peek at the next character to see it we have short hand end tag
+                    ch=pXML->lpXML[pXML->nIndex];
+                    // If we found a short hand end tag then we need to exit the loop
+                    if (ch==_CXML('>')) { pXML->nIndex--; break; }
+
+                } else if ((ch==_CXML('<'))||(ch==_CXML('>'))||(ch==_CXML('=')))
+                {
+                    pXML->nIndex--; break;
+                }
+            }
+        }
+        *pcbToken = pXML->nIndex-indexStart;
+    } else
+    {
+        // If we failed to obtain a valid character
+        *pcbToken = 0;
+        *pType = eTokenError;
+        result.pStr=NULL;
+    }
+
+    return result;
+}
+
+XMLCSTR XMLNode::updateName_WOSD(XMLSTR lpszName)
+{
+    if (!d) { free(lpszName); return NULL; }
+    if (d->lpszName&&(lpszName!=d->lpszName)) free((void*)d->lpszName);
+    d->lpszName=lpszName;
+    return lpszName;
+}
+
+// private:
+XMLNode::XMLNode(struct XMLNodeDataTag *p){ d=p; (p->ref_count)++; }
+XMLNode::XMLNode(XMLNodeData *pParent, XMLSTR lpszName, char isDeclaration)
+{
+    d=(XMLNodeData*)malloc(sizeof(XMLNodeData));
+    d->ref_count=1;
+
+    d->lpszName=NULL;
+    d->nChild= 0;
+    d->nText = 0;
+    d->nClear = 0;
+    d->nAttribute = 0;
+
+    d->isDeclaration = isDeclaration;
+
+    d->pParent = pParent;
+    d->pChild= NULL;
+    d->pText= NULL;
+    d->pClear= NULL;
+    d->pAttribute= NULL;
+    d->pOrder= NULL;
+
+    updateName_WOSD(lpszName);
+}
+
+XMLNode XMLNode::createXMLTopNode_WOSD(XMLSTR lpszName, char isDeclaration) { return XMLNode(NULL,lpszName,isDeclaration); }
+XMLNode XMLNode::createXMLTopNode(XMLCSTR lpszName, char isDeclaration) { return XMLNode(NULL,stringDup(lpszName),isDeclaration); }
+
+#define MEMORYINCREASE 50
+
+static inline void myFree(void *p) { if (p) free(p); }
+static inline void *myRealloc(void *p, int newsize, int memInc, int sizeofElem)
+{
+    if (p==NULL) { if (memInc) return malloc(memInc*sizeofElem); return malloc(sizeofElem); }
+    if ((memInc==0)||((newsize%memInc)==0)) p=realloc(p,(newsize+memInc)*sizeofElem);
+//    if (!p)
+//    {
+//        printf("XMLParser Error: Not enough memory! Aborting...\n"); exit(220);
+//    }
+    return p;
+}
+
+// private:
+XMLElementPosition XMLNode::findPosition(XMLNodeData *d, int index, XMLElementType xxtype)
+{
+    if (index<0) return -1;
+    int i=0,j=(int)((index<<2)+xxtype),*o=d->pOrder; while (o[i]!=j) i++; return i;
+}
+
+// private:
+// update "order" information when deleting a content of a XMLNode
+int XMLNode::removeOrderElement(XMLNodeData *d, XMLElementType t, int index)
+{
+    int n=d->nChild+d->nText+d->nClear, *o=d->pOrder,i=findPosition(d,index,t);
+    memmove(o+i, o+i+1, (n-i)*sizeof(int));
+    for (;i<n;i++)
+        if ((o[i]&3)==(int)t) o[i]-=4;
+    // We should normally do:
+    // d->pOrder=(int)realloc(d->pOrder,n*sizeof(int));
+    // but we skip reallocation because it's too time consuming.
+    // Anyway, at the end, it will be free'd completely at once.
+    return i;
+}
+
+void *XMLNode::addToOrder(int memoryIncrease,int *_pos, int nc, void *p, int size, XMLElementType xtype)
+{
+    //  in: *_pos is the position inside d->pOrder ("-1" means "EndOf")
+    // out: *_pos is the index inside p
+    p=myRealloc(p,(nc+1),memoryIncrease,size);
+    int n=d->nChild+d->nText+d->nClear;
+    d->pOrder=(int*)myRealloc(d->pOrder,n+1,memoryIncrease*3,sizeof(int));
+    int pos=*_pos,*o=d->pOrder;
+
+    if ((pos<0)||(pos>=n)) { *_pos=nc; o[n]=(int)((nc<<2)+xtype); return p; }
+
+    int i=pos;
+    memmove(o+i+1, o+i, (n-i)*sizeof(int));
+
+    while ((pos<n)&&((o[pos]&3)!=(int)xtype)) pos++;
+    if (pos==n) { *_pos=nc; o[n]=(int)((nc<<2)+xtype); return p; }
+
+    o[i]=o[pos];
+    for (i=pos+1;i<=n;i++) if ((o[i]&3)==(int)xtype) o[i]+=4;
+
+    *_pos=pos=o[pos]>>2;
+    memmove(((char*)p)+(pos+1)*size,((char*)p)+pos*size,(nc-pos)*size);
+
+    return p;
+}
+
+// Add a child node to the given element.
+XMLNode XMLNode::addChild_priv(int memoryIncrease, XMLSTR lpszName, char isDeclaration, int pos)
+{
+    if (!lpszName) return emptyXMLNode;
+    d->pChild=(XMLNode*)addToOrder(memoryIncrease,&pos,d->nChild,d->pChild,sizeof(XMLNode),eNodeChild);
+    d->pChild[pos].d=NULL;
+    d->pChild[pos]=XMLNode(d,lpszName,isDeclaration);
+    d->nChild++;
+    return d->pChild[pos];
+}
+
+// Add an attribute to an element.
+XMLAttribute *XMLNode::addAttribute_priv(int memoryIncrease,XMLSTR lpszName, XMLSTR lpszValuev)
+{
+    if (!lpszName) return &emptyXMLAttribute;
+    if (!d) { myFree(lpszName); myFree(lpszValuev); return &emptyXMLAttribute; }
+    int nc=d->nAttribute;
+    d->pAttribute=(XMLAttribute*)myRealloc(d->pAttribute,(nc+1),memoryIncrease,sizeof(XMLAttribute));
+    XMLAttribute *pAttr=d->pAttribute+nc;
+    pAttr->lpszName = lpszName;
+    pAttr->lpszValue = lpszValuev;
+    d->nAttribute++;
+    return pAttr;
+}
+
+// Add text to the element.
+XMLCSTR XMLNode::addText_priv(int memoryIncrease, XMLSTR lpszValue, int pos)
+{
+    if (!lpszValue) return NULL;
+    if (!d) { myFree(lpszValue); return NULL; }
+    d->pText=(XMLCSTR*)addToOrder(memoryIncrease,&pos,d->nText,d->pText,sizeof(XMLSTR),eNodeText);
+    d->pText[pos]=lpszValue;
+    d->nText++;
+    return lpszValue;
+}
+
+// Add clear (unformatted) text to the element.
+XMLClear *XMLNode::addClear_priv(int memoryIncrease, XMLSTR lpszValue, XMLCSTR lpszOpen, XMLCSTR lpszClose, int pos)
+{
+    if (!lpszValue) return &emptyXMLClear;
+    if (!d) { myFree(lpszValue); return &emptyXMLClear; }
+    d->pClear=(XMLClear *)addToOrder(memoryIncrease,&pos,d->nClear,d->pClear,sizeof(XMLClear),eNodeClear);
+    XMLClear *pNewClear=d->pClear+pos;
+    pNewClear->lpszValue = lpszValue;
+    if (!lpszOpen) lpszOpen=XMLClearTags->lpszOpen;
+    if (!lpszClose) lpszClose=XMLClearTags->lpszClose;
+    pNewClear->lpszOpenTag = lpszOpen;
+    pNewClear->lpszCloseTag = lpszClose;
+    d->nClear++;
+    return pNewClear;
+}
+
+// private:
+// Parse a clear (unformatted) type node.
+char XMLNode::parseClearTag(void *px, void *_pClear)
+{
+    XML *pXML=(XML *)px;
+    ALLXMLClearTag pClear=*((ALLXMLClearTag*)_pClear);
+    int cbTemp=0;
+    XMLCSTR lpszTemp=NULL;
+    XMLCSTR lpXML=&pXML->lpXML[pXML->nIndex];
+    static XMLCSTR docTypeEnd=_CXML("]>");
+
+    // Find the closing tag
+    // Seems the <!DOCTYPE need a better treatment so lets handle it
+    if (pClear.lpszOpen==XMLClearTags[1].lpszOpen)
+    {
+        XMLCSTR pCh=lpXML;
+        while (*pCh)
+        {
+            if (*pCh==_CXML('<')) { pClear.lpszClose=docTypeEnd; lpszTemp=xstrstr(lpXML,docTypeEnd); break; }
+            else if (*pCh==_CXML('>')) { lpszTemp=pCh; break; }
+#ifdef _XMLWIDECHAR
+            pCh++;
+#else
+            pCh+=XML_ByteTable[(unsigned char)(*pCh)];
+#endif
+        }
+    } else lpszTemp=xstrstr(lpXML, pClear.lpszClose);
+
+    if (lpszTemp)
+    {
+        // Cache the size and increment the index
+        cbTemp = (int)(lpszTemp - lpXML);
+
+        pXML->nIndex += cbTemp+(int)xstrlen(pClear.lpszClose);
+
+        // Add the clear node to the current element
+        addClear_priv(MEMORYINCREASE,cbTemp?stringDup(lpXML,cbTemp):NULL, pClear.lpszOpen, pClear.lpszClose,-1);
+        return 0;
+    }
+
+    // If we failed to find the end tag
+    pXML->error = eXMLErrorUnmatchedEndClearTag;
+    return 1;
+}
+
+void XMLNode::exactMemory(XMLNodeData *d)
+{
+    if (d->pOrder)     d->pOrder=(int*)realloc(d->pOrder,(d->nChild+d->nText+d->nClear)*sizeof(int));
+    if (d->pChild)     d->pChild=(XMLNode*)realloc(d->pChild,d->nChild*sizeof(XMLNode));
+    if (d->pAttribute) d->pAttribute=(XMLAttribute*)realloc(d->pAttribute,d->nAttribute*sizeof(XMLAttribute));
+    if (d->pText)      d->pText=(XMLCSTR*)realloc(d->pText,d->nText*sizeof(XMLSTR));
+    if (d->pClear)     d->pClear=(XMLClear *)realloc(d->pClear,d->nClear*sizeof(XMLClear));
+}
+
+char XMLNode::maybeAddTxT(void *pa, XMLCSTR tokenPStr)
+{
+    XML *pXML=(XML *)pa;
+    XMLCSTR lpszText=pXML->lpszText;
+    if (!lpszText) return 0;
+    if (dropWhiteSpace) while (XML_isSPACECHAR(*lpszText)&&(lpszText!=tokenPStr)) lpszText++;
+    int cbText = (int)(tokenPStr - lpszText);
+    if (!cbText) { pXML->lpszText=NULL; return 0; }
+    if (dropWhiteSpace) { cbText--; while ((cbText)&&XML_isSPACECHAR(lpszText[cbText])) cbText--; cbText++; }
+    if (!cbText) { pXML->lpszText=NULL; return 0; }
+    XMLSTR lpt=fromXMLString(lpszText,cbText,pXML);
+    if (!lpt) return 1;
+    pXML->lpszText=NULL;
+    if (removeCommentsInMiddleOfText && d->nText && d->nClear)
+    {
+        // if the previous insertion was a comment (<!-- -->) AND
+        // if the previous previous insertion was a text then, delete the comment and append the text
+        int n=d->nChild+d->nText+d->nClear-1,*o=d->pOrder;
+        if (((o[n]&3)==eNodeClear)&&((o[n-1]&3)==eNodeText))
+        {
+            int i=o[n]>>2;
+            if (d->pClear[i].lpszOpenTag==XMLClearTags[2].lpszOpen)
+            {
+                deleteClear(i);
+                i=o[n-1]>>2;
+                n=xstrlen(d->pText[i]);
+                int n2=xstrlen(lpt)+1;
+                d->pText[i]=(XMLSTR)realloc((void*)d->pText[i],(n+n2)*sizeof(XMLCHAR));
+                if (!d->pText[i]) return 1;
+                memcpy((void*)(d->pText[i]+n),lpt,n2*sizeof(XMLCHAR));
+                free(lpt);
+                return 0;
+            }
+        }
+    }
+    addText_priv(MEMORYINCREASE,lpt,-1);
+    return 0;
+}
+// private:
+// Recursively parse an XML element.
+int XMLNode::ParseXMLElement(void *pa)
+{
+    XML *pXML=(XML *)pa;
+    int cbToken;
+    enum XMLTokenTypeTag xtype;
+    NextToken token;
+    XMLCSTR lpszTemp=NULL;
+    int cbTemp=0;
+    char nDeclaration;
+    XMLNode pNew;
+    enum XMLStatus status; // inside or outside a tag
+    enum Attrib attrib = eAttribName;
+
+    assert(pXML);
+
+    // If this is the first call to the function
+    if (pXML->nFirst)
+    {
+        // Assume we are outside of a tag definition
+        pXML->nFirst = FALSE;
+        status = eOutsideTag;
+    } else
+    {
+        // If this is not the first call then we should only be called when inside a tag.
+        status = eInsideTag;
+    }
+
+    // Iterate through the tokens in the document
+    for(;;)
+    {
+        // Obtain the next token
+        token = GetNextToken(pXML, &cbToken, &xtype);
+
+        if (xtype != eTokenError)
+        {
+            // Check the current status
+            switch(status)
+            {
+
+            // If we are outside of a tag definition
+            case eOutsideTag:
+
+                // Check what type of token we obtained
+                switch(xtype)
+                {
+                // If we have found text or quoted text
+                case eTokenText:
+                case eTokenCloseTag:          /* '>'         */
+                case eTokenShortHandClose:    /* '/>'        */
+                case eTokenQuotedText:
+                case eTokenEquals:
+                    break;
+
+                // If we found a start tag '<' and declarations '<?'
+                case eTokenTagStart:
+                case eTokenDeclaration:
+
+                    // Cache whether this new element is a declaration or not
+                    nDeclaration = (xtype == eTokenDeclaration);
+
+                    // If we have node text then add this to the element
+                    if (maybeAddTxT(pXML,token.pStr)) return FALSE;
+
+                    // Find the name of the tag
+                    token = GetNextToken(pXML, &cbToken, &xtype);
+
+                    // Return an error if we couldn't obtain the next token or
+                    // it wasnt text
+                    if (xtype != eTokenText)
+                    {
+                        pXML->error = eXMLErrorMissingTagName;
+                        return FALSE;
+                    }
+
+                    // If we found a new element which is the same as this
+                    // element then we need to pass this back to the caller..
+
+#ifdef APPROXIMATE_PARSING
+                    if (d->lpszName &&
+                        myTagCompare(d->lpszName, token.pStr) == 0)
+                    {
+                        // Indicate to the caller that it needs to create a
+                        // new element.
+                        pXML->lpNewElement = token.pStr;
+                        pXML->cbNewElement = cbToken;
+                        return TRUE;
+                    } else
+#endif
+                    {
+                        // If the name of the new element differs from the name of
+                        // the current element we need to add the new element to
+                        // the current one and recurse
+                        pNew = addChild_priv(MEMORYINCREASE,stringDup(token.pStr,cbToken), nDeclaration,-1);
+
+                        while (!pNew.isEmpty())
+                        {
+                            // Callself to process the new node.  If we return
+                            // FALSE this means we dont have any more
+                            // processing to do...
+
+                            if (!pNew.ParseXMLElement(pXML)) return FALSE;
+                            else
+                            {
+                                // If the call to recurse this function
+                                // evented in a end tag specified in XML then
+                                // we need to unwind the calls to this
+                                // function until we find the appropriate node
+                                // (the element name and end tag name must
+                                // match)
+                                if (pXML->cbEndTag)
+                                {
+                                    // If we are back at the root node then we
+                                    // have an unmatched end tag
+                                    if (!d->lpszName)
+                                    {
+                                        pXML->error=eXMLErrorUnmatchedEndTag;
+                                        return FALSE;
+                                    }
+
+                                    // If the end tag matches the name of this
+                                    // element then we only need to unwind
+                                    // once more...
+
+                                    if (myTagCompare(d->lpszName, pXML->lpEndTag)==0)
+                                    {
+                                        pXML->cbEndTag = 0;
+                                    }
+
+                                    return TRUE;
+                                } else
+                                    if (pXML->cbNewElement)
+                                    {
+                                        // If the call indicated a new element is to
+                                        // be created on THIS element.
+
+                                        // If the name of this element matches the
+                                        // name of the element we need to create
+                                        // then we need to return to the caller
+                                        // and let it process the element.
+
+                                        if (myTagCompare(d->lpszName, pXML->lpNewElement)==0)
+                                        {
+                                            return TRUE;
+                                        }
+
+                                        // Add the new element and recurse
+                                        pNew = addChild_priv(MEMORYINCREASE,stringDup(pXML->lpNewElement,pXML->cbNewElement),0,-1);
+                                        pXML->cbNewElement = 0;
+                                    }
+                                    else
+                                    {
+                                        // If we didn't have a new element to create
+                                        pNew = emptyXMLNode;
+
+                                    }
+                            }
+                        }
+                    }
+                    break;
+
+                // If we found an end tag
+                case eTokenTagEnd:
+
+                    // If we have node text then add this to the element
+                    if (maybeAddTxT(pXML,token.pStr)) return FALSE;
+
+                    // Find the name of the end tag
+                    token = GetNextToken(pXML, &cbTemp, &xtype);
+
+                    // The end tag should be text
+                    if (xtype != eTokenText)
+                    {
+                        pXML->error = eXMLErrorMissingEndTagName;
+                        return FALSE;
+                    }
+                    lpszTemp = token.pStr;
+
+                    // After the end tag we should find a closing tag
+                    token = GetNextToken(pXML, &cbToken, &xtype);
+                    if (xtype != eTokenCloseTag)
+                    {
+                        pXML->error = eXMLErrorMissingEndTagName;
+                        return FALSE;
+                    }
+                    pXML->lpszText=pXML->lpXML+pXML->nIndex;
+
+                    // We need to return to the previous caller.  If the name
+                    // of the tag cannot be found we need to keep returning to
+                    // caller until we find a match
+                    if (myTagCompare(d->lpszName, lpszTemp) != 0)
+#ifdef STRICT_PARSING
+                    {
+                        pXML->error=eXMLErrorUnmatchedEndTag;
+                        pXML->nIndexMissigEndTag=pXML->nIndex;
+                        return FALSE;
+                    }
+#else
+                    {
+                        pXML->error=eXMLErrorMissingEndTag;
+                        pXML->nIndexMissigEndTag=pXML->nIndex;
+                        pXML->lpEndTag = lpszTemp;
+                        pXML->cbEndTag = cbTemp;
+                    }
+#endif
+
+                    // Return to the caller
+                    exactMemory(d);
+                    return TRUE;
+
+                // If we found a clear (unformatted) token
+                case eTokenClear:
+                    // If we have node text then add this to the element
+                    if (maybeAddTxT(pXML,token.pStr)) return FALSE;
+                    if (parseClearTag(pXML, token.pClr)) return FALSE;
+                    pXML->lpszText=pXML->lpXML+pXML->nIndex;
+                    break;
+
+                default:
+                    break;
+                }
+                break;
+
+            // If we are inside a tag definition we need to search for attributes
+            case eInsideTag:
+
+                // Check what part of the attribute (name, equals, value) we
+                // are looking for.
+                switch(attrib)
+                {
+                // If we are looking for a new attribute
+                case eAttribName:
+
+                    // Check what the current token type is
+                    switch(xtype)
+                    {
+                    // If the current type is text...
+                    // Eg.  'attribute'
+                    case eTokenText:
+                        // Cache the token then indicate that we are next to
+                        // look for the equals
+                        lpszTemp = token.pStr;
+                        cbTemp = cbToken;
+                        attrib = eAttribEquals;
+                        break;
+
+                    // If we found a closing tag...
+                    // Eg.  '>'
+                    case eTokenCloseTag:
+                        // We are now outside the tag
+                        status = eOutsideTag;
+                        pXML->lpszText=pXML->lpXML+pXML->nIndex;
+                        break;
+
+                    // If we found a short hand '/>' closing tag then we can
+                    // return to the caller
+                    case eTokenShortHandClose:
+                        exactMemory(d);
+                        pXML->lpszText=pXML->lpXML+pXML->nIndex;
+                        return TRUE;
+
+                    // Errors...
+                    case eTokenQuotedText:    /* '"SomeText"'   */
+                    case eTokenTagStart:      /* '<'            */
+                    case eTokenTagEnd:        /* '</'           */
+                    case eTokenEquals:        /* '='            */
+                    case eTokenDeclaration:   /* '<?'           */
+                    case eTokenClear:
+                        pXML->error = eXMLErrorUnexpectedToken;
+                        return FALSE;
+                    default: break;
+                    }
+                    break;
+
+                // If we are looking for an equals
+                case eAttribEquals:
+                    // Check what the current token type is
+                    switch(xtype)
+                    {
+                    // If the current type is text...
+                    // Eg.  'Attribute AnotherAttribute'
+                    case eTokenText:
+                        // Add the unvalued attribute to the list
+                        addAttribute_priv(MEMORYINCREASE,stringDup(lpszTemp,cbTemp), NULL);
+                        // Cache the token then indicate.  We are next to
+                        // look for the equals attribute
+                        lpszTemp = token.pStr;
+                        cbTemp = cbToken;
+                        break;
+
+                    // If we found a closing tag 'Attribute >' or a short hand
+                    // closing tag 'Attribute />'
+                    case eTokenShortHandClose:
+                    case eTokenCloseTag:
+                        // If we are a declaration element '<?' then we need
+                        // to remove extra closing '?' if it exists
+                        pXML->lpszText=pXML->lpXML+pXML->nIndex;
+
+                        if (d->isDeclaration &&
+                            (lpszTemp[cbTemp-1]) == _CXML('?'))
+                        {
+                            cbTemp--;
+                            if (d->pParent && d->pParent->pParent) xtype = eTokenShortHandClose;
+                        }
+
+                        if (cbTemp)
+                        {
+                            // Add the unvalued attribute to the list
+                            addAttribute_priv(MEMORYINCREASE,stringDup(lpszTemp,cbTemp), NULL);
+                        }
+
+                        // If this is the end of the tag then return to the caller
+                        if (xtype == eTokenShortHandClose)
+                        {
+                            exactMemory(d);
+                            return TRUE;
+                        }
+
+                        // We are now outside the tag
+                        status = eOutsideTag;
+                        break;
+
+                    // If we found the equals token...
+                    // Eg.  'Attribute ='
+                    case eTokenEquals:
+                        // Indicate that we next need to search for the value
+                        // for the attribute
+                        attrib = eAttribValue;
+                        break;
+
+                    // Errors...
+                    case eTokenQuotedText:    /* 'Attribute "InvalidAttr"'*/
+                    case eTokenTagStart:      /* 'Attribute <'            */
+                    case eTokenTagEnd:        /* 'Attribute </'           */
+                    case eTokenDeclaration:   /* 'Attribute <?'           */
+                    case eTokenClear:
+                        pXML->error = eXMLErrorUnexpectedToken;
+                        return FALSE;
+                    default: break;
+                    }
+                    break;
+
+                // If we are looking for an attribute value
+                case eAttribValue:
+                    // Check what the current token type is
+                    switch(xtype)
+                    {
+                    // If the current type is text or quoted text...
+                    // Eg.  'Attribute = "Value"' or 'Attribute = Value' or
+                    // 'Attribute = 'Value''.
+                    case eTokenText:
+                    case eTokenQuotedText:
+                        // If we are a declaration element '<?' then we need
+                        // to remove extra closing '?' if it exists
+                        if (d->isDeclaration &&
+                            (token.pStr[cbToken-1]) == _CXML('?'))
+                        {
+                            cbToken--;
+                        }
+
+                        if (cbTemp)
+                        {
+                            // Add the valued attribute to the list
+                            if (xtype==eTokenQuotedText) { token.pStr++; cbToken-=2; }
+                            XMLSTR attrVal=(XMLSTR)token.pStr;
+                            if (attrVal)
+                            {
+                                attrVal=fromXMLString(attrVal,cbToken,pXML);
+                                if (!attrVal) return FALSE;
+                            }
+                            addAttribute_priv(MEMORYINCREASE,stringDup(lpszTemp,cbTemp),attrVal);
+                        }
+
+                        // Indicate we are searching for a new attribute
+                        attrib = eAttribName;
+                        break;
+
+                    // Errors...
+                    case eTokenTagStart:        /* 'Attr = <'          */
+                    case eTokenTagEnd:          /* 'Attr = </'         */
+                    case eTokenCloseTag:        /* 'Attr = >'          */
+                    case eTokenShortHandClose:  /* "Attr = />"         */
+                    case eTokenEquals:          /* 'Attr = ='          */
+                    case eTokenDeclaration:     /* 'Attr = <?'         */
+                    case eTokenClear:
+                        pXML->error = eXMLErrorUnexpectedToken;
+                        return FALSE;
+                        break;
+                    default: break;
+                    }
+                }
+            }
+        }
+        // If we failed to obtain the next token
+        else
+        {
+            if ((!d->isDeclaration)&&(d->pParent))
+            {
+#ifdef STRICT_PARSING
+                pXML->error=eXMLErrorUnmatchedEndTag;
+#else
+                pXML->error=eXMLErrorMissingEndTag;
+#endif
+                pXML->nIndexMissigEndTag=pXML->nIndex;
+            }
+            maybeAddTxT(pXML,pXML->lpXML+pXML->nIndex);
+            return FALSE;
+        }
+    }
+}
+
+// Count the number of lines and columns in an XML string.
+static void CountLinesAndColumns(XMLCSTR lpXML, int nUpto, XMLResults *pResults)
+{
+    XMLCHAR ch;
+    assert(lpXML);
+    assert(pResults);
+
+    struct XML xml={ lpXML,lpXML, 0, 0, eXMLErrorNone, NULL, 0, NULL, 0, TRUE };
+
+    pResults->nLine = 1;
+    pResults->nColumn = 1;
+    while (xml.nIndex<nUpto)
+    {
+        ch = getNextChar(&xml);
+        if (ch != _CXML('\n')) pResults->nColumn++;
+        else
+        {
+            pResults->nLine++;
+            pResults->nColumn=1;
+        }
+    }
+}
+
+// Parse XML and return the root element.
+XMLNode XMLNode::parseString(XMLCSTR lpszXML, XMLCSTR tag, XMLResults *pResults)
+{
+    if (!lpszXML)
+    {
+        if (pResults)
+        {
+            pResults->error=eXMLErrorNoElements;
+            pResults->nLine=0;
+            pResults->nColumn=0;
+        }
+        return emptyXMLNode;
+    }
+
+    XMLNode xnode(NULL,NULL,FALSE);
+    struct XML xml={ lpszXML, lpszXML, 0, 0, eXMLErrorNone, NULL, 0, NULL, 0, TRUE };
+
+    // Create header element
+    xnode.ParseXMLElement(&xml);
+    enum XMLError error = xml.error;
+    if (!xnode.nChildNode()) error=eXMLErrorNoXMLTagFound;
+    if ((xnode.nChildNode()==1)&&(xnode.nElement()==1)) xnode=xnode.getChildNode(); // skip the empty node
+
+    // If no error occurred
+    if ((error==eXMLErrorNone)||(error==eXMLErrorMissingEndTag)||(error==eXMLErrorNoXMLTagFound))
+    {
+        XMLCSTR name=xnode.getName();
+        if (tag&&(*tag)&&((!name)||(xstricmp(name,tag))))
+        {
+            xnode=xnode.getChildNode(tag);
+            if (xnode.isEmpty())
+            {
+                if (pResults)
+                {
+                    pResults->error=eXMLErrorFirstTagNotFound;
+                    pResults->nLine=0;
+                    pResults->nColumn=0;
+                }
+                return emptyXMLNode;
+            }
+        }
+    } else
+    {
+        // Cleanup: this will destroy all the nodes
+        xnode = emptyXMLNode;
+    }
+
+
+    // If we have been given somewhere to place results
+    if (pResults)
+    {
+        pResults->error = error;
+
+        // If we have an error
+        if (error!=eXMLErrorNone)
+        {
+            if (error==eXMLErrorMissingEndTag) xml.nIndex=xml.nIndexMissigEndTag;
+            // Find which line and column it starts on.
+            CountLinesAndColumns(xml.lpXML, xml.nIndex, pResults);
+        }
+    }
+    return xnode;
+}
+
+XMLNode XMLNode::parseFile(XMLCSTR filename, XMLCSTR tag, XMLResults *pResults)
+{
+    if (pResults) { pResults->nLine=0; pResults->nColumn=0; }
+    FILE *f=xfopen(filename,_CXML("rb"));
+    if (f==NULL) { if (pResults) pResults->error=eXMLErrorFileNotFound; return emptyXMLNode; }
+    fseek(f,0,SEEK_END);
+    int l=(int)ftell(f),headerSz=0;
+    if (!l) { if (pResults) pResults->error=eXMLErrorEmpty; fclose(f); return emptyXMLNode; }
+    fseek(f,0,SEEK_SET);
+    unsigned char *buf=(unsigned char*)malloc(l+4);
+    l=(int)fread(buf,1,l,f);
+    fclose(f);
+    buf[l]=0;buf[l+1]=0;buf[l+2]=0;buf[l+3]=0;
+#ifdef _XMLWIDECHAR
+    if (guessWideCharChars)
+    {
+        if (!myIsTextWideChar(buf,l))
+        {
+            XMLNode::XMLCharEncoding ce=XMLNode::char_encoding_legacy;
+            if ((buf[0]==0xef)&&(buf[1]==0xbb)&&(buf[2]==0xbf)) { headerSz=3; ce=XMLNode::char_encoding_UTF8; }
+            XMLSTR b2=myMultiByteToWideChar((const char*)(buf+headerSz),ce);
+            if (!b2)
+            {
+            	// todo: unable to convert
+            }
+            free(buf); buf=(unsigned char*)b2; headerSz=0;
+        } else
+        {
+            if ((buf[0]==0xef)&&(buf[1]==0xff)) headerSz=2;
+            if ((buf[0]==0xff)&&(buf[1]==0xfe)) headerSz=2;
+        }
+    } else
+    {
+        if ((buf[0]==0xef)&&(buf[1]==0xff)) headerSz=2;
+        if ((buf[0]==0xff)&&(buf[1]==0xfe)) headerSz=2;
+        if ((buf[0]==0xef)&&(buf[1]==0xbb)&&(buf[2]==0xbf)) headerSz=3;
+    }
+#else
+    if (guessWideCharChars)
+    {
+        if (myIsTextWideChar(buf,l))
+        {
+            if ((buf[0]==0xef)&&(buf[1]==0xff)) headerSz=2;
+            if ((buf[0]==0xff)&&(buf[1]==0xfe)) headerSz=2;
+            char *b2=myWideCharToMultiByte((const wchar_t*)(buf+headerSz));
+            free(buf); buf=(unsigned char*)b2; headerSz=0;
+        } else
+        {
+            if ((buf[0]==0xef)&&(buf[1]==0xbb)&&(buf[2]==0xbf)) headerSz=3;
+        }
+    } else
+    {
+        if ((buf[0]==0xef)&&(buf[1]==0xff)) headerSz=2;
+        if ((buf[0]==0xff)&&(buf[1]==0xfe)) headerSz=2;
+        if ((buf[0]==0xef)&&(buf[1]==0xbb)&&(buf[2]==0xbf)) headerSz=3;
+    }
+#endif
+
+    if (!buf) { if (pResults) pResults->error=eXMLErrorCharConversionError; return emptyXMLNode; }
+    XMLNode x=parseString((XMLSTR)(buf+headerSz),tag,pResults);
+    free(buf);
+    return x;
+}
+
+static inline void charmemset(XMLSTR dest,XMLCHAR c,int l) { while (l--) *(dest++)=c; }
+// private:
+// Creates an user friendly XML string from a given element with
+// appropriate white space and carriage returns.
+//
+// This recurses through all subnodes then adds contents of the nodes to the
+// string.
+int XMLNode::CreateXMLStringR(XMLNodeData *pEntry, XMLSTR lpszMarker, int nFormat)
+{
+    int nResult = 0;
+    int cb=nFormat<0?0:nFormat;
+    int cbElement;
+    int nChildFormat=-1;
+    int nElementI=pEntry->nChild+pEntry->nText+pEntry->nClear;
+    int i,j;
+    if ((nFormat>=0)&&(nElementI==1)&&(pEntry->nText==1)&&(!pEntry->isDeclaration)) nFormat=-2;
+
+    assert(pEntry);
+
+#define LENSTR(lpsz) (lpsz ? xstrlen(lpsz) : 0)
+
+    // If the element has no name then assume this is the head node.
+    cbElement = (int)LENSTR(pEntry->lpszName);
+
+    if (cbElement)
+    {
+        // "<elementname "
+        if (lpszMarker)
+        {
+            if (cb) charmemset(lpszMarker, INDENTCHAR, cb);
+            nResult = cb;
+            lpszMarker[nResult++]=_CXML('<');
+            if (pEntry->isDeclaration) lpszMarker[nResult++]=_CXML('?');
+            xstrcpy(&lpszMarker[nResult], pEntry->lpszName);
+            nResult+=cbElement;
+            lpszMarker[nResult++]=_CXML(' ');
+
+        } else
+        {
+            nResult+=cbElement+2+cb;
+            if (pEntry->isDeclaration) nResult++;
+        }
+
+        // Enumerate attributes and add them to the string
+        XMLAttribute *pAttr=pEntry->pAttribute;
+        for (i=0; i<pEntry->nAttribute; i++)
+        {
+            // "Attrib
+            cb = (int)LENSTR(pAttr->lpszName);
+            if (cb)
+            {
+                if (lpszMarker) xstrcpy(&lpszMarker[nResult], pAttr->lpszName);
+                nResult += cb;
+                // "Attrib=Value "
+                if (pAttr->lpszValue)
+                {
+                    cb=(int)ToXMLStringTool::lengthXMLString(pAttr->lpszValue);
+                    if (lpszMarker)
+                    {
+                        lpszMarker[nResult]=_CXML('=');
+                        lpszMarker[nResult+1]=_CXML('"');
+                        if (cb) ToXMLStringTool::toXMLUnSafe(&lpszMarker[nResult+2],pAttr->lpszValue);
+                        lpszMarker[nResult+cb+2]=_CXML('"');
+                    }
+                    nResult+=cb+3;
+                }
+                if (lpszMarker) lpszMarker[nResult] = _CXML(' ');
+                nResult++;
+            }
+            pAttr++;
+        }
+
+        if (pEntry->isDeclaration)
+        {
+            if (lpszMarker)
+            {
+                lpszMarker[nResult-1]=_CXML('?');
+                lpszMarker[nResult]=_CXML('>');
+            }
+            nResult++;
+            if (nFormat!=-1)
+            {
+                if (lpszMarker) lpszMarker[nResult]=_CXML('\n');
+                nResult++;
+            }
+        } else
+            // If there are child nodes we need to terminate the start tag
+            if (nElementI)
+            {
+                if (lpszMarker) lpszMarker[nResult-1]=_CXML('>');
+                if (nFormat>=0)
+                {
+                    if (lpszMarker) lpszMarker[nResult]=_CXML('\n');
+                    nResult++;
+                }
+            } else nResult--;
+    }
+
+    // Calculate the child format for when we recurse.  This is used to
+    // determine the number of spaces used for prefixes.
+    if (nFormat!=-1)
+    {
+        if (cbElement&&(!pEntry->isDeclaration)) nChildFormat=nFormat+1;
+        else nChildFormat=nFormat;
+    }
+
+    // Enumerate through remaining children
+    for (i=0; i<nElementI; i++)
+    {
+        j=pEntry->pOrder[i];
+        switch((XMLElementType)(j&3))
+        {
+        // Text nodes
+        case eNodeText:
+            {
+                // "Text"
+                XMLCSTR pChild=pEntry->pText[j>>2];
+                cb = (int)ToXMLStringTool::lengthXMLString(pChild);
+                if (cb)
+                {
+                    if (nFormat>=0)
+                    {
+                        if (lpszMarker)
+                        {
+                            charmemset(&lpszMarker[nResult],INDENTCHAR,nFormat+1);
+                            ToXMLStringTool::toXMLUnSafe(&lpszMarker[nResult+nFormat+1],pChild);
+                            lpszMarker[nResult+nFormat+1+cb]=_CXML('\n');
+                        }
+                        nResult+=cb+nFormat+2;
+                    } else
+                    {
+                        if (lpszMarker) ToXMLStringTool::toXMLUnSafe(&lpszMarker[nResult], pChild);
+                        nResult += cb;
+                    }
+                }
+                break;
+            }
+
+        // Clear type nodes
+        case eNodeClear:
+            {
+                XMLClear *pChild=pEntry->pClear+(j>>2);
+                // "OpenTag"
+                cb = (int)LENSTR(pChild->lpszOpenTag);
+                if (cb)
+                {
+                    if (nFormat!=-1)
+                    {
+                        if (lpszMarker)
+                        {
+                            charmemset(&lpszMarker[nResult], INDENTCHAR, nFormat+1);
+                            xstrcpy(&lpszMarker[nResult+nFormat+1], pChild->lpszOpenTag);
+                        }
+                        nResult+=cb+nFormat+1;
+                    }
+                    else
+                    {
+                        if (lpszMarker)xstrcpy(&lpszMarker[nResult], pChild->lpszOpenTag);
+                        nResult += cb;
+                    }
+                }
+
+                // "OpenTag Value"
+                cb = (int)LENSTR(pChild->lpszValue);
+                if (cb)
+                {
+                    if (lpszMarker) xstrcpy(&lpszMarker[nResult], pChild->lpszValue);
+                    nResult += cb;
+                }
+
+                // "OpenTag Value CloseTag"
+                cb = (int)LENSTR(pChild->lpszCloseTag);
+                if (cb)
+                {
+                    if (lpszMarker) xstrcpy(&lpszMarker[nResult], pChild->lpszCloseTag);
+                    nResult += cb;
+                }
+
+                if (nFormat!=-1)
+                {
+                    if (lpszMarker) lpszMarker[nResult] = _CXML('\n');
+                    nResult++;
+                }
+                break;
+            }
+
+        // Element nodes
+        case eNodeChild:
+            {
+                // Recursively add child nodes
+                nResult += CreateXMLStringR(pEntry->pChild[j>>2].d, lpszMarker ? lpszMarker + nResult : 0, nChildFormat);
+                break;
+            }
+        default: break;
+        }
+    }
+
+    if ((cbElement)&&(!pEntry->isDeclaration))
+    {
+        // If we have child entries we need to use long XML notation for
+        // closing the element - "<elementname>blah blah blah</elementname>"
+        if (nElementI)
+        {
+            // "</elementname>\0"
+            if (lpszMarker)
+            {
+                if (nFormat >=0)
+                {
+                    charmemset(&lpszMarker[nResult], INDENTCHAR,nFormat);
+                    nResult+=nFormat;
+                }
+
+                lpszMarker[nResult]=_CXML('<'); lpszMarker[nResult+1]=_CXML('/');
+                nResult += 2;
+                xstrcpy(&lpszMarker[nResult], pEntry->lpszName);
+                nResult += cbElement;
+
+                lpszMarker[nResult]=_CXML('>');
+                if (nFormat == -1) nResult++;
+                else
+                {
+                    lpszMarker[nResult+1]=_CXML('\n');
+                    nResult+=2;
+                }
+            } else
+            {
+                if (nFormat>=0) nResult+=cbElement+4+nFormat;
+                else if (nFormat==-1) nResult+=cbElement+3;
+                else nResult+=cbElement+4;
+            }
+        } else
+        {
+            // If there are no children we can use shorthand XML notation -
+            // "<elementname/>"
+            // "/>\0"
+            if (lpszMarker)
+            {
+                lpszMarker[nResult]=_CXML('/'); lpszMarker[nResult+1]=_CXML('>');
+                if (nFormat != -1) lpszMarker[nResult+2]=_CXML('\n');
+            }
+            nResult += nFormat == -1 ? 2 : 3;
+        }
+    }
+
+    return nResult;
+}
+
+#undef LENSTR
+
+// Create an XML string
+// @param       int nFormat             - 0 if no formatting is required
+//                                        otherwise nonzero for formatted text
+//                                        with carriage returns and indentation.
+// @param       int *pnSize             - [out] pointer to the size of the
+//                                        returned string not including the
+//                                        NULL terminator.
+// @return      XMLSTR                  - Allocated XML string, you must free
+//                                        this with free().
+XMLSTR XMLNode::createXMLString(int nFormat, int *pnSize) const
+{
+    if (!d) { if (pnSize) *pnSize=0; return NULL; }
+
+    XMLSTR lpszResult = NULL;
+    int cbStr;
+
+    // Recursively Calculate the size of the XML string
+    if (!dropWhiteSpace) nFormat=0;
+    nFormat = nFormat ? 0 : -1;
+    cbStr = CreateXMLStringR(d, 0, nFormat);
+    // Alllocate memory for the XML string + the NULL terminator and
+    // create the recursively XML string.
+    lpszResult=(XMLSTR)malloc((cbStr+1)*sizeof(XMLCHAR));
+    CreateXMLStringR(d, lpszResult, nFormat);
+    lpszResult[cbStr]=_CXML('\0');
+    if (pnSize) *pnSize = cbStr;
+    return lpszResult;
+}
+
+int XMLNode::detachFromParent(XMLNodeData *d)
+{
+    XMLNode *pa=d->pParent->pChild;
+    int i=0;
+    while (((void*)(pa[i].d))!=((void*)d)) i++;
+    d->pParent->nChild--;
+    if (d->pParent->nChild) memmove(pa+i,pa+i+1,(d->pParent->nChild-i)*sizeof(XMLNode));
+    else { free(pa); d->pParent->pChild=NULL; }
+    return removeOrderElement(d->pParent,eNodeChild,i);
+}
+
+XMLNode::~XMLNode()
+{
+    if (!d) return;
+    d->ref_count--;
+    emptyTheNode(0);
+}
+void XMLNode::deleteNodeContent()
+{
+    if (!d) return;
+    if (d->pParent) { detachFromParent(d); d->pParent=NULL; d->ref_count--; }
+    emptyTheNode(1);
+}
+void XMLNode::emptyTheNode(char force)
+{
+    XMLNodeData *dd=d; // warning: must stay this way!
+    if ((dd->ref_count==0)||force)
+    {
+        if (d->pParent) detachFromParent(d);
+        int i;
+        XMLNode *pc;
+        for(i=0; i<dd->nChild; i++)
+        {
+            pc=dd->pChild+i;
+            pc->d->pParent=NULL;
+            pc->d->ref_count--;
+            pc->emptyTheNode(force);
+        }
+        myFree(dd->pChild);
+        for(i=0; i<dd->nText; i++) free((void*)dd->pText[i]);
+        myFree(dd->pText);
+        for(i=0; i<dd->nClear; i++) free((void*)dd->pClear[i].lpszValue);
+        myFree(dd->pClear);
+        for(i=0; i<dd->nAttribute; i++)
+        {
+            free((void*)dd->pAttribute[i].lpszName);
+            if (dd->pAttribute[i].lpszValue) free((void*)dd->pAttribute[i].lpszValue);
+        }
+        myFree(dd->pAttribute);
+        myFree(dd->pOrder);
+        myFree((void*)dd->lpszName);
+        dd->nChild=0;    dd->nText=0;    dd->nClear=0;    dd->nAttribute=0;
+        dd->pChild=NULL; dd->pText=NULL; dd->pClear=NULL; dd->pAttribute=NULL;
+        dd->pOrder=NULL; dd->lpszName=NULL; dd->pParent=NULL;
+    }
+    if (dd->ref_count==0)
+    {
+        free(dd);
+        d=NULL;
+    }
+}
+
+XMLNode& XMLNode::operator=( const XMLNode& A )
+{
+    // shallow copy
+    if (this != &A)
+    {
+        if (d) { d->ref_count--; emptyTheNode(0); }
+        d=A.d;
+        if (d) (d->ref_count) ++ ;
+    }
+    return *this;
+}
+
+XMLNode::XMLNode(const XMLNode &A)
+{
+    // shallow copy
+    d=A.d;
+    if (d) (d->ref_count)++ ;
+}
+
+XMLNode XMLNode::deepCopy() const
+{
+    if (!d) return XMLNode::emptyXMLNode;
+    XMLNode x(NULL,stringDup(d->lpszName),d->isDeclaration);
+    XMLNodeData *p=x.d;
+    int n=d->nAttribute;
+    if (n)
+    {
+        p->nAttribute=n; p->pAttribute=(XMLAttribute*)malloc(n*sizeof(XMLAttribute));
+        while (n--)
+        {
+            p->pAttribute[n].lpszName=stringDup(d->pAttribute[n].lpszName);
+            p->pAttribute[n].lpszValue=stringDup(d->pAttribute[n].lpszValue);
+        }
+    }
+    if (d->pOrder)
+    {
+        n=(d->nChild+d->nText+d->nClear)*sizeof(int); p->pOrder=(int*)malloc(n); memcpy(p->pOrder,d->pOrder,n);
+    }
+    n=d->nText;
+    if (n)
+    {
+        p->nText=n; p->pText=(XMLCSTR*)malloc(n*sizeof(XMLCSTR));
+        while(n--) p->pText[n]=stringDup(d->pText[n]);
+    }
+    n=d->nClear;
+    if (n)
+    {
+        p->nClear=n; p->pClear=(XMLClear*)malloc(n*sizeof(XMLClear));
+        while (n--)
+        {
+            p->pClear[n].lpszCloseTag=d->pClear[n].lpszCloseTag;
+            p->pClear[n].lpszOpenTag=d->pClear[n].lpszOpenTag;
+            p->pClear[n].lpszValue=stringDup(d->pClear[n].lpszValue);
+        }
+    }
+    n=d->nChild;
+    if (n)
+    {
+        p->nChild=n; p->pChild=(XMLNode*)malloc(n*sizeof(XMLNode));
+        while (n--)
+        {
+            p->pChild[n].d=NULL;
+            p->pChild[n]=d->pChild[n].deepCopy();
+            p->pChild[n].d->pParent=p;
+        }
+    }
+    return x;
+}
+
+XMLNode XMLNode::addChild(XMLNode childNode, int pos)
+{
+    XMLNodeData *dc=childNode.d;
+    if ((!dc)||(!d)) return childNode;
+    if (!dc->lpszName)
+    {
+        // this is a root node: todo: correct fix
+        int j=pos;
+        while (dc->nChild)
+        {
+            addChild(dc->pChild[0],j);
+            if (pos>=0) j++;
+        }
+        return childNode;
+    }
+    if (dc->pParent) { if ((detachFromParent(dc)<=pos)&&(dc->pParent==d)) pos--; } else dc->ref_count++;
+    dc->pParent=d;
+//     int nc=d->nChild;
+//     d->pChild=(XMLNode*)myRealloc(d->pChild,(nc+1),memoryIncrease,sizeof(XMLNode));
+    d->pChild=(XMLNode*)addToOrder(0,&pos,d->nChild,d->pChild,sizeof(XMLNode),eNodeChild);
+    d->pChild[pos].d=dc;
+    d->nChild++;
+    return childNode;
+}
+
+void XMLNode::deleteAttribute(int i)
+{
+    if ((!d)||(i<0)||(i>=d->nAttribute)) return;
+    d->nAttribute--;
+    XMLAttribute *p=d->pAttribute+i;
+    free((void*)p->lpszName);
+    if (p->lpszValue) free((void*)p->lpszValue);
+    if (d->nAttribute) memmove(p,p+1,(d->nAttribute-i)*sizeof(XMLAttribute)); else { free(p); d->pAttribute=NULL; }
+}
+
+void XMLNode::deleteAttribute(XMLAttribute *a){ if (a) deleteAttribute(a->lpszName); }
+void XMLNode::deleteAttribute(XMLCSTR lpszName)
+{
+    int j=0;
+    getAttribute(lpszName,&j);
+    if (j) deleteAttribute(j-1);
+}
+
+XMLAttribute *XMLNode::updateAttribute_WOSD(XMLSTR lpszNewValue, XMLSTR lpszNewName,int i)
+{
+    if (!d) { if (lpszNewValue) free(lpszNewValue); if (lpszNewName) free(lpszNewName); return NULL; }
+    if (i>=d->nAttribute)
+    {
+        if (lpszNewName) return addAttribute_WOSD(lpszNewName,lpszNewValue);
+        return NULL;
+    }
+    XMLAttribute *p=d->pAttribute+i;
+    if (p->lpszValue&&p->lpszValue!=lpszNewValue) free((void*)p->lpszValue);
+    p->lpszValue=lpszNewValue;
+    if (lpszNewName&&p->lpszName!=lpszNewName) { free((void*)p->lpszName); p->lpszName=lpszNewName; };
+    return p;
+}
+
+XMLAttribute *XMLNode::updateAttribute_WOSD(XMLAttribute *newAttribute, XMLAttribute *oldAttribute)
+{
+    if (oldAttribute) return updateAttribute_WOSD((XMLSTR)newAttribute->lpszValue,(XMLSTR)newAttribute->lpszName,oldAttribute->lpszName);
+    return addAttribute_WOSD((XMLSTR)newAttribute->lpszName,(XMLSTR)newAttribute->lpszValue);
+}
+
+XMLAttribute *XMLNode::updateAttribute_WOSD(XMLSTR lpszNewValue, XMLSTR lpszNewName,XMLCSTR lpszOldName)
+{
+    int j=0;
+    getAttribute(lpszOldName,&j);
+    if (j) return updateAttribute_WOSD(lpszNewValue,lpszNewName,j-1);
+    else
+    {
+        if (lpszNewName) return addAttribute_WOSD(lpszNewName,lpszNewValue);
+        else             return addAttribute_WOSD(stringDup(lpszOldName),lpszNewValue);
+    }
+}
+
+int XMLNode::indexText(XMLCSTR lpszValue) const
+{
+    if (!d) return -1;
+    int i,l=d->nText;
+    if (!lpszValue) { if (l) return 0; return -1; }
+    XMLCSTR *p=d->pText;
+    for (i=0; i<l; i++) if (lpszValue==p[i]) return i;
+    return -1;
+}
+
+void XMLNode::deleteText(int i)
+{
+    if ((!d)||(i<0)||(i>=d->nText)) return;
+    d->nText--;
+    XMLCSTR *p=d->pText+i;
+    free((void*)*p);
+    if (d->nText) memmove(p,p+1,(d->nText-i)*sizeof(XMLCSTR)); else { free(p); d->pText=NULL; }
+    removeOrderElement(d,eNodeText,i);
+}
+
+void XMLNode::deleteText(XMLCSTR lpszValue) { deleteText(indexText(lpszValue)); }
+
+XMLCSTR XMLNode::updateText_WOSD(XMLSTR lpszNewValue, int i)
+{
+    if (!d) { if (lpszNewValue) free(lpszNewValue); return NULL; }
+    if (i>=d->nText) return addText_WOSD(lpszNewValue);
+    XMLCSTR *p=d->pText+i;
+    if (*p!=lpszNewValue) { free((void*)*p); *p=lpszNewValue; }
+    return lpszNewValue;
+}
+
+XMLCSTR XMLNode::updateText_WOSD(XMLSTR lpszNewValue, XMLCSTR lpszOldValue)
+{
+    if (!d) { if (lpszNewValue) free(lpszNewValue); return NULL; }
+    int i=indexText(lpszOldValue);
+    if (i>=0) return updateText_WOSD(lpszNewValue,i);
+    return addText_WOSD(lpszNewValue);
+}
+
+void XMLNode::deleteClear(int i)
+{
+    if ((!d)||(i<0)||(i>=d->nClear)) return;
+    d->nClear--;
+    XMLClear *p=d->pClear+i;
+    free((void*)p->lpszValue);
+    if (d->nClear) memmove(p,p+1,(d->nClear-i)*sizeof(XMLClear)); else { free(p); d->pClear=NULL; }
+    removeOrderElement(d,eNodeClear,i);
+}
+
+int XMLNode::indexClear(XMLCSTR lpszValue) const
+{
+    if (!d) return -1;
+    int i,l=d->nClear;
+    if (!lpszValue) { if (l) return 0; return -1; }
+    XMLClear *p=d->pClear;
+    for (i=0; i<l; i++) if (lpszValue==p[i].lpszValue) return i;
+    return -1;
+}
+
+void XMLNode::deleteClear(XMLCSTR lpszValue) { deleteClear(indexClear(lpszValue)); }
+void XMLNode::deleteClear(XMLClear *a) { if (a) deleteClear(a->lpszValue); }
+
+XMLClear *XMLNode::updateClear_WOSD(XMLSTR lpszNewContent, int i)
+{
+    if (!d) { if (lpszNewContent) free(lpszNewContent); return NULL; }
+    if (i>=d->nClear) return addClear_WOSD(lpszNewContent);
+    XMLClear *p=d->pClear+i;
+    if (lpszNewContent!=p->lpszValue) { free((void*)p->lpszValue); p->lpszValue=lpszNewContent; }
+    return p;
+}
+
+XMLClear *XMLNode::updateClear_WOSD(XMLSTR lpszNewContent, XMLCSTR lpszOldValue)
+{
+    if (!d) { if (lpszNewContent) free(lpszNewContent); return NULL; }
+    int i=indexClear(lpszOldValue);
+    if (i>=0) return updateClear_WOSD(lpszNewContent,i);
+    return addClear_WOSD(lpszNewContent);
+}
+
+XMLClear *XMLNode::updateClear_WOSD(XMLClear *newP,XMLClear *oldP)
+{
+    if (oldP) return updateClear_WOSD((XMLSTR)newP->lpszValue,(XMLSTR)oldP->lpszValue);
+    return NULL;
+}
+
+int XMLNode::nChildNode(XMLCSTR name) const
+{
+    if (!d) return 0;
+    int i,j=0,n=d->nChild;
+    XMLNode *pc=d->pChild;
+    for (i=0; i<n; i++)
+    {
+        if (xstricmp(pc->d->lpszName, name)==0) j++;
+        pc++;
+    }
+    return j;
+}
+
+XMLNode XMLNode::getChildNode(XMLCSTR name, int *j) const
+{
+    if (!d) return emptyXMLNode;
+    int i=0,n=d->nChild;
+    if (j) i=*j;
+    XMLNode *pc=d->pChild+i;
+    for (; i<n; i++)
+    {
+        if (!xstricmp(pc->d->lpszName, name))
+        {
+            if (j) *j=i+1;
+            return *pc;
+        }
+        pc++;
+    }
+    return emptyXMLNode;
+}
+
+XMLNode XMLNode::getChildNode(XMLCSTR name, int j) const
+{
+    if (!d) return emptyXMLNode;
+    if (j>=0)
+    {
+        int i=0;
+        while (j-->0) getChildNode(name,&i);
+        return getChildNode(name,&i);
+    }
+    int i=d->nChild;
+    while (i--) if (!xstricmp(name,d->pChild[i].d->lpszName)) break;
+    if (i<0) return emptyXMLNode;
+    return getChildNode(i);
+}
+
+XMLNode XMLNode::getChildNodeByPath(XMLCSTR _path, char createMissing, XMLCHAR sep)
+{
+    XMLSTR path=stringDup(_path);
+    XMLNode x=getChildNodeByPathNonConst(path,createMissing,sep);
+    if (path) free(path);
+    return x;
+}
+
+XMLNode XMLNode::getChildNodeByPathNonConst(XMLSTR path, char createIfMissing, XMLCHAR sep)
+{
+    if ((!path)||(!(*path))) return *this;
+    XMLNode xn,xbase=*this;
+    XMLCHAR *tend1,sepString[2]; sepString[0]=sep; sepString[1]=0;
+    tend1=xstrstr(path,sepString);
+    while(tend1)
+    {
+        *tend1=0;
+        xn=xbase.getChildNode(path);
+        if (xn.isEmpty())
+        {
+            if (createIfMissing) xn=xbase.addChild(path);
+            else { *tend1=sep; return XMLNode::emptyXMLNode; }
+        }
+        *tend1=sep;
+        xbase=xn;
+        path=tend1+1;
+        tend1=xstrstr(path,sepString);
+    }
+    xn=xbase.getChildNode(path);
+    if (xn.isEmpty()&&createIfMissing) xn=xbase.addChild(path);
+    return xn;
+}
+
+XMLElementPosition XMLNode::positionOfText     (int i) const { if (i>=d->nText ) i=d->nText-1;  return findPosition(d,i,eNodeText ); }
+XMLElementPosition XMLNode::positionOfClear    (int i) const { if (i>=d->nClear) i=d->nClear-1; return findPosition(d,i,eNodeClear); }
+XMLElementPosition XMLNode::positionOfChildNode(int i) const { if (i>=d->nChild) i=d->nChild-1; return findPosition(d,i,eNodeChild); }
+XMLElementPosition XMLNode::positionOfText (XMLCSTR lpszValue) const { return positionOfText (indexText (lpszValue)); }
+XMLElementPosition XMLNode::positionOfClear(XMLCSTR lpszValue) const { return positionOfClear(indexClear(lpszValue)); }
+XMLElementPosition XMLNode::positionOfClear(XMLClear *a) const { if (a) return positionOfClear(a->lpszValue); return positionOfClear(); }
+XMLElementPosition XMLNode::positionOfChildNode(XMLNode x)  const
+{
+    if ((!d)||(!x.d)) return -1;
+    XMLNodeData *dd=x.d;
+    XMLNode *pc=d->pChild;
+    int i=d->nChild;
+    while (i--) if (pc[i].d==dd) return findPosition(d,i,eNodeChild);
+    return -1;
+}
+XMLElementPosition XMLNode::positionOfChildNode(XMLCSTR name, int count) const
+{
+    if (!name) return positionOfChildNode(count);
+    int j=0;
+    do { getChildNode(name,&j); if (j<0) return -1; } while (count--);
+    return findPosition(d,j-1,eNodeChild);
+}
+
+XMLNode XMLNode::getChildNodeWithAttribute(XMLCSTR name,XMLCSTR attributeName,XMLCSTR attributeValue, int *k) const
+{
+     int i=0,j;
+     if (k) i=*k;
+     XMLNode x;
+     XMLCSTR t;
+     do
+     {
+         x=getChildNode(name,&i);
+         if (!x.isEmpty())
+         {
+             if (attributeValue)
+             {
+                 j=0;
+                 do
+                 {
+                     t=x.getAttribute(attributeName,&j);
+                     if (t&&(xstricmp(attributeValue,t)==0)) { if (k) *k=i; return x; }
+                 } while (t);
+             } else
+             {
+                 if (x.isAttributeSet(attributeName)) { if (k) *k=i; return x; }
+             }
+         }
+     } while (!x.isEmpty());
+     return emptyXMLNode;
+}
+
+// Find an attribute on an node.
+XMLCSTR XMLNode::getAttribute(XMLCSTR lpszAttrib, int *j) const
+{
+    if (!d) return NULL;
+    int i=0,n=d->nAttribute;
+    if (j) i=*j;
+    XMLAttribute *pAttr=d->pAttribute+i;
+    for (; i<n; i++)
+    {
+        if (xstricmp(pAttr->lpszName, lpszAttrib)==0)
+        {
+            if (j) *j=i+1;
+            return pAttr->lpszValue;
+        }
+        pAttr++;
+    }
+    return NULL;
+}
+
+char XMLNode::isAttributeSet(XMLCSTR lpszAttrib) const
+{
+    if (!d) return FALSE;
+    int i,n=d->nAttribute;
+    XMLAttribute *pAttr=d->pAttribute;
+    for (i=0; i<n; i++)
+    {
+        if (xstricmp(pAttr->lpszName, lpszAttrib)==0)
+        {
+            return TRUE;
+        }
+        pAttr++;
+    }
+    return FALSE;
+}
+
+XMLCSTR XMLNode::getAttribute(XMLCSTR name, int j) const
+{
+    if (!d) return NULL;
+    int i=0;
+    while (j-->0) getAttribute(name,&i);
+    return getAttribute(name,&i);
+}
+
+XMLNodeContents XMLNode::enumContents(int i) const
+{
+    XMLNodeContents c;
+    if (!d) { c.etype=eNodeNULL; return c; }
+    if (i<d->nAttribute)
+    {
+        c.etype=eNodeAttribute;
+        c.attrib=d->pAttribute[i];
+        return c;
+    }
+    i-=d->nAttribute;
+    c.etype=(XMLElementType)(d->pOrder[i]&3);
+    i=(d->pOrder[i])>>2;
+    switch (c.etype)
+    {
+    case eNodeChild:     c.child = d->pChild[i];      break;
+    case eNodeText:      c.text  = d->pText[i];       break;
+    case eNodeClear:     c.clear = d->pClear[i];      break;
+    default: break;
+    }
+    return c;
+}
+
+XMLCSTR XMLNode::getName() const { if (!d) return NULL; return d->lpszName;   }
+int XMLNode::nText()       const { if (!d) return 0;    return d->nText;      }
+int XMLNode::nChildNode()  const { if (!d) return 0;    return d->nChild;     }
+int XMLNode::nAttribute()  const { if (!d) return 0;    return d->nAttribute; }
+int XMLNode::nClear()      const { if (!d) return 0;    return d->nClear;     }
+int XMLNode::nElement()    const { if (!d) return 0;    return d->nAttribute+d->nChild+d->nText+d->nClear; }
+XMLClear     XMLNode::getClear         (int i) const { if ((!d)||(i>=d->nClear    )) return emptyXMLClear;     return d->pClear[i];     }
+XMLAttribute XMLNode::getAttribute     (int i) const { if ((!d)||(i>=d->nAttribute)) return emptyXMLAttribute; return d->pAttribute[i]; }
+XMLCSTR      XMLNode::getAttributeName (int i) const { if ((!d)||(i>=d->nAttribute)) return NULL;              return d->pAttribute[i].lpszName;  }
+XMLCSTR      XMLNode::getAttributeValue(int i) const { if ((!d)||(i>=d->nAttribute)) return NULL;              return d->pAttribute[i].lpszValue; }
+XMLCSTR      XMLNode::getText          (int i) const { if ((!d)||(i>=d->nText     )) return NULL;              return d->pText[i];      }
+XMLNode      XMLNode::getChildNode     (int i) const { if ((!d)||(i>=d->nChild    )) return emptyXMLNode;      return d->pChild[i];     }
+XMLNode      XMLNode::getParentNode    (     ) const { if ((!d)||(!d->pParent     )) return emptyXMLNode;      return XMLNode(d->pParent); }
+char         XMLNode::isDeclaration    (     ) const { if (!d) return 0;             return d->isDeclaration; }
+char         XMLNode::isEmpty          (     ) const { return (d==NULL); }
+XMLNode       XMLNode::emptyNode       (     )       { return XMLNode::emptyXMLNode; }
+
+XMLNode       XMLNode::addChild(XMLCSTR lpszName, char isDeclaration, XMLElementPosition pos)
+              { return addChild_priv(0,stringDup(lpszName),isDeclaration,pos); }
+XMLNode       XMLNode::addChild_WOSD(XMLSTR lpszName, char isDeclaration, XMLElementPosition pos)
+              { return addChild_priv(0,lpszName,isDeclaration,pos); }
+XMLAttribute *XMLNode::addAttribute(XMLCSTR lpszName, XMLCSTR lpszValue)
+              { return addAttribute_priv(0,stringDup(lpszName),stringDup(lpszValue)); }
+XMLAttribute *XMLNode::addAttribute_WOSD(XMLSTR lpszName, XMLSTR lpszValuev)
+              { return addAttribute_priv(0,lpszName,lpszValuev); }
+XMLCSTR       XMLNode::addText(XMLCSTR lpszValue, XMLElementPosition pos)
+              { return addText_priv(0,stringDup(lpszValue),pos); }
+XMLCSTR       XMLNode::addText_WOSD(XMLSTR lpszValue, XMLElementPosition pos)
+              { return addText_priv(0,lpszValue,pos); }
+XMLClear     *XMLNode::addClear(XMLCSTR lpszValue, XMLCSTR lpszOpen, XMLCSTR lpszClose, XMLElementPosition pos)
+              { return addClear_priv(0,stringDup(lpszValue),lpszOpen,lpszClose,pos); }
+XMLClear     *XMLNode::addClear_WOSD(XMLSTR lpszValue, XMLCSTR lpszOpen, XMLCSTR lpszClose, XMLElementPosition pos)
+              { return addClear_priv(0,lpszValue,lpszOpen,lpszClose,pos); }
+XMLCSTR       XMLNode::updateName(XMLCSTR lpszName)
+              { return updateName_WOSD(stringDup(lpszName)); }
+XMLAttribute *XMLNode::updateAttribute(XMLAttribute *newAttribute, XMLAttribute *oldAttribute)
+              { return updateAttribute_WOSD(stringDup(newAttribute->lpszValue),stringDup(newAttribute->lpszName),oldAttribute->lpszName); }
+XMLAttribute *XMLNode::updateAttribute(XMLCSTR lpszNewValue, XMLCSTR lpszNewName,int i)
+              { return updateAttribute_WOSD(stringDup(lpszNewValue),stringDup(lpszNewName),i); }
+XMLAttribute *XMLNode::updateAttribute(XMLCSTR lpszNewValue, XMLCSTR lpszNewName,XMLCSTR lpszOldName)
+              { return updateAttribute_WOSD(stringDup(lpszNewValue),stringDup(lpszNewName),lpszOldName); }
+XMLCSTR       XMLNode::updateText(XMLCSTR lpszNewValue, int i)
+              { return updateText_WOSD(stringDup(lpszNewValue),i); }
+XMLCSTR       XMLNode::updateText(XMLCSTR lpszNewValue, XMLCSTR lpszOldValue)
+              { return updateText_WOSD(stringDup(lpszNewValue),lpszOldValue); }
+XMLClear     *XMLNode::updateClear(XMLCSTR lpszNewContent, int i)
+              { return updateClear_WOSD(stringDup(lpszNewContent),i); }
+XMLClear     *XMLNode::updateClear(XMLCSTR lpszNewValue, XMLCSTR lpszOldValue)
+              { return updateClear_WOSD(stringDup(lpszNewValue),lpszOldValue); }
+XMLClear     *XMLNode::updateClear(XMLClear *newP,XMLClear *oldP)
+              { return updateClear_WOSD(stringDup(newP->lpszValue),oldP->lpszValue); }
+
+char XMLNode::setGlobalOptions(XMLCharEncoding _characterEncoding, char _guessWideCharChars,
+                               char _dropWhiteSpace, char _removeCommentsInMiddleOfText)
+{
+    guessWideCharChars=_guessWideCharChars; dropWhiteSpace=_dropWhiteSpace; removeCommentsInMiddleOfText=_removeCommentsInMiddleOfText;
+#ifdef _XMLWIDECHAR
+    if (_characterEncoding) characterEncoding=_characterEncoding;
+#else
+    switch(_characterEncoding)
+    {
+    case char_encoding_UTF8:     characterEncoding=_characterEncoding; XML_ByteTable=XML_utf8ByteTable; break;
+    case char_encoding_legacy:   characterEncoding=_characterEncoding; XML_ByteTable=XML_legacyByteTable; break;
+    case char_encoding_ShiftJIS: characterEncoding=_characterEncoding; XML_ByteTable=XML_sjisByteTable; break;
+    case char_encoding_GB2312:   characterEncoding=_characterEncoding; XML_ByteTable=XML_gb2312ByteTable; break;
+    case char_encoding_Big5:
+    case char_encoding_GBK:      characterEncoding=_characterEncoding; XML_ByteTable=XML_gbk_big5_ByteTable; break;
+    default: return 1;
+    }
+#endif
+    return 0;
+}
+
+XMLNode::XMLCharEncoding XMLNode::guessCharEncoding(void *buf,int l, char useXMLEncodingAttribute)
+{
+#ifdef _XMLWIDECHAR
+    return (XMLCharEncoding)0;
+#else
+    if (l<25) return (XMLCharEncoding)0;
+    if (guessWideCharChars&&(myIsTextWideChar(buf,l))) return (XMLCharEncoding)0;
+    unsigned char *b=(unsigned char*)buf;
+    if ((b[0]==0xef)&&(b[1]==0xbb)&&(b[2]==0xbf)) return char_encoding_UTF8;
+
+    // Match utf-8 model ?
+    XMLCharEncoding bestGuess=char_encoding_UTF8;
+    int i=0;
+    while (i<l)
+        switch (XML_utf8ByteTable[b[i]])
+        {
+        case 4: i++; if ((i<l)&&(b[i]& 0xC0)!=0x80) { bestGuess=char_encoding_legacy; i=l; } // 10bbbbbb ?
+        case 3: i++; if ((i<l)&&(b[i]& 0xC0)!=0x80) { bestGuess=char_encoding_legacy; i=l; } // 10bbbbbb ?
+        case 2: i++; if ((i<l)&&(b[i]& 0xC0)!=0x80) { bestGuess=char_encoding_legacy; i=l; } // 10bbbbbb ?
+        case 1: i++; break;
+        case 0: i=l;
+        }
+    if (!useXMLEncodingAttribute) return bestGuess;
+    // if encoding is specified and different from utf-8 than it's non-utf8
+    // otherwise it's utf-8
+    char bb[201];
+    l=mmin(l,200);
+    memcpy(bb,buf,l); // copy buf into bb to be able to do "bb[l]=0"
+    bb[l]=0;
+    b=(unsigned char*)strstr(bb,"encoding");
+    if (!b) return bestGuess;
+    b+=8; while XML_isSPACECHAR(*b) b++; if (*b!='=') return bestGuess;
+    b++;  while XML_isSPACECHAR(*b) b++; if ((*b!='\'')&&(*b!='"')) return bestGuess;
+    b++;  while XML_isSPACECHAR(*b) b++;
+
+    if ((xstrnicmp((char*)b,"utf-8",5)==0)||
+        (xstrnicmp((char*)b,"utf8",4)==0))
+    {
+        if (bestGuess==char_encoding_legacy) return char_encoding_error;
+        return char_encoding_UTF8;
+    }
+
+    if ((xstrnicmp((char*)b,"shiftjis",8)==0)||
+        (xstrnicmp((char*)b,"shift-jis",9)==0)||
+        (xstrnicmp((char*)b,"sjis",4)==0)) return char_encoding_ShiftJIS;
+
+    if (xstrnicmp((char*)b,"GB2312",6)==0) return char_encoding_GB2312;
+    if (xstrnicmp((char*)b,"Big5",4)==0) return char_encoding_Big5;
+    if (xstrnicmp((char*)b,"GBK",3)==0) return char_encoding_GBK;
+
+    return char_encoding_legacy;
+#endif
+}
+#undef XML_isSPACECHAR
+
+//////////////////////////////////////////////////////////
+//      Here starts the base64 conversion functions.    //
+//////////////////////////////////////////////////////////
+
+static const char base64Fillchar = _CXML('='); // used to mark partial words at the end
+
+// this lookup table defines the base64 encoding
+XMLCSTR base64EncodeTable=_CXML("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
+
+// Decode Table gives the index of any valid base64 character in the Base64 table]
+// 96: '='  -   97: space char   -   98: illegal char   -   99: end of string
+const unsigned char base64DecodeTable[] = {
+    99,98,98,98,98,98,98,98,98,97,  97,98,98,97,98,98,98,98,98,98,  98,98,98,98,98,98,98,98,98,98,  //00 -29
+    98,98,97,98,98,98,98,98,98,98,  98,98,98,62,98,98,98,63,52,53,  54,55,56,57,58,59,60,61,98,98,  //30 -59
+    98,96,98,98,98, 0, 1, 2, 3, 4,   5, 6, 7, 8, 9,10,11,12,13,14,  15,16,17,18,19,20,21,22,23,24,  //60 -89
+    25,98,98,98,98,98,98,26,27,28,  29,30,31,32,33,34,35,36,37,38,  39,40,41,42,43,44,45,46,47,48,  //90 -119
+    49,50,51,98,98,98,98,98,98,98,  98,98,98,98,98,98,98,98,98,98,  98,98,98,98,98,98,98,98,98,98,  //120 -149
+    98,98,98,98,98,98,98,98,98,98,  98,98,98,98,98,98,98,98,98,98,  98,98,98,98,98,98,98,98,98,98,  //150 -179
+    98,98,98,98,98,98,98,98,98,98,  98,98,98,98,98,98,98,98,98,98,  98,98,98,98,98,98,98,98,98,98,  //180 -209
+    98,98,98,98,98,98,98,98,98,98,  98,98,98,98,98,98,98,98,98,98,  98,98,98,98,98,98,98,98,98,98,  //210 -239
+    98,98,98,98,98,98,98,98,98,98,  98,98,98,98,98,98                                               //240 -255
+};
+
+XMLParserBase64Tool::~XMLParserBase64Tool(){ freeBuffer(); }
+
+void XMLParserBase64Tool::freeBuffer(){ if (buf) free(buf); buf=NULL; buflen=0; }
+
+int XMLParserBase64Tool::encodeLength(int inlen, char formatted)
+{
+    unsigned int i=((inlen-1)/3*4+4+1);
+    if (formatted) i+=inlen/54;
+    return i;
+}
+
+XMLSTR XMLParserBase64Tool::encode(unsigned char *inbuf, unsigned int inlen, char formatted)
+{
+    int i=encodeLength(inlen,formatted),k=17,eLen=inlen/3,j;
+    alloc(i*sizeof(XMLCHAR));
+    XMLSTR curr=(XMLSTR)buf;
+    for(i=0;i<eLen;i++)
+    {
+        // Copy next three bytes into lower 24 bits of int, paying attention to sign.
+        j=(inbuf[0]<<16)|(inbuf[1]<<8)|inbuf[2]; inbuf+=3;
+        // Encode the int into four chars
+        *(curr++)=base64EncodeTable[ j>>18      ];
+        *(curr++)=base64EncodeTable[(j>>12)&0x3f];
+        *(curr++)=base64EncodeTable[(j>> 6)&0x3f];
+        *(curr++)=base64EncodeTable[(j    )&0x3f];
+        if (formatted) { if (!k) { *(curr++)=_CXML('\n'); k=18; } k--; }
+    }
+    eLen=inlen-eLen*3; // 0 - 2.
+    if (eLen==1)
+    {
+        *(curr++)=base64EncodeTable[ inbuf[0]>>2      ];
+        *(curr++)=base64EncodeTable[(inbuf[0]<<4)&0x3F];
+        *(curr++)=base64Fillchar;
+        *(curr++)=base64Fillchar;
+    } else if (eLen==2)
+    {
+        j=(inbuf[0]<<8)|inbuf[1];
+        *(curr++)=base64EncodeTable[ j>>10      ];
+        *(curr++)=base64EncodeTable[(j>> 4)&0x3f];
+        *(curr++)=base64EncodeTable[(j<< 2)&0x3f];
+        *(curr++)=base64Fillchar;
+    }
+    *(curr++)=0;
+    return (XMLSTR)buf;
+}
+
+unsigned int XMLParserBase64Tool::decodeSize(XMLCSTR data,XMLError *xe)
+{
+    if (!data) return 0;
+    if (xe) *xe=eXMLErrorNone;
+    int size=0;
+    unsigned char c;
+    //skip any extra characters (e.g. newlines or spaces)
+    while (*data)
+    {
+#ifdef _XMLWIDECHAR
+        if (*data>255) { if (xe) *xe=eXMLErrorBase64DecodeIllegalCharacter; return 0; }
+#endif
+        c=base64DecodeTable[(unsigned char)(*data)];
+        if (c<97) size++;
+        else if (c==98) { if (xe) *xe=eXMLErrorBase64DecodeIllegalCharacter; return 0; }
+        data++;
+    }
+    if (xe&&(size%4!=0)) *xe=eXMLErrorBase64DataSizeIsNotMultipleOf4;
+    if (size==0) return 0;
+    do { data--; size--; } while(*data==base64Fillchar); size++;
+    return (unsigned int)((size*3)/4);
+}
+
+unsigned char XMLParserBase64Tool::decode(XMLCSTR data, unsigned char *buf, int len, XMLError *xe)
+{
+    if (!data) return 0;
+    if (xe) *xe=eXMLErrorNone;
+    int i=0,p=0;
+    unsigned char d,c;
+    for(;;)
+    {
+
+#ifdef _XMLWIDECHAR
+#define BASE64DECODE_READ_NEXT_CHAR(c)                                              \
+        do {                                                                        \
+            if (data[i]>255){ c=98; break; }                                        \
+            c=base64DecodeTable[(unsigned char)data[i++]];                       \
+        }while (c==97);                                                             \
+        if(c==98){ if(xe)*xe=eXMLErrorBase64DecodeIllegalCharacter; return 0; }
+#else
+#define BASE64DECODE_READ_NEXT_CHAR(c)                                           \
+        do { c=base64DecodeTable[(unsigned char)data[i++]]; }while (c==97);   \
+        if(c==98){ if(xe)*xe=eXMLErrorBase64DecodeIllegalCharacter; return 0; }
+#endif
+
+        BASE64DECODE_READ_NEXT_CHAR(c)
+        if (c==99) { return 2; }
+        if (c==96)
+        {
+            if (p==(int)len) return 2;
+            if (xe) *xe=eXMLErrorBase64DecodeTruncatedData;
+            return 1;
+        }
+
+        BASE64DECODE_READ_NEXT_CHAR(d)
+        if ((d==99)||(d==96)) { if (xe) *xe=eXMLErrorBase64DecodeTruncatedData;  return 1; }
+        if (p==(int)len) {      if (xe) *xe=eXMLErrorBase64DecodeBufferTooSmall; return 0; }
+        buf[p++]=(unsigned char)((c<<2)|((d>>4)&0x3));
+
+        BASE64DECODE_READ_NEXT_CHAR(c)
+        if (c==99) { if (xe) *xe=eXMLErrorBase64DecodeTruncatedData;  return 1; }
+        if (p==(int)len)
+        {
+            if (c==96) return 2;
+            if (xe) *xe=eXMLErrorBase64DecodeBufferTooSmall;
+            return 0;
+        }
+        if (c==96) { if (xe) *xe=eXMLErrorBase64DecodeTruncatedData;  return 1; }
+        buf[p++]=(unsigned char)(((d<<4)&0xf0)|((c>>2)&0xf));
+
+        BASE64DECODE_READ_NEXT_CHAR(d)
+        if (d==99 ) { if (xe) *xe=eXMLErrorBase64DecodeTruncatedData;  return 1; }
+        if (p==(int)len)
+        {
+            if (d==96) return 2;
+            if (xe) *xe=eXMLErrorBase64DecodeBufferTooSmall;
+            return 0;
+        }
+        if (d==96) { if (xe) *xe=eXMLErrorBase64DecodeTruncatedData;  return 1; }
+        buf[p++]=(unsigned char)(((c<<6)&0xc0)|d);
+    }
+}
+#undef BASE64DECODE_READ_NEXT_CHAR
+
+void XMLParserBase64Tool::alloc(int newsize)
+{
+    if ((!buf)&&(newsize)) { buf=malloc(newsize); buflen=newsize; return; }
+    if (newsize>buflen) { buf=realloc(buf,newsize); buflen=newsize; }
+}
+
+unsigned char *XMLParserBase64Tool::decode(XMLCSTR data, int *outlen, XMLError *xe)
+{
+    if (xe) *xe=eXMLErrorNone;
+    if (!data) { *outlen=0; return (unsigned char*)""; }
+    unsigned int len=decodeSize(data,xe);
+    if (outlen) *outlen=len;
+    if (!len) return NULL;
+    alloc(len+1);
+    if(!decode(data,(unsigned char*)buf,len,xe)){ return NULL; }
+    return (unsigned char*)buf;
+}
+
diff --git a/xbmc/pvrclients/vuplus/xmlParser.h b/xbmc/pvrclients/vuplus/xmlParser.h
new file mode 100644
index 0000000..56b29d7
--- /dev/null
+++ b/xbmc/pvrclients/vuplus/xmlParser.h
@@ -0,0 +1,733 @@
+/****************************************************************************/
+/*! \mainpage XMLParser library
+ * \section intro_sec Introduction
+ *
+ * This is a basic XML parser written in ANSI C++ for portability.
+ * It works by using recursion and a node tree for breaking
+ * down the elements of an XML document.
+ *
+ * @version     V2.43
+ * @author      Frank Vanden Berghen
+ *
+ * Copyright (c) 2002, Business-Insight
+ * <a href="http://www.Business-Insight.com">Business-Insight</a>
+ * All rights reserved.
+ * See the file <a href="../../AFPL-license.txt">AFPL-license.txt</a> about the licensing terms
+ *
+ * \section tutorial First Tutorial
+ * You can follow a simple <a href="../../xmlParser.html">Tutorial</a> to know the basics...
+ *
+ * \section usage General usage: How to include the XMLParser library inside your project.
+ *
+ * The library is composed of two files: <a href="../../xmlParser.cpp">xmlParser.cpp</a> and
+ * <a href="../../xmlParser.h">xmlParser.h</a>. These are the ONLY 2 files that you need when
+ * using the library inside your own projects.
+ *
+ * All the functions of the library are documented inside the comments of the file
+ * <a href="../../xmlParser.h">xmlParser.h</a>. These comments can be transformed in
+ * full-fledged HTML documentation using the DOXYGEN software: simply type: "doxygen doxy.cfg"
+ *
+ * By default, the XMLParser library uses (char*) for string representation.To use the (wchar_t*)
+ * version of the library, you need to define the "_UNICODE" preprocessor definition variable
+ * (this is usually done inside your project definition file) (This is done automatically for you
+ * when using Visual Studio).
+ *
+ * \section example Advanced Tutorial and Many Examples of usage.
+ *
+ * Some very small introductory examples are described inside the Tutorial file
+ * <a href="../../xmlParser.html">xmlParser.html</a>
+ *
+ * Some additional small examples are also inside the file <a href="../../xmlTest.cpp">xmlTest.cpp</a>
+ * (for the "char*" version of the library) and inside the file
+ * <a href="../../xmlTestUnicode.cpp">xmlTestUnicode.cpp</a> (for the "wchar_t*"
+ * version of the library). If you have a question, please review these additionnal examples
+ * before sending an e-mail to the author.
+ *
+ * To build the examples:
+ * - linux/unix: type "make"
+ * - solaris: type "make -f makefile.solaris"
+ * - windows: Visual Studio: double-click on xmlParser.dsw
+ *   (under Visual Studio .NET, the .dsp and .dsw files will be automatically converted to .vcproj and .sln files)
+ *
+ * In order to build the examples you need some additional files:
+ * - linux/unix: makefile
+ * - solaris: makefile.solaris
+ * - windows: Visual Studio: *.dsp, xmlParser.dsw and also xmlParser.lib and xmlParser.dll
+ *
+ * \section debugging Debugging with the XMLParser library
+ *
+ * \subsection debugwin Debugging under WINDOWS
+ *
+ * 	Inside Visual C++, the "debug versions" of the memory allocation functions are
+ * 	very slow: Do not forget to compile in "release mode" to get maximum speed.
+ * 	When I had to debug a software that was using the XMLParser Library, it was usually
+ * 	a nightmare because the library was sooOOOoooo slow in debug mode (because of the
+ *  slow memory allocations in Debug mode). To solve this
+ * 	problem, during all the debugging session, I am now using a very fast DLL version of the
+ * 	XMLParser Library (the DLL is compiled in release mode). Using the DLL version of
+ * 	the XMLParser Library allows me to have lightening XML parsing speed even in debug!
+ * 	Other than that, the DLL version is useless: In the release version of my tool,
+ * 	I always use the normal, ".cpp"-based, XMLParser Library (I simply include the
+ * <a href="../../xmlParser.cpp">xmlParser.cpp</a> and
+ * <a href="../../xmlParser.h">xmlParser.h</a> files into the project).
+ *
+ * 	The file <a href="../../XMLNodeAutoexp.txt">XMLNodeAutoexp.txt</a> contains some
+ * "tweaks" that improve substancially the display of the content of the XMLNode objects
+ * inside the Visual Studio Debugger. Believe me, once you have seen inside the debugger
+ * the "smooth" display of the XMLNode objects, you cannot live without it anymore!
+ *
+ * \subsection debuglinux Debugging under LINUX/UNIX
+ *
+ * 	The speed of the debug version of the XMLParser library is tolerable so no extra
+ * work.has been done.
+ *
+ ****************************************************************************/
+
+#ifndef __INCLUDE_XML_NODE__
+#define __INCLUDE_XML_NODE__
+
+#include <stdlib.h>
+
+#ifdef _UNICODE
+// If you comment the next "define" line then the library will never "switch to" _UNICODE (wchar_t*) mode (16/32 bits per characters).
+// This is useful when you get error messages like:
+//    'XMLNode::openFileHelper' : cannot convert parameter 2 from 'const char [5]' to 'const wchar_t *'
+// The _XMLWIDECHAR preprocessor variable force the XMLParser library into either utf16/32-mode (the proprocessor variable
+// must be defined) or utf8-mode(the pre-processor variable must be undefined).
+#define _XMLWIDECHAR
+#endif
+
+#if defined(WIN32) || defined(UNDER_CE) || defined(_WIN32) || defined(WIN64) || defined(__BORLANDC__)
+// comment the next line if you are under windows and the compiler is not Microsoft Visual Studio (6.0 or .NET) or Borland
+#define _XMLWINDOWS
+#endif
+
+#ifdef XMLDLLENTRY
+#undef XMLDLLENTRY
+#endif
+#ifdef _USE_XMLPARSER_DLL
+#ifdef _DLL_EXPORTS_
+#define XMLDLLENTRY __declspec(dllexport)
+#else
+#define XMLDLLENTRY __declspec(dllimport)
+#endif
+#else
+#define XMLDLLENTRY
+#endif
+
+// uncomment the next line if you want no support for wchar_t* (no need for the <wchar.h> or <tchar.h> libraries anymore to compile)
+//#define XML_NO_WIDE_CHAR
+
+#ifdef XML_NO_WIDE_CHAR
+#undef _XMLWINDOWS
+#undef _XMLWIDECHAR
+#endif
+
+#ifdef _XMLWINDOWS
+#include <tchar.h>
+#else
+#define XMLDLLENTRY
+#ifndef XML_NO_WIDE_CHAR
+#include <wchar.h> // to have 'wcsrtombs' for ANSI version
+                   // to have 'mbsrtowcs' for WIDECHAR version
+#endif
+#endif
+
+// Some common types for char set portable code
+#ifdef _XMLWIDECHAR
+    #define _CXML(c) L ## c
+    #define XMLCSTR const wchar_t *
+    #define XMLSTR  wchar_t *
+    #define XMLCHAR wchar_t
+#else
+    #define _CXML(c) c
+    #define XMLCSTR const char *
+    #define XMLSTR  char *
+    #define XMLCHAR char
+#endif
+#ifndef FALSE
+    #define FALSE 0
+#endif /* FALSE */
+#ifndef TRUE
+    #define TRUE 1
+#endif /* TRUE */
+
+
+/// Enumeration for XML parse errors.
+typedef enum XMLError
+{
+    eXMLErrorNone = 0,
+    eXMLErrorMissingEndTag,
+    eXMLErrorNoXMLTagFound,
+    eXMLErrorEmpty,
+    eXMLErrorMissingTagName,
+    eXMLErrorMissingEndTagName,
+    eXMLErrorUnmatchedEndTag,
+    eXMLErrorUnmatchedEndClearTag,
+    eXMLErrorUnexpectedToken,
+    eXMLErrorNoElements,
+    eXMLErrorFileNotFound,
+    eXMLErrorFirstTagNotFound,
+    eXMLErrorUnknownCharacterEntity,
+    eXMLErrorCharacterCodeAbove255,
+    eXMLErrorCharConversionError,
+    eXMLErrorCannotOpenWriteFile,
+    eXMLErrorCannotWriteFile,
+
+    eXMLErrorBase64DataSizeIsNotMultipleOf4,
+    eXMLErrorBase64DecodeIllegalCharacter,
+    eXMLErrorBase64DecodeTruncatedData,
+    eXMLErrorBase64DecodeBufferTooSmall
+} XMLError;
+
+
+/// Enumeration used to manage type of data. Use in conjunction with structure XMLNodeContents
+typedef enum XMLElementType
+{
+    eNodeChild=0,
+    eNodeAttribute=1,
+    eNodeText=2,
+    eNodeClear=3,
+    eNodeNULL=4
+} XMLElementType;
+
+/// Structure used to obtain error details if the parse fails.
+typedef struct XMLResults
+{
+    enum XMLError error;
+    int  nLine,nColumn;
+} XMLResults;
+
+/// Structure for XML clear (unformatted) node (usually comments)
+typedef struct XMLClear {
+    XMLCSTR lpszValue; XMLCSTR lpszOpenTag; XMLCSTR lpszCloseTag;
+} XMLClear;
+
+/// Structure for XML attribute.
+typedef struct XMLAttribute {
+    XMLCSTR lpszName; XMLCSTR lpszValue;
+} XMLAttribute;
+
+/// XMLElementPosition are not interchangeable with simple indexes
+typedef int XMLElementPosition;
+
+struct XMLNodeContents;
+
+/** @defgroup XMLParserGeneral The XML parser */
+
+/// Main Class representing a XML node
+/**
+ * All operations are performed using this class.
+ * \note The constructors of the XMLNode class are protected, so use instead one of these four methods to get your first instance of XMLNode:
+ * <ul>
+ *    <li> XMLNode::parseString </li>
+ *    <li> XMLNode::parseFile </li>
+ *    <li> XMLNode::openFileHelper </li>
+ *    <li> XMLNode::createXMLTopNode (or XMLNode::createXMLTopNode_WOSD)</li>
+ * </ul> */
+typedef struct XMLDLLENTRY XMLNode
+{
+  private:
+
+    struct XMLNodeDataTag;
+
+    /// Constructors are protected, so use instead one of: XMLNode::parseString, XMLNode::parseFile, XMLNode::openFileHelper, XMLNode::createXMLTopNode
+    XMLNode(struct XMLNodeDataTag *pParent, XMLSTR lpszName, char isDeclaration);
+    /// Constructors are protected, so use instead one of: XMLNode::parseString, XMLNode::parseFile, XMLNode::openFileHelper, XMLNode::createXMLTopNode
+    XMLNode(struct XMLNodeDataTag *p);
+
+  public:
+    static XMLCSTR getVersion();///< Return the XMLParser library version number
+
+    /** @defgroup conversions Parsing XML files/strings to an XMLNode structure and Rendering XMLNode's to files/string.
+     * @ingroup XMLParserGeneral
+     * @{ */
+
+    /// Parse an XML string and return the root of a XMLNode tree representing the string.
+    static XMLNode parseString   (XMLCSTR  lpXMLString, XMLCSTR tag=NULL, XMLResults *pResults=NULL);
+    /**< The "parseString" function parse an XML string and return the root of a XMLNode tree. The "opposite" of this function is
+     * the function "createXMLString" that re-creates an XML string from an XMLNode tree. If the XML document is corrupted, the
+     * "parseString" method will initialize the "pResults" variable with some information that can be used to trace the error.
+     * If you still want to parse the file, you can use the APPROXIMATE_PARSING option as explained inside the note at the
+     * beginning of the "xmlParser.cpp" file.
+     *
+     * @param lpXMLString the XML string to parse
+     * @param tag  the name of the first tag inside the XML file. If the tag parameter is omitted, this function returns a node that represents the head of the xml document including the declaration term (<? ... ?>).
+     * @param pResults a pointer to a XMLResults variable that will contain some information that can be used to trace the XML parsing error. You can have a user-friendly explanation of the parsing error with the "getError" function.
+     */
+
+    /// Parse an XML file and return the root of a XMLNode tree representing the file.
+    static XMLNode parseFile     (XMLCSTR     filename, XMLCSTR tag=NULL, XMLResults *pResults=NULL);
+    /**< The "parseFile" function parse an XML file and return the root of a XMLNode tree. The "opposite" of this function is
+     * the function "writeToFile" that re-creates an XML file from an XMLNode tree. If the XML document is corrupted, the
+     * "parseFile" method will initialize the "pResults" variable with some information that can be used to trace the error.
+     * If you still want to parse the file, you can use the APPROXIMATE_PARSING option as explained inside the note at the
+     * beginning of the "xmlParser.cpp" file.
+     *
+     * @param filename the path to the XML file to parse
+     * @param tag the name of the first tag inside the XML file. If the tag parameter is omitted, this function returns a node that represents the head of the xml document including the declaration term (<? ... ?>).
+     * @param pResults a pointer to a XMLResults variable that will contain some information that can be used to trace the XML parsing error. You can have a user-friendly explanation of the parsing error with the "getError" function.
+     */
+
+    /// Parse an XML file and return the root of a XMLNode tree representing the file. A very crude error checking is made. An attempt to guess the Char Encoding used in the file is made.
+    static XMLNode openFileHelper(XMLCSTR     filename, XMLCSTR tag=NULL);
+    /**< The "openFileHelper" function reports to the screen all the warnings and errors that occurred during parsing of the XML file.
+     * This function also tries to guess char Encoding (UTF-8, ASCII or SHIT-JIS) based on the first 200 bytes of the file. Since each
+     * application has its own way to report and deal with errors, you should rather use the "parseFile" function to parse XML files
+     * and program yourself thereafter an "error reporting" tailored for your needs (instead of using the very crude "error reporting"
+     * mechanism included inside the "openFileHelper" function).
+     *
+     * If the XML document is corrupted, the "openFileHelper" method will:
+     *         - display an error message on the console (or inside a messageBox for windows).
+     *         - stop execution (exit).
+     *
+     * I strongly suggest that you write your own "openFileHelper" method tailored to your needs. If you still want to parse
+     * the file, you can use the APPROXIMATE_PARSING option as explained inside the note at the beginning of the "xmlParser.cpp" file.
+     *
+     * @param filename the path of the XML file to parse.
+     * @param tag the name of the first tag inside the XML file. If the tag parameter is omitted, this function returns a node that represents the head of the xml document including the declaration term (<? ... ?>).
+     */
+
+    static XMLCSTR getError(XMLError error); ///< this gives you a user-friendly explanation of the parsing error
+
+    /// Create an XML string starting from the current XMLNode.
+    XMLSTR createXMLString(int nFormat=1, int *pnSize=NULL) const;
+    /**< The returned string should be free'd using the "freeXMLString" function.
+     *
+     *   If nFormat==0, no formatting is required otherwise this returns an user friendly XML string from a given element
+     *   with appropriate white spaces and carriage returns. if pnSize is given it returns the size in character of the string. */
+
+    /// Save the content of an xmlNode inside a file
+    XMLError writeToFile(XMLCSTR filename,
+                         const char *encoding=NULL,
+                         char nFormat=1) const;
+    /**< If nFormat==0, no formatting is required otherwise this returns an user friendly XML string from a given element with appropriate white spaces and carriage returns.
+     * If the global parameter "characterEncoding==encoding_UTF8", then the "encoding" parameter is ignored and always set to "utf-8".
+     * If the global parameter "characterEncoding==encoding_ShiftJIS", then the "encoding" parameter is ignored and always set to "SHIFT-JIS".
+     * If "_XMLWIDECHAR=1", then the "encoding" parameter is ignored and always set to "utf-16".
+     * If no "encoding" parameter is given the "ISO-8859-1" encoding is used. */
+    /** @} */
+
+    /** @defgroup navigate Navigate the XMLNode structure
+     * @ingroup XMLParserGeneral
+     * @{ */
+    XMLCSTR getName() const;                                       ///< name of the node
+    XMLCSTR getText(int i=0) const;                                ///< return ith text field
+    int nText() const;                                             ///< nbr of text field
+    XMLNode getParentNode() const;                                 ///< return the parent node
+    XMLNode getChildNode(int i=0) const;                           ///< return ith child node
+    XMLNode getChildNode(XMLCSTR name, int i)  const;              ///< return ith child node with specific name (return an empty node if failing). If i==-1, this returns the last XMLNode with the given name.
+    XMLNode getChildNode(XMLCSTR name, int *i=NULL) const;         ///< return next child node with specific name (return an empty node if failing)
+    XMLNode getChildNodeWithAttribute(XMLCSTR tagName,
+                                      XMLCSTR attributeName,
+                                      XMLCSTR attributeValue=NULL,
+                                      int *i=NULL)  const;         ///< return child node with specific name/attribute (return an empty node if failing)
+    XMLNode getChildNodeByPath(XMLCSTR path, char createNodeIfMissing=0, XMLCHAR sep='/');
+                                                                   ///< return the first child node with specific path
+    XMLNode getChildNodeByPathNonConst(XMLSTR  path, char createNodeIfMissing=0, XMLCHAR sep='/');
+                                                                   ///< return the first child node with specific path.
+
+    int nChildNode(XMLCSTR name) const;                            ///< return the number of child node with specific name
+    int nChildNode() const;                                        ///< nbr of child node
+    XMLAttribute getAttribute(int i=0) const;                      ///< return ith attribute
+    XMLCSTR      getAttributeName(int i=0) const;                  ///< return ith attribute name
+    XMLCSTR      getAttributeValue(int i=0) const;                 ///< return ith attribute value
+    char  isAttributeSet(XMLCSTR name) const;                      ///< test if an attribute with a specific name is given
+    XMLCSTR getAttribute(XMLCSTR name, int i) const;               ///< return ith attribute content with specific name (return a NULL if failing)
+    XMLCSTR getAttribute(XMLCSTR name, int *i=NULL) const;         ///< return next attribute content with specific name (return a NULL if failing)
+    int nAttribute() const;                                        ///< nbr of attribute
+    XMLClear getClear(int i=0) const;                              ///< return ith clear field (comments)
+    int nClear() const;                                            ///< nbr of clear field
+    XMLNodeContents enumContents(XMLElementPosition i) const;      ///< enumerate all the different contents (attribute,child,text, clear) of the current XMLNode. The order is reflecting the order of the original file/string. NOTE: 0 <= i < nElement();
+    int nElement() const;                                          ///< nbr of different contents for current node
+    char isEmpty() const;                                          ///< is this node Empty?
+    char isDeclaration() const;                                    ///< is this node a declaration <? .... ?>
+    XMLNode deepCopy() const;                                      ///< deep copy (duplicate/clone) a XMLNode
+    static XMLNode emptyNode();                                    ///< return XMLNode::emptyXMLNode;
+    /** @} */
+
+    ~XMLNode();
+    XMLNode(const XMLNode &A);                                     ///< to allow shallow/fast copy:
+    XMLNode& operator=( const XMLNode& A );                        ///< to allow shallow/fast copy:
+
+    XMLNode(): d(NULL){};
+    static XMLNode emptyXMLNode;
+    static XMLClear emptyXMLClear;
+    static XMLAttribute emptyXMLAttribute;
+
+    /** @defgroup xmlModify Create or Update the XMLNode structure
+     * @ingroup XMLParserGeneral
+     *  The functions in this group allows you to create from scratch (or update) a XMLNode structure. Start by creating your top
+     *  node with the "createXMLTopNode" function and then add new nodes with the "addChild" function. The parameter 'pos' gives
+     *  the position where the childNode, the text or the XMLClearTag will be inserted. The default value (pos=-1) inserts at the
+     *  end. The value (pos=0) insert at the beginning (Insertion at the beginning is slower than at the end). <br>
+     *
+     *  REMARK: 0 <= pos < nChild()+nText()+nClear() <br>
+     */
+
+    /** @defgroup creation Creating from scratch a XMLNode structure
+     * @ingroup xmlModify
+     * @{ */
+    static XMLNode createXMLTopNode(XMLCSTR lpszName, char isDeclaration=FALSE);                    ///< Create the top node of an XMLNode structure
+    XMLNode        addChild(XMLCSTR lpszName, char isDeclaration=FALSE, XMLElementPosition pos=-1); ///< Add a new child node
+    XMLNode        addChild(XMLNode nodeToAdd, XMLElementPosition pos=-1);                          ///< If the "nodeToAdd" has some parents, it will be detached from it's parents before being attached to the current XMLNode
+    XMLAttribute  *addAttribute(XMLCSTR lpszName, XMLCSTR lpszValuev);                              ///< Add a new attribute
+    XMLCSTR        addText(XMLCSTR lpszValue, XMLElementPosition pos=-1);                           ///< Add a new text content
+    XMLClear      *addClear(XMLCSTR lpszValue, XMLCSTR lpszOpen=NULL, XMLCSTR lpszClose=NULL, XMLElementPosition pos=-1);
+    /**< Add a new clear tag
+     * @param lpszOpen default value "<![CDATA["
+     * @param lpszClose default value "]]>"
+     */
+    /** @} */
+
+    /** @defgroup xmlUpdate Updating Nodes
+     * @ingroup xmlModify
+     * Some update functions:
+     * @{
+     */
+    XMLCSTR       updateName(XMLCSTR lpszName);                                                  ///< change node's name
+    XMLAttribute *updateAttribute(XMLAttribute *newAttribute, XMLAttribute *oldAttribute);       ///< if the attribute to update is missing, a new one will be added
+    XMLAttribute *updateAttribute(XMLCSTR lpszNewValue, XMLCSTR lpszNewName=NULL,int i=0);       ///< if the attribute to update is missing, a new one will be added
+    XMLAttribute *updateAttribute(XMLCSTR lpszNewValue, XMLCSTR lpszNewName,XMLCSTR lpszOldName);///< set lpszNewName=NULL if you don't want to change the name of the attribute if the attribute to update is missing, a new one will be added
+    XMLCSTR       updateText(XMLCSTR lpszNewValue, int i=0);                                     ///< if the text to update is missing, a new one will be added
+    XMLCSTR       updateText(XMLCSTR lpszNewValue, XMLCSTR lpszOldValue);                        ///< if the text to update is missing, a new one will be added
+    XMLClear     *updateClear(XMLCSTR lpszNewContent, int i=0);                                  ///< if the clearTag to update is missing, a new one will be added
+    XMLClear     *updateClear(XMLClear *newP,XMLClear *oldP);                                    ///< if the clearTag to update is missing, a new one will be added
+    XMLClear     *updateClear(XMLCSTR lpszNewValue, XMLCSTR lpszOldValue);                       ///< if the clearTag to update is missing, a new one will be added
+    /** @} */
+
+    /** @defgroup xmlDelete Deleting Nodes or Attributes
+     * @ingroup xmlModify
+     * Some deletion functions:
+     * @{
+     */
+    /// The "deleteNodeContent" function forces the deletion of the content of this XMLNode and the subtree.
+    void deleteNodeContent();
+    /**< \note The XMLNode instances that are referring to the part of the subtree that has been deleted CANNOT be used anymore!!. Unexpected results will occur if you continue using them. */
+    void deleteAttribute(int i=0);                   ///< Delete the ith attribute of the current XMLNode
+    void deleteAttribute(XMLCSTR lpszName);          ///< Delete the attribute with the given name (the "strcmp" function is used to find the right attribute)
+    void deleteAttribute(XMLAttribute *anAttribute); ///< Delete the attribute with the name "anAttribute->lpszName" (the "strcmp" function is used to find the right attribute)
+    void deleteText(int i=0);                        ///< Delete the Ith text content of the current XMLNode
+    void deleteText(XMLCSTR lpszValue);              ///< Delete the text content "lpszValue" inside the current XMLNode (direct "pointer-to-pointer" comparison is used to find the right text)
+    void deleteClear(int i=0);                       ///< Delete the Ith clear tag inside the current XMLNode
+    void deleteClear(XMLCSTR lpszValue);             ///< Delete the clear tag "lpszValue" inside the current XMLNode (direct "pointer-to-pointer" comparison is used to find the clear tag)
+    void deleteClear(XMLClear *p);                   ///< Delete the clear tag "p" inside the current XMLNode (direct "pointer-to-pointer" comparison on the lpszName of the clear tag is used to find the clear tag)
+    /** @} */
+
+    /** @defgroup xmlWOSD ???_WOSD functions.
+     * @ingroup xmlModify
+     *  The strings given as parameters for the "add" and "update" methods that have a name with
+     *  the postfix "_WOSD" (that means "WithOut String Duplication")(for example "addText_WOSD")
+     *  will be free'd by the XMLNode class. For example, it means that this is incorrect:
+     *  \code
+     *     xNode.addText_WOSD("foo");
+     *     xNode.updateAttribute_WOSD("#newcolor" ,NULL,"color");
+     *  \endcode
+     *  In opposition, this is correct:
+     *  \code
+     *     xNode.addText("foo");
+     *     xNode.addText_WOSD(stringDup("foo"));
+     *     xNode.updateAttribute("#newcolor" ,NULL,"color");
+     *     xNode.updateAttribute_WOSD(stringDup("#newcolor"),NULL,"color");
+     *  \endcode
+     *  Typically, you will never do:
+     *  \code
+     *     char *b=(char*)malloc(...);
+     *     xNode.addText(b);
+     *     free(b);
+     *  \endcode
+     *  ... but rather:
+     *  \code
+     *     char *b=(char*)malloc(...);
+     *     xNode.addText_WOSD(b);
+     *  \endcode
+     *  ('free(b)' is performed by the XMLNode class)
+     * @{ */
+    static XMLNode createXMLTopNode_WOSD(XMLSTR lpszName, char isDeclaration=FALSE);                     ///< Create the top node of an XMLNode structure
+    XMLNode        addChild_WOSD(XMLSTR lpszName, char isDeclaration=FALSE, XMLElementPosition pos=-1);  ///< Add a new child node
+    XMLAttribute  *addAttribute_WOSD(XMLSTR lpszName, XMLSTR lpszValue);                                 ///< Add a new attribute
+    XMLCSTR        addText_WOSD(XMLSTR lpszValue, XMLElementPosition pos=-1);                            ///< Add a new text content
+    XMLClear      *addClear_WOSD(XMLSTR lpszValue, XMLCSTR lpszOpen=NULL, XMLCSTR lpszClose=NULL, XMLElementPosition pos=-1); ///< Add a new clear Tag
+
+    XMLCSTR        updateName_WOSD(XMLSTR lpszName);                                                  ///< change node's name
+    XMLAttribute  *updateAttribute_WOSD(XMLAttribute *newAttribute, XMLAttribute *oldAttribute);      ///< if the attribute to update is missing, a new one will be added
+    XMLAttribute  *updateAttribute_WOSD(XMLSTR lpszNewValue, XMLSTR lpszNewName=NULL,int i=0);        ///< if the attribute to update is missing, a new one will be added
+    XMLAttribute  *updateAttribute_WOSD(XMLSTR lpszNewValue, XMLSTR lpszNewName,XMLCSTR lpszOldName); ///< set lpszNewName=NULL if you don't want to change the name of the attribute if the attribute to update is missing, a new one will be added
+    XMLCSTR        updateText_WOSD(XMLSTR lpszNewValue, int i=0);                                     ///< if the text to update is missing, a new one will be added
+    XMLCSTR        updateText_WOSD(XMLSTR lpszNewValue, XMLCSTR lpszOldValue);                        ///< if the text to update is missing, a new one will be added
+    XMLClear      *updateClear_WOSD(XMLSTR lpszNewContent, int i=0);                                  ///< if the clearTag to update is missing, a new one will be added
+    XMLClear      *updateClear_WOSD(XMLClear *newP,XMLClear *oldP);                                   ///< if the clearTag to update is missing, a new one will be added
+    XMLClear      *updateClear_WOSD(XMLSTR lpszNewValue, XMLCSTR lpszOldValue);                       ///< if the clearTag to update is missing, a new one will be added
+    /** @} */
+
+    /** @defgroup xmlPosition Position helper functions (use in conjunction with the update&add functions
+     * @ingroup xmlModify
+     * These are some useful functions when you want to insert a childNode, a text or a XMLClearTag in the
+     * middle (at a specified position) of a XMLNode tree already constructed. The value returned by these
+     * methods is to be used as last parameter (parameter 'pos') of addChild, addText or addClear.
+     * @{ */
+    XMLElementPosition positionOfText(int i=0) const;
+    XMLElementPosition positionOfText(XMLCSTR lpszValue) const;
+    XMLElementPosition positionOfClear(int i=0) const;
+    XMLElementPosition positionOfClear(XMLCSTR lpszValue) const;
+    XMLElementPosition positionOfClear(XMLClear *a) const;
+    XMLElementPosition positionOfChildNode(int i=0) const;
+    XMLElementPosition positionOfChildNode(XMLNode x) const;
+    XMLElementPosition positionOfChildNode(XMLCSTR name, int i=0) const; ///< return the position of the ith childNode with the specified name if (name==NULL) return the position of the ith childNode
+    /** @} */
+
+    /// Enumeration for XML character encoding.
+    typedef enum XMLCharEncoding
+    {
+        char_encoding_error=0,
+        char_encoding_UTF8=1,
+        char_encoding_legacy=2,
+        char_encoding_ShiftJIS=3,
+        char_encoding_GB2312=4,
+        char_encoding_Big5=5,
+        char_encoding_GBK=6     // this is actually the same as Big5
+    } XMLCharEncoding;
+
+    /** \addtogroup conversions
+     * @{ */
+
+    /// Sets the global options for the conversions
+    static char setGlobalOptions(XMLCharEncoding characterEncoding=XMLNode::char_encoding_UTF8, char guessWideCharChars=1,
+                                 char dropWhiteSpace=1, char removeCommentsInMiddleOfText=1);
+    /**< The "setGlobalOptions" function allows you to change four global parameters that affect string & file
+     * parsing. First of all, you most-probably will never have to change these 3 global parameters.
+     *
+     * @param guessWideCharChars If "guessWideCharChars"=1 and if this library is compiled in WideChar mode, then the
+     *     XMLNode::parseFile and XMLNode::openFileHelper functions will test if the file contains ASCII
+     *     characters. If this is the case, then the file will be loaded and converted in memory to
+     *     WideChar before being parsed. If 0, no conversion will be performed.
+     *
+     * @param guessWideCharChars If "guessWideCharChars"=1 and if this library is compiled in ASCII/UTF8/char* mode, then the
+     *     XMLNode::parseFile and XMLNode::openFileHelper functions will test if the file contains WideChar
+     *     characters. If this is the case, then the file will be loaded and converted in memory to
+     *     ASCII/UTF8/char* before being parsed. If 0, no conversion will be performed.
+     *
+     * @param characterEncoding This parameter is only meaningful when compiling in char* mode (multibyte character mode).
+     *     In wchar_t* (wide char mode), this parameter is ignored. This parameter should be one of the
+     *     three currently recognized encodings: XMLNode::encoding_UTF8, XMLNode::encoding_ascii,
+     *     XMLNode::encoding_ShiftJIS.
+     *
+     * @param dropWhiteSpace In most situations, text fields containing only white spaces (and carriage returns)
+     *     are useless. Even more, these "empty" text fields are annoying because they increase the
+     *     complexity of the user's code for parsing. So, 99% of the time, it's better to drop
+     *     the "empty" text fields. However The XML specification indicates that no white spaces
+     *     should be lost when parsing the file. So to be perfectly XML-compliant, you should set
+     *     dropWhiteSpace=0. A note of caution: if you set "dropWhiteSpace=0", the parser will be
+     *     slower and your code will be more complex.
+     *
+     * @param removeCommentsInMiddleOfText To explain this parameter, let's consider this code:
+     * \code
+     *        XMLNode x=XMLNode::parseString("<a>foo<!-- hello -->bar<!DOCTYPE world >chu</a>","a");
+     * \endcode
+     *     If removeCommentsInMiddleOfText=0, then we will have:
+     * \code
+     *        x.getText(0) -> "foo"
+     *        x.getText(1) -> "bar"
+     *        x.getText(2) -> "chu"
+     *        x.getClear(0) --> "<!-- hello -->"
+     *        x.getClear(1) --> "<!DOCTYPE world >"
+     * \endcode
+     *     If removeCommentsInMiddleOfText=1, then we will have:
+     * \code
+     *        x.getText(0) -> "foobar"
+     *        x.getText(1) -> "chu"
+     *        x.getClear(0) --> "<!DOCTYPE world >"
+     * \endcode
+     *
+     * \return "0" when there are no errors. If you try to set an unrecognized encoding then the return value will be "1" to signal an error.
+     *
+     * \note Sometime, it's useful to set "guessWideCharChars=0" to disable any conversion
+     * because the test to detect the file-type (ASCII/UTF8/char* or WideChar) may fail (rarely). */
+
+    /// Guess the character encoding of the string (ascii, utf8 or shift-JIS)
+    static XMLCharEncoding guessCharEncoding(void *buffer, int bufLen, char useXMLEncodingAttribute=1);
+    /**< The "guessCharEncoding" function try to guess the character encoding. You most-probably will never
+     * have to use this function. It then returns the appropriate value of the global parameter
+     * "characterEncoding" described in the XMLNode::setGlobalOptions. The guess is based on the content of a buffer of length
+     * "bufLen" bytes that contains the first bytes (minimum 25 bytes; 200 bytes is a good value) of the
+     * file to be parsed. The XMLNode::openFileHelper function is using this function to automatically compute
+     * the value of the "characterEncoding" global parameter. There are several heuristics used to do the
+     * guess. One of the heuristic is based on the "encoding" attribute. The original XML specifications
+     * forbids to use this attribute to do the guess but you can still use it if you set
+     * "useXMLEncodingAttribute" to 1 (this is the default behavior and the behavior of most parsers).
+     * If an inconsistency in the encoding is detected, then the return value is "0". */
+    /** @} */
+
+  private:
+      // these are functions and structures used internally by the XMLNode class (don't bother about them):
+
+      typedef struct XMLNodeDataTag // to allow shallow copy and "intelligent/smart" pointers (automatic delete):
+      {
+          XMLCSTR                lpszName;        // Element name (=NULL if root)
+          int                    nChild,          // Number of child nodes
+                                 nText,           // Number of text fields
+                                 nClear,          // Number of Clear fields (comments)
+                                 nAttribute;      // Number of attributes
+          char                   isDeclaration;   // Whether node is an XML declaration - '<?xml ?>'
+          struct XMLNodeDataTag  *pParent;        // Pointer to parent element (=NULL if root)
+          XMLNode                *pChild;         // Array of child nodes
+          XMLCSTR                *pText;          // Array of text fields
+          XMLClear               *pClear;         // Array of clear fields
+          XMLAttribute           *pAttribute;     // Array of attributes
+          int                    *pOrder;         // order of the child_nodes,text_fields,clear_fields
+          int                    ref_count;       // for garbage collection (smart pointers)
+      } XMLNodeData;
+      XMLNodeData *d;
+
+      char parseClearTag(void *px, void *pa);
+      char maybeAddTxT(void *pa, XMLCSTR tokenPStr);
+      int ParseXMLElement(void *pXML);
+      void *addToOrder(int memInc, int *_pos, int nc, void *p, int size, XMLElementType xtype);
+      int indexText(XMLCSTR lpszValue) const;
+      int indexClear(XMLCSTR lpszValue) const;
+      XMLNode addChild_priv(int,XMLSTR,char,int);
+      XMLAttribute *addAttribute_priv(int,XMLSTR,XMLSTR);
+      XMLCSTR addText_priv(int,XMLSTR,int);
+      XMLClear *addClear_priv(int,XMLSTR,XMLCSTR,XMLCSTR,int);
+      void emptyTheNode(char force);
+      static inline XMLElementPosition findPosition(XMLNodeData *d, int index, XMLElementType xtype);
+      static int CreateXMLStringR(XMLNodeData *pEntry, XMLSTR lpszMarker, int nFormat);
+      static int removeOrderElement(XMLNodeData *d, XMLElementType t, int index);
+      static void exactMemory(XMLNodeData *d);
+      static int detachFromParent(XMLNodeData *d);
+} XMLNode;
+
+/// This structure is given by the function XMLNode::enumContents.
+typedef struct XMLNodeContents
+{
+    /// This dictates what's the content of the XMLNodeContent
+    enum XMLElementType etype;
+    /**< should be an union to access the appropriate data. Compiler does not allow union of object with constructor... too bad. */
+    XMLNode child;
+    XMLAttribute attrib;
+    XMLCSTR text;
+    XMLClear clear;
+
+} XMLNodeContents;
+
+/** @defgroup StringAlloc String Allocation/Free functions
+ * @ingroup xmlModify
+ * @{ */
+/// Duplicate (copy in a new allocated buffer) the source string.
+XMLDLLENTRY XMLSTR stringDup(XMLCSTR source, int cbData=-1);
+/**< This is
+ * a very handy function when used with all the "XMLNode::*_WOSD" functions (\link xmlWOSD \endlink).
+ * @param cbData If !=0 then cbData is the number of chars to duplicate. New strings allocated with
+ * this function should be free'd using the "freeXMLString" function. */
+
+/// to free the string allocated inside the "stringDup" function or the "createXMLString" function.
+XMLDLLENTRY void freeXMLString(XMLSTR t); // {free(t);}
+/** @} */
+
+/** @defgroup atoX ato? like functions
+ * @ingroup XMLParserGeneral
+ * The "xmlto?" functions are equivalents to the atoi, atol, atof functions.
+ * The only difference is: If the variable "xmlString" is NULL, than the return value
+ * is "defautValue". These 6 functions are only here as "convenience" functions for the
+ * user (they are not used inside the XMLparser). If you don't need them, you can
+ * delete them without any trouble.
+ *
+ * @{ */
+XMLDLLENTRY char    xmltob(XMLCSTR xmlString,char   defautValue=0);
+XMLDLLENTRY int     xmltoi(XMLCSTR xmlString,int    defautValue=0);
+XMLDLLENTRY long    xmltol(XMLCSTR xmlString,long   defautValue=0);
+XMLDLLENTRY double  xmltof(XMLCSTR xmlString,double defautValue=.0);
+XMLDLLENTRY XMLCSTR xmltoa(XMLCSTR xmlString,XMLCSTR defautValue=_CXML(""));
+XMLDLLENTRY XMLCHAR xmltoc(XMLCSTR xmlString,const XMLCHAR defautValue=_CXML('\0'));
+/** @} */
+
+/** @defgroup ToXMLStringTool Helper class to create XML files using "printf", "fprintf", "cout",... functions.
+ * @ingroup XMLParserGeneral
+ * @{ */
+/// Helper class to create XML files using "printf", "fprintf", "cout",... functions.
+/** The ToXMLStringTool class helps you creating XML files using "printf", "fprintf", "cout",... functions.
+ * The "ToXMLStringTool" class is processing strings so that all the characters
+ * &,",',<,> are replaced by their XML equivalent:
+ * \verbatim &amp;, &quot;, &apos;, &lt;, &gt; \endverbatim
+ * Using the "ToXMLStringTool class" and the "fprintf function" is THE most efficient
+ * way to produce VERY large XML documents VERY fast.
+ * \note If you are creating from scratch an XML file using the provided XMLNode class
+ * you must not use the "ToXMLStringTool" class (because the "XMLNode" class does the
+ * processing job for you during rendering).*/
+typedef struct XMLDLLENTRY ToXMLStringTool
+{
+public:
+    ToXMLStringTool(): buf(NULL),buflen(0){}
+    ~ToXMLStringTool();
+    void freeBuffer();///<call this function when you have finished using this object to release memory used by the internal buffer.
+
+    XMLSTR toXML(XMLCSTR source);///< returns a pointer to an internal buffer that contains a XML-encoded string based on the "source" parameter.
+
+    /** The "toXMLUnSafe" function is deprecated because there is a possibility of
+     * "destination-buffer-overflow". It converts the string
+     * "source" to the string "dest". */
+    static XMLSTR toXMLUnSafe(XMLSTR dest,XMLCSTR source); ///< deprecated: use "toXML" instead
+    static int lengthXMLString(XMLCSTR source);            ///< deprecated: use "toXML" instead
+
+private:
+    XMLSTR buf;
+    int buflen;
+} ToXMLStringTool;
+/** @} */
+
+/** @defgroup XMLParserBase64Tool Helper class to include binary data inside XML strings using "Base64 encoding".
+ * @ingroup XMLParserGeneral
+ * @{ */
+/// Helper class to include binary data inside XML strings using "Base64 encoding".
+/** The "XMLParserBase64Tool" class allows you to include any binary data (images, sounds,...)
+ * into an XML document using "Base64 encoding". This class is completely
+ * separated from the rest of the xmlParser library and can be removed without any problem.
+ * To include some binary data into an XML file, you must convert the binary data into
+ * standard text (using "encode"). To retrieve the original binary data from the
+ * b64-encoded text included inside the XML file, use "decode". Alternatively, these
+ * functions can also be used to "encrypt/decrypt" some critical data contained inside
+ * the XML (it's not a strong encryption at all, but sometimes it can be useful). */
+typedef struct XMLDLLENTRY XMLParserBase64Tool
+{
+public:
+    XMLParserBase64Tool(): buf(NULL),buflen(0){}
+    ~XMLParserBase64Tool();
+    void freeBuffer();///< Call this function when you have finished using this object to release memory used by the internal buffer.
+
+    /**
+     * @param formatted If "formatted"=true, some space will be reserved for a carriage-return every 72 chars. */
+    static int encodeLength(int inBufLen, char formatted=0); ///< return the length of the base64 string that encodes a data buffer of size inBufLen bytes.
+
+    /**
+     * The "base64Encode" function returns a string containing the base64 encoding of "inByteLen" bytes
+     * from "inByteBuf". If "formatted" parameter is true, then there will be a carriage-return every 72 chars.
+     * The string will be free'd when the XMLParserBase64Tool object is deleted.
+     * All returned strings are sharing the same memory space. */
+    XMLSTR encode(unsigned char *inByteBuf, unsigned int inByteLen, char formatted=0); ///< returns a pointer to an internal buffer containing the base64 string containing the binary data encoded from "inByteBuf"
+
+    /// returns the number of bytes which will be decoded from "inString".
+    static unsigned int decodeSize(XMLCSTR inString, XMLError *xe=NULL);
+
+    /**
+     * The "decode" function returns a pointer to a buffer containing the binary data decoded from "inString"
+     * The output buffer will be free'd when the XMLParserBase64Tool object is deleted.
+     * All output buffer are sharing the same memory space.
+     * @param inString If "instring" is malformed, NULL will be returned */
+    unsigned char* decode(XMLCSTR inString, int *outByteLen=NULL, XMLError *xe=NULL); ///< returns a pointer to an internal buffer containing the binary data decoded from "inString"
+
+    /**
+     * decodes data from "inString" to "outByteBuf". You need to provide the size (in byte) of "outByteBuf"
+     * in "inMaxByteOutBuflen". If "outByteBuf" is not large enough or if data is malformed, then "FALSE"
+     * will be returned; otherwise "TRUE". */
+    static unsigned char decode(XMLCSTR inString, unsigned char *outByteBuf, int inMaxByteOutBuflen, XMLError *xe=NULL); ///< deprecated.
+
+private:
+    void *buf;
+    int buflen;
+    void alloc(int newsize);
+}XMLParserBase64Tool;
+/** @} */
+
+#undef XMLDLLENTRY
+
+#endif
-- 
1.7.5.4

