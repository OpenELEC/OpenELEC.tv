diff -urN a/drivers/media/dvb-frontends/Kconfig b/drivers/media/dvb-frontends/Kconfig
--- a/drivers/media/dvb-frontends/Kconfig	2013-03-21 04:11:19.000000000 +0800
+++ b/drivers/media/dvb-frontends/Kconfig	2013-02-14 22:57:20.000000000 +0800
@@ -200,6 +200,27 @@
 	help
 	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
 
+config DVB_M88DS3103
+	tristate "Montage M88DS3103 based"
+	depends on DVB_CORE && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
+
+config DVB_M88DC2800
+	tristate "Montage M88DC2800 based"
+	depends on DVB_CORE && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  A DVB-C tuner module. Say Y when you want to support this frontend.
+
+config DVB_SI2168
+	tristate "Si2168 based"
+	depends on DVB_CORE && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  A DVB-T2/T/C tuner module. Say Y when you want to support this frontend.
+	  	  
 config DVB_SI21XX
 	tristate "Silicon Labs SI21XX based"
 	depends on DVB_CORE && I2C
diff -urN a/drivers/media/dvb-frontends/m88dc2800.c b/drivers/media/dvb-frontends/m88dc2800.c
--- a/drivers/media/dvb-frontends/m88dc2800.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/m88dc2800.c	2013-01-26 16:03:21.000000000 +0800
@@ -0,0 +1,2124 @@
+/*
+    M88DC2800/M88TC2800  - DVB-C demodulator and tuner from Montage
+
+    Copyright (C) 2012 Max nibble<nibble.max@gmail.com>
+    Copyright (C) 2011 Montage Technology / www.montage-tech.com
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <asm/div64.h>
+#include "dvb_frontend.h"
+#include "m88dc2800.h"
+
+struct m88dc2800_state {
+	struct i2c_adapter *i2c;
+	const struct m88dc2800_config *config;
+	struct dvb_frontend frontend;
+	u32 freq;
+	u32 ber;
+	u32 sym;
+	u16 qam;
+	u8 inverted;
+	u32 xtal;
+	/* tuner state */
+	u8 tuner_init_OK;	/* Tuner initialize status */
+	u8 tuner_dev_addr;	/* Tuner device address */
+	u32 tuner_freq;		/* RF frequency to be set, unit: KHz */
+	u16 tuner_qam;		/* Reserved */
+	u16 tuner_mode;
+	u8 tuner_bandwidth;	/* Bandwidth of the channel, unit: MHz, 6/7/8 */
+	u8 tuner_loopthrough;	/* Tuner loop through switch, 0/1 */
+	u32 tuner_crystal;	/* Tuner crystal frequency, unit: KHz */
+	u32 tuner_dac;		/* Tuner DAC frequency, unit: KHz */
+	u16 tuner_mtt;		/* Tuner chip version, D1: 0x0d, E0: 0x0e, E1: 0x8e */
+	u16 tuner_custom_cfg;
+	u32 tuner_version;	/* Tuner driver version number */
+	u32 tuner_time;
+};
+
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Activates frontend debugging (default:0)");
+
+#define dprintk(args...) \
+	do { \
+		if (debug) \
+			printk(KERN_INFO "m88dc2800: " args); \
+	} while (0)
+
+
+static int m88dc2800_i2c_write(struct m88dc2800_state *state, u8 addr,
+			       u8 * p_data, u8 len)
+{
+	struct i2c_msg msg = { .flags = 0 };
+
+	msg.addr = addr;
+	msg.buf = p_data;
+	msg.len = len;
+
+	return i2c_transfer(state->i2c, &msg, 1);
+}
+
+static int m88dc2800_i2c_read(struct m88dc2800_state *state, u8 addr,
+			      u8 * p_data, u8 len)
+{
+	struct i2c_msg msg = { .flags = I2C_M_RD };
+
+	msg.addr = addr;
+	msg.buf = p_data;
+	msg.len = len;
+
+	return i2c_transfer(state->i2c, &msg, 1);
+}
+
+/*demod register operations.*/
+static int WriteReg(struct m88dc2800_state *state, u8 reg, u8 data)
+{
+	u8 buf[] = { reg, data };
+	u8 addr = state->config->demod_address;
+	int err;
+
+	dprintk("%s: write reg 0x%02x, value 0x%02x\n", __func__, reg, data);
+
+	err = m88dc2800_i2c_write(state, addr, buf, 2);
+
+	if (err != 1) {
+		printk(KERN_ERR
+		       "%s: writereg error(err == %i, reg == 0x%02x,"
+		       " value == 0x%02x)\n", __func__, err, reg, data);
+		return -EIO;
+	}
+	return 0;
+}
+
+static int ReadReg(struct m88dc2800_state *state, u8 reg)
+{
+	int ret;
+	u8 b0[] = { reg };
+	u8 b1[] = { 0 };
+	u8 addr = state->config->demod_address;
+
+	ret = m88dc2800_i2c_write(state, addr, b0, 1);
+
+	if (ret != 1) {
+		printk(KERN_ERR "%s: reg=0x%x (error=%d)\n",
+		       __func__, reg, ret);
+		return -EIO;
+	}
+
+	ret = m88dc2800_i2c_read(state, addr, b1, 1);
+
+	dprintk("%s: read reg 0x%02x, value 0x%02x\n", __func__, reg, b1[0]);
+	return b1[0];
+}
+
+static int _mt_fe_tn_set_reg(struct m88dc2800_state *state, u8 reg,
+			     u8 data)
+{
+	int ret;
+	u8 buf[2];
+	u8 addr = state->tuner_dev_addr;
+
+	buf[1] = ReadReg(state, 0x86);
+	buf[1] |= 0x80;
+	ret = WriteReg(state, 0x86, buf[1]);
+
+	buf[0] = reg;
+	buf[1] = data;
+
+	ret = m88dc2800_i2c_write(state, addr, buf, 2);
+	if (ret != 1)
+		return -EIO;
+	return 0;
+}
+
+static int _mt_fe_tn_get_reg(struct m88dc2800_state *state, u8 reg,
+			     u8 * p_data)
+{
+	int ret;
+	u8 buf[2];
+	u8 addr = state->tuner_dev_addr;
+
+	buf[1] = ReadReg(state, 0x86);
+	buf[1] |= 0x80;
+	ret = WriteReg(state, 0x86, buf[1]);
+
+	buf[0] = reg;
+	ret = m88dc2800_i2c_write(state, addr, buf, 1);
+
+	msleep(1);
+
+	buf[1] = ReadReg(state, 0x86);
+	buf[1] |= 0x80;
+	ret = WriteReg(state, 0x86, buf[1]);
+
+	return m88dc2800_i2c_read(state, addr, p_data, 1);
+}
+
+/* Tuner operation functions.*/
+static int _mt_fe_tn_set_RF_front_tc2800(struct m88dc2800_state *state)
+{
+	u32 freq_KHz = state->tuner_freq;
+	u8 a, b, c;
+	if (state->tuner_mtt == 0xD1) {	/* D1 */
+		if (freq_KHz <= 123000) {
+			if (freq_KHz <= 56000) {
+				a = 0x00; b = 0x00; c = 0x00;
+			} else if (freq_KHz <= 64000) {
+				a = 0x10; b = 0x01; c = 0x08;
+			} else if (freq_KHz <= 72000) {
+				a = 0x20; b = 0x02; c = 0x10;
+			} else if (freq_KHz <= 80000) {
+				a = 0x30; b = 0x03; c = 0x18;
+			} else if (freq_KHz <= 88000) {
+				a = 0x40; b = 0x04; c = 0x20;
+			} else if (freq_KHz <= 96000) {
+				a = 0x50; b = 0x05; c = 0x28;
+			} else if (freq_KHz <= 104000) {
+				a = 0x60; b = 0x06; c = 0x30;
+			} else {
+				a = 0x70; b = 0x07; c = 0x38;
+			}
+			_mt_fe_tn_set_reg(state, 0x58, 0x9b);
+			_mt_fe_tn_set_reg(state, 0x59, a);
+			_mt_fe_tn_set_reg(state, 0x5d, b);
+			_mt_fe_tn_set_reg(state, 0x5e, c);
+			_mt_fe_tn_set_reg(state, 0x5a, 0x75);
+			_mt_fe_tn_set_reg(state, 0x73, 0x0c);
+		} else {	/* if (freq_KHz > 112000) */
+			_mt_fe_tn_set_reg(state, 0x58, 0x7b);
+			if (freq_KHz <= 304000) {
+				if (freq_KHz <= 136000) {
+					_mt_fe_tn_set_reg(state, 0x5e, 0x40);
+				} else if (freq_KHz <= 160000) {
+					_mt_fe_tn_set_reg(state, 0x5e, 0x48);
+				} else if (freq_KHz <= 184000) {
+					_mt_fe_tn_set_reg(state, 0x5e, 0x50);
+				} else if (freq_KHz <= 208000) {
+					_mt_fe_tn_set_reg(state, 0x5e, 0x58);
+				} else if (freq_KHz <= 232000) {
+					_mt_fe_tn_set_reg(state, 0x5e, 0x60);
+				} else if (freq_KHz <= 256000) {
+					_mt_fe_tn_set_reg(state, 0x5e, 0x68);
+				} else if (freq_KHz <= 280000) {
+					_mt_fe_tn_set_reg(state, 0x5e, 0x70);
+				} else {	/* if (freq_KHz <= 304000) */
+					_mt_fe_tn_set_reg(state, 0x5e, 0x78);
+				}
+				if (freq_KHz <= 171000) {
+					_mt_fe_tn_set_reg(state, 0x73, 0x08);
+				} else if (freq_KHz <= 211000) {
+					_mt_fe_tn_set_reg(state, 0x73, 0x0a);
+				} else {
+					_mt_fe_tn_set_reg(state, 0x73, 0x0e);
+				}
+			} else {	/* if (freq_KHz > 304000) */
+				_mt_fe_tn_set_reg(state, 0x5e, 0x88);
+				if (freq_KHz <= 400000) {
+					_mt_fe_tn_set_reg(state, 0x73, 0x0c);
+				} else if (freq_KHz <= 450000) {
+					_mt_fe_tn_set_reg(state, 0x73, 0x09);
+				} else if (freq_KHz <= 550000) {
+					_mt_fe_tn_set_reg(state, 0x73, 0x0e);
+				} else if (freq_KHz <= 650000) {
+					_mt_fe_tn_set_reg(state, 0x73, 0x0d);
+				} else {	/*if (freq_KHz > 650000) */
+					_mt_fe_tn_set_reg(state, 0x73, 0x0e);
+				}
+			}
+		}
+		if (freq_KHz > 800000)
+			_mt_fe_tn_set_reg(state, 0x87, 0x24);
+		else if (freq_KHz > 700000)
+			_mt_fe_tn_set_reg(state, 0x87, 0x34);
+		else if (freq_KHz > 500000)
+			_mt_fe_tn_set_reg(state, 0x87, 0x44);
+		else if (freq_KHz > 300000)
+			_mt_fe_tn_set_reg(state, 0x87, 0x43);
+		else if (freq_KHz > 220000)
+			_mt_fe_tn_set_reg(state, 0x87, 0x54);
+		else if (freq_KHz > 110000)
+			_mt_fe_tn_set_reg(state, 0x87, 0x14);
+		else
+			_mt_fe_tn_set_reg(state, 0x87, 0x54);
+		if (freq_KHz > 600000)
+			_mt_fe_tn_set_reg(state, 0x6a, 0x53);
+		else if (freq_KHz > 500000)
+			_mt_fe_tn_set_reg(state, 0x6a, 0x57);
+		else
+			_mt_fe_tn_set_reg(state, 0x6a, 0x59);
+		if (freq_KHz < 200000) {
+			_mt_fe_tn_set_reg(state, 0x20, 0x5d);
+		} else if (freq_KHz < 500000) {
+			_mt_fe_tn_set_reg(state, 0x20, 0x7d);
+		} else {
+			_mt_fe_tn_set_reg(state, 0x20, 0xfd);
+		}		/* end of 0xD1 */
+	} else if (state->tuner_mtt == 0xE1) {	/* E1 */
+		if (freq_KHz <= 112000) {	/* 123MHz */
+			if (freq_KHz <= 56000) {
+				_mt_fe_tn_set_reg(state, 0x5c, 0x01);
+			} else if (freq_KHz <= 64000) {
+				_mt_fe_tn_set_reg(state, 0x5c, 0x09);
+			} else if (freq_KHz <= 72000) {
+				_mt_fe_tn_set_reg(state, 0x5c, 0x11);
+			} else if (freq_KHz <= 80000) {
+				_mt_fe_tn_set_reg(state, 0x5c, 0x19);
+			} else if (freq_KHz <= 88000) {
+				_mt_fe_tn_set_reg(state, 0x5c, 0x21);
+			} else if (freq_KHz <= 96000) {
+				_mt_fe_tn_set_reg(state, 0x5c, 0x29);
+			} else if (freq_KHz <= 104000) {
+				_mt_fe_tn_set_reg(state, 0x5c, 0x31);
+			} else {	/* if (freq_KHz <= 112000) */
+				_mt_fe_tn_set_reg(state, 0x5c, 0x39);
+			}
+			_mt_fe_tn_set_reg(state, 0x5b, 0x30);
+		} else {	/* if (freq_KHz > 112000) */
+			if (freq_KHz <= 304000) {
+				if (freq_KHz <= 136000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0x41);
+				} else if (freq_KHz <= 160000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0x49);
+				} else if (freq_KHz <= 184000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0x51);
+				} else if (freq_KHz <= 208000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0x59);
+				} else if (freq_KHz <= 232000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0x61);
+				} else if (freq_KHz <= 256000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0x69);
+				} else if (freq_KHz <= 280000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0x71);
+				} else {	/* if (freq_KHz <= 304000) */
+					_mt_fe_tn_set_reg(state, 0x5c, 0x79);
+				}
+				if (freq_KHz <= 150000) {
+					_mt_fe_tn_set_reg(state, 0x5b, 0x28);
+				} else if (freq_KHz <= 256000) {
+					_mt_fe_tn_set_reg(state, 0x5b, 0x29);
+				} else {
+					_mt_fe_tn_set_reg(state, 0x5b, 0x2a);
+				}
+			} else {	/* if (freq_KHz > 304000) */
+				if (freq_KHz <= 400000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0x89);
+				} else if (freq_KHz <= 450000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0x91);
+				} else if (freq_KHz <= 650000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0x98);
+				} else if (freq_KHz <= 850000) {
+					_mt_fe_tn_set_reg(state, 0x5c, 0xa0);
+				} else {
+					_mt_fe_tn_set_reg(state, 0x5c, 0xa8);
+				}
+				_mt_fe_tn_set_reg(state, 0x5b, 0x08);
+			}
+		}
+	}			/* end of 0xE1 */
+	return 0;
+}
+
+static int _mt_fe_tn_cali_PLL_tc2800(struct m88dc2800_state *state,
+				     u32 freq_KHz,
+				     u32 cali_freq_thres_div2,
+				     u32 cali_freq_thres_div3r,
+				     u32 cali_freq_thres_div3)
+{
+	s32 N, F, MUL;
+	u8 buf, tmp, tmp2;
+	s32 M;
+	const s32 crystal_KHz = state->tuner_crystal;
+	 if (state->tuner_mtt == 0xD1) {
+		M = state->tuner_crystal / 4000;
+		if (freq_KHz > cali_freq_thres_div2) {
+			MUL = 4;
+			tmp = 2;
+		} else if (freq_KHz > 300000) {
+			MUL = 8;
+			tmp = 3;
+		} else if (freq_KHz > (cali_freq_thres_div2 / 2)) {
+			MUL = 8;
+			tmp = 4;
+		} else if (freq_KHz > (cali_freq_thres_div2 / 4)) {
+			MUL = 16;
+			tmp = 5;
+		} else if (freq_KHz > (cali_freq_thres_div2 / 8)) {
+			MUL = 32;
+			tmp = 6;
+		} else if (freq_KHz > (cali_freq_thres_div2 / 16)) {
+			MUL = 64;
+			tmp = 7;
+		} else {	/* invalid */
+			MUL = 0;
+			tmp = 0;
+			return 1;
+		}
+	} else if (state->tuner_mtt == 0xE1) {
+		M = state->tuner_crystal / 1000;
+		_mt_fe_tn_set_reg(state, 0x30, 0xff);
+		_mt_fe_tn_set_reg(state, 0x32, 0xe0);
+		_mt_fe_tn_set_reg(state, 0x33, 0x86);
+		_mt_fe_tn_set_reg(state, 0x37, 0x70);
+		_mt_fe_tn_set_reg(state, 0x38, 0x20);
+		_mt_fe_tn_set_reg(state, 0x39, 0x18);
+		_mt_fe_tn_set_reg(state, 0x89, 0x83);
+		if (freq_KHz > cali_freq_thres_div2) {
+			M = M / 4;
+			MUL = 4;
+			tmp = 2;
+			tmp2 = M + 16;	/* 48 */
+		} else if (freq_KHz > cali_freq_thres_div3r) {
+			M = M / 3;
+			MUL = 6;
+			tmp = 2;
+			tmp2 = M + 32;	/* 32 */
+		} else if (freq_KHz > cali_freq_thres_div3) {
+			M = M / 3;
+			MUL = 6;
+			tmp = 2;
+			tmp2 = M;	/* 16 */
+		} else if (freq_KHz > 304000) {
+			M = M / 4;
+			MUL = 8;
+			tmp = 3;
+			tmp2 = M + 16;	/* 48 */
+		} else if (freq_KHz > (cali_freq_thres_div2 / 2)) {
+			M = M / 4;
+			MUL = 8;
+			tmp = 4;
+			tmp2 = M + 16;	/* 48 */
+		} else if (freq_KHz > (cali_freq_thres_div3r / 2)) {
+			M = M / 3;
+			MUL = 12;
+			tmp = 4;
+			tmp2 = M + 32;	/* 32 */
+		} else if (freq_KHz > (cali_freq_thres_div3 / 2)) {
+			M = M / 3;
+			MUL = 12;
+			tmp = 4;
+			tmp2 = M;	/* 16 */
+		} else if (freq_KHz > (cali_freq_thres_div2 / 4)) {
+			M = M / 4;
+			MUL = 16;
+			tmp = 5;
+			tmp2 = M + 16;	/* 48 */
+		} else if (freq_KHz > (cali_freq_thres_div3r / 4)) {
+			M = M / 3;
+			MUL = 24;
+			tmp = 5;
+			tmp2 = M + 32;	/* 32 */
+		} else if (freq_KHz > (cali_freq_thres_div3 / 4)) {
+			M = M / 3;
+			MUL = 24;
+			tmp = 5;
+			tmp2 = M;	/* 16 */
+		} else if (freq_KHz > (cali_freq_thres_div2 / 8)) {
+			M = M / 4;
+			MUL = 32;
+			tmp = 6;
+			tmp2 = M + 16;	/* 48 */
+		} else if (freq_KHz > (cali_freq_thres_div3r / 8)) {
+			M = M / 3;
+			MUL = 48;
+			tmp = 6;
+			tmp2 = M + 32;	/* 32 */
+		} else if (freq_KHz > (cali_freq_thres_div3 / 8)) {
+			M = M / 3;
+			MUL = 48;
+			tmp = 6;
+			tmp2 = M;	/* 16 */
+		} else if (freq_KHz > (cali_freq_thres_div2 / 16)) {
+			M = M / 4;
+			MUL = 64;
+			tmp = 7;
+			tmp2 = M + 16;	/* 48 */
+		} else if (freq_KHz > (cali_freq_thres_div3r / 16)) {
+			M = M / 3;
+			MUL = 96;
+			tmp = 7;
+			tmp2 = M + 32;	/* 32 */
+		} else if (freq_KHz > (cali_freq_thres_div3 / 16)) {
+			M = M / 3;
+			MUL = 96;
+			tmp = 7;
+			tmp2 = M;	/* 16 */
+		} else {	/* invalid */
+			M = M / 4;
+			MUL = 0;
+			tmp = 0;
+			tmp2 = 48;
+			return 1;
+		}
+		if (freq_KHz == 291000) {
+			M = state->tuner_crystal / 1000 / 3;
+			MUL = 12;
+			tmp = 4;
+			tmp2 = M + 32;	/* 32 */
+		}
+		/*
+		   if (freq_KHz == 578000) {
+		   M = state->tuner_crystal / 1000 / 4;
+		   MUL = 4;
+		   tmp = 2;
+		   tmp2 = M + 16;	// 48
+		   }
+		 */
+		if (freq_KHz == 690000) {
+			M = state->tuner_crystal / 1000 / 3;
+			MUL = 4;
+			tmp = 2;
+			tmp2 = M + 16;	/* 48 */
+		}
+		_mt_fe_tn_get_reg(state, 0x33, &buf);
+		buf &= 0xc0;
+		buf += tmp2;
+		_mt_fe_tn_set_reg(state, 0x33, buf);
+	} else {
+		return 1;
+	}
+	_mt_fe_tn_get_reg(state, 0x39, &buf);
+	buf &= 0xf8;
+	buf += tmp;
+	_mt_fe_tn_set_reg(state, 0x39, buf);
+	N = (freq_KHz * MUL * M / crystal_KHz) / 2 * 2 - 256;
+	buf = (N >> 8) & 0xcf;
+	if (state->tuner_mtt == 0xE1) {
+		buf |= 0x30;
+	}
+	_mt_fe_tn_set_reg(state, 0x34, buf);
+	buf = N & 0xff;
+	_mt_fe_tn_set_reg(state, 0x35, buf);
+	F = ((freq_KHz * MUL * M / (crystal_KHz / 1000) / 2) -
+	     (freq_KHz * MUL * M / crystal_KHz / 2 * 1000)) * 64 / 1000;
+	buf = F & 0xff;
+	_mt_fe_tn_set_reg(state, 0x36, buf);
+	if (F == 0) {
+		if (state->tuner_mtt == 0xD1) {
+			_mt_fe_tn_set_reg(state, 0x3d, 0xca);
+		} else if (state->tuner_mtt == 0xE1) {
+			_mt_fe_tn_set_reg(state, 0x3d, 0xfe);
+		} else {
+			return 1;
+		}
+		_mt_fe_tn_set_reg(state, 0x3e, 0x9c);
+		_mt_fe_tn_set_reg(state, 0x3f, 0x34);
+	}
+	if (F > 0) {
+		if (state->tuner_mtt == 0xD1) {
+			if ((F == 32) || (F == 16) || (F == 48)) {
+				_mt_fe_tn_set_reg(state, 0x3e, 0xa4);
+				_mt_fe_tn_set_reg(state, 0x3d, 0x4a);
+				_mt_fe_tn_set_reg(state, 0x3f, 0x36);
+			} else {
+				_mt_fe_tn_set_reg(state, 0x3e, 0xa4);
+				_mt_fe_tn_set_reg(state, 0x3d, 0x4a);
+				_mt_fe_tn_set_reg(state, 0x3f, 0x36);
+			}
+		} else if (state->tuner_mtt == 0xE1) {
+			_mt_fe_tn_set_reg(state, 0x3e, 0xa4);
+			_mt_fe_tn_set_reg(state, 0x3d, 0x7e);
+			_mt_fe_tn_set_reg(state, 0x3f, 0x36);
+			_mt_fe_tn_set_reg(state, 0x89, 0x84);
+			_mt_fe_tn_get_reg(state, 0x39, &buf);
+			buf = buf & 0x1f;
+			_mt_fe_tn_set_reg(state, 0x39, buf);
+			_mt_fe_tn_get_reg(state, 0x32, &buf);
+			buf = buf | 0x02;
+			_mt_fe_tn_set_reg(state, 0x32, buf);
+		} else {
+			return 1;
+		}
+	}
+	_mt_fe_tn_set_reg(state, 0x41, 0x00);
+	if (state->tuner_mtt == 0xD1) {
+		msleep(5);
+	} else if (state->tuner_mtt == 0xE1) {
+		msleep(2);
+	} else {
+		return 1;
+	}
+	_mt_fe_tn_set_reg(state, 0x41, 0x02);
+	_mt_fe_tn_set_reg(state, 0x30, 0x7f);
+	_mt_fe_tn_set_reg(state, 0x30, 0xff);
+	_mt_fe_tn_set_reg(state, 0x31, 0x80);
+	_mt_fe_tn_set_reg(state, 0x31, 0x00);
+
+	return 0;
+}
+
+static int _mt_fe_tn_set_PLL_freq_tc2800(struct m88dc2800_state *state)
+{
+	u8 buf, buf1;
+	u32 freq_thres_div2_KHz, freq_thres_div3r_KHz,
+	    freq_thres_div3_KHz;
+	const u32 freq_KHz = state->tuner_freq;
+	if (state->tuner_mtt == 0xD1) {
+		_mt_fe_tn_set_reg(state, 0x32, 0xe1);
+		_mt_fe_tn_set_reg(state, 0x33, 0xa6);
+		_mt_fe_tn_set_reg(state, 0x37, 0x7f);
+		_mt_fe_tn_set_reg(state, 0x38, 0x20);
+		_mt_fe_tn_set_reg(state, 0x39, 0x18);
+		_mt_fe_tn_set_reg(state, 0x40, 0x40);
+		 freq_thres_div2_KHz = 520000;
+		_mt_fe_tn_cali_PLL_tc2800(state, freq_KHz,
+					   freq_thres_div2_KHz, 0, 0);
+		 msleep(5);
+		_mt_fe_tn_get_reg(state, 0x3a, &buf);
+		buf1 = buf;
+		buf = buf & 0x03;
+		buf1 = buf1 & 0x01;
+		if ((buf1 == 0) || (buf == 3)) {
+			freq_thres_div2_KHz = 420000;
+			_mt_fe_tn_cali_PLL_tc2800(state, freq_KHz,
+						   freq_thres_div2_KHz, 0,
+						   0);
+			msleep(5);
+			 _mt_fe_tn_get_reg(state, 0x3a, &buf);
+			buf = buf & 0x07;
+			if (buf == 5) {
+				freq_thres_div2_KHz = 520000;
+				_mt_fe_tn_cali_PLL_tc2800(state, freq_KHz,
+							   freq_thres_div2_KHz,
+							   0, 0);
+				msleep(5);
+			}
+		}
+		 _mt_fe_tn_get_reg(state, 0x38, &buf);
+		_mt_fe_tn_set_reg(state, 0x38, buf);
+		 _mt_fe_tn_get_reg(state, 0x32, &buf);
+		buf = buf | 0x10;
+		_mt_fe_tn_set_reg(state, 0x32, buf);
+		 _mt_fe_tn_set_reg(state, 0x30, 0x7f);
+		_mt_fe_tn_set_reg(state, 0x30, 0xff);
+		 _mt_fe_tn_get_reg(state, 0x32, &buf);
+		buf = buf & 0xdf;
+		_mt_fe_tn_set_reg(state, 0x32, buf);
+		_mt_fe_tn_set_reg(state, 0x40, 0x0);
+		 _mt_fe_tn_set_reg(state, 0x30, 0x7f);
+		_mt_fe_tn_set_reg(state, 0x30, 0xff);
+		_mt_fe_tn_set_reg(state, 0x31, 0x80);
+		_mt_fe_tn_set_reg(state, 0x31, 0x00);
+		msleep(5);
+		 _mt_fe_tn_get_reg(state, 0x39, &buf);
+		buf = buf >> 5;
+		if (buf < 5) {
+			_mt_fe_tn_get_reg(state, 0x39, &buf);
+			buf = buf | 0xa0;
+			buf = buf & 0xbf;
+			_mt_fe_tn_set_reg(state, 0x39, buf);
+			 _mt_fe_tn_get_reg(state, 0x32, &buf);
+			buf = buf | 0x02;
+			_mt_fe_tn_set_reg(state, 0x32, buf);
+		}
+		 _mt_fe_tn_get_reg(state, 0x37, &buf);
+		if (buf > 0x70) {
+			buf = 0x7f;
+			_mt_fe_tn_set_reg(state, 0x40, 0x40);
+		}
+		_mt_fe_tn_set_reg(state, 0x37, buf);
+		  _mt_fe_tn_get_reg(state, 0x38, &buf);
+		if (buf < 0x0f) {
+			buf = (buf & 0x0f) << 2;
+			buf = buf + 0x0f;
+			_mt_fe_tn_set_reg(state, 0x37, buf);
+		} else if (buf < 0x1f) {
+			buf = buf + 0x0f;
+			_mt_fe_tn_set_reg(state, 0x37, buf);
+		}
+		 _mt_fe_tn_get_reg(state, 0x32, &buf);
+		buf = (buf | 0x20) & 0xef;
+		_mt_fe_tn_set_reg(state, 0x32, buf);
+		 _mt_fe_tn_set_reg(state, 0x41, 0x00);
+		msleep(5);
+		_mt_fe_tn_set_reg(state, 0x41, 0x02);
+	} else if (state->tuner_mtt == 0xE1) {
+		freq_thres_div2_KHz = 580000;
+		freq_thres_div3r_KHz = 500000;
+		freq_thres_div3_KHz = 440000;
+		_mt_fe_tn_cali_PLL_tc2800(state, freq_KHz,
+					   freq_thres_div2_KHz,
+					   freq_thres_div3r_KHz,
+					   freq_thres_div3_KHz);
+		msleep(3);
+		_mt_fe_tn_get_reg(state, 0x38, &buf);
+		_mt_fe_tn_set_reg(state, 0x38, buf);
+		_mt_fe_tn_set_reg(state, 0x30, 0x7f);
+		_mt_fe_tn_set_reg(state, 0x30, 0xff);
+		_mt_fe_tn_set_reg(state, 0x31, 0x80);
+		_mt_fe_tn_set_reg(state, 0x31, 0x00);
+		msleep(3);
+		_mt_fe_tn_get_reg(state, 0x38, &buf);
+		_mt_fe_tn_set_reg(state, 0x38, buf);
+		_mt_fe_tn_get_reg(state, 0x32, &buf);
+		buf = buf | 0x10;
+		_mt_fe_tn_set_reg(state, 0x32, buf);
+		 _mt_fe_tn_set_reg(state, 0x30, 0x7f);
+		_mt_fe_tn_set_reg(state, 0x30, 0xff);
+		_mt_fe_tn_get_reg(state, 0x32, &buf);
+		buf = buf & 0xdf;
+		_mt_fe_tn_set_reg(state, 0x32, buf);
+		_mt_fe_tn_set_reg(state, 0x31, 0x80);
+		_mt_fe_tn_set_reg(state, 0x31, 0x00);
+		msleep(3);
+		_mt_fe_tn_get_reg(state, 0x37, &buf);
+		_mt_fe_tn_set_reg(state, 0x37, buf);
+		/*
+		   if ((freq_KHz == 802000) || (freq_KHz == 826000)) {
+		   _mt_fe_tn_set_reg(state, 0x37, 0x5e);
+		   }
+		 */
+		_mt_fe_tn_get_reg(state, 0x32, &buf);
+		buf = (buf & 0xef) | 0x30;
+		_mt_fe_tn_set_reg(state, 0x32, buf);
+		 _mt_fe_tn_set_reg(state, 0x41, 0x00);
+		msleep(2);
+		_mt_fe_tn_set_reg(state, 0x41, 0x02);
+	} else {
+		return 1;
+	}
+	return 0;
+}
+
+static int _mt_fe_tn_set_BB_tc2800(struct m88dc2800_state *state)
+{
+	return 0;
+}
+
+ static int _mt_fe_tn_set_appendix_tc2800(struct m88dc2800_state *state)
+
+{
+	u8 buf;
+	const u32 freq_KHz = state->tuner_freq;
+	if (state->tuner_mtt == 0xD1) {
+		if ((freq_KHz == 123000) || (freq_KHz == 147000) ||
+		    (freq_KHz == 171000) || (freq_KHz == 195000)) {
+			_mt_fe_tn_set_reg(state, 0x20, 0x1b);
+		}
+		if ((freq_KHz == 371000) || (freq_KHz == 419000) ||
+		    (freq_KHz == 610000) || (freq_KHz == 730000) ||
+		    (freq_KHz == 754000) || (freq_KHz == 826000)) {
+			_mt_fe_tn_get_reg(state, 0x0d, &buf);
+			_mt_fe_tn_set_reg(state, 0x0d, (u8) (buf + 1));
+		}
+		if ((freq_KHz == 522000) || (freq_KHz == 578000) ||
+		    (freq_KHz == 634000) || (freq_KHz == 690000) ||
+		    (freq_KHz == 834000)) {
+			_mt_fe_tn_get_reg(state, 0x0d, &buf);
+			_mt_fe_tn_set_reg(state, 0x0d, (u8) (buf - 1));
+		}
+	} else if (state->tuner_mtt == 0xE1) {
+		_mt_fe_tn_set_reg(state, 0x20, 0xfc);
+		if (freq_KHz == 123000 || freq_KHz == 147000 ||
+		    freq_KHz == 171000 || freq_KHz == 195000 ||
+		    freq_KHz == 219000 || freq_KHz == 267000 ||
+		    freq_KHz == 291000 || freq_KHz == 339000 ||
+		    freq_KHz == 387000 || freq_KHz == 435000 ||
+		    freq_KHz == 482000 || freq_KHz == 530000 ||
+		    freq_KHz == 722000 ||
+		    (state->tuner_custom_cfg == 1 && freq_KHz == 315000)) {
+			_mt_fe_tn_set_reg(state, 0x20, 0x5c);
+		}
+	}
+	return 0;
+}
+
+ static int _mt_fe_tn_set_DAC_tc2800(struct m88dc2800_state *state)
+{
+	u8 buf, tempnumber;
+	s32 N;
+	s32 f1f2number, f1, f2, delta1, Totalnum1;
+	s32 cntT, cntin, NCOI, z0, z1, z2, tmp;
+	u32 fc, fadc, fsd, f2d;
+	u32 FreqTrue108_Hz;
+	s32 M = state->tuner_crystal / 4000;
+	/* const u8 bandwidth = state->tuner_bandwidth; */
+	const u16 DAC_fre = 108;
+	const u32 crystal_KHz = state->tuner_crystal;
+	const u32 DACFreq_KHz = state->tuner_dac;
+	const u32 freq_KHz = state->tuner_freq;
+
+	if (state->tuner_mtt == 0xE1) {
+		_mt_fe_tn_get_reg(state, 0x33, &buf);
+		M = buf & 0x0f;
+		if (M == 0)
+			M = 6;
+	}
+	_mt_fe_tn_get_reg(state, 0x34, &buf);
+	N = buf & 0x07;
+	_mt_fe_tn_get_reg(state, 0x35, &buf);
+	N = (N << 8) + buf;
+	buf = ((N + 256) * crystal_KHz / M / DAC_fre + 500) / 1000;
+	if (state->tuner_mtt == 0xE1) {
+		_mt_fe_tn_set_appendix_tc2800(state);
+		if (freq_KHz == 187000 || freq_KHz == 195000 ||
+		    freq_KHz == 131000 || freq_KHz == 211000 ||
+		    freq_KHz == 219000 || freq_KHz == 227000 ||
+		    freq_KHz == 267000 || freq_KHz == 299000 ||
+		    freq_KHz == 347000 || freq_KHz == 363000 ||
+		    freq_KHz == 395000 || freq_KHz == 403000 ||
+		    freq_KHz == 435000 || freq_KHz == 482000 ||
+		    freq_KHz == 474000 || freq_KHz == 490000 ||
+		    freq_KHz == 610000 || freq_KHz == 642000 ||
+		    freq_KHz == 666000 || freq_KHz == 722000 ||
+		    freq_KHz == 754000 ||
+		    ((freq_KHz == 379000 || freq_KHz == 467000 ||
+		      freq_KHz == 762000) && state->tuner_custom_cfg != 1)) {
+			buf = buf + 1;
+		}
+		if (freq_KHz == 123000 || freq_KHz == 139000 ||
+		    freq_KHz == 147000 || freq_KHz == 171000 ||
+		    freq_KHz == 179000 || freq_KHz == 203000 ||
+		    freq_KHz == 235000 || freq_KHz == 251000 ||
+		    freq_KHz == 259000 || freq_KHz == 283000 ||
+		    freq_KHz == 331000 || freq_KHz == 363000 ||
+		    freq_KHz == 371000 || freq_KHz == 387000 ||
+		    freq_KHz == 411000 || freq_KHz == 427000 ||
+		    freq_KHz == 443000 || freq_KHz == 451000 ||
+		    freq_KHz == 459000 || freq_KHz == 506000 ||
+		    freq_KHz == 514000 || freq_KHz == 538000 ||
+		    freq_KHz == 546000 || freq_KHz == 554000 ||
+		    freq_KHz == 562000 || freq_KHz == 570000 ||
+		    freq_KHz == 578000 || freq_KHz == 602000 ||
+		    freq_KHz == 626000 || freq_KHz == 658000 ||
+		    freq_KHz == 690000 || freq_KHz == 714000 ||
+		    freq_KHz == 746000 || freq_KHz == 522000 ||
+		    freq_KHz == 826000 || freq_KHz == 155000 ||
+		    freq_KHz == 530000 ||
+		    ((freq_KHz == 275000 || freq_KHz == 355000) &&
+		     state->tuner_custom_cfg != 1) ||
+		    ((freq_KHz == 467000 || freq_KHz == 762000 ||
+		      freq_KHz == 778000 || freq_KHz == 818000) &&
+		     state->tuner_custom_cfg == 1)) {
+			buf = buf - 1;
+		}
+	}
+	 _mt_fe_tn_set_reg(state, 0x0e, buf);
+	_mt_fe_tn_set_reg(state, 0x0d, buf);
+	f1f2number =
+	    (((DACFreq_KHz * M * buf) / crystal_KHz) << 16) / (N + 256) +
+	    (((DACFreq_KHz * M * buf) % crystal_KHz) << 16) / ((N + 256) *
+								crystal_KHz);
+	_mt_fe_tn_set_reg(state, 0xf1, (f1f2number & 0xff00) >> 8);
+	_mt_fe_tn_set_reg(state, 0xf2, f1f2number & 0x00ff);
+	 FreqTrue108_Hz =
+	    (N + 256) * crystal_KHz / (M * buf) * 1000 +
+	    (((N + 256) * crystal_KHz) % (M * buf)) * 1000 / (M * buf);
+	f1 = 4096;
+	fc = FreqTrue108_Hz;
+	fadc = fc / 4;
+	fsd = 27000000;
+	f2d = state->tuner_bandwidth * 1000 / 2 - 150;
+	f2 = (fsd / 250) * f2d / ((fc + 500) / 1000);
+	delta1 = ((f1 - f2) << 15) / f2;
+	Totalnum1 = ((f1 - f2) << 15) - delta1 * f2;
+	cntT = f2;
+	cntin = Totalnum1;
+	NCOI = delta1;
+	 z0 = cntin;
+	z1 = cntT;
+	z2 = NCOI;
+	tempnumber = (z0 & 0xff00) >> 8;
+	_mt_fe_tn_set_reg(state, 0xc9, (u8) (tempnumber & 0x0f));
+	tempnumber = (z0 & 0xff);
+	_mt_fe_tn_set_reg(state, 0xca, tempnumber);
+	 tempnumber = (z1 & 0xff00) >> 8;
+	_mt_fe_tn_set_reg(state, 0xcb, tempnumber);
+	tempnumber = (z1 & 0xff);
+	_mt_fe_tn_set_reg(state, 0xcc, tempnumber);
+	 tempnumber = (z2 & 0xff00) >> 8;
+	_mt_fe_tn_set_reg(state, 0xcd, tempnumber);
+	tempnumber = (z2 & 0xff);
+	_mt_fe_tn_set_reg(state, 0xce, tempnumber);
+	 tmp = f1;
+	f1 = f2;
+	f2 = tmp / 2;
+	delta1 = ((f1 - f2) << 15) / f2;
+	Totalnum1 = ((f1 - f2) << 15) - delta1 * f2;
+	NCOI = (f1 << 15) / f2 - (1 << 15);
+	cntT = f2;
+	cntin = Totalnum1;
+	z0 = cntin;
+	z1 = cntT;
+	z2 = NCOI;
+	tempnumber = (z0 & 0xff00) >> 8;
+	_mt_fe_tn_set_reg(state, 0xd9, (u8) (tempnumber & 0x0f));
+	tempnumber = (z0 & 0xff);
+	_mt_fe_tn_set_reg(state, 0xda, tempnumber);
+	 tempnumber = (z1 & 0xff00) >> 8;
+	_mt_fe_tn_set_reg(state, 0xdb, tempnumber);
+	tempnumber = (z1 & 0xff);
+	_mt_fe_tn_set_reg(state, 0xdc, tempnumber);
+	 tempnumber = (z2 & 0xff00) >> 8;
+	_mt_fe_tn_set_reg(state, 0xdd, tempnumber);
+	tempnumber = (z2 & 0xff);
+	_mt_fe_tn_set_reg(state, 0xde, tempnumber);
+
+	return 0;
+}
+
+static int _mt_fe_tn_preset_tc2800(struct m88dc2800_state *state)
+{
+	if (state->tuner_mtt == 0xD1) {
+		_mt_fe_tn_set_reg(state, 0x19, 0x4a);
+		_mt_fe_tn_set_reg(state, 0x1b, 0x4b);
+		 _mt_fe_tn_set_reg(state, 0x04, 0x04);
+		_mt_fe_tn_set_reg(state, 0x17, 0x0d);
+		_mt_fe_tn_set_reg(state, 0x62, 0x6c);
+		_mt_fe_tn_set_reg(state, 0x63, 0xf4);
+		_mt_fe_tn_set_reg(state, 0x1f, 0x0e);
+		_mt_fe_tn_set_reg(state, 0x6b, 0xf4);
+		_mt_fe_tn_set_reg(state, 0x14, 0x01);
+		_mt_fe_tn_set_reg(state, 0x5a, 0x75);
+		_mt_fe_tn_set_reg(state, 0x66, 0x74);
+		_mt_fe_tn_set_reg(state, 0x72, 0xe0);
+		_mt_fe_tn_set_reg(state, 0x70, 0x07);
+		_mt_fe_tn_set_reg(state, 0x15, 0x7b);
+		_mt_fe_tn_set_reg(state, 0x55, 0x71);
+		 _mt_fe_tn_set_reg(state, 0x75, 0x55);
+		_mt_fe_tn_set_reg(state, 0x76, 0xac);
+		_mt_fe_tn_set_reg(state, 0x77, 0x6c);
+		_mt_fe_tn_set_reg(state, 0x78, 0x8b);
+		_mt_fe_tn_set_reg(state, 0x79, 0x42);
+		_mt_fe_tn_set_reg(state, 0x7a, 0xd2);
+		 _mt_fe_tn_set_reg(state, 0x81, 0x01);
+		_mt_fe_tn_set_reg(state, 0x82, 0x00);
+		_mt_fe_tn_set_reg(state, 0x82, 0x02);
+		_mt_fe_tn_set_reg(state, 0x82, 0x04);
+		_mt_fe_tn_set_reg(state, 0x82, 0x06);
+		_mt_fe_tn_set_reg(state, 0x82, 0x08);
+		_mt_fe_tn_set_reg(state, 0x82, 0x09);
+		_mt_fe_tn_set_reg(state, 0x82, 0x29);
+		_mt_fe_tn_set_reg(state, 0x82, 0x49);
+		_mt_fe_tn_set_reg(state, 0x82, 0x58);
+		_mt_fe_tn_set_reg(state, 0x82, 0x59);
+		_mt_fe_tn_set_reg(state, 0x82, 0x98);
+		_mt_fe_tn_set_reg(state, 0x82, 0x99);
+		_mt_fe_tn_set_reg(state, 0x10, 0x05);
+		_mt_fe_tn_set_reg(state, 0x10, 0x0d);
+		_mt_fe_tn_set_reg(state, 0x11, 0x95);
+		_mt_fe_tn_set_reg(state, 0x11, 0x9d);
+		if (state->tuner_loopthrough != 0) {
+			_mt_fe_tn_set_reg(state, 0x67, 0x25);
+		} else {
+			_mt_fe_tn_set_reg(state, 0x67, 0x05);
+		}
+	} else if (state->tuner_mtt == 0xE1) {
+		_mt_fe_tn_set_reg(state, 0x1b, 0x47);
+		if (state->tuner_mode == 0) {	/* DVB-C */
+			_mt_fe_tn_set_reg(state, 0x66, 0x74);
+			_mt_fe_tn_set_reg(state, 0x62, 0x2c);
+			_mt_fe_tn_set_reg(state, 0x63, 0x54);
+			_mt_fe_tn_set_reg(state, 0x68, 0x0b);
+			_mt_fe_tn_set_reg(state, 0x14, 0x00);
+		} else {			/* CTTB */
+			_mt_fe_tn_set_reg(state, 0x66, 0x74);
+			_mt_fe_tn_set_reg(state, 0x62, 0x0c);
+			_mt_fe_tn_set_reg(state, 0x63, 0x54);
+			_mt_fe_tn_set_reg(state, 0x68, 0x0b);
+			_mt_fe_tn_set_reg(state, 0x14, 0x05);
+		}
+		_mt_fe_tn_set_reg(state, 0x6f, 0x00);
+		_mt_fe_tn_set_reg(state, 0x84, 0x04);
+		_mt_fe_tn_set_reg(state, 0x5e, 0xbe);
+		_mt_fe_tn_set_reg(state, 0x87, 0x07);
+		_mt_fe_tn_set_reg(state, 0x8a, 0x1f);
+		_mt_fe_tn_set_reg(state, 0x8b, 0x1f);
+		_mt_fe_tn_set_reg(state, 0x88, 0x30);
+		_mt_fe_tn_set_reg(state, 0x58, 0x34);
+		_mt_fe_tn_set_reg(state, 0x61, 0x8c);
+		_mt_fe_tn_set_reg(state, 0x6a, 0x42);
+	}
+	return 0;
+}
+
+static int mt_fe_tn_wakeup_tc2800(struct m88dc2800_state *state)
+{
+	_mt_fe_tn_set_reg(state, 0x16, 0xb1);
+	_mt_fe_tn_set_reg(state, 0x09, 0x7d);
+	return 0;
+}
+
+  static int mt_fe_tn_sleep_tc2800(struct m88dc2800_state *state)
+{
+	_mt_fe_tn_set_reg(state, 0x16, 0xb0);
+	_mt_fe_tn_set_reg(state, 0x09, 0x6d);
+	return 0;
+}
+
+ static int mt_fe_tn_init_tc2800(struct m88dc2800_state *state)
+{
+	if (state->tuner_init_OK != 1) {
+		state->tuner_dev_addr = 0x61;	/* TUNER_I2C_ADDR_TC2800 */
+		state->tuner_freq = 650000;
+		state->tuner_qam = 0;
+		state->tuner_mode = 0;	// 0: DVB-C, 1: CTTB
+		state->tuner_bandwidth = 8;
+		state->tuner_loopthrough = 0;
+		state->tuner_crystal = 24000;
+		state->tuner_dac = 7200;
+		state->tuner_mtt = 0x00;
+		state->tuner_custom_cfg = 0;
+		state->tuner_version = 30022;	/* Driver version number */
+		state->tuner_time = 12092611;
+		state->tuner_init_OK = 1;
+	}
+	_mt_fe_tn_set_reg(state, 0x2b, 0x46);
+	_mt_fe_tn_set_reg(state, 0x2c, 0x75);
+	if (state->tuner_mtt == 0x00) {
+		u8 tmp = 0;
+		_mt_fe_tn_get_reg(state, 0x01, &tmp);
+		printk(KERN_INFO "m88dc2800: tuner id = 0x%02x ", tmp);
+		switch (tmp) {
+		case 0x0d:
+			state->tuner_mtt = 0xD1;
+			break;
+		case 0x8e:
+		default:
+			state->tuner_mtt = 0xE1;
+			break;
+		}
+	}
+	return 0;
+}
+
+ static int mt_fe_tn_set_freq_tc2800(struct m88dc2800_state *state,
+				       u32 freq_KHz)
+{
+	u8 buf;
+	u8 buf1;
+
+	mt_fe_tn_init_tc2800(state);
+	state->tuner_freq = freq_KHz;
+	_mt_fe_tn_set_reg(state, 0x21, freq_KHz > 500000 ? 0xb9 : 0x99);
+	mt_fe_tn_wakeup_tc2800(state);
+	 _mt_fe_tn_set_reg(state, 0x05, 0x7f);
+	_mt_fe_tn_set_reg(state, 0x06, 0xf8);
+	 _mt_fe_tn_set_RF_front_tc2800(state);
+	_mt_fe_tn_set_PLL_freq_tc2800(state);
+	_mt_fe_tn_set_DAC_tc2800(state);
+	_mt_fe_tn_set_BB_tc2800(state);
+	_mt_fe_tn_preset_tc2800(state);
+	 _mt_fe_tn_set_reg(state, 0x05, 0x00);
+	_mt_fe_tn_set_reg(state, 0x06, 0x00);
+	 if (state->tuner_mtt == 0xD1) {
+		_mt_fe_tn_set_reg(state, 0x00, 0x01);
+		_mt_fe_tn_set_reg(state, 0x00, 0x00);
+		 msleep(5);
+		_mt_fe_tn_set_reg(state, 0x41, 0x00);
+		msleep(5);
+		_mt_fe_tn_set_reg(state, 0x41, 0x02);
+
+		_mt_fe_tn_get_reg(state, 0x69, &buf1);
+		buf1 = buf1 & 0x0f;
+		_mt_fe_tn_get_reg(state, 0x61, &buf);
+		buf = buf & 0x0f;
+		if (buf == 0x0c)
+			_mt_fe_tn_set_reg(state, 0x6a, 0x59);
+		if (buf1 > 0x02) {
+			if (freq_KHz > 600000)
+				_mt_fe_tn_set_reg(state, 0x66, 0x44);
+			else if (freq_KHz > 500000)
+				_mt_fe_tn_set_reg(state, 0x66, 0x64);
+			else
+				_mt_fe_tn_set_reg(state, 0x66, 0x74);
+		}		
+		if (buf1 < 0x03) {
+			if (freq_KHz > 800000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x64);
+			else if (freq_KHz > 600000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x54);
+			else if (freq_KHz > 500000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x54);
+			else if (freq_KHz > 300000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x43);
+			else if (freq_KHz > 220000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x54);
+			else if (freq_KHz > 110000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x14);
+			else
+				_mt_fe_tn_set_reg(state, 0x87, 0x54);
+			msleep(5);
+		} else if (buf < 0x0c) {
+			if (freq_KHz > 800000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x14);
+			else if (freq_KHz > 600000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x14);
+			else if (freq_KHz > 500000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x34);
+			else if (freq_KHz > 300000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x43);
+			else if (freq_KHz > 220000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x54);
+			else if (freq_KHz > 110000)
+				_mt_fe_tn_set_reg(state, 0x87, 0x14);
+			else
+				_mt_fe_tn_set_reg(state, 0x87, 0x54);
+			msleep(5);
+		}
+	} else if ((state->tuner_mtt == 0xE1)) {
+		_mt_fe_tn_set_reg(state, 0x00, 0x01);
+		_mt_fe_tn_set_reg(state, 0x00, 0x00);
+		 msleep(20);
+		 _mt_fe_tn_get_reg(state, 0x32, &buf);
+		buf = (buf & 0xef) | 0x28;
+		_mt_fe_tn_set_reg(state, 0x32, buf);
+		 msleep(50);
+		_mt_fe_tn_get_reg(state, 0x38, &buf);
+		_mt_fe_tn_set_reg(state, 0x38, buf);
+		_mt_fe_tn_get_reg(state, 0x32, &buf);
+		buf = (buf & 0xf7) | 0x10;
+		_mt_fe_tn_set_reg(state, 0x32, buf);
+		 msleep(10);
+		 _mt_fe_tn_get_reg(state, 0x69, &buf);
+		buf = buf & 0x03;
+		_mt_fe_tn_set_reg(state, 0x2a, buf);
+		if (buf > 0) {
+			msleep(20);
+			_mt_fe_tn_get_reg(state, 0x84, &buf);
+			buf = buf & 0x1f;
+			_mt_fe_tn_set_reg(state, 0x68, 0x0a);
+			_mt_fe_tn_get_reg(state, 0x88, &buf1);
+			buf1 = buf1 & 0x1f;
+			if (buf <= buf1)
+				_mt_fe_tn_set_reg(state, 0x66, 0x44);
+			else
+				_mt_fe_tn_set_reg(state, 0x66, 0x74);
+		} else {
+			if (freq_KHz <= 600000)
+				_mt_fe_tn_set_reg(state, 0x68, 0x0c);
+			else
+				_mt_fe_tn_set_reg(state, 0x68, 0x0e);
+			_mt_fe_tn_set_reg(state, 0x30, 0xfb);
+			_mt_fe_tn_set_reg(state, 0x30, 0xff);
+			_mt_fe_tn_set_reg(state, 0x31, 0x04);
+			_mt_fe_tn_set_reg(state, 0x31, 0x00);
+		}
+		if (state->tuner_loopthrough != 0) {
+			_mt_fe_tn_get_reg(state, 0x28, &buf);
+			if (buf == 0) {
+				_mt_fe_tn_set_reg(state, 0x28, 0xff);
+				_mt_fe_tn_get_reg(state, 0x61, &buf);
+				buf = buf & 0x0f;
+				if (buf > 9)
+					_mt_fe_tn_set_reg(state, 0x67, 0x74);
+				else if (buf > 6)
+					_mt_fe_tn_set_reg(state, 0x67, 0x64);
+				else if (buf > 3)
+					_mt_fe_tn_set_reg(state, 0x67, 0x54);
+				else
+					_mt_fe_tn_set_reg(state, 0x67, 0x44);
+			}
+		} else {
+			_mt_fe_tn_set_reg(state, 0x67, 0x34);
+		}
+	} else {
+		return 1;
+	}
+	return 0;
+}
+
+
+/*
+static int mt_fe_tn_set_BB_filter_band_tc2800(struct m88dc2800_state *state,
+					      u8 bandwidth)
+{
+	u8 buf, tmp;
+
+	_mt_fe_tn_get_reg(state, 0x53, &tmp);
+
+	if (bandwidth == 6)
+		buf = 0x01 << 1;
+	else if (bandwidth == 7)
+		buf = 0x02 << 1;
+	else if (bandwidth == 8)
+		buf = 0x04 << 1;
+	else
+		buf = 0x04 << 1;
+
+	tmp &= 0xf1;
+	tmp |= buf;
+	_mt_fe_tn_set_reg(state, 0x53, tmp);
+	state->tuner_bandwidth = bandwidth;
+	return 0;
+}
+*/
+
+static s32 mt_fe_tn_get_signal_strength_tc2800(struct m88dc2800_state
+					       *state)
+{
+	s32 level = -107;
+	s32 tmp1, tmp2, tmp3, tmp4, tmp5, tmp6;
+	s32 val1, val2, val;
+	s32 result2, result3, result4, result5, result6;
+	s32 append;
+	u8 tmp;
+	s32 freq_KHz = (s32) state->tuner_freq;
+	if (state->tuner_mtt == 0xD1) {
+		_mt_fe_tn_get_reg(state, 0x61, &tmp);
+		tmp1 = tmp & 0x0f;
+		 _mt_fe_tn_get_reg(state, 0x69, &tmp);
+		tmp2 = tmp & 0x0f;
+		 _mt_fe_tn_get_reg(state, 0x73, &tmp);
+		tmp3 = tmp & 0x07;
+		 _mt_fe_tn_get_reg(state, 0x7c, &tmp);
+		tmp4 = (tmp >> 4) & 0x0f;
+		 _mt_fe_tn_get_reg(state, 0x7b, &tmp);
+		tmp5 = tmp & 0x0f;
+		 _mt_fe_tn_get_reg(state, 0x7f, &tmp);
+		tmp6 = (tmp >> 5) & 0x01;
+		if (tmp1 > 6) {
+			val1 = 0;
+			if (freq_KHz <= 200000) {
+				val2 = (tmp1 - 6) * 267;
+			} else if (freq_KHz <= 600000) {
+				val2 = (tmp1 - 6) * 280;
+			} else {
+				val2 = (tmp1 - 6) * 290;
+			}
+			val = val1 + val2;
+		} else {
+			if (tmp1 == 0) {
+				val1 = -550;
+			} else {
+				val1 = 0;
+			}
+			if ((tmp1 < 4) && (freq_KHz >= 506000)) {
+				val1 = -850;
+			}
+			val2 = 0;
+			val = val1 + val2;
+		}
+		if (freq_KHz <= 95000) {
+			result2 = tmp2 * 289;
+		} else if (freq_KHz <= 155000) {
+			result2 = tmp2 * 278;
+		} else if (freq_KHz <= 245000) {
+			result2 = tmp2 * 267;
+		} else if (freq_KHz <= 305000) {
+			result2 = tmp2 * 256;
+		} else if (freq_KHz <= 335000) {
+			result2 = tmp2 * 244;
+		} else if (freq_KHz <= 425000) {
+			result2 = tmp2 * 233;
+		} else if (freq_KHz <= 575000) {
+			result2 = tmp2 * 222;
+		} else if (freq_KHz <= 665000) {
+			result2 = tmp2 * 211;
+		} else {
+			result2 = tmp2 * 200;
+		}
+		result3 = (6 - tmp3) * 100;
+		result4 = 300 * tmp4;
+		result5 = 50 * tmp5;
+		result6 = 300 * tmp6;
+		if (freq_KHz < 105000) {
+			append = -450;
+		} else if (freq_KHz <= 227000) {
+			append = -4 * (freq_KHz / 1000 - 100) + 150;
+		} else if (freq_KHz <= 305000) {
+			append = -4 * (freq_KHz / 1000 - 100);
+		} else if (freq_KHz <= 419000) {
+			append = 500 - 40 * (freq_KHz / 1000 - 300) / 17 + 130;
+		} else if (freq_KHz <= 640000) {
+			append = 500 - 40 * (freq_KHz / 1000 - 300) / 17;
+		} else {
+			append = -500;
+		}
+		level = append - (val + result2 + result3 + result4 +
+				  result5 + result6);
+		level /= 100;
+	} else if (state->tuner_mtt == 0xE1) {
+		_mt_fe_tn_get_reg(state, 0x61, &tmp);
+		tmp1 = tmp & 0x0f;
+		 _mt_fe_tn_get_reg(state, 0x84, &tmp);
+		tmp2 = tmp & 0x1f;
+		 _mt_fe_tn_get_reg(state, 0x69, &tmp);
+		tmp3 = tmp & 0x03;
+		 _mt_fe_tn_get_reg(state, 0x73, &tmp);
+		tmp4 = tmp & 0x0f;
+		 _mt_fe_tn_get_reg(state, 0x7c, &tmp);
+		tmp5 = (tmp >> 4) & 0x0f;
+		 _mt_fe_tn_get_reg(state, 0x7b, &tmp);
+		tmp6 = tmp & 0x0f;
+		if (freq_KHz < 151000) {
+			result2 = (1150 - freq_KHz / 100) * 163 / 33 + 4230;
+			result3 = (1150 - freq_KHz / 100) * 115 / 33 + 1850;
+			result4 = -3676 * (freq_KHz / 1000) / 100 + 6115;
+		} else if (freq_KHz < 257000) {
+			result2 = (1540 - freq_KHz / 100) * 11 / 4 + 3870;
+			result3 = (1540 - freq_KHz / 100) * 205 / 96 + 2100;
+			result4 = -21 * freq_KHz / 1000 + 5084;
+		} else if (freq_KHz < 305000) {
+			result2 = (2620 - freq_KHz / 100) * 5 / 3 + 2770;
+			result3 = (2620 - freq_KHz / 100) * 10 / 7 + 1700;
+			result4 = 650;
+		} else if (freq_KHz < 449000) {
+			result2 = (307 - freq_KHz / 1000) * 82 / 27 + 11270;
+			result3 = (3100 - freq_KHz / 100) * 5 / 3 + 10000;
+			result4 = 134 * freq_KHz / 10000 + 11875;
+		} else {
+			result2 = (307 - freq_KHz / 1000) * 82 / 27 + 11270;
+			result3 = 8400;
+			result4 = 5300;
+		}
+		if (tmp1 > 6) {
+			val1 = result2;
+			val2 = 2900;
+			val = 500;
+		} else if (tmp1 > 0) {
+			val1 = result3;
+			val2 = 2700;
+			val = 500;
+		} else {
+			val1 = result4;
+			val2 = 2700;
+			val = 400;
+		}
+		level = val1 - (val2 * tmp1 + 500 * tmp2 + 3000 * tmp3 -
+			    500 * tmp4 + 3000 * tmp5 + val * tmp6) - 1000;
+		level /= 1000;
+	}
+	return level;
+}
+
+
+/* m88dc2800 operation functions */
+u8 M88DC2000GetLock(struct m88dc2800_state * state)
+{
+	u8 u8ret = 0;
+	if (ReadReg(state, 0x80) < 0x06) {
+		if ((ReadReg(state, 0xdf) & 0x80) == 0x80
+		     &&(ReadReg(state, 0x91) & 0x23) == 0x03
+		     &&(ReadReg(state, 0x43) & 0x08) == 0x08)
+			u8ret = 1;
+		else
+			u8ret = 0;
+	} else {
+		if ((ReadReg(state, 0x85) & 0x08) == 0x08)
+			u8ret = 1;
+		else
+			u8ret = 0;
+	}
+	dprintk("%s, lock=%d\n", __func__, u8ret);
+	return u8ret;
+}
+
+static int M88DC2000SetTsType(struct m88dc2800_state *state, u8 type)
+{
+	u8 regC2H;
+
+	if (type == 3) {
+		WriteReg(state, 0x84, 0x6A);
+		WriteReg(state, 0xC0, 0x43);
+		WriteReg(state, 0xE2, 0x06);
+		regC2H = ReadReg(state, 0xC2);
+		regC2H &= 0xC0;
+		regC2H |= 0x1B;
+		WriteReg(state, 0xC2, regC2H);
+		WriteReg(state, 0xC1, 0x60);	/* common interface */
+	} else if (type == 1) {
+		WriteReg(state, 0x84, 0x6A);
+		WriteReg(state, 0xC0, 0x47);	/* serial format */
+		WriteReg(state, 0xE2, 0x02);
+		regC2H = ReadReg(state, 0xC2);
+		regC2H &= 0xC7;
+		WriteReg(state, 0xC2, regC2H);
+		WriteReg(state, 0xC1, 0x00);
+	} else {
+		WriteReg(state, 0x84, 0x6C);
+		WriteReg(state, 0xC0, 0x43);	/* parallel format */
+		WriteReg(state, 0xE2, 0x06);
+		regC2H = ReadReg(state, 0xC2);
+		regC2H &= 0xC7;
+		WriteReg(state, 0xC2, regC2H);
+		WriteReg(state, 0xC1, 0x00);
+	}
+	return 0;
+}
+
+static int M88DC2000RegInitial_TC2800(struct m88dc2800_state *state)
+{
+	u8 RegE3H, RegE4H;
+
+	WriteReg(state, 0x00, 0x48);
+	WriteReg(state, 0x01, 0x09);
+	WriteReg(state, 0xFB, 0x0A);
+	WriteReg(state, 0xFC, 0x0B);
+	WriteReg(state, 0x02, 0x0B);
+	WriteReg(state, 0x03, 0x18);
+	WriteReg(state, 0x05, 0x0D);
+	WriteReg(state, 0x36, 0x80);
+	WriteReg(state, 0x43, 0x40);
+	WriteReg(state, 0x55, 0x7A);
+	WriteReg(state, 0x56, 0xD9);
+	WriteReg(state, 0x57, 0xDF);
+	WriteReg(state, 0x58, 0x39);
+	WriteReg(state, 0x5A, 0x00);
+	WriteReg(state, 0x5C, 0x71);
+	WriteReg(state, 0x5D, 0x23);
+	WriteReg(state, 0x86, 0x40);
+	WriteReg(state, 0xF9, 0x08);
+	WriteReg(state, 0x61, 0x40);
+	WriteReg(state, 0x62, 0x0A);
+	WriteReg(state, 0x90, 0x06);
+	WriteReg(state, 0xDE, 0x00);
+	WriteReg(state, 0xA0, 0x03);
+	WriteReg(state, 0xDF, 0x81);
+	WriteReg(state, 0xFA, 0x40);
+	WriteReg(state, 0x37, 0x10);
+	WriteReg(state, 0xF0, 0x40);
+	WriteReg(state, 0xF2, 0x9C);
+	WriteReg(state, 0xF3, 0x40);
+	RegE3H = ReadReg(state, 0xE3);
+	RegE4H = ReadReg(state, 0xE4);
+	if (((RegE3H & 0xC0) == 0x00) && ((RegE4H & 0xC0) == 0x00)) {
+		WriteReg(state, 0x30, 0xFF);
+		WriteReg(state, 0x31, 0x00);
+		WriteReg(state, 0x32, 0x00);
+		WriteReg(state, 0x33, 0x00);
+		WriteReg(state, 0x35, 0x32);
+		WriteReg(state, 0x40, 0x00);
+		WriteReg(state, 0x41, 0x10);
+		WriteReg(state, 0xF1, 0x02);
+		WriteReg(state, 0xF4, 0x04);
+		WriteReg(state, 0xF5, 0x00);
+		WriteReg(state, 0x42, 0x14);
+		WriteReg(state, 0xE1, 0x25);
+	} else if (((RegE3H & 0xC0) == 0x80) && ((RegE4H & 0xC0) == 0x40)) {
+		WriteReg(state, 0x30, 0xFF);
+		WriteReg(state, 0x31, 0x00);
+		WriteReg(state, 0x32, 0x00);
+		WriteReg(state, 0x33, 0x00);
+		WriteReg(state, 0x35, 0x32);
+		WriteReg(state, 0x39, 0x00);
+		WriteReg(state, 0x3A, 0x00);
+		WriteReg(state, 0x40, 0x00);
+		WriteReg(state, 0x41, 0x10);
+		WriteReg(state, 0xF1, 0x00);
+		WriteReg(state, 0xF4, 0x00);
+		WriteReg(state, 0xF5, 0x40);
+		WriteReg(state, 0x42, 0x14);
+		WriteReg(state, 0xE1, 0x25);
+	} else if ((RegE3H == 0x80 || RegE3H == 0x81)
+		    && (RegE4H == 0x80 || RegE4H == 0x81)) {
+		WriteReg(state, 0x30, 0xFF);
+		WriteReg(state, 0x31, 0x00);
+		WriteReg(state, 0x32, 0x00);
+		WriteReg(state, 0x33, 0x00);
+		WriteReg(state, 0x35, 0x32);
+		WriteReg(state, 0x39, 0x00);
+		WriteReg(state, 0x3A, 0x00);
+		WriteReg(state, 0xF1, 0x00);
+		WriteReg(state, 0xF4, 0x00);
+		WriteReg(state, 0xF5, 0x40);
+		WriteReg(state, 0x42, 0x24);
+		WriteReg(state, 0xE1, 0x25);
+		WriteReg(state, 0x92, 0x7F);
+		WriteReg(state, 0x93, 0x91);
+		WriteReg(state, 0x95, 0x00);
+		WriteReg(state, 0x2B, 0x33);
+		WriteReg(state, 0x2A, 0x2A);
+		WriteReg(state, 0x2E, 0x80);
+		WriteReg(state, 0x25, 0x25);
+		WriteReg(state, 0x2D, 0xFF);
+		WriteReg(state, 0x26, 0xFF);
+		WriteReg(state, 0x27, 0x00);
+		WriteReg(state, 0x24, 0x25);
+		WriteReg(state, 0xA4, 0xFF);
+		WriteReg(state, 0xA3, 0x0D);
+	} else {
+		WriteReg(state, 0x30, 0xFF);
+		WriteReg(state, 0x31, 0x00);
+		WriteReg(state, 0x32, 0x00);
+		WriteReg(state, 0x33, 0x00);
+		WriteReg(state, 0x35, 0x32);
+		WriteReg(state, 0x39, 0x00);
+		WriteReg(state, 0x3A, 0x00);
+		WriteReg(state, 0xF1, 0x00);
+		WriteReg(state, 0xF4, 0x00);
+		WriteReg(state, 0xF5, 0x40);
+		WriteReg(state, 0x42, 0x24);
+		WriteReg(state, 0xE1, 0x27);
+		WriteReg(state, 0x92, 0x7F);
+		WriteReg(state, 0x93, 0x91);
+		WriteReg(state, 0x95, 0x00);
+		WriteReg(state, 0x2B, 0x33);
+		WriteReg(state, 0x2A, 0x2A);
+		WriteReg(state, 0x2E, 0x80);
+		WriteReg(state, 0x25, 0x25);
+		WriteReg(state, 0x2D, 0xFF);
+		WriteReg(state, 0x26, 0xFF);
+		WriteReg(state, 0x27, 0x00);
+		WriteReg(state, 0x24, 0x25);
+		WriteReg(state, 0xA4, 0xFF);
+		WriteReg(state, 0xA3, 0x10);
+	}
+	WriteReg(state, 0xF6, 0x4E);
+	WriteReg(state, 0xF7, 0x20);
+	WriteReg(state, 0x89, 0x02);
+	WriteReg(state, 0x14, 0x08);
+	WriteReg(state, 0x6F, 0x0D);
+	WriteReg(state, 0x10, 0xFF);
+	WriteReg(state, 0x11, 0x00);
+	WriteReg(state, 0x12, 0x30);
+	WriteReg(state, 0x13, 0x23);
+	WriteReg(state, 0x60, 0x00);
+	WriteReg(state, 0x69, 0x00);
+	WriteReg(state, 0x6A, 0x03);
+	WriteReg(state, 0xE0, 0x75);
+	WriteReg(state, 0x8D, 0x29);
+	WriteReg(state, 0x4E, 0xD8);
+	WriteReg(state, 0x88, 0x80);
+	WriteReg(state, 0x52, 0x79);
+	WriteReg(state, 0x53, 0x03);
+	WriteReg(state, 0x59, 0x30);
+	WriteReg(state, 0x5E, 0x02);
+	WriteReg(state, 0x5F, 0x0F);
+	WriteReg(state, 0x71, 0x03);
+	WriteReg(state, 0x72, 0x12);
+	WriteReg(state, 0x73, 0x12);
+
+	return 0;
+}
+
+static int M88DC2000AutoTSClock_P(struct m88dc2800_state *state, u32 sym,
+				  u16 qam)
+{
+	u32 dataRate;
+	u8 clk_div, value;
+	printk(KERN_INFO
+	       "m88dc2800: M88DC2000AutoTSClock_P, symrate=%d qam=%d\n",
+	       sym, qam);
+	switch (qam) {
+	case 16:
+		dataRate = 4;
+		break;
+	case 32:
+		dataRate = 5;
+		break;
+	case 128:
+		dataRate = 7;
+		break;
+	case 256:
+		dataRate = 8;
+		break;
+	case 64:
+	default:
+		dataRate = 6;
+		break;
+	}
+	dataRate *= sym * 105;
+	dataRate /= 800;
+	if (dataRate <= 4115)
+		clk_div = 0x05;
+	else if (dataRate <= 4800)
+		clk_div = 0x04;
+	else if (dataRate <= 5760)
+		clk_div = 0x03;
+	else if (dataRate <= 7200)
+		clk_div = 0x02;
+	else if (dataRate <= 9600)
+		clk_div = 0x01;
+	else
+		clk_div = 0x00;
+	value = ReadReg(state, 0xC2);
+	value &= 0xc0;
+	value |= clk_div;
+	WriteReg(state, 0xC2, value);
+	return 0;
+}
+
+static int M88DC2000AutoTSClock_C(struct m88dc2800_state *state, u32 sym,
+				  u16 qam)
+{
+	u32 dataRate;
+	u8 clk_div, value;
+	printk(KERN_INFO
+	       "m88dc2800: M88DC2000AutoTSClock_C, symrate=%d qam=%d\n",
+	       sym, qam);
+	switch (qam) {
+	case 16:
+		dataRate = 4;
+		break;
+	case 32:
+		dataRate = 5;
+		break;
+	case 128:
+		dataRate = 7;
+		break;
+	case 256:
+		dataRate = 8;
+		break;
+	case 64:
+	default:
+		dataRate = 6;
+		break;
+	}
+	dataRate *= sym * 105;
+	dataRate /= 800;
+	if (dataRate <= 4115)
+		clk_div = 0x3F;
+	else if (dataRate <= 4800)
+		clk_div = 0x36;
+	else if (dataRate <= 5760)
+		clk_div = 0x2D;
+	else if (dataRate <= 7200)
+		clk_div = 0x24;
+	else if (dataRate <= 9600)
+		clk_div = 0x1B;
+	else
+		clk_div = 0x12;
+	value = ReadReg(state, 0xC2);
+	value &= 0xc0;
+	value |= clk_div;
+	WriteReg(state, 0xC2, value);
+	return 0;
+}
+
+static int M88DC2000SetTxMode(struct m88dc2800_state *state, u8 inverted,
+			      u8 j83)
+{
+	u8 value = 0;
+	if (inverted)
+		value |= 0x08;	/*	spectrum inverted	*/
+	if (j83)
+		value |= 0x01;	/*	J83C			*/
+	WriteReg(state, 0x83, value);
+	return 0;
+}
+
+static int M88DC2000SoftReset(struct m88dc2800_state *state)
+{
+	WriteReg(state, 0x80, 0x01);
+	WriteReg(state, 0x82, 0x00);
+	msleep(1);
+	WriteReg(state, 0x80, 0x00);
+	return 0;
+}
+
+static int M88DC2000SetSym(struct m88dc2800_state *state, u32 sym, u32 xtal)
+{
+	u8 value;
+	u8 reg6FH, reg12H;
+	u64 fValue;
+	u32 dwValue;
+
+	printk(KERN_INFO "%s, sym=%d, xtal=%d\n", __func__, sym, xtal);
+	fValue = 4294967296 * (sym + 10);
+	do_div(fValue, xtal);
+
+	/* fValue  = 4294967296 * (sym + 10) / xtal; */
+	dwValue = (u32) fValue;
+	printk(KERN_INFO "%s, fvalue1=%x\n", __func__, dwValue);
+	WriteReg(state, 0x58, (u8) ((dwValue >> 24) & 0xff));
+	WriteReg(state, 0x57, (u8) ((dwValue >> 16) & 0xff));
+	WriteReg(state, 0x56, (u8) ((dwValue >> 8) & 0xff));
+	WriteReg(state, 0x55, (u8) ((dwValue >> 0) & 0xff));
+
+	/* fValue = 2048 * xtal / sym; */
+	fValue = 2048 * xtal;
+	do_div(fValue, sym);
+	dwValue = (u32) fValue;
+	printk(KERN_INFO "%s, fvalue2=%x\n", __func__, dwValue);
+	WriteReg(state, 0x5D, (u8) ((dwValue >> 8) & 0xff));
+	WriteReg(state, 0x5C, (u8) ((dwValue >> 0) & 0xff));
+	value = ReadReg(state, 0x5A);
+	if (((dwValue >> 16) & 0x0001) == 0)
+		value &= 0x7F;
+	else
+		value |= 0x80;
+	WriteReg(state, 0x5A, value);
+	value = ReadReg(state, 0x89);
+	if (sym <= 1800)
+		value |= 0x01;
+	else
+		value &= 0xFE;
+	WriteReg(state, 0x89, value);
+	if (sym >= 6700) {
+		reg6FH = 0x0D;
+		reg12H = 0x30;
+	} else if (sym >= 4000) {
+		fValue = 22 * 4096 / sym;
+		reg6FH = (u8) fValue;
+		reg12H = 0x30;
+	} else if (sym >= 2000) {
+		fValue = 14 * 4096 / sym;
+		reg6FH = (u8) fValue;
+		reg12H = 0x20;
+	} else {
+		fValue = 7 * 4096 / sym;
+		reg6FH = (u8) fValue;
+		reg12H = 0x10;
+	}
+	WriteReg(state, 0x6F, reg6FH);
+	WriteReg(state, 0x12, reg12H);
+	if (((ReadReg(state, 0xE3) & 0x80) == 0x80)
+	       && ((ReadReg(state, 0xE4) & 0x80) == 0x80)) {
+		if (sym < 3000) {
+			WriteReg(state, 0x6C, 0x16);
+			WriteReg(state, 0x6D, 0x10);
+			WriteReg(state, 0x6E, 0x18);
+		} else {
+			WriteReg(state, 0x6C, 0x14);
+			WriteReg(state, 0x6D, 0x0E);
+			WriteReg(state, 0x6E, 0x36);
+		}
+	} else {
+		WriteReg(state, 0x6C, 0x16);
+		WriteReg(state, 0x6D, 0x10);
+		WriteReg(state, 0x6E, 0x18);
+	}
+	return 0;
+}
+
+static int M88DC2000SetQAM(struct m88dc2800_state *state, u16 qam)
+{
+	u8 reg00H, reg4AH, regC2H, reg44H, reg4CH, reg4DH, reg74H, value;
+	u8 reg8BH, reg8EH;
+	printk(KERN_INFO "%s, qam=%d\n", __func__, qam);
+	regC2H = ReadReg(state, 0xC2);
+	regC2H &= 0xF8;
+	switch (qam) {
+	case 16:		/* 16 QAM */
+		reg00H = 0x08;
+		reg4AH = 0x0F;
+		regC2H |= 0x02;
+		reg44H = 0xAA;
+		reg4CH = 0x0C;
+		reg4DH = 0xF7;
+		reg74H = 0x0E;
+		if (((ReadReg(state, 0xE3) & 0x80) == 0x80)
+		     && ((ReadReg(state, 0xE4) & 0x80) == 0x80)) {
+			reg8BH = 0x5A;
+			reg8EH = 0xBD;
+		} else {
+			reg8BH = 0x5B;
+			reg8EH = 0x9D;
+		}
+		WriteReg(state, 0x6E, 0x18);
+		break;
+	case 32:		/* 32 QAM */
+		reg00H = 0x18;
+		reg4AH = 0xFB;
+		regC2H |= 0x02;
+		reg44H = 0xAA;
+		reg4CH = 0x0C;
+		reg4DH = 0xF7;
+		reg74H = 0x0E;
+		if (((ReadReg(state, 0xE3) & 0x80) == 0x80)
+		     && ((ReadReg(state, 0xE4) & 0x80) == 0x80)) {
+			reg8BH = 0x5A;
+			reg8EH = 0xBD;
+		} else {
+			reg8BH = 0x5B;
+			reg8EH = 0x9D;
+		}
+		WriteReg(state, 0x6E, 0x18);
+		break;
+	case 64:		/* 64 QAM */
+		reg00H = 0x48;
+		reg4AH = 0xCD;
+		regC2H |= 0x02;
+		reg44H = 0xAA;
+		reg4CH = 0x0C;
+		reg4DH = 0xF7;
+		reg74H = 0x0E;
+		if (((ReadReg(state, 0xE3) & 0x80) == 0x80)
+		     && ((ReadReg(state, 0xE4) & 0x80) == 0x80)) {
+			reg8BH = 0x5A;
+			reg8EH = 0xBD;
+		} else {
+			reg8BH = 0x5B;
+			reg8EH = 0x9D;
+		}
+		break;
+	case 128:		/* 128 QAM */
+		reg00H = 0x28;
+		reg4AH = 0xFF;
+		regC2H |= 0x02;
+		reg44H = 0xA9;
+		reg4CH = 0x08;
+		reg4DH = 0xF5;
+		reg74H = 0x0E;
+		reg8BH = 0x5B;
+		reg8EH = 0x9D;
+		break;
+	case 256:		/* 256 QAM */
+		reg00H = 0x38;
+		reg4AH = 0xCD;
+		if (((ReadReg(state, 0xE3) & 0x80) == 0x80)
+		     && ((ReadReg(state, 0xE4) & 0x80) == 0x80)) {
+			regC2H |= 0x02;
+		} else {
+			regC2H |= 0x01;
+		}
+		reg44H = 0xA9;
+		reg4CH = 0x08;
+		reg4DH = 0xF5;
+		reg74H = 0x0E;
+		reg8BH = 0x5B;
+		reg8EH = 0x9D;
+		break;
+	default:		/* 64 QAM */
+		reg00H = 0x48;
+		reg4AH = 0xCD;
+		regC2H |= 0x02;
+		reg44H = 0xAA;
+		reg4CH = 0x0C;
+		reg4DH = 0xF7;
+		reg74H = 0x0E;
+		if (((ReadReg(state, 0xE3) & 0x80) == 0x80)
+		     && ((ReadReg(state, 0xE4) & 0x80) == 0x80)) {
+			reg8BH = 0x5A;
+			reg8EH = 0xBD;
+		} else {
+			reg8BH = 0x5B;
+			reg8EH = 0x9D;
+		}
+		break;
+	}
+	WriteReg(state, 0x00, reg00H);
+	value = ReadReg(state, 0x88);
+	value |= 0x08;
+	WriteReg(state, 0x88, value);
+	WriteReg(state, 0x4B, 0xFF);
+	WriteReg(state, 0x4A, reg4AH);
+	value &= 0xF7;
+	WriteReg(state, 0x88, value);
+	WriteReg(state, 0xC2, regC2H);
+	WriteReg(state, 0x44, reg44H);
+	WriteReg(state, 0x4C, reg4CH);
+	WriteReg(state, 0x4D, reg4DH);
+	WriteReg(state, 0x74, reg74H);
+	WriteReg(state, 0x8B, reg8BH);
+	WriteReg(state, 0x8E, reg8EH);
+	return 0;
+}
+
+static int M88DC2000WriteTuner_TC2800(struct m88dc2800_state *state,
+				      u32 freq_KHz)
+{
+	printk(KERN_INFO "%s, freq=%d KHz\n", __func__, freq_KHz);
+	return mt_fe_tn_set_freq_tc2800(state, freq_KHz);
+}
+
+static int m88dc2800_init(struct dvb_frontend *fe)
+{
+	dprintk("%s()\n", __func__);
+	return 0;
+}
+
+static int m88dc2800_set_parameters(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	u8 is_annex_c, is_update;
+	u16 temp_qam;
+	s32 waiting_time;
+	struct m88dc2800_state *state = fe->demodulator_priv;
+
+	is_annex_c = c->delivery_system == SYS_DVBC_ANNEX_C ? 1 : 0;
+
+	switch (c->modulation) {
+	case QAM_16:
+		temp_qam = 16;
+		break;
+	case QAM_32:
+		temp_qam = 32;
+		break;
+	case QAM_128:
+		temp_qam = 128;
+		break;
+	case QAM_256:
+		temp_qam = 256;
+		break;
+	default:		/* QAM_64 */
+		temp_qam = 64;
+		break;
+	}
+
+	state->inverted = c->inversion == INVERSION_ON ? 1 : 0;
+
+	printk(KERN_INFO
+	     "m88dc2800: state, freq=%d qam=%d sym=%d inverted=%d xtal=%d\n",
+	     state->freq, state->qam, state->sym, state->inverted,
+	     state->xtal);
+	printk(KERN_INFO
+	     "m88dc2800: set frequency to %d qam=%d symrate=%d annex-c=%d\n",
+	     c->frequency, temp_qam, c->symbol_rate, is_annex_c);
+
+	is_update = 0;
+	WriteReg(state, 0x80, 0x01);
+	if (c->frequency != state->freq) {
+		M88DC2000WriteTuner_TC2800(state, c->frequency / 1000);
+		state->freq = c->frequency;
+	}
+	if (c->symbol_rate != state->sym) {
+		M88DC2000SetSym(state, c->symbol_rate / 1000, state->xtal);
+		state->sym = c->symbol_rate;
+		is_update = 1;
+	}
+	if (temp_qam != state->qam) {
+		M88DC2000SetQAM(state, temp_qam);
+		state->qam = temp_qam;
+		is_update = 1;
+	}
+
+	if (is_update != 0) {
+		if (state->config->ts_mode == 3)
+			M88DC2000AutoTSClock_C(state, state->sym / 1000,
+					       temp_qam);
+		else
+			M88DC2000AutoTSClock_P(state, state->sym / 1000,
+					       temp_qam);
+	}
+
+	M88DC2000SetTxMode(state, state->inverted, is_annex_c);
+	M88DC2000SoftReset(state);
+	if (((ReadReg(state, 0xE3) & 0x80) == 0x80)
+	    && ((ReadReg(state, 0xE4) & 0x80) == 0x80))
+		waiting_time = 800;
+	else
+		waiting_time = 500;
+	while (waiting_time > 0) {
+		msleep(50);
+		waiting_time -= 50;
+		if (M88DC2000GetLock(state))
+			return 0;
+	}
+
+	state->inverted = (state->inverted != 0) ? 0 : 1;
+	M88DC2000SetTxMode(state, state->inverted, is_annex_c);
+	M88DC2000SoftReset(state);
+	if (((ReadReg(state, 0xE3) & 0x80) == 0x80) &&
+	    ((ReadReg(state, 0xE4) & 0x80) == 0x80))
+		waiting_time = 800;
+	else
+		waiting_time = 500;
+	while (waiting_time > 0) {
+		msleep(50);
+		waiting_time -= 50;
+		if (M88DC2000GetLock(state))
+			return 0;
+	}
+	return 0;
+}
+
+static int m88dc2800_read_status(struct dvb_frontend *fe,
+				 fe_status_t * status)
+{
+	struct m88dc2800_state *state = fe->demodulator_priv;
+	*status = 0;
+
+	if (M88DC2000GetLock(state)) {
+		*status = FE_HAS_SIGNAL | FE_HAS_CARRIER
+		    |FE_HAS_SYNC | FE_HAS_VITERBI | FE_HAS_LOCK;
+	}
+	return 0;
+}
+
+static int m88dc2800_read_ber(struct dvb_frontend *fe, u32 * ber)
+{
+	struct m88dc2800_state *state = fe->demodulator_priv;
+	u16 tmp;
+
+	if (M88DC2000GetLock(state) == 0) {
+		state->ber = 0;
+	} else if ((ReadReg(state, 0xA0) & 0x80) != 0x80) {
+		tmp = ReadReg(state, 0xA2) << 8;
+		tmp += ReadReg(state, 0xA1);
+		state->ber = tmp;
+		WriteReg(state, 0xA0, 0x05);
+		WriteReg(state, 0xA0, 0x85);
+	}
+	*ber = state->ber;
+	return 0;
+}
+
+static int m88dc2800_read_signal_strength(struct dvb_frontend *fe,
+					  u16 * strength)
+{
+	struct m88dc2800_state *state = fe->demodulator_priv;
+	s16 tuner_strength;
+
+	tuner_strength = mt_fe_tn_get_signal_strength_tc2800(state);
+	*strength = tuner_strength < -107 ? 0 : tuner_strength + 107;
+
+	return 0;
+}
+
+static int m88dc2800_read_snr(struct dvb_frontend *fe, u16 * snr)
+{
+	static const u32 mes_log[] = {
+		0, 3010, 4771, 6021, 6990, 7781, 8451, 9031, 9542, 10000,
+		10414, 10792, 11139, 11461, 11761, 12041, 12304, 12553, 12788,
+		13010, 13222, 13424, 13617, 13802, 13979, 14150, 14314, 14472,
+		14624, 14771, 14914, 15052, 15185, 15315, 15441, 15563, 15682,
+		15798, 15911, 16021, 16128, 16232, 16335, 16435, 16532, 16628,
+		16721, 16812, 16902, 16990, 17076, 17160, 17243, 17324, 17404,
+		17482, 17559, 17634, 17709, 17782, 17853, 17924, 17993, 18062,
+		18129, 18195, 18261, 18325, 18388, 18451, 18513, 18573, 18633,
+		18692, 18751, 18808, 18865, 18921, 18976, 19031
+	};
+	struct m88dc2800_state *state = fe->demodulator_priv;
+	u8 i;
+	u32 _snr, mse;
+
+	if ((ReadReg(state, 0x91) & 0x23) != 0x03) {
+		*snr = 0;
+		return 0;
+	}
+	mse = 0;
+	for (i = 0; i < 30; i++) {
+		mse += (ReadReg(state, 0x08) << 8) + ReadReg(state, 0x07);
+	}
+	mse /= 30;
+	if (mse > 80)
+		mse = 80;
+	switch (state->qam) {
+	case 16:
+		_snr = 34080;
+		break;		/*      16QAM                           */
+	case 32:
+		_snr = 37600;
+		break;		/*      32QAM                           */
+	case 64:
+		_snr = 40310;
+		break;		/*      64QAM                           */
+	case 128:
+		_snr = 43720;
+		break;		/*      128QAM                          */
+	case 256:
+		_snr = 46390;
+		break;		/*      256QAM                          */
+	default:
+		_snr = 40310;
+		break;
+	}
+	_snr -= mes_log[mse - 1];	/*      C - 10*log10(MSE)       */
+	_snr /= 1000;
+	if (_snr > 0xff)
+		_snr = 0xff;
+	*snr = _snr;
+	return 0;
+}
+
+static int m88dc2800_read_ucblocks(struct dvb_frontend *fe, u32 * ucblocks)
+{
+	struct m88dc2800_state *state = fe->demodulator_priv;
+	u8 u8Value;
+
+	u8Value = ReadReg(state, 0xdf);
+	u8Value |= 0x02;	/* Hold */
+	WriteReg(state, 0xdf, u8Value);
+
+	*ucblocks = ReadReg(state, 0xd5);
+	*ucblocks = (*ucblocks << 8) | ReadReg(state, 0xd4);
+
+	u8Value &= 0xfe;	/* Clear */
+	WriteReg(state, 0xdf, u8Value);
+	u8Value &= 0xfc;	/* Update */
+	u8Value |= 0x01;
+	WriteReg(state, 0xdf, u8Value);
+
+	return 0;
+}
+
+static int m88dc2800_sleep(struct dvb_frontend *fe)
+{
+	struct m88dc2800_state *state = fe->demodulator_priv;
+
+	mt_fe_tn_sleep_tc2800(state);
+	state->freq = 0;
+
+	return 0;
+}
+
+static void m88dc2800_release(struct dvb_frontend *fe)
+{
+	struct m88dc2800_state *state = fe->demodulator_priv;
+	kfree(state);
+}
+
+static struct dvb_frontend_ops m88dc2800_ops;
+
+struct dvb_frontend *m88dc2800_attach(const struct m88dc2800_config
+				      *config, struct i2c_adapter *i2c)
+{
+	struct m88dc2800_state *state = NULL;
+
+	/* allocate memory for the internal state */
+	state = kzalloc(sizeof(struct m88dc2800_state), GFP_KERNEL);
+	if (state == NULL)
+		goto error;
+
+	/* setup the state */
+	state->config = config;
+	state->i2c = i2c;
+	state->xtal = 28800;
+
+	WriteReg(state, 0x80, 0x01);
+	M88DC2000RegInitial_TC2800(state);
+	M88DC2000SetTsType(state, state->config->ts_mode);
+	mt_fe_tn_init_tc2800(state);
+
+	/* create dvb_frontend */
+	memcpy(&state->frontend.ops, &m88dc2800_ops,
+	       sizeof(struct dvb_frontend_ops));
+	state->frontend.demodulator_priv = state;
+	return &state->frontend;
+
+      error:
+	kfree(state);
+	return NULL;
+}
+
+EXPORT_SYMBOL(m88dc2800_attach);
+
+static struct dvb_frontend_ops m88dc2800_ops = {
+	.delsys = {SYS_DVBC_ANNEX_A, SYS_DVBC_ANNEX_C},
+	.info = {
+		 .name = "Montage M88DC2800 DVB-C",
+		 .frequency_stepsize = 62500,
+		 .frequency_min = 48000000,
+		 .frequency_max = 870000000,
+		 .symbol_rate_min = 870000,
+		 .symbol_rate_max = 9000000,
+		 .caps = FE_CAN_QAM_16 | FE_CAN_QAM_32 | FE_CAN_QAM_64 |
+			 FE_CAN_QAM_128 | FE_CAN_QAM_256 | FE_CAN_FEC_AUTO
+	},
+	.release = m88dc2800_release,
+	.init = m88dc2800_init,
+	.sleep = m88dc2800_sleep,
+	.set_frontend = m88dc2800_set_parameters,
+	.read_status = m88dc2800_read_status,
+	.read_ber = m88dc2800_read_ber,
+	.read_signal_strength = m88dc2800_read_signal_strength,
+	.read_snr = m88dc2800_read_snr,
+	.read_ucblocks = m88dc2800_read_ucblocks,
+};
+
+MODULE_DESCRIPTION("Montage DVB-C demodulator driver");
+MODULE_AUTHOR("Max Nibble <nibble.max@gmail.com>");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.00");
diff -urN a/drivers/media/dvb-frontends/m88dc2800.h b/drivers/media/dvb-frontends/m88dc2800.h
--- a/drivers/media/dvb-frontends/m88dc2800.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/m88dc2800.h	2013-01-26 14:57:32.000000000 +0800
@@ -0,0 +1,43 @@
+/*
+    M88DC2800/M88TC2800  - DVB-C demodulator and tuner from Montage
+
+    Copyright (C) 2012 Max Nibble <nibble.max@gmail.com>
+    Copyright (C) 2011 Montage Technology - www.montage-tech.com
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef M88DC2800_H
+#define M88DC2800_H
+
+#include <linux/dvb/frontend.h>
+
+struct m88dc2800_config {
+	u8 demod_address;
+	u8 ts_mode;
+};
+
+#if defined(CONFIG_DVB_M88DC2800) || (defined(CONFIG_DVB_M88DC2800_MODULE) && defined(MODULE))
+extern struct dvb_frontend* m88dc2800_attach(const struct m88dc2800_config* config,
+					    struct i2c_adapter* i2c);
+#else
+static inline struct dvb_frontend* m88dc2800_attach(const struct m88dc2800_config* config,
+					    struct i2c_adapter* i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif /* CONFIG_DVB_M88DC2800 */
+#endif /* M88DC2800_H */
diff -urN a/drivers/media/dvb-frontends/m88ds3103.c b/drivers/media/dvb-frontends/m88ds3103.c
--- a/drivers/media/dvb-frontends/m88ds3103.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/m88ds3103.c	2013-01-30 12:33:47.000000000 +0800
@@ -0,0 +1,1710 @@
+/*
+    Montage Technology M88DS3103/M88TS2022 - DVBS/S2 Satellite demod/tuner driver
+
+    Copyright (C) 2011 Max nibble<nibble.max@gmail.com>
+    Copyright (C) 2010 Montage Technology<www.montage-tech.com>
+    Copyright (C) 2009 Konstantin Dimitrov.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/firmware.h>
+
+#include "dvb_frontend.h"
+#include "m88ds3103.h"
+#include "m88ds3103_priv.h"
+
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Activates frontend debugging (default:0)");
+
+#define dprintk(args...) \
+	do { \
+		if (debug) \
+			printk(KERN_INFO "m88ds3103: " args); \
+	} while (0)
+
+/*demod register operations.*/
+static int m88ds3103_writereg(struct m88ds3103_state *state, int reg, int data)
+{
+	u8 buf[] = { reg, data };
+	struct i2c_msg msg = { .addr = state->config->demod_address,
+		.flags = 0, .buf = buf, .len = 2 };
+	int err;
+
+	if (debug > 1)
+		printk("m88ds3103: %s: write reg 0x%02x, value 0x%02x\n",
+			__func__, reg, data);
+
+	err = i2c_transfer(state->i2c, &msg, 1);
+	if (err != 1) {
+		printk(KERN_ERR "%s: writereg error(err == %i, reg == 0x%02x,"
+			 " value == 0x%02x)\n", __func__, err, reg, data);
+		return -EREMOTEIO;
+	}
+	return 0;
+}
+
+static int m88ds3103_readreg(struct m88ds3103_state *state, u8 reg)
+{
+	int ret;
+	u8 b0[] = { reg };
+	u8 b1[] = { 0 };
+	struct i2c_msg msg[] = {
+		{ .addr = state->config->demod_address, .flags = 0,
+			.buf = b0, .len = 1 },
+		{ .addr = state->config->demod_address, .flags = I2C_M_RD,
+			.buf = b1, .len = 1 }
+	};
+	ret = i2c_transfer(state->i2c, msg, 2);
+
+	if (ret != 2) {
+		printk(KERN_ERR "%s: reg=0x%x (error=%d)\n",
+			__func__, reg, ret);
+		return ret;
+	}
+
+	if (debug > 1)
+		printk(KERN_INFO "m88ds3103: read reg 0x%02x, value 0x%02x\n",
+			reg, b1[0]);
+
+	return b1[0];
+}
+
+/*tuner register operations.*/
+static int m88ds3103_tuner_writereg(struct m88ds3103_state *state, int reg, int data)
+{
+	u8 buf[] = { reg, data };
+	struct i2c_msg msg = { .addr = 0x60,
+		.flags = 0, .buf = buf, .len = 2 };
+	int err;
+
+	m88ds3103_writereg(state, 0x03, 0x11);
+	err = i2c_transfer(state->i2c, &msg, 1);
+	
+	if (err != 1) {
+		printk("%s: writereg error(err == %i, reg == 0x%02x,"
+			 " value == 0x%02x)\n", __func__, err, reg, data);
+		return -EREMOTEIO;
+	}
+
+	return 0;
+}
+
+static int m88ds3103_tuner_readreg(struct m88ds3103_state *state, u8 reg)
+{
+	int ret;
+	u8 b0[] = { reg };
+	u8 b1[] = { 0 };
+	struct i2c_msg msg[] = {
+		{ .addr = 0x60, .flags = 0,
+			.buf = b0, .len = 1 },
+		{ .addr = 0x60, .flags = I2C_M_RD,
+			.buf = b1, .len = 1 }
+	};
+
+	m88ds3103_writereg(state, 0x03, 0x11);	
+	ret = i2c_transfer(state->i2c, msg, 2);
+
+	if (ret != 2) {
+		printk(KERN_ERR "%s: reg=0x%x(error=%d)\n", __func__, reg, ret);
+		return ret;
+	}
+
+	return b1[0];
+}
+
+/* Bulk demod I2C write, for firmware download. */
+static int m88ds3103_writeregN(struct m88ds3103_state *state, int reg,
+				const u8 *data, u16 len)
+{
+	int ret = -EREMOTEIO;
+	struct i2c_msg msg;
+	u8 *buf;
+
+	buf = kmalloc(len + 1, GFP_KERNEL);
+	if (buf == NULL) {
+		printk("Unable to kmalloc\n");
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	*(buf) = reg;
+	memcpy(buf + 1, data, len);
+
+	msg.addr = state->config->demod_address;
+	msg.flags = 0;
+	msg.buf = buf;
+	msg.len = len + 1;
+
+	if (debug > 1)
+		printk(KERN_INFO "m88ds3103: %s:  write regN 0x%02x, len = %d\n",
+			__func__, reg, len);
+
+	ret = i2c_transfer(state->i2c, &msg, 1);
+	if (ret != 1) {
+		printk(KERN_ERR "%s: writereg error(err == %i, reg == 0x%02x\n",
+			 __func__, ret, reg);
+		ret = -EREMOTEIO;
+	}
+	
+error:
+	kfree(buf);
+
+	return ret;
+}
+
+static int m88ds3103_load_firmware(struct dvb_frontend *fe)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	const struct firmware *fw;
+	int i, ret = 0;
+
+	dprintk("%s()\n", __func__);
+		
+	if (state->skip_fw_load)
+		return 0;
+	/* Load firmware */
+	/* request the firmware, this will block until someone uploads it */	
+	if(state->demod_id == DS3000_ID){
+		printk(KERN_INFO "%s: Waiting for firmware upload (%s)...\n", __func__,
+				DS3000_DEFAULT_FIRMWARE);		
+		ret = request_firmware(&fw, DS3000_DEFAULT_FIRMWARE,
+					state->i2c->dev.parent);
+	}else if(state->demod_id == DS3103_ID){
+		printk(KERN_INFO "%s: Waiting for firmware upload (%s)...\n", __func__,
+				DS3103_DEFAULT_FIRMWARE);
+		ret = request_firmware(&fw, DS3103_DEFAULT_FIRMWARE,
+					state->i2c->dev.parent);
+	}
+	
+	printk(KERN_INFO "%s: Waiting for firmware upload(2)...\n", __func__);
+	if (ret) {
+		printk(KERN_ERR "%s: No firmware uploaded (timeout or file not "
+				"found?)\n", __func__);
+		return ret;
+	}
+
+	/* Make sure we don't recurse back through here during loading */
+	state->skip_fw_load = 1;
+
+	dprintk("Firmware is %zu bytes (%02x %02x .. %02x %02x)\n",
+			fw->size,
+			fw->data[0],
+			fw->data[1],
+			fw->data[fw->size - 2],
+			fw->data[fw->size - 1]);
+			
+	/* stop internal mcu. */
+	m88ds3103_writereg(state, 0xb2, 0x01);
+	/* split firmware to download.*/
+	for(i = 0; i < FW_DOWN_LOOP; i++){
+		ret = m88ds3103_writeregN(state, 0xb0, &(fw->data[FW_DOWN_SIZE*i]), FW_DOWN_SIZE);
+		if(ret != 1) break;		
+	}
+	/* start internal mcu. */
+	if(ret == 1)
+		m88ds3103_writereg(state, 0xb2, 0x00);
+		
+	release_firmware(fw);
+
+	dprintk("%s: Firmware upload %s\n", __func__,
+			ret == 1 ? "complete" : "failed");
+
+	if(ret == 1) ret = 0;
+	
+	/* Ensure firmware is always loaded if required */
+	state->skip_fw_load = 0;
+
+	return ret;
+}
+
+
+static int m88ds3103_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	u8 data;
+
+	dprintk("%s(%d)\n", __func__, voltage);
+
+	dprintk("m88ds3103:pin_ctrl = (%02x)\n", state->config->pin_ctrl);
+	
+	if(state->config->set_voltage)
+		state->config->set_voltage(fe, voltage);
+	
+	data = m88ds3103_readreg(state, 0xa2);
+	
+        if(state->config->pin_ctrl & 0x80){ /*If control pin is assigned.*/
+	        data &= ~0x03; /* bit0 V/H, bit1 off/on */
+	        if(state->config->pin_ctrl & 0x02)
+		     data |= 0x02;
+
+	        switch (voltage) {
+	        case SEC_VOLTAGE_18:
+		     if((state->config->pin_ctrl & 0x01) == 0)
+			  data |= 0x01;
+		     break;
+	        case SEC_VOLTAGE_13:
+		     if(state->config->pin_ctrl & 0x01)
+			  data |= 0x01;
+		     break;
+	        case SEC_VOLTAGE_OFF:
+		     if(state->config->pin_ctrl & 0x02)
+			   data &= ~0x02;			
+		     else
+			   data |= 0x02;
+		     break;
+	         }
+        }
+
+	m88ds3103_writereg(state, 0xa2, data);
+
+	return 0;
+}
+
+static int m88ds3103_read_status(struct dvb_frontend *fe, fe_status_t* status)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	int lock = 0;
+	
+	*status = 0;
+	
+	switch (state->delivery_system){
+	case SYS_DVBS:
+		lock = m88ds3103_readreg(state, 0xd1);
+		dprintk("%s: SYS_DVBS status=%x.\n", __func__, lock);
+		
+		if ((lock & 0x07) == 0x07){
+			/*if((m88ds3103_readreg(state, 0x0d) & 0x07) == 0x07)*/
+				*status = FE_HAS_SIGNAL | FE_HAS_CARRIER 
+					| FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;
+			
+		}
+		break;
+	case SYS_DVBS2:
+		lock = m88ds3103_readreg(state, 0x0d);
+		dprintk("%s: SYS_DVBS2 status=%x.\n", __func__, lock);
+
+		if ((lock & 0x8f) == 0x8f)
+			*status = FE_HAS_SIGNAL | FE_HAS_CARRIER 
+				| FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;
+			
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int m88ds3103_read_ber(struct dvb_frontend *fe, u32* ber)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	u8 tmp1, tmp2, tmp3;
+	u32 ldpc_frame_cnt, pre_err_packags, code_rate_fac = 0;
+
+	dprintk("%s()\n", __func__);
+
+	switch (state->delivery_system) {
+	case SYS_DVBS:
+		m88ds3103_writereg(state, 0xf9, 0x04);
+		tmp3 = m88ds3103_readreg(state, 0xf8);
+		if ((tmp3&0x10) == 0){
+			tmp1 = m88ds3103_readreg(state, 0xf7);
+			tmp2 = m88ds3103_readreg(state, 0xf6);
+			tmp3 |= 0x10;
+			m88ds3103_writereg(state, 0xf8, tmp3);
+			state->preBer = (tmp1<<8) | tmp2;
+		}
+		break;
+	case SYS_DVBS2:
+		tmp1 = m88ds3103_readreg(state, 0x7e) & 0x0f;
+		switch(tmp1){
+		case 0:	code_rate_fac = 16008 - 80; break;
+		case 1:	code_rate_fac = 21408 - 80; break;
+		case 2:	code_rate_fac = 25728 - 80; break;
+		case 3:	code_rate_fac = 32208 - 80; break;
+		case 4:	code_rate_fac = 38688 - 80; break;
+		case 5:	code_rate_fac = 43040 - 80; break;
+		case 6:	code_rate_fac = 48408 - 80; break;
+		case 7:	code_rate_fac = 51648 - 80; break;
+		case 8:	code_rate_fac = 53840 - 80; break;
+		case 9:	code_rate_fac = 57472 - 80; break;
+		case 10: code_rate_fac = 58192 - 80; break;
+		}
+		
+		tmp1 = m88ds3103_readreg(state, 0xd7) & 0xff;
+		tmp2 = m88ds3103_readreg(state, 0xd6) & 0xff;
+		tmp3 = m88ds3103_readreg(state, 0xd5) & 0xff;		
+		ldpc_frame_cnt = (tmp1 << 16) | (tmp2 << 8) | tmp3;
+
+		tmp1 = m88ds3103_readreg(state, 0xf8) & 0xff;
+		tmp2 = m88ds3103_readreg(state, 0xf7) & 0xff;
+		pre_err_packags = tmp1<<8 | tmp2;
+		
+		if (ldpc_frame_cnt > 1000){
+			m88ds3103_writereg(state, 0xd1, 0x01);
+			m88ds3103_writereg(state, 0xf9, 0x01);
+			m88ds3103_writereg(state, 0xf9, 0x00);
+			m88ds3103_writereg(state, 0xd1, 0x00);
+			state->preBer = pre_err_packags;
+		} 				
+		break;
+	default:
+		break;
+	}
+	*ber = state->preBer;
+	
+	return 0;
+}
+
+static int m88ds3103_read_signal_strength(struct dvb_frontend *fe,
+						u16 *signal_strength)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	u16 gain;
+	u8 gain1, gain2, gain3 = 0;
+
+	dprintk("%s()\n", __func__);
+
+	gain1 = m88ds3103_tuner_readreg(state, 0x3d) & 0x1f;
+	dprintk("%s: gain1 = 0x%02x \n", __func__, gain1);
+	
+	if (gain1 > 15) gain1 = 15;
+	gain2 = m88ds3103_tuner_readreg(state, 0x21) & 0x1f;
+	dprintk("%s: gain2 = 0x%02x \n", __func__, gain2);
+	
+	if(state->tuner_id == TS2022_ID){
+		gain3 = (m88ds3103_tuner_readreg(state, 0x66)>>3) & 0x07;
+		dprintk("%s: gain3 = 0x%02x \n", __func__, gain3);
+		
+		if (gain2 > 16) gain2 = 16;
+		if (gain2 < 2) gain2 = 2;			
+		if (gain3 > 6) gain3 = 6;
+	}else{
+		if (gain2 > 13) gain2 = 13;
+		gain3 = 0;
+	}
+
+	gain = gain1*23 + gain2*35 + gain3*29;
+	*signal_strength = 60000 - gain*55;
+
+	return 0;
+}
+
+
+static int m88ds3103_read_snr(struct dvb_frontend *fe, u16 *p_snr)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	u8 val, npow1, npow2, spow1, cnt;
+	u16 tmp, snr;
+	u32 npow, spow, snr_total;	
+	static const u16 mes_log10[] ={
+		0,	3010,	4771,	6021, 	6990,	7781,	8451,	9031,	9542,	10000,
+		10414,	10792,	11139,	11461,	11761,	12041,	12304,	12553,	12788,	13010,
+		13222,	13424,	13617,	13802,	13979,	14150,	14314,	14472,	14624,	14771,
+		14914,	15052,	15185,	15315,	15441,	15563,	15682,	15798,	15911,	16021,
+		16128,	16232,	16335,	16435,	16532,	16628,	16721,	16812,	16902,	16990,
+		17076,	17160,	17243,	17324,	17404,	17482,	17559,	17634,	17709,	17782,
+		17853,	17924,	17993,	18062,	18129,	18195,	18261,	18325,	18388,	18451,
+		18513,	18573,	18633,	18692,	18751,	18808,	18865,	18921,	18976,	19031
+	};
+	static const u16 mes_loge[] ={
+		0,	6931,	10986,	13863, 	16094,	17918,	19459,	20794,	21972,	23026,
+		23979,	24849,	25649,	26391,	27081,	27726,	28332,	28904,	29444,	29957,
+		30445,	30910,	31355,	31781,	32189,	32581,	32958,	33322,	33673,	34012,
+		34340,	34657,
+	};
+
+	dprintk("%s()\n", __func__);
+
+	snr = 0;
+	
+	switch (state->delivery_system){
+	case SYS_DVBS:
+		cnt = 10; snr_total = 0;
+		while(cnt > 0){
+			val = m88ds3103_readreg(state, 0xff);
+			snr_total += val;
+			cnt--;
+		}
+		tmp = (u16)(snr_total/80);
+		if(tmp > 0){
+			if (tmp > 32) tmp = 32;
+			snr = (mes_loge[tmp - 1] * 100) / 45;
+		}else{
+			snr = 0;
+		}
+		break;
+	case SYS_DVBS2:
+		cnt  = 10; npow = 0; spow = 0;
+		while(cnt >0){
+			npow1 = m88ds3103_readreg(state, 0x8c) & 0xff;
+			npow2 = m88ds3103_readreg(state, 0x8d) & 0xff;
+			npow += (((npow1 & 0x3f) + (u16)(npow2 << 6)) >> 2);
+
+			spow1 = m88ds3103_readreg(state, 0x8e) & 0xff;
+			spow += ((spow1 * spow1) >> 1);
+			cnt--;
+		}
+		npow /= 10; spow /= 10;
+		if(spow == 0){
+			snr = 0;
+		}else if(npow == 0){
+			snr = 19;
+		}else{
+			if(spow > npow){
+				tmp = (u16)(spow / npow);
+				if (tmp > 80) tmp = 80;
+				snr = mes_log10[tmp - 1]*3;
+			}else{
+				tmp = (u16)(npow / spow);
+				if (tmp > 80) tmp = 80;
+				snr = -(mes_log10[tmp - 1] / 1000);
+			}
+		}			
+		break;
+	default:
+		break;
+	}
+	*p_snr = snr;
+
+	return 0;
+}
+
+
+static int m88ds3103_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	u8 tmp1, tmp2, tmp3, data;
+
+	dprintk("%s()\n", __func__);
+
+	switch (state->delivery_system) {
+	case SYS_DVBS:
+		data = m88ds3103_readreg(state, 0xf8);
+		data |= 0x40;
+		m88ds3103_writereg(state, 0xf8, data);		
+		tmp1 = m88ds3103_readreg(state, 0xf5);
+		tmp2 = m88ds3103_readreg(state, 0xf4);
+		*ucblocks = (tmp1 <<8) | tmp2;		
+		data &= ~0x20;
+		m88ds3103_writereg(state, 0xf8, data);
+		data |= 0x20;
+		m88ds3103_writereg(state, 0xf8, data);
+		data &= ~0x40;
+		m88ds3103_writereg(state, 0xf8, data);
+		break;
+	case SYS_DVBS2:
+		tmp1 = m88ds3103_readreg(state, 0xda);
+		tmp2 = m88ds3103_readreg(state, 0xd9);
+		tmp3 = m88ds3103_readreg(state, 0xd8);
+		*ucblocks = (tmp1 <<16)|(tmp2 <<8)|tmp3;
+		data = m88ds3103_readreg(state, 0xd1);
+		data |= 0x01;
+		m88ds3103_writereg(state, 0xd1, data);
+		data &= ~0x01;
+		m88ds3103_writereg(state, 0xd1, data);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int m88ds3103_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t tone)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	u8 data_a1, data_a2;
+
+	dprintk("%s(%d)\n", __func__, tone);
+	if ((tone != SEC_TONE_ON) && (tone != SEC_TONE_OFF)) {
+		printk(KERN_ERR "%s: Invalid, tone=%d\n", __func__, tone);
+		return -EINVAL;
+	}
+
+	data_a1 = m88ds3103_readreg(state, 0xa1);
+	data_a2 = m88ds3103_readreg(state, 0xa2);
+	if(state->demod_id == DS3103_ID)
+		data_a2 &= 0xdf; /* Normal mode */
+	switch (tone) {
+	case SEC_TONE_ON:
+		dprintk("%s: SEC_TONE_ON\n", __func__);
+		data_a1 |= 0x04;
+		data_a1 &= ~0x03;
+		data_a1 &= ~0x40;
+		data_a2 &= ~0xc0;
+		break;
+	case SEC_TONE_OFF:
+		dprintk("%s: SEC_TONE_OFF\n", __func__);
+		data_a2 &= ~0xc0;
+		data_a2 |= 0x80;
+		break;
+	}
+	m88ds3103_writereg(state, 0xa2, data_a2);
+	m88ds3103_writereg(state, 0xa1, data_a1);
+	return 0;
+}
+
+static int m88ds3103_send_diseqc_msg(struct dvb_frontend *fe,
+				struct dvb_diseqc_master_cmd *d)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	int i, ret = 0;
+	u8 tmp, time_out;
+
+	/* Dump DiSEqC message */
+	if (debug) {
+		printk(KERN_INFO "m88ds3103: %s(", __func__);
+		for (i = 0 ; i < d->msg_len ;) {
+			printk(KERN_INFO "0x%02x", d->msg[i]);
+			if (++i < d->msg_len)
+				printk(KERN_INFO ", ");
+		}
+	}
+
+	tmp = m88ds3103_readreg(state, 0xa2);
+	tmp &= ~0xc0;
+	if(state->demod_id == DS3103_ID)
+		tmp &= ~0x20;
+	m88ds3103_writereg(state, 0xa2, tmp);
+	
+	for (i = 0; i < d->msg_len; i ++)
+		m88ds3103_writereg(state, (0xa3+i), d->msg[i]);
+
+	tmp = m88ds3103_readreg(state, 0xa1);	
+	tmp &= ~0x38;
+	tmp &= ~0x40;
+	tmp |= ((d->msg_len-1) << 3) | 0x07;
+	tmp &= ~0x80;
+	m88ds3103_writereg(state, 0xa1, tmp);
+	/*	1.5 * 9 * 8	= 108ms	*/
+	time_out = 150;
+	while (time_out > 0){
+		msleep(10);
+		time_out -= 10;
+		tmp = m88ds3103_readreg(state, 0xa1);		
+		if ((tmp & 0x40) == 0)
+			break;
+	}
+	if (time_out == 0){
+		tmp = m88ds3103_readreg(state, 0xa1);
+		tmp &= ~0x80;
+		tmp |= 0x40;
+		m88ds3103_writereg(state, 0xa1, tmp);
+		ret = 1;
+	}
+	tmp = m88ds3103_readreg(state, 0xa2);
+	tmp &= ~0xc0;
+	tmp |= 0x80;
+	m88ds3103_writereg(state, 0xa2, tmp);	
+	return ret;
+}
+
+
+static int m88ds3103_diseqc_send_burst(struct dvb_frontend *fe,
+					fe_sec_mini_cmd_t burst)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	u8	val, time_out;
+	
+	dprintk("%s()\n", __func__);
+
+	val = m88ds3103_readreg(state, 0xa2);
+	val &= ~0xc0;
+	if(state->demod_id == DS3103_ID)
+		val &= 0xdf; /* Normal mode */
+	m88ds3103_writereg(state, 0xa2, val);
+	/* DiSEqC burst */
+	if (burst == SEC_MINI_B)
+		m88ds3103_writereg(state, 0xa1, 0x01);
+	else
+		m88ds3103_writereg(state, 0xa1, 0x02);
+
+	msleep(13);
+
+	time_out = 5;
+	do{
+		val = m88ds3103_readreg(state, 0xa1);
+		if ((val & 0x40) == 0)
+			break;
+		msleep(1);
+		time_out --;
+	} while (time_out > 0);
+
+	val = m88ds3103_readreg(state, 0xa2);
+	val &= ~0xc0;
+	val |= 0x80;
+	m88ds3103_writereg(state, 0xa2, val);
+	
+	return 0;
+}
+
+static void m88ds3103_release(struct dvb_frontend *fe)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+
+	dprintk("%s\n", __func__);
+	kfree(state);
+}
+
+static int m88ds3103_check_id(struct m88ds3103_state *state)
+{
+	int val_00, val_01;
+	
+	/*check demod id*/
+	val_01 = m88ds3103_readreg(state, 0x01);
+	printk(KERN_INFO "DS3000 chip version: %x attached.\n", val_01);
+			
+	if(val_01 == 0xD0)
+		state->demod_id = DS3103_ID;
+	else if(val_01 == 0xC0)
+		state->demod_id = DS3000_ID;
+	else
+		state->demod_id = UNKNOW_ID;
+		
+	/*check tuner id*/
+	val_00 = m88ds3103_tuner_readreg(state, 0x00);
+	printk(KERN_INFO "TS202x chip version[1]: %x attached.\n", val_00);
+	val_00 &= 0x03;
+	if(val_00 == 0)
+	{
+		m88ds3103_tuner_writereg(state, 0x00, 0x01);
+		msleep(3);		
+	}
+	m88ds3103_tuner_writereg(state, 0x00, 0x03);
+	msleep(5);
+	
+	val_00 = m88ds3103_tuner_readreg(state, 0x00);
+	printk(KERN_INFO "TS202x chip version[2]: %x attached.\n", val_00);
+	val_00 &= 0xff;
+	if((val_00 == 0x01) || (val_00 == 0x41) || (val_00 == 0x81))
+		state->tuner_id = TS2020_ID;
+	else if(((val_00 & 0xc0)== 0xc0) || (val_00 == 0x83))
+		state->tuner_id = TS2022_ID;
+	else
+		state->tuner_id = UNKNOW_ID;
+			
+	return state->demod_id;	
+}
+
+static struct dvb_frontend_ops m88ds3103_ops;
+static int m88ds3103_initilaze(struct dvb_frontend *fe);
+
+struct dvb_frontend *m88ds3103_attach(const struct m88ds3103_config *config,
+				    struct i2c_adapter *i2c)
+{
+	struct m88ds3103_state *state = NULL;
+
+	dprintk("%s\n", __func__);
+
+	/* allocate memory for the internal state */
+	state = kzalloc(sizeof(struct m88ds3103_state), GFP_KERNEL);
+	if (state == NULL) {
+		printk(KERN_ERR "Unable to kmalloc\n");
+		goto error2;
+	}
+
+	state->config = config;
+	state->i2c = i2c;
+	state->preBer = 0xffff;
+	state->delivery_system = SYS_DVBS; /*Default to DVB-S.*/
+	
+	/* check demod id */
+	if(m88ds3103_check_id(state) == UNKNOW_ID){
+		printk(KERN_ERR "Unable to find Montage chip\n");
+		goto error3;
+	}
+
+	memcpy(&state->frontend.ops, &m88ds3103_ops,
+			sizeof(struct dvb_frontend_ops));
+	state->frontend.demodulator_priv = state;
+	
+	m88ds3103_initilaze(&state->frontend);
+	
+	return &state->frontend;
+
+error3:
+	kfree(state);
+error2:
+	return NULL;
+}
+EXPORT_SYMBOL(m88ds3103_attach);
+
+static int m88ds3103_set_carrier_offset(struct dvb_frontend *fe,
+					s32 carrier_offset_khz)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	s32 tmp;
+
+	tmp = carrier_offset_khz;
+	tmp *= 65536;
+	
+	tmp = (2*tmp + MT_FE_MCLK_KHZ) / (2*MT_FE_MCLK_KHZ);
+
+	if (tmp < 0)
+		tmp += 65536;
+
+	m88ds3103_writereg(state, 0x5f, tmp >> 8);
+	m88ds3103_writereg(state, 0x5e, tmp & 0xff);
+
+	return 0;
+}
+
+static int m88ds3103_set_symrate(struct dvb_frontend *fe)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	u16 value;
+	
+	value = (((c->symbol_rate / 1000) << 15) + (MT_FE_MCLK_KHZ / 4)) / (MT_FE_MCLK_KHZ / 2);
+	m88ds3103_writereg(state, 0x61, value & 0x00ff);
+	m88ds3103_writereg(state, 0x62, (value & 0xff00) >> 8);
+
+	return 0;
+}
+
+static int m88ds3103_set_CCI(struct dvb_frontend *fe)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	u8 tmp;
+
+	tmp = m88ds3103_readreg(state, 0x56);
+	tmp &= ~0x01;
+	m88ds3103_writereg(state, 0x56, tmp);
+
+	tmp = m88ds3103_readreg(state, 0x76);
+	tmp &= ~0x80;
+	m88ds3103_writereg(state, 0x76, tmp);
+
+	return 0;
+}
+
+static int m88ds3103_init_reg(struct m88ds3103_state *state, const u8 *p_reg_tab, u32 size)
+{
+	u32 i;
+	
+	for(i = 0; i < size; i+=2)
+		m88ds3103_writereg(state, p_reg_tab[i], p_reg_tab[i+1]);
+		
+	return 0;
+}
+
+static int m88ds3103_get_locked_sym_rate(struct m88ds3103_state *state, u32 *sym_rate_KSs)
+{
+	u16	tmp;
+	u32	sym_rate_tmp;
+	u8	val_0x6d, val_0x6e;
+
+	val_0x6d = m88ds3103_readreg(state, 0x6d);
+	val_0x6e = m88ds3103_readreg(state, 0x6e);
+
+	tmp = (u16)((val_0x6e<<8) | val_0x6d);
+
+	sym_rate_tmp = (u32)(tmp * MT_FE_MCLK_KHZ);
+	sym_rate_tmp = (u32)(sym_rate_tmp / (1<<16));
+	*sym_rate_KSs = sym_rate_tmp;
+
+	return 0;
+}
+
+static int m88ds3103_get_channel_info(struct m88ds3103_state *state, u8 *p_mode, u8 *p_coderate)
+{
+	u8	tmp, val_0x7E;
+
+	if(state->delivery_system == SYS_DVBS2){
+		val_0x7E = m88ds3103_readreg(state, 0x7e);
+		tmp = (u8)((val_0x7E&0xC0) >> 6);
+		*p_mode = tmp;
+		tmp = (u8)(val_0x7E & 0x0f);
+		*p_coderate = tmp;
+	} else {
+		*p_mode = 0;
+		tmp = m88ds3103_readreg(state, 0xe6);		
+		tmp = (u8)(tmp >> 5);
+		*p_coderate = tmp;
+	}
+	
+	return 0;
+}
+
+static int m88ds3103_set_clock_ratio(struct m88ds3103_state *state)
+{
+	u8	val, mod_fac, tmp1, tmp2;
+	u32	input_datarate, locked_sym_rate_KSs;
+	u32 MClk_KHz = 96000;
+	u8 mod_mode, code_rate, divid_ratio = 0;
+
+	locked_sym_rate_KSs = 0;
+	m88ds3103_get_locked_sym_rate(state, &locked_sym_rate_KSs);
+	if(locked_sym_rate_KSs == 0)
+		return 0;
+
+	m88ds3103_get_channel_info(state, &mod_mode, &code_rate);
+
+	if (state->delivery_system == SYS_DVBS2)
+	{
+		switch(mod_mode) {
+			case 1: mod_fac = 3; break;
+			case 2:	mod_fac = 4; break;
+			case 3:	mod_fac = 5; break;
+			default: mod_fac = 2; break;
+		}
+
+		switch(code_rate) {
+			case 0: input_datarate = locked_sym_rate_KSs*mod_fac/8/4; break;
+			case 1: input_datarate = locked_sym_rate_KSs*mod_fac/8/3;  	break;
+			case 2: input_datarate = locked_sym_rate_KSs*mod_fac*2/8/5;	break;
+			case 3:	input_datarate = locked_sym_rate_KSs*mod_fac/8/2;	break;
+			case 4:	input_datarate = locked_sym_rate_KSs*mod_fac*3/8/5;	break;
+			case 5:	input_datarate = locked_sym_rate_KSs*mod_fac*2/8/3;	break;
+			case 6:	input_datarate = locked_sym_rate_KSs*mod_fac*3/8/4;	break;
+			case 7:	input_datarate = locked_sym_rate_KSs*mod_fac*4/8/5;	break;
+			case 8:	input_datarate = locked_sym_rate_KSs*mod_fac*5/8/6;	break;
+			case 9:	input_datarate = locked_sym_rate_KSs*mod_fac*8/8/9;	break;
+			case 10: input_datarate = locked_sym_rate_KSs*mod_fac*9/8/10; break;
+			default: input_datarate = locked_sym_rate_KSs*mod_fac*2/8/3; break;
+		}
+
+		if(state->demod_id == DS3000_ID)
+			input_datarate = input_datarate * 115 / 100;
+
+		if(input_datarate < 4800)  {tmp1 = 15;tmp2 = 15;} //4.8MHz         TS clock
+		else if(input_datarate < 4966)  {tmp1 = 14;tmp2 = 15;} //4.966MHz  TS clock
+		else if(input_datarate < 5143)  {tmp1 = 14;tmp2 = 14;} //5.143MHz  TS clock
+		else if(input_datarate < 5333)  {tmp1 = 13;tmp2 = 14;} //5.333MHz  TS clock
+		else if(input_datarate < 5538)  {tmp1 = 13;tmp2 = 13;} //5.538MHz  TS clock
+		else if(input_datarate < 5760)  {tmp1 = 12;tmp2 = 13;} //5.76MHz   TS clock       allan 0809
+		else if(input_datarate < 6000)  {tmp1 = 12;tmp2 = 12;} //6MHz      TS clock
+		else if(input_datarate < 6260)  {tmp1 = 11;tmp2 = 12;} //6.26MHz   TS clock
+		else if(input_datarate < 6545)  {tmp1 = 11;tmp2 = 11;} //6.545MHz  TS clock
+		else if(input_datarate < 6857)  {tmp1 = 10;tmp2 = 11;} //6.857MHz  TS clock
+		else if(input_datarate < 7200)  {tmp1 = 10;tmp2 = 10;} //7.2MHz    TS clock
+		else if(input_datarate < 7578)  {tmp1 = 9;tmp2 = 10;}  //7.578MHz  TS clock
+		else if(input_datarate < 8000)	{tmp1 = 9;tmp2 = 9;}   //8MHz      TS clock
+		else if(input_datarate < 8470)	{tmp1 = 8;tmp2 = 9;}   //8.47MHz   TS clock
+		else if(input_datarate < 9000)	{tmp1 = 8;tmp2 = 8;}   //9MHz      TS clock
+		else if(input_datarate < 9600)	{tmp1 = 7;tmp2 = 8;}   //9.6MHz    TS clock
+		else if(input_datarate < 10285)	{tmp1 = 7;tmp2 = 7;}   //10.285MHz TS clock
+		else if(input_datarate < 12000)	{tmp1 = 6;tmp2 = 6;}   //12MHz     TS clock
+		else if(input_datarate < 14400)	{tmp1 = 5;tmp2 = 5;}   //14.4MHz   TS clock
+		else if(input_datarate < 18000)	{tmp1 = 4;tmp2 = 4;}   //18MHz     TS clock
+		else							{tmp1 = 3;tmp2 = 3;}   //24MHz     TS clock
+
+		if(state->demod_id == DS3000_ID) {
+			val = (u8)((tmp1<<4) + tmp2);
+			m88ds3103_writereg(state, 0xfe, val);
+		} else {
+			tmp1 = m88ds3103_readreg(state, 0x22);
+			tmp2 = m88ds3103_readreg(state, 0x24);
+
+			tmp1 >>= 6;
+			tmp1 &= 0x03;
+			tmp2 >>= 6;
+			tmp2 &= 0x03;
+
+			if((tmp1 == 0x00) && (tmp2 == 0x01))
+				MClk_KHz = 144000;
+			else if((tmp1 == 0x00) && (tmp2 == 0x03))
+				MClk_KHz = 72000;
+			else if((tmp1 == 0x01) && (tmp2 == 0x01))
+				MClk_KHz = 115200;
+			else if((tmp1 == 0x02) && (tmp2 == 0x01))
+				MClk_KHz = 96000;
+			else if((tmp1 == 0x03) && (tmp2 == 0x00))
+				MClk_KHz = 192000;
+			else
+				return 0;
+
+			if(input_datarate < 5200) /*Max. 2011-12-23 11:55*/
+				input_datarate = 5200;
+				
+			if(input_datarate != 0)
+				divid_ratio = (u8)(MClk_KHz / input_datarate);
+			else
+				divid_ratio = 0xFF;
+
+			if(divid_ratio > 128)
+				divid_ratio = 128;
+
+			if(divid_ratio < 2)
+				divid_ratio = 2;
+
+			tmp1 = (u8)(divid_ratio / 2);
+			tmp2 = (u8)(divid_ratio / 2);
+
+			if((divid_ratio % 2) != 0)
+				tmp2 += 1;
+
+			tmp1 -= 1;
+			tmp2 -= 1;
+
+			tmp1 &= 0x3f;
+			tmp2 &= 0x3f;
+
+			val = m88ds3103_readreg(state, 0xfe);
+			val &= 0xF0;
+			val |= (tmp2 >> 2) & 0x0f;
+			m88ds3103_writereg(state, 0xfe, val);
+
+			val = (u8)((tmp2 & 0x03) << 6);	
+			val |= tmp1;
+			m88ds3103_writereg(state, 0xea, val);
+		}
+	} else {
+		mod_fac = 2;
+
+		switch(code_rate) {
+			case 4:	input_datarate = locked_sym_rate_KSs*mod_fac/2/8;	break;
+			case 3:	input_datarate = locked_sym_rate_KSs*mod_fac*2/3/8;	break;
+			case 2:	input_datarate = locked_sym_rate_KSs*mod_fac*3/4/8;	break;
+			case 1:	input_datarate = locked_sym_rate_KSs*mod_fac*5/6/8;	break;
+			case 0:	input_datarate = locked_sym_rate_KSs*mod_fac*7/8/8;	break;
+			default: input_datarate = locked_sym_rate_KSs*mod_fac*3/4/8;	break;
+		}
+
+		if(state->demod_id == DS3000_ID)
+			input_datarate = input_datarate * 115 / 100;
+
+		if(input_datarate < 6857)		{tmp1 = 7;tmp2 = 7;} //6.857MHz     TS clock
+		else if(input_datarate < 7384)	{tmp1 = 6;tmp2 = 7;} //7.384MHz     TS clock
+		else if(input_datarate < 8000)	{tmp1 = 6;tmp2 = 6;} //8MHz     	TS clock
+		else if(input_datarate < 8727)	{tmp1 = 5;tmp2 = 6;} //8.727MHz 	TS clock
+		else if(input_datarate < 9600)	{tmp1 = 5;tmp2 = 5;} //9.6MHz    	TS clock
+		else if(input_datarate < 10666)	{tmp1 = 4;tmp2 = 5;} //10.666MHz 	TS clock
+		else if(input_datarate < 12000)	{tmp1 = 4;tmp2 = 4;} //12MHz 	 	TS clock
+		else if(input_datarate < 13714)	{tmp1 = 3;tmp2 = 4;} //13.714MHz 	TS clock
+		else if(input_datarate < 16000)	{tmp1 = 3;tmp2 = 3;} //16MHz     	TS clock
+		else if(input_datarate < 19200)	{tmp1 = 2;tmp2 = 3;} //19.2MHz   	TS clock
+		else 							{tmp1 = 2;tmp2 = 2;} //24MHz     	TS clock
+
+		if(state->demod_id == DS3000_ID) {
+			val = m88ds3103_readreg(state, 0xfe);
+			val &= 0xc0;
+			val |= ((u8)((tmp1<<3) + tmp2));
+			m88ds3103_writereg(state, 0xfe, val);
+		} else {
+			if(input_datarate < 5200) /*Max. 2011-12-23 11:55*/
+				input_datarate = 5200;
+			
+			if(input_datarate != 0)
+				divid_ratio = (u8)(MClk_KHz / input_datarate);
+			else
+				divid_ratio = 0xFF;
+
+			if(divid_ratio > 128)
+				divid_ratio = 128;
+
+			if(divid_ratio < 2)
+				divid_ratio = 2;
+
+			tmp1 = (u8)(divid_ratio / 2);
+			tmp2 = (u8)(divid_ratio / 2);
+
+			if((divid_ratio % 2) != 0)
+				tmp2 += 1;
+
+			tmp1 -= 1;
+			tmp2 -= 1;
+
+			tmp1 &= 0x3f;
+			tmp2 &= 0x3f;
+
+			val = m88ds3103_readreg(state, 0xfe);
+			val &= 0xF0;
+			val |= (tmp2 >> 2) & 0x0f;
+			m88ds3103_writereg(state, 0xfe, val);
+			
+			val = (u8)((tmp2 & 0x03) << 6);
+			val |= tmp1;
+			m88ds3103_writereg(state, 0xea, val);
+		}
+	}
+	return 0;
+}
+
+static int m88ds3103_demod_connect(struct dvb_frontend *fe, s32 carrier_offset_khz) 
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	u16 value;
+	u8 val1,val2,data;
+	
+	dprintk("connect delivery system = %d\n", state->delivery_system);
+	
+	/* ds3000 global reset */
+	m88ds3103_writereg(state, 0x07, 0x80);
+	m88ds3103_writereg(state, 0x07, 0x00);
+	/* ds3000 build-in uC reset */
+	m88ds3103_writereg(state, 0xb2, 0x01);
+	/* ds3000 software reset */
+	m88ds3103_writereg(state, 0x00, 0x01);
+
+	switch (state->delivery_system) {
+	case SYS_DVBS:
+		/* initialise the demod in DVB-S mode */
+		if(state->demod_id == DS3000_ID){
+			m88ds3103_init_reg(state, ds3000_dvbs_init_tab, sizeof(ds3000_dvbs_init_tab));
+			
+			value = m88ds3103_readreg(state, 0xfe);
+			value &= 0xc0;
+			value |= 0x1b;
+			m88ds3103_writereg(state, 0xfe, value);
+			
+			if(state->config->ci_mode)
+				val1 = 0x80;
+			else if(state->config->ts_mode)
+				val1 = 0x60;
+			else
+				val1 = 0x20;
+			m88ds3103_writereg(state, 0xfd, val1);
+			
+		}else if(state->demod_id == DS3103_ID){
+			m88ds3103_init_reg(state, ds3103_dvbs_init_tab, sizeof(ds3103_dvbs_init_tab));
+			
+			/* set ts clock */
+			if(state->config->ci_mode == 2){
+				val1 = 6; val2 = 6;
+			}else if(state->config->ts_mode == 0)	{
+				val1 = 3; val2 = 3;
+			}else{
+				val1 = 0; val2 = 0;
+			}
+			val1 -= 1; val2 -= 1;
+			val1 &= 0x3f; val2 &= 0x3f;
+			data = m88ds3103_readreg(state, 0xfe);
+			data &= 0xf0;
+			data |= (val2 >> 2) & 0x0f;
+			m88ds3103_writereg(state, 0xfe, data);
+			data = (val2 & 0x03) << 6;
+			data |= val1;
+			m88ds3103_writereg(state, 0xea, data);
+			
+			m88ds3103_writereg(state, 0x4d, 0xfd & m88ds3103_readreg(state, 0x4d));
+			m88ds3103_writereg(state, 0x30, 0xef & m88ds3103_readreg(state, 0x30));
+			
+			/* set master clock */
+			val1 = m88ds3103_readreg(state, 0x22);
+			val2 = m88ds3103_readreg(state, 0x24);
+			
+			val1 &= 0x3f;
+			val2 &= 0x3f;
+			val1 |= 0x80;
+			val2 |= 0x40;
+
+			m88ds3103_writereg(state, 0x22, val1);
+			m88ds3103_writereg(state, 0x24, val2);	
+			
+			if(state->config->ci_mode)
+				val1 = 0x03;
+			else if(state->config->ts_mode)
+				val1 = 0x06;
+			else
+				val1 = 0x42;
+			m88ds3103_writereg(state, 0xfd, val1);		
+		}
+		break;
+	case SYS_DVBS2:
+		/* initialise the demod in DVB-S2 mode */
+		if(state->demod_id == DS3000_ID){
+			m88ds3103_init_reg(state, ds3000_dvbs2_init_tab, sizeof(ds3000_dvbs2_init_tab));
+		
+			if (c->symbol_rate >= 30000000)
+				m88ds3103_writereg(state, 0xfe, 0x54);
+			else
+				m88ds3103_writereg(state, 0xfe, 0x98);
+								
+		}else if(state->demod_id == DS3103_ID){
+			m88ds3103_init_reg(state, ds3103_dvbs2_init_tab, sizeof(ds3103_dvbs2_init_tab));
+
+			/* set ts clock */
+			if(state->config->ci_mode == 2){
+				val1 = 6; val2 = 6;
+			}else if(state->config->ts_mode == 0){
+				val1 = 5; val2 = 4;
+			}else{
+				val1 = 0; val2 = 0;
+			}
+			val1 -= 1; val2 -= 1;
+			val1 &= 0x3f; val2 &= 0x3f;
+			data = m88ds3103_readreg(state, 0xfe);
+			data &= 0xf0;
+			data |= (val2 >> 2) & 0x0f;
+			m88ds3103_writereg(state, 0xfe, data);
+			data = (val2 & 0x03) << 6;
+			data |= val1;
+			m88ds3103_writereg(state, 0xea, data);
+			
+			m88ds3103_writereg(state, 0x4d, 0xfd & m88ds3103_readreg(state, 0x4d));
+			m88ds3103_writereg(state, 0x30, 0xef & m88ds3103_readreg(state, 0x30));
+			
+			/* set master clock */
+			val1 = m88ds3103_readreg(state, 0x22);
+			val2 = m88ds3103_readreg(state, 0x24);
+			
+			val1 &= 0x3f;
+			val2 &= 0x3f;
+			if((state->config->ci_mode == 2) || (state->config->ts_mode == 1)){
+				val1 |= 0x80;
+				val2 |= 0x40;
+			}else{
+				if (c->symbol_rate >= 28000000){
+					val1 |= 0xc0;
+				}else if (c->symbol_rate >= 18000000){
+					val2 |= 0x40;
+				}else{
+					val1 |= 0x80;
+					val2 |= 0x40;
+				}				
+			}
+			m88ds3103_writereg(state, 0x22, val1);
+			m88ds3103_writereg(state, 0x24, val2);					
+		}
+		
+		if(state->config->ci_mode)
+			val1 = 0x03;
+		else if(state->config->ts_mode)
+			val1 = 0x06;
+		else
+			val1 = 0x42;
+		m88ds3103_writereg(state, 0xfd, val1);
+		
+		break;
+	default:
+		return 1;
+	}
+	/* disable 27MHz clock output */
+	m88ds3103_writereg(state, 0x29, 0x80);
+	/* enable ac coupling */
+	m88ds3103_writereg(state, 0x25, 0x8a);
+
+	if ((c->symbol_rate / 1000) <= 3000){
+		m88ds3103_writereg(state, 0xc3, 0x08); /* 8 * 32 * 100 / 64 = 400*/
+		m88ds3103_writereg(state, 0xc8, 0x20);
+		m88ds3103_writereg(state, 0xc4, 0x08); /* 8 * 0 * 100 / 128 = 0*/
+		m88ds3103_writereg(state, 0xc7, 0x00);
+	}else if((c->symbol_rate / 1000) <= 10000){
+		m88ds3103_writereg(state, 0xc3, 0x08); /* 8 * 16 * 100 / 64 = 200*/
+		m88ds3103_writereg(state, 0xc8, 0x10);
+		m88ds3103_writereg(state, 0xc4, 0x08); /* 8 * 0 * 100 / 128 = 0*/
+		m88ds3103_writereg(state, 0xc7, 0x00);
+	}else{
+		m88ds3103_writereg(state, 0xc3, 0x08); /* 8 * 6 * 100 / 64 = 75*/
+		m88ds3103_writereg(state, 0xc8, 0x06);
+		m88ds3103_writereg(state, 0xc4, 0x08); /* 8 * 0 * 100 / 128 = 0*/
+		m88ds3103_writereg(state, 0xc7, 0x00);
+	}
+
+	m88ds3103_set_symrate(fe);
+	
+	m88ds3103_set_CCI(fe);
+
+	m88ds3103_set_carrier_offset(fe, carrier_offset_khz);
+		
+	/* ds3000 out of software reset */
+	m88ds3103_writereg(state, 0x00, 0x00);
+	/* start ds3000 build-in uC */
+	m88ds3103_writereg(state, 0xb2, 0x00);	
+	
+	return 0;
+}
+
+static int m88ds3103_set_frontend(struct dvb_frontend *fe)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+
+	int i;
+	fe_status_t status;
+	u8 lpf_mxdiv, mlpf_max, mlpf_min, nlpf, div4, capCode, changePLL;
+	s32 offset_khz, lpf_offset_KHz;
+	u16 value, ndiv, lpf_coeff;
+	u32 f3db, gdiv28, realFreq;
+	u8 RFgain;
+
+	dprintk("%s() ", __func__);
+	dprintk("c frequency = %d\n", c->frequency);
+	dprintk("symbol rate = %d\n", c->symbol_rate);
+	dprintk("delivery system = %d\n", c->delivery_system);
+	
+	realFreq = c->frequency;
+	lpf_offset_KHz = 0;
+	if(c->symbol_rate < 5000000){
+		lpf_offset_KHz = FREQ_OFFSET_AT_SMALL_SYM_RATE_KHz;
+		realFreq += FREQ_OFFSET_AT_SMALL_SYM_RATE_KHz;
+	}
+	
+	if (state->config->set_ts_params)
+		state->config->set_ts_params(fe, 0);
+
+	div4 = 0;
+	RFgain = 0;
+	if(state->tuner_id == TS2022_ID){
+		m88ds3103_tuner_writereg(state, 0x10, 0x0a);
+		m88ds3103_tuner_writereg(state, 0x11, 0x40);
+		if (realFreq < 1103000) {
+			m88ds3103_tuner_writereg(state, 0x10, 0x1b);
+			div4 = 1;
+			ndiv = (realFreq * (6 + 8) * 4)/MT_FE_CRYSTAL_KHZ;				
+		}else {
+			ndiv = (realFreq * (6 + 8) * 2)/MT_FE_CRYSTAL_KHZ;
+		}
+		ndiv = ndiv + ndiv%2;
+		if(ndiv < 4095)
+			ndiv = ndiv - 1024;
+		else if (ndiv < 6143)
+			ndiv = ndiv + 1024;
+		else
+			ndiv = ndiv + 3072;	
+		
+		m88ds3103_tuner_writereg(state, 0x01, (ndiv & 0x3f00) >> 8);											
+	}else{
+		m88ds3103_tuner_writereg(state, 0x10, 0x00);			
+		if (realFreq < 1146000){
+			m88ds3103_tuner_writereg(state, 0x10, 0x11);
+			div4 = 1;
+			ndiv = (realFreq * (6 + 8) * 4) / MT_FE_CRYSTAL_KHZ;
+		}else{
+			m88ds3103_tuner_writereg(state, 0x10, 0x01);
+			ndiv = (realFreq * (6 + 8) * 2) / MT_FE_CRYSTAL_KHZ;
+		}
+		ndiv = ndiv + ndiv%2;
+		ndiv = ndiv - 1024;
+		m88ds3103_tuner_writereg(state, 0x01, (ndiv>>8)&0x0f);
+	}
+	/* set pll */
+	m88ds3103_tuner_writereg(state, 0x02, ndiv & 0x00ff);
+	m88ds3103_tuner_writereg(state, 0x03, 0x06);
+	m88ds3103_tuner_writereg(state, 0x51, 0x0f);
+	m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+	m88ds3103_tuner_writereg(state, 0x50, 0x10);
+	m88ds3103_tuner_writereg(state, 0x50, 0x00);	
+
+	if(state->tuner_id == TS2022_ID){
+		if(( realFreq >= 1650000 ) && (realFreq <= 1850000)){
+			msleep(5);
+			value = m88ds3103_tuner_readreg(state, 0x14);
+			value &= 0x7f;
+			if(value < 64){
+				m88ds3103_tuner_writereg(state, 0x10, 0x82);
+				m88ds3103_tuner_writereg(state, 0x11, 0x6f);
+
+				m88ds3103_tuner_writereg(state, 0x51, 0x0f);
+				m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+				m88ds3103_tuner_writereg(state, 0x50, 0x10);
+				m88ds3103_tuner_writereg(state, 0x50, 0x00);
+			}
+		}
+		msleep(5);
+		value = m88ds3103_tuner_readreg(state, 0x14);
+		value &= 0x1f;
+
+		if(value > 19){
+			value = m88ds3103_tuner_readreg(state, 0x10);
+			value &= 0x1d;
+			m88ds3103_tuner_writereg(state, 0x10, value);
+		}				
+	}else{
+		msleep(5);
+		value = m88ds3103_tuner_readreg(state, 0x66);
+		changePLL = (((value & 0x80) >> 7) != div4);
+
+		if(changePLL){
+			m88ds3103_tuner_writereg(state, 0x10, 0x11);
+			div4 = 1;
+			ndiv = (realFreq * (6 + 8) * 4)/MT_FE_CRYSTAL_KHZ;
+			ndiv = ndiv + ndiv%2;
+			ndiv = ndiv - 1024;
+					
+			m88ds3103_tuner_writereg(state, 0x01, (ndiv>>8) & 0x0f);
+			m88ds3103_tuner_writereg(state, 0x02, ndiv & 0xff);
+			
+			m88ds3103_tuner_writereg(state, 0x51, 0x0f);
+			m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+			m88ds3103_tuner_writereg(state, 0x50, 0x10);
+			m88ds3103_tuner_writereg(state, 0x50, 0x00);
+		}		
+	}
+	/*set the RF gain*/
+	if(state->tuner_id == TS2020_ID)
+		m88ds3103_tuner_writereg(state, 0x60, 0x79);
+			
+	m88ds3103_tuner_writereg(state, 0x51, 0x17);
+	m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+	m88ds3103_tuner_writereg(state, 0x50, 0x08);
+	m88ds3103_tuner_writereg(state, 0x50, 0x00);
+	msleep(5);
+
+	if(state->tuner_id == TS2020_ID){
+		RFgain = m88ds3103_tuner_readreg(state, 0x3d);
+		RFgain &= 0x0f;
+		if(RFgain < 15){
+			if(RFgain < 4) 
+				RFgain = 0;
+			else
+				RFgain = RFgain -3;
+			value = ((RFgain << 3) | 0x01) & 0x79;
+			m88ds3103_tuner_writereg(state, 0x60, value);
+			m88ds3103_tuner_writereg(state, 0x51, 0x17);
+			m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+			m88ds3103_tuner_writereg(state, 0x50, 0x08);
+			m88ds3103_tuner_writereg(state, 0x50, 0x00);
+		}
+	}
+	
+	/* set the LPF */
+	if(state->tuner_id == TS2022_ID){
+		m88ds3103_tuner_writereg(state, 0x25, 0x00);
+		m88ds3103_tuner_writereg(state, 0x27, 0x70);
+		m88ds3103_tuner_writereg(state, 0x41, 0x09);
+		m88ds3103_tuner_writereg(state, 0x08, 0x0b);
+	}
+
+	f3db = ((c->symbol_rate / 1000) *135) / 200 + 2000;
+	f3db += lpf_offset_KHz;
+	if (f3db < 7000)
+		f3db = 7000;
+	if (f3db > 40000)
+		f3db = 40000;
+			
+	gdiv28 = (MT_FE_CRYSTAL_KHZ / 1000 * 1694 + 500) / 1000;
+	m88ds3103_tuner_writereg(state, 0x04, gdiv28 & 0xff);
+	m88ds3103_tuner_writereg(state, 0x51, 0x1b);
+	m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+	m88ds3103_tuner_writereg(state, 0x50, 0x04);
+	m88ds3103_tuner_writereg(state, 0x50, 0x00);
+	msleep(5);
+
+	value = m88ds3103_tuner_readreg(state, 0x26);
+	capCode = value & 0x3f;
+	if(state->tuner_id == TS2022_ID){
+		m88ds3103_tuner_writereg(state, 0x41, 0x0d);
+
+		m88ds3103_tuner_writereg(state, 0x51, 0x1b);
+		m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+		m88ds3103_tuner_writereg(state, 0x50, 0x04);
+		m88ds3103_tuner_writereg(state, 0x50, 0x00);
+
+		msleep(2);
+
+		value = m88ds3103_tuner_readreg(state, 0x26);
+		value &= 0x3f;
+		value = (capCode + value) / 2;		
+	}
+	else
+		value = capCode;
+		
+	gdiv28 = gdiv28 * 207 / (value * 2 + 151);	
+	mlpf_max = gdiv28 * 135 / 100;
+	mlpf_min = gdiv28 * 78 / 100;
+	if (mlpf_max > 63)
+		mlpf_max = 63;
+
+	if(state->tuner_id == TS2022_ID)
+		lpf_coeff = 3200;
+	else
+		lpf_coeff = 2766;
+		
+	nlpf = (f3db * gdiv28 * 2 / lpf_coeff / (MT_FE_CRYSTAL_KHZ / 1000)  + 1) / 2 ;	
+	if (nlpf > 23) nlpf = 23;
+	if (nlpf < 1) nlpf = 1;
+
+	lpf_mxdiv = (nlpf * (MT_FE_CRYSTAL_KHZ / 1000) * lpf_coeff * 2 / f3db + 1) / 2;
+
+	if (lpf_mxdiv < mlpf_min){
+		nlpf++;
+		lpf_mxdiv = (nlpf * (MT_FE_CRYSTAL_KHZ / 1000) * lpf_coeff * 2  / f3db + 1) / 2;
+	}
+
+	if (lpf_mxdiv > mlpf_max)
+		lpf_mxdiv = mlpf_max;
+
+	m88ds3103_tuner_writereg(state, 0x04, lpf_mxdiv);
+	m88ds3103_tuner_writereg(state, 0x06, nlpf);
+	m88ds3103_tuner_writereg(state, 0x51, 0x1b);
+	m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+	m88ds3103_tuner_writereg(state, 0x50, 0x04);
+	m88ds3103_tuner_writereg(state, 0x50, 0x00);
+	msleep(5);
+	
+	if(state->tuner_id == TS2022_ID){
+		msleep(2);
+		value = m88ds3103_tuner_readreg(state, 0x26);
+		capCode = value & 0x3f;
+
+		m88ds3103_tuner_writereg(state, 0x41, 0x09);
+
+		m88ds3103_tuner_writereg(state, 0x51, 0x1b);
+		m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+		m88ds3103_tuner_writereg(state, 0x50, 0x04);
+		m88ds3103_tuner_writereg(state, 0x50, 0x00);
+
+		msleep(2);
+		value = m88ds3103_tuner_readreg(state, 0x26);
+		value &= 0x3f;
+		value = (capCode + value) / 2;
+
+		value = value | 0x80;
+		m88ds3103_tuner_writereg(state, 0x25, value);
+		m88ds3103_tuner_writereg(state, 0x27, 0x30);
+
+		m88ds3103_tuner_writereg(state, 0x08, 0x09);		
+	}
+
+	/* Set the BB gain */
+	m88ds3103_tuner_writereg(state, 0x51, 0x1e);
+	m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+	m88ds3103_tuner_writereg(state, 0x50, 0x01);
+	m88ds3103_tuner_writereg(state, 0x50, 0x00);
+	if(state->tuner_id == TS2020_ID){
+		if(RFgain == 15){
+			msleep(40);
+			value = m88ds3103_tuner_readreg(state, 0x21);
+			value &= 0x0f;
+			if(value < 3){
+				m88ds3103_tuner_writereg(state, 0x60, 0x61);
+				m88ds3103_tuner_writereg(state, 0x51, 0x17);
+				m88ds3103_tuner_writereg(state, 0x51, 0x1f);
+				m88ds3103_tuner_writereg(state, 0x50, 0x08);
+				m88ds3103_tuner_writereg(state, 0x50, 0x00);
+			}			
+		}
+	}
+	msleep(60);
+	
+	offset_khz = (ndiv - ndiv % 2 + 1024) * MT_FE_CRYSTAL_KHZ
+		/ (6 + 8) / (div4 + 1) / 2 - realFreq;
+
+	m88ds3103_demod_connect(fe, offset_khz+lpf_offset_KHz);
+
+	for (i = 0; i < 30 ; i++) {
+		m88ds3103_read_status(fe, &status);
+		if (status & FE_HAS_LOCK){
+			break;
+                }
+		msleep(20);
+	}
+	
+	if((status & FE_HAS_LOCK) == 0){
+		state->delivery_system = (state->delivery_system == SYS_DVBS) ? SYS_DVBS2 : SYS_DVBS;
+		m88ds3103_demod_connect(fe, offset_khz);
+	
+		for (i = 0; i < 30 ; i++) {
+			m88ds3103_read_status(fe, &status);
+			if (status & FE_HAS_LOCK){
+				break;
+                	}
+			msleep(20);
+		}
+	}
+	
+	if (status & FE_HAS_LOCK){
+		if(state->config->ci_mode == 2)
+			m88ds3103_set_clock_ratio(state);
+		if(state->config->start_ctrl){
+			if(state->first_lock == 0){
+				state->config->start_ctrl(fe);
+				state->first_lock = 1;	
+			}
+		}		
+	}
+		
+	return 0;
+}
+
+static int m88ds3103_tune(struct dvb_frontend *fe,
+			bool re_tune,
+			unsigned int mode_flags,
+			unsigned int *delay,
+			fe_status_t *status)
+{	
+	*delay = HZ / 5;
+	
+	dprintk("%s() ", __func__);
+	dprintk("re_tune = %d\n", re_tune);
+	
+	if (re_tune) {
+		int ret = m88ds3103_set_frontend(fe);
+		if (ret)
+			return ret;
+	}
+	
+	return m88ds3103_read_status(fe, status);
+}
+
+static enum dvbfe_algo m88ds3103_get_algo(struct dvb_frontend *fe)
+{
+	return DVBFE_ALGO_HW;
+}
+ 
+ /*
+ * Power config will reset and load initial firmware if required
+ */
+static int m88ds3103_initilaze(struct dvb_frontend *fe)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	int ret;
+
+	dprintk("%s()\n", __func__);
+	/* hard reset */
+	m88ds3103_writereg(state, 0x07, 0x80);
+	m88ds3103_writereg(state, 0x07, 0x00);
+	msleep(1);
+	
+	m88ds3103_writereg(state, 0x08, 0x01 | m88ds3103_readreg(state, 0x08));
+	msleep(1);
+
+	if(state->tuner_id == TS2020_ID){
+		/* TS2020 init */
+		m88ds3103_tuner_writereg(state, 0x42, 0x73);
+		msleep(2);
+		m88ds3103_tuner_writereg(state, 0x05, 0x01);
+		m88ds3103_tuner_writereg(state, 0x62, 0xb5);
+		m88ds3103_tuner_writereg(state, 0x07, 0x02);
+		m88ds3103_tuner_writereg(state, 0x08, 0x01);
+	}
+	else if(state->tuner_id == TS2022_ID){
+		/* TS2022 init */
+		m88ds3103_tuner_writereg(state, 0x62, 0x6c);
+		msleep(2);
+		m88ds3103_tuner_writereg(state, 0x42, 0x6c);
+		msleep(2);
+		m88ds3103_tuner_writereg(state, 0x7d, 0x9d);
+		m88ds3103_tuner_writereg(state, 0x7c, 0x9a);
+		m88ds3103_tuner_writereg(state, 0x7a, 0x76);
+
+		m88ds3103_tuner_writereg(state, 0x3b, 0x01);
+		m88ds3103_tuner_writereg(state, 0x63, 0x88);
+
+		m88ds3103_tuner_writereg(state, 0x61, 0x85);
+		m88ds3103_tuner_writereg(state, 0x22, 0x30);
+		m88ds3103_tuner_writereg(state, 0x30, 0x40);
+		m88ds3103_tuner_writereg(state, 0x20, 0x23);
+		m88ds3103_tuner_writereg(state, 0x24, 0x02);
+		m88ds3103_tuner_writereg(state, 0x12, 0xa0);	
+	}
+		
+	if(state->demod_id == DS3103_ID){
+		m88ds3103_writereg(state, 0x07, 0xe0);
+		m88ds3103_writereg(state, 0x07, 0x00);
+		msleep(1);		
+	}
+	m88ds3103_writereg(state, 0xb2, 0x01);
+	
+	/* Load the firmware if required */
+	ret = m88ds3103_load_firmware(fe);
+	if (ret != 0){
+		printk(KERN_ERR "%s: Unable initialize firmware\n", __func__);
+		return ret;
+	}
+	if(state->demod_id == DS3103_ID){
+		m88ds3103_writereg(state, 0x4d, 0xfd & m88ds3103_readreg(state, 0x4d));
+		m88ds3103_writereg(state, 0x30, 0xef & m88ds3103_readreg(state, 0x30));		
+	}
+
+	return 0;
+}
+
+/*
+ * Initialise or wake up device
+ */
+static int m88ds3103_initfe(struct dvb_frontend *fe)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+	u8 val;
+
+	dprintk("%s()\n", __func__);
+
+	/* 1st step to wake up demod */
+	m88ds3103_writereg(state, 0x08, 0x01 | m88ds3103_readreg(state, 0x08));
+	m88ds3103_writereg(state, 0x04, 0xfe & m88ds3103_readreg(state, 0x04));
+	m88ds3103_writereg(state, 0x23, 0xef & m88ds3103_readreg(state, 0x23));
+	
+	/* 2nd step to wake up tuner */
+	val = m88ds3103_tuner_readreg(state, 0x00) & 0xff;
+	if((val & 0x01) == 0){
+		m88ds3103_tuner_writereg(state, 0x00, 0x01);
+		msleep(50);
+	}
+	m88ds3103_tuner_writereg(state, 0x00, 0x03);
+	msleep(50);
+	
+	return 0;	
+}
+
+/* Put device to sleep */
+static int m88ds3103_sleep(struct dvb_frontend *fe)
+{
+	struct m88ds3103_state *state = fe->demodulator_priv;
+
+	dprintk("%s()\n", __func__);
+	
+	/* 1st step to sleep tuner */
+	m88ds3103_tuner_writereg(state, 0x00, 0x00);
+	
+	/* 2nd step to sleep demod */
+	m88ds3103_writereg(state, 0x08, 0xfe & m88ds3103_readreg(state, 0x08));
+	m88ds3103_writereg(state, 0x04, 0x01 | m88ds3103_readreg(state, 0x04));
+	m88ds3103_writereg(state, 0x23, 0x10 | m88ds3103_readreg(state, 0x23));
+	
+
+	return 0;
+}
+
+static struct dvb_frontend_ops m88ds3103_ops = {
+	.delsys = { SYS_DVBS, SYS_DVBS2},
+	.info = {
+		.name = "Montage DS3103/TS2022",
+		.type = FE_QPSK,
+		.frequency_min = 950000,
+		.frequency_max = 2150000,
+		.frequency_stepsize = 1011, /* kHz for QPSK frontends */
+		.frequency_tolerance = 5000,
+		.symbol_rate_min = 1000000,
+		.symbol_rate_max = 45000000,
+		.caps = FE_CAN_INVERSION_AUTO |
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |
+			FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_2G_MODULATION |
+			FE_CAN_QPSK | FE_CAN_RECOVER
+	},
+
+	.release = m88ds3103_release,
+
+	.init = m88ds3103_initfe,
+	.sleep = m88ds3103_sleep,
+	.read_status = m88ds3103_read_status,
+	.read_ber = m88ds3103_read_ber,
+	.read_signal_strength = m88ds3103_read_signal_strength,
+	.read_snr = m88ds3103_read_snr,
+	.read_ucblocks = m88ds3103_read_ucblocks,
+	.set_tone = m88ds3103_set_tone,
+	.set_voltage = m88ds3103_set_voltage,
+	.diseqc_send_master_cmd = m88ds3103_send_diseqc_msg,
+	.diseqc_send_burst = m88ds3103_diseqc_send_burst,
+	.get_frontend_algo = m88ds3103_get_algo,
+	.tune = m88ds3103_tune,
+	.set_frontend = m88ds3103_set_frontend,
+};
+
+MODULE_DESCRIPTION("DVB Frontend module for Montage DS3103/TS2022 hardware");
+MODULE_AUTHOR("Max nibble");
+MODULE_LICENSE("GPL");
diff -urN a/drivers/media/dvb-frontends/m88ds3103.h b/drivers/media/dvb-frontends/m88ds3103.h
--- a/drivers/media/dvb-frontends/m88ds3103.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/m88ds3103.h	2013-01-30 12:33:51.000000000 +0800
@@ -0,0 +1,53 @@
+/*
+    Montage Technology M88DS3103/M88TS2022 - DVBS/S2 Satellite demod/tuner driver
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef M88DS3103_H
+#define M88DS3103_H
+
+#include <linux/dvb/frontend.h>
+
+struct m88ds3103_config {
+	/* the demodulator's i2c address */
+	u8 demod_address;
+	u8 ci_mode;
+	u8 pin_ctrl;
+	u8 ts_mode; /* 0: Parallel, 1: Serial */
+
+	/* Set device param to start dma */
+	int (*set_ts_params)(struct dvb_frontend *fe, int is_punctured);
+    /* Start to transfer data */
+    int (*start_ctrl)(struct dvb_frontend *fe);
+    /* Set LNB voltage */
+    int (*set_voltage)(struct dvb_frontend* fe, fe_sec_voltage_t voltage);
+};
+
+#if defined(CONFIG_DVB_M88DS3103) || \
+	(defined(CONFIG_DVB_M88DS3103_MODULE) && defined(MODULE))
+extern struct dvb_frontend *m88ds3103_attach(
+       const struct m88ds3103_config *config,
+       struct i2c_adapter *i2c);
+#else
+static inline struct dvb_frontend *m88ds3103_attach(
+       const struct m88ds3103_config *config,
+       struct i2c_adapter *i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif /* CONFIG_DVB_M88DS3103 */
+#endif /* M88DS3103_H */
diff -urN a/drivers/media/dvb-frontends/m88ds3103_priv.h b/drivers/media/dvb-frontends/m88ds3103_priv.h
--- a/drivers/media/dvb-frontends/m88ds3103_priv.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/m88ds3103_priv.h	2013-01-30 12:33:56.000000000 +0800
@@ -0,0 +1,403 @@
+/*
+    Montage Technology M88DS3103/M88TS2022 - DVBS/S2 Satellite demod/tuner driver
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef M88DS3103_PRIV_H
+#define M88DS3103_PRIV_H
+
+#define FW_DOWN_SIZE 32
+#define FW_DOWN_LOOP (8192/FW_DOWN_SIZE)
+#define DS3103_DEFAULT_FIRMWARE "dvb-fe-ds3103.fw"
+#define DS3000_DEFAULT_FIRMWARE "dvb-fe-ds300x.fw"
+#define MT_FE_MCLK_KHZ 96000 /* in kHz */
+#define MT_FE_CRYSTAL_KHZ   27000 /* in kHz */
+#define FREQ_OFFSET_AT_SMALL_SYM_RATE_KHz 3000
+#define DS3000_ID	0x3000
+#define DS3103_ID	0x3103
+#define TS2020_ID	0x2020
+#define TS2022_ID	0x2022
+#define UNKNOW_ID	0x0000
+
+struct m88ds3103_state {
+	struct i2c_adapter *i2c;
+	const struct m88ds3103_config *config;
+	
+	struct dvb_frontend frontend;
+	
+	u32 preBer;
+	u8 skip_fw_load;	
+	u8 first_lock; /* The first time of signal lock */
+	u16 demod_id; /* demod chip type */
+	u16 tuner_id; /* tuner chip type */
+	fe_delivery_system_t delivery_system;
+};
+
+/* For M88DS3103 demod dvbs mode.*/
+static u8 ds3103_dvbs_init_tab[] = {
+	0x23, 0x07,
+	0x08, 0x03,
+	0x0c, 0x02,
+	0x21, 0x54,
+	0x25, 0x82,
+	0x27, 0x31,
+	0x30, 0x08,
+	0x31, 0x40,
+	0x32, 0x32,
+	0x33, 0x35,
+	0x35, 0xff,
+	0x3a, 0x00,
+	0x37, 0x10,
+	0x38, 0x10,
+	0x39, 0x02,
+	0x42, 0x60,
+	0x4a, 0x80,
+	0x4b, 0x04,
+	0x4d, 0x91,
+	0x5d, 0xc8,
+	0x50, 0x36,
+	0x51, 0x36,
+	0x52, 0x36,
+	0x53, 0x36,
+	0x63, 0x0f,
+	0x64, 0x30,
+	0x65, 0x40,
+	0x68, 0x26,
+	0x69, 0x4c,
+	0x70, 0x20,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x40,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x60,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x80,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0xa0,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x1f,
+	0x76, 0x38,
+	0x77, 0xa6,
+	0x78, 0x0c,
+	0x79, 0x80,
+	0x7f, 0x14,
+	0x7c, 0x00,
+	0xae, 0x82,
+	0x80, 0x64,
+	0x81, 0x66,
+	0x82, 0x44,
+	0x85, 0x04,
+	0xcd, 0xf4,
+	0x90, 0x33,
+	0xa0, 0x44,
+	0xc0, 0x08,
+	0xc3, 0x10,
+	0xc4, 0x08,
+	0xc5, 0xf0,
+	0xc6, 0xff,
+	0xc7, 0x00,
+	0xc8, 0x1a,
+	0xc9, 0x80,
+	0xe0, 0xf8,
+	0xe6, 0x8b,
+	0xd0, 0x40,
+	0xf8, 0x20,
+	0xfa, 0x0f,
+	0x00, 0x00,
+	0xbd, 0x01,
+	0xb8, 0x00,
+};
+/* For M88DS3103 demod dvbs2 mode.*/
+static u8 ds3103_dvbs2_init_tab[] = {
+	0x23, 0x07,
+	0x08, 0x07,
+	0x0c, 0x02,
+	0x21, 0x54,
+	0x25, 0x82,
+	0x27, 0x31,
+	0x30, 0x08,
+	0x32, 0x32,
+	0x33, 0x35,
+	0x35, 0xff,
+	0x3a, 0x00,
+	0x37, 0x10,
+	0x38, 0x10,
+	0x39, 0x02,
+	0x42, 0x60,
+	0x4a, 0x80,
+	0x4b, 0x04,
+	0x4d, 0x91,
+	0x5d, 0xc8,
+	0x50, 0x36,
+	0x51, 0x36,
+	0x52, 0x36,
+	0x53, 0x36,
+	0x63, 0x0f,
+	0x64, 0x10,
+	0x65, 0x20,
+	0x68, 0x46,
+	0x69, 0xcd,
+	0x70, 0x20,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x40,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x60,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x80,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0xa0,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x1f,
+	0x76, 0x38,
+	0x77, 0xa6,
+	0x78, 0x0c,
+	0x79, 0x80,
+	0x7f, 0x14,
+	0x85, 0x08,
+	0xcd, 0xf4,
+	0x90, 0x33,
+	0x86, 0x00,
+	0x87, 0x0f,
+	0x89, 0x00,
+	0x8b, 0x44,
+	0x8c, 0x66,
+	0x9d, 0xc1,
+	0x8a, 0x10,
+	0xad, 0x40,
+	0xa0, 0x44,
+	0xc0, 0x08,
+	0xc1, 0x10,
+	0xc2, 0x08,
+	0xc3, 0x10,
+	0xc4, 0x08,
+	0xc5, 0xf0,
+	0xc6, 0xff,
+	0xc7, 0x00,
+	0xc8, 0x1a,
+	0xc9, 0x80,
+	0xca, 0x23,
+	0xcb, 0x24,
+	0xcc, 0xf4,
+	0xce, 0x74,
+	0x00, 0x00,
+	0xbd, 0x01,
+	0xb8, 0x00,
+};
+
+/* For M88DS3000 demod dvbs mode.*/
+static u8 ds3000_dvbs_init_tab[] = {
+	0x23, 0x05,
+	0x08, 0x03,
+	0x0c, 0x02,
+	0x21, 0x54,
+	0x25, 0x82,
+	0x27, 0x31,
+	0x30, 0x08,
+	0x31, 0x40,
+	0x32, 0x32,
+	0x33, 0x35,
+	0x35, 0xff,
+	0x3a, 0x00,
+	0x37, 0x10,
+	0x38, 0x10,
+	0x39, 0x02,
+	0x42, 0x60,
+	0x4a, 0x40,
+	0x4b, 0x04,
+	0x4d, 0x91,
+	0x5d, 0xc8,
+	0x50, 0x77,
+	0x51, 0x77,
+	0x52, 0x36,
+	0x53, 0x36,
+	0x56, 0x01,
+	0x63, 0x47,
+	0x64, 0x30,
+	0x65, 0x40,
+	0x68, 0x26,
+	0x69, 0x4c,
+	0x70, 0x20,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x40,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x60,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x80,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0xa0,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x1f,
+	0x76, 0x00,
+	0x77, 0xd1,
+	0x78, 0x0c,
+	0x79, 0x80,
+	0x7f, 0x04,
+	0x7c, 0x00,
+	0x80, 0x86,
+	0x81, 0xa6,
+	0x85, 0x04,
+	0xcd, 0xf4,
+	0x90, 0x33,
+	0xa0, 0x44,
+	0xc0, 0x18,
+	0xc3, 0x10,
+	0xc4, 0x08,
+	0xc5, 0x80,
+	0xc6, 0x80,
+	0xc7, 0x0a,
+	0xc8, 0x1a,
+	0xc9, 0x80,
+	0xfe, 0xb6,
+	0xe0, 0xf8,
+	0xe6, 0x8b,
+	0xd0, 0x40,
+	0xf8, 0x20,
+	0xfa, 0x0f,
+	0xad, 0x20,
+	0xae, 0x07,
+	0xb8, 0x00,
+};
+
+/* For M88DS3000 demod dvbs2 mode.*/
+static u8 ds3000_dvbs2_init_tab[] = {
+	0x23, 0x0f,
+	0x08, 0x07,
+	0x0c, 0x02,
+	0x21, 0x54,
+	0x25, 0x82,
+	0x27, 0x31,
+	0x30, 0x08,
+	0x31, 0x32,
+	0x32, 0x32,
+	0x33, 0x35,
+	0x35, 0xff,
+	0x3a, 0x00,
+	0x37, 0x10,
+	0x38, 0x10,
+	0x39, 0x02,
+	0x42, 0x60,
+	0x4a, 0x80,
+	0x4b, 0x04,
+	0x4d, 0x91,
+	0x5d, 0x88,
+	0x50, 0x36,
+	0x51, 0x36,
+	0x52, 0x36,
+	0x53, 0x36,
+	0x63, 0x60,
+	0x64, 0x10,
+	0x65, 0x10,
+	0x68, 0x04,
+	0x69, 0x29,
+	0x70, 0x20,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x40,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x60,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x80,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0xa0,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x1f,
+	0xa0, 0x44,
+	0xc0, 0x08,
+	0xc1, 0x10,
+	0xc2, 0x08,
+	0xc3, 0x10,
+	0xc4, 0x08,
+	0xc5, 0xf0,
+	0xc6, 0xf0,
+	0xc7, 0x0a,
+	0xc8, 0x1a,
+	0xc9, 0x80,
+	0xca, 0x23,
+	0xcb, 0x24,
+	0xce, 0x74,
+	0x56, 0x01,
+	0x90, 0x03,
+	0x76, 0x80,
+	0x77, 0x42,
+	0x78, 0x0a,
+	0x79, 0x80,
+	0xad, 0x40,
+	0xae, 0x07,
+	0x7f, 0xd4,
+	0x7c, 0x00,
+	0x80, 0xa8,
+	0x81, 0xda,
+	0x7c, 0x01,
+	0x80, 0xda,
+	0x81, 0xec,
+	0x7c, 0x02,
+	0x80, 0xca,
+	0x81, 0xeb,
+	0x7c, 0x03,
+	0x80, 0xba,
+	0x81, 0xdb,
+	0x85, 0x08,
+	0x86, 0x00,
+	0x87, 0x02,
+	0x89, 0x80,
+	0x8b, 0x44,
+	0x8c, 0xaa,
+	0x8a, 0x10,
+	0xba, 0x00,
+	0xf5, 0x04,
+	0xd2, 0x32,
+	0xb8, 0x00,
+};
+
+#endif /* M88DS3103_PRIV_H */
diff -urN a/drivers/media/dvb-frontends/Makefile b/drivers/media/dvb-frontends/Makefile
--- a/drivers/media/dvb-frontends/Makefile	2013-03-21 04:11:19.000000000 +0800
+++ b/drivers/media/dvb-frontends/Makefile	2013-02-14 22:57:10.000000000 +0800
@@ -10,6 +10,7 @@
 drxd-objs := drxd_firm.o drxd_hard.o
 cxd2820r-objs := cxd2820r_core.o cxd2820r_c.o cxd2820r_t.o cxd2820r_t2.o
 drxk-objs := drxk_hard.o
+si2168-objs := si2168_demod.o si2168_si2158.o si2168_drv.o
 
 obj-$(CONFIG_DVB_PLL) += dvb-pll.o
 obj-$(CONFIG_DVB_STV0299) += stv0299.o
@@ -102,4 +103,6 @@
 obj-$(CONFIG_DVB_RTL2832) += rtl2832.o
 obj-$(CONFIG_DVB_M88RS2000) += m88rs2000.o
 obj-$(CONFIG_DVB_AF9033) += af9033.o
-
+obj-$(CONFIG_DVB_M88DS3103) += m88ds3103.o
+obj-$(CONFIG_DVB_M88DC2800) += m88dc2800.o
+obj-$(CONFIG_DVB_SI2168) += si2168.o
diff -urN a/drivers/media/dvb-frontends/si2158_commands.h b/drivers/media/dvb-frontends/si2158_commands.h
--- a/drivers/media/dvb-frontends/si2158_commands.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/si2158_commands.h	2013-02-17 18:04:35.000000000 +0800
@@ -0,0 +1,1223 @@
+/************************************************************************************/
+#ifndef    Si2158_COMMANDS_H
+#define    Si2158_COMMANDS_H
+
+/* STATUS structure definition */
+  typedef struct { /* Si2158_COMMON_REPLY_struct */
+    unsigned char   tunint;
+    unsigned char   atvint;
+    unsigned char   dtvint;
+    unsigned char   err;
+    unsigned char   cts;
+ }  Si2158_COMMON_REPLY_struct;
+
+/* STATUS fields definition */
+  /* STATUS, TUNINT field definition (address 0, size 1, lsb 0, unsigned)*/
+  #define  Si2158_STATUS_TUNINT_LSB         0
+  #define  Si2158_STATUS_TUNINT_MASK        0x01
+   #define Si2158_STATUS_TUNINT_NOT_TRIGGERED  0
+   #define Si2158_STATUS_TUNINT_TRIGGERED      1
+  /* STATUS, ATVINT field definition (address 0, size 1, lsb 1, unsigned)*/
+  #define  Si2158_STATUS_ATVINT_LSB         1
+  #define  Si2158_STATUS_ATVINT_MASK        0x01
+   #define Si2158_STATUS_ATVINT_NOT_TRIGGERED  0
+   #define Si2158_STATUS_ATVINT_TRIGGERED      1
+  /* STATUS, DTVINT field definition (address 0, size 1, lsb 2, unsigned)*/
+  #define  Si2158_STATUS_DTVINT_LSB         2
+  #define  Si2158_STATUS_DTVINT_MASK        0x01
+   #define Si2158_STATUS_DTVINT_NOT_TRIGGERED  0
+   #define Si2158_STATUS_DTVINT_TRIGGERED      1
+  /* STATUS, ERR field definition (address 0, size 1, lsb 6, unsigned)*/
+  #define  Si2158_STATUS_ERR_LSB         6
+  #define  Si2158_STATUS_ERR_MASK        0x01
+   #define Si2158_STATUS_ERR_ERROR     1
+   #define Si2158_STATUS_ERR_NO_ERROR  0
+  /* STATUS, CTS field definition (address 0, size 1, lsb 7, unsigned)*/
+  #define  Si2158_STATUS_CTS_LSB         7
+  #define  Si2158_STATUS_CTS_MASK        0x01
+   #define Si2158_STATUS_CTS_COMPLETED  1
+   #define Si2158_STATUS_CTS_WAIT       0
+
+/* _status_defines_insertion_point */
+
+/* _commands_defines_insertion_start */
+/* Si2158_AGC_OVERRIDE command definition */
+#define   Si2158_AGC_OVERRIDE_CMD 0x44
+
+#ifdef    Si2158_AGC_OVERRIDE_CMD
+  #define Si2158_AGC_OVERRIDE_CMD_CODE 0x010044
+
+    typedef struct { /* Si2158_AGC_OVERRIDE_CMD_struct */
+     unsigned char   force_max_gain;
+     unsigned char   force_top_gain;
+   } Si2158_AGC_OVERRIDE_CMD_struct;
+
+
+    typedef struct { /* Si2158_AGC_OVERRIDE_CMD_REPLY_struct */
+       Si2158_COMMON_REPLY_struct * STATUS;
+   }  Si2158_AGC_OVERRIDE_CMD_REPLY_struct;
+
+   /* AGC_OVERRIDE command, FORCE_MAX_GAIN field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2158_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_LSB         0
+   #define  Si2158_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MASK        0x01
+   #define  Si2158_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MIN         0
+   #define  Si2158_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MAX         1
+    #define Si2158_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_DISABLE  0
+    #define Si2158_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_ENABLE   1
+   /* AGC_OVERRIDE command, FORCE_TOP_GAIN field definition (address 1,size 1, lsb 1, unsigned) */
+   #define  Si2158_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_LSB         1
+   #define  Si2158_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MASK        0x01
+   #define  Si2158_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MIN         0
+   #define  Si2158_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MAX         1
+    #define Si2158_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_DISABLE  0
+    #define Si2158_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_ENABLE   1
+#endif /* Si2158_AGC_OVERRIDE_CMD */
+
+/* Si2158_ATV_CW_TEST command definition */
+#define   Si2158_ATV_CW_TEST_CMD 0x53
+
+#ifdef    Si2158_ATV_CW_TEST_CMD
+  #define Si2158_ATV_CW_TEST_CMD_CODE 0x010053
+
+    typedef struct { /* Si2158_ATV_CW_TEST_CMD_struct */
+     unsigned char   pc_lock;
+   } Si2158_ATV_CW_TEST_CMD_struct;
+
+
+    typedef struct { /* Si2158_ATV_CW_TEST_CMD_REPLY_struct */
+       Si2158_COMMON_REPLY_struct * STATUS;
+   }  Si2158_ATV_CW_TEST_CMD_REPLY_struct;
+
+   /* ATV_CW_TEST command, PC_LOCK field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2158_ATV_CW_TEST_CMD_PC_LOCK_LSB         0
+   #define  Si2158_ATV_CW_TEST_CMD_PC_LOCK_MASK        0x01
+   #define  Si2158_ATV_CW_TEST_CMD_PC_LOCK_MIN         0
+   #define  Si2158_ATV_CW_TEST_CMD_PC_LOCK_MAX         1
+    #define Si2158_ATV_CW_TEST_CMD_PC_LOCK_LOCK    1
+    #define Si2158_ATV_CW_TEST_CMD_PC_LOCK_UNLOCK  0
+#endif /* Si2158_ATV_CW_TEST_CMD */
+
+/* Si2158_ATV_RESTART command definition */
+#define   Si2158_ATV_RESTART_CMD 0x51
+
+#ifdef    Si2158_ATV_RESTART_CMD
+  #define Si2158_ATV_RESTART_CMD_CODE 0x010051
+
+    typedef struct { /* Si2158_ATV_RESTART_CMD_struct */
+         unsigned char   nothing;   } Si2158_ATV_RESTART_CMD_struct;
+
+
+    typedef struct { /* Si2158_ATV_RESTART_CMD_REPLY_struct */
+       Si2158_COMMON_REPLY_struct * STATUS;
+   }  Si2158_ATV_RESTART_CMD_REPLY_struct;
+
+#endif /* Si2158_ATV_RESTART_CMD */
+
+/* Si2158_ATV_STATUS command definition */
+#define   Si2158_ATV_STATUS_CMD 0x52
+
+#ifdef    Si2158_ATV_STATUS_CMD
+  #define Si2158_ATV_STATUS_CMD_CODE 0x010052
+
+    typedef struct { /* Si2158_ATV_STATUS_CMD_struct */
+     unsigned char   intack;
+   } Si2158_ATV_STATUS_CMD_struct;
+
+
+    typedef struct { /* Si2158_ATV_STATUS_CMD_REPLY_struct */
+       Si2158_COMMON_REPLY_struct * STATUS;
+      unsigned char   chlint;
+      unsigned char   pclint;
+      unsigned char   chl;
+      unsigned char   pcl;
+               int    afc_freq;
+      unsigned char   video_sys;
+      unsigned char   color;
+   }  Si2158_ATV_STATUS_CMD_REPLY_struct;
+
+   /* ATV_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2158_ATV_STATUS_CMD_INTACK_LSB         0
+   #define  Si2158_ATV_STATUS_CMD_INTACK_MASK        0x01
+   #define  Si2158_ATV_STATUS_CMD_INTACK_MIN         0
+   #define  Si2158_ATV_STATUS_CMD_INTACK_MAX         1
+    #define Si2158_ATV_STATUS_CMD_INTACK_CLEAR  1
+    #define Si2158_ATV_STATUS_CMD_INTACK_OK     0
+   /* ATV_STATUS command, CHLINT field definition (address 1, size 1, lsb 0, unsigned)*/
+   #define  Si2158_ATV_STATUS_RESPONSE_CHLINT_LSB         0
+   #define  Si2158_ATV_STATUS_RESPONSE_CHLINT_MASK        0x01
+    #define Si2158_ATV_STATUS_RESPONSE_CHLINT_CHANGED    1
+    #define Si2158_ATV_STATUS_RESPONSE_CHLINT_NO_CHANGE  0
+   /* ATV_STATUS command, PCLINT field definition (address 1, size 1, lsb 1, unsigned)*/
+   #define  Si2158_ATV_STATUS_RESPONSE_PCLINT_LSB         1
+   #define  Si2158_ATV_STATUS_RESPONSE_PCLINT_MASK        0x01
+    #define Si2158_ATV_STATUS_RESPONSE_PCLINT_CHANGED    1
+    #define Si2158_ATV_STATUS_RESPONSE_PCLINT_NO_CHANGE  0
+   /* ATV_STATUS command, CHL field definition (address 2, size 1, lsb 0, unsigned)*/
+   #define  Si2158_ATV_STATUS_RESPONSE_CHL_LSB         0
+   #define  Si2158_ATV_STATUS_RESPONSE_CHL_MASK        0x01
+    #define Si2158_ATV_STATUS_RESPONSE_CHL_CHANNEL     1
+    #define Si2158_ATV_STATUS_RESPONSE_CHL_NO_CHANNEL  0
+   /* ATV_STATUS command, PCL field definition (address 2, size 1, lsb 1, unsigned)*/
+   #define  Si2158_ATV_STATUS_RESPONSE_PCL_LSB         1
+   #define  Si2158_ATV_STATUS_RESPONSE_PCL_MASK        0x01
+    #define Si2158_ATV_STATUS_RESPONSE_PCL_LOCKED   1
+    #define Si2158_ATV_STATUS_RESPONSE_PCL_NO_LOCK  0
+   /* ATV_STATUS command, AFC_FREQ field definition (address 4, size 16, lsb 0, signed)*/
+   #define  Si2158_ATV_STATUS_RESPONSE_AFC_FREQ_LSB         0
+   #define  Si2158_ATV_STATUS_RESPONSE_AFC_FREQ_MASK        0xffff
+   #define  Si2158_ATV_STATUS_RESPONSE_AFC_FREQ_SHIFT       16
+   /* ATV_STATUS command, VIDEO_SYS field definition (address 8, size 3, lsb 0, unsigned)*/
+   #define  Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_LSB         0
+   #define  Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_MASK        0x07
+    #define Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_B   0
+    #define Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_DK  5
+    #define Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_GH  1
+    #define Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_I   4
+    #define Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_L   6
+    #define Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_LP  7
+    #define Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_M   2
+    #define Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_N   3
+   /* ATV_STATUS command, COLOR field definition (address 8, size 1, lsb 4, unsigned)*/
+   #define  Si2158_ATV_STATUS_RESPONSE_COLOR_LSB         4
+   #define  Si2158_ATV_STATUS_RESPONSE_COLOR_MASK        0x01
+    #define Si2158_ATV_STATUS_RESPONSE_COLOR_PAL_NTSC  0
+    #define Si2158_ATV_STATUS_RESPONSE_COLOR_SECAM     1
+
+#endif /* Si2158_ATV_STATUS_CMD */
+
+/* Si2158_CONFIG_CLOCKS command definition */
+#define   Si2158_CONFIG_CLOCKS_CMD 0xc0
+
+#ifdef    Si2158_CONFIG_CLOCKS_CMD
+  #define Si2158_CONFIG_CLOCKS_CMD_CODE 0x0100c0
+
+    typedef struct { /* Si2158_CONFIG_CLOCKS_CMD_struct */
+     unsigned char   subcode;
+     unsigned char   clock_mode;
+     unsigned char   en_xout;
+   } Si2158_CONFIG_CLOCKS_CMD_struct;
+
+
+    typedef struct { /* Si2158_CONFIG_CLOCKS_CMD_REPLY_struct */
+       Si2158_COMMON_REPLY_struct * STATUS;
+   }  Si2158_CONFIG_CLOCKS_CMD_REPLY_struct;
+
+   /* CONFIG_CLOCKS command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  Si2158_CONFIG_CLOCKS_CMD_SUBCODE_LSB         0
+   #define  Si2158_CONFIG_CLOCKS_CMD_SUBCODE_MASK        0xff
+   #define  Si2158_CONFIG_CLOCKS_CMD_SUBCODE_MIN         0
+   #define  Si2158_CONFIG_CLOCKS_CMD_SUBCODE_MAX         0
+    #define Si2158_CONFIG_CLOCKS_CMD_SUBCODE_CODE  0
+   /* CONFIG_CLOCKS command, CLOCK_MODE field definition (address 2,size 2, lsb 0, unsigned) */
+   #define  Si2158_CONFIG_CLOCKS_CMD_CLOCK_MODE_LSB         0
+   #define  Si2158_CONFIG_CLOCKS_CMD_CLOCK_MODE_MASK        0x03
+   #define  Si2158_CONFIG_CLOCKS_CMD_CLOCK_MODE_MIN         0
+   #define  Si2158_CONFIG_CLOCKS_CMD_CLOCK_MODE_MAX         2
+    #define Si2158_CONFIG_CLOCKS_CMD_CLOCK_MODE_EXTCLK  2
+    #define Si2158_CONFIG_CLOCKS_CMD_CLOCK_MODE_XTAL    0
+   /* CONFIG_CLOCKS command, EN_XOUT field definition (address 2,size 3, lsb 2, unsigned) */
+   #define  Si2158_CONFIG_CLOCKS_CMD_EN_XOUT_LSB         2
+   #define  Si2158_CONFIG_CLOCKS_CMD_EN_XOUT_MASK        0x07
+   #define  Si2158_CONFIG_CLOCKS_CMD_EN_XOUT_MIN         0
+   #define  Si2158_CONFIG_CLOCKS_CMD_EN_XOUT_MAX         3
+    #define Si2158_CONFIG_CLOCKS_CMD_EN_XOUT_DIS_XOUT  0
+    #define Si2158_CONFIG_CLOCKS_CMD_EN_XOUT_EN_XOUT   3
+#endif /* Si2158_CONFIG_CLOCKS_CMD */
+
+/* Si2158_CONFIG_PINS command definition */
+#define   Si2158_CONFIG_PINS_CMD 0x12
+
+#ifdef    Si2158_CONFIG_PINS_CMD
+  #define Si2158_CONFIG_PINS_CMD_CODE 0x010012
+
+    typedef struct { /* Si2158_CONFIG_PINS_CMD_struct */
+     unsigned char   gpio1_mode;
+     unsigned char   gpio1_read;
+     unsigned char   gpio2_mode;
+     unsigned char   gpio2_read;
+     unsigned char   reserved1;
+     unsigned char   reserved2;
+     unsigned char   reserved3;
+   } Si2158_CONFIG_PINS_CMD_struct;
+
+
+    typedef struct { /* Si2158_CONFIG_PINS_CMD_REPLY_struct */
+       Si2158_COMMON_REPLY_struct * STATUS;
+      unsigned char   gpio1_mode;
+      unsigned char   gpio1_state;
+      unsigned char   gpio2_mode;
+      unsigned char   gpio2_state;
+      unsigned char   reserved1;
+      unsigned char   reserved2;
+      unsigned char   reserved3;
+   }  Si2158_CONFIG_PINS_CMD_REPLY_struct;
+
+   /* CONFIG_PINS command, GPIO1_MODE field definition (address 1,size 7, lsb 0, unsigned) */
+   #define  Si2158_CONFIG_PINS_CMD_GPIO1_MODE_LSB         0
+   #define  Si2158_CONFIG_PINS_CMD_GPIO1_MODE_MASK        0x7f
+   #define  Si2158_CONFIG_PINS_CMD_GPIO1_MODE_MIN         0
+   #define  Si2158_CONFIG_PINS_CMD_GPIO1_MODE_MAX         3
+    #define Si2158_CONFIG_PINS_CMD_GPIO1_MODE_DISABLE    1
+    #define Si2158_CONFIG_PINS_CMD_GPIO1_MODE_DRIVE_0    2
+    #define Si2158_CONFIG_PINS_CMD_GPIO1_MODE_DRIVE_1    3
+    #define Si2158_CONFIG_PINS_CMD_GPIO1_MODE_NO_CHANGE  0
+   /* CONFIG_PINS command, GPIO1_READ field definition (address 1,size 1, lsb 7, unsigned) */
+   #define  Si2158_CONFIG_PINS_CMD_GPIO1_READ_LSB         7
+   #define  Si2158_CONFIG_PINS_CMD_GPIO1_READ_MASK        0x01
+   #define  Si2158_CONFIG_PINS_CMD_GPIO1_READ_MIN         0
+   #define  Si2158_CONFIG_PINS_CMD_GPIO1_READ_MAX         1
+    #define Si2158_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ  0
+    #define Si2158_CONFIG_PINS_CMD_GPIO1_READ_READ         1
+   /* CONFIG_PINS command, GPIO2_MODE field definition (address 2,size 7, lsb 0, unsigned) */
+   #define  Si2158_CONFIG_PINS_CMD_GPIO2_MODE_LSB         0
+   #define  Si2158_CONFIG_PINS_CMD_GPIO2_MODE_MASK        0x7f
+   #define  Si2158_CONFIG_PINS_CMD_GPIO2_MODE_MIN         0
+   #define  Si2158_CONFIG_PINS_CMD_GPIO2_MODE_MAX         3
+    #define Si2158_CONFIG_PINS_CMD_GPIO2_MODE_DISABLE    1
+    #define Si2158_CONFIG_PINS_CMD_GPIO2_MODE_DRIVE_0    2
+    #define Si2158_CONFIG_PINS_CMD_GPIO2_MODE_DRIVE_1    3
+    #define Si2158_CONFIG_PINS_CMD_GPIO2_MODE_NO_CHANGE  0
+   /* CONFIG_PINS command, GPIO2_READ field definition (address 2,size 1, lsb 7, unsigned) */
+   #define  Si2158_CONFIG_PINS_CMD_GPIO2_READ_LSB         7
+   #define  Si2158_CONFIG_PINS_CMD_GPIO2_READ_MASK        0x01
+   #define  Si2158_CONFIG_PINS_CMD_GPIO2_READ_MIN         0
+   #define  Si2158_CONFIG_PINS_CMD_GPIO2_READ_MAX         1
+    #define Si2158_CONFIG_PINS_CMD_GPIO2_READ_DO_NOT_READ  0
+    #define Si2158_CONFIG_PINS_CMD_GPIO2_READ_READ         1
+   /* CONFIG_PINS command, RESERVED1 field definition (address 3,size 8, lsb 0, unsigned) */
+   #define  Si2158_CONFIG_PINS_CMD_RESERVED1_LSB         0
+   #define  Si2158_CONFIG_PINS_CMD_RESERVED1_MASK        0xff
+   #define  Si2158_CONFIG_PINS_CMD_RESERVED1_MIN         1
+   #define  Si2158_CONFIG_PINS_CMD_RESERVED1_MAX         1
+    #define Si2158_CONFIG_PINS_CMD_RESERVED1_RESERVED  1
+   /* CONFIG_PINS command, RESERVED2 field definition (address 4,size 8, lsb 0, unsigned) */
+   #define  Si2158_CONFIG_PINS_CMD_RESERVED2_LSB         0
+   #define  Si2158_CONFIG_PINS_CMD_RESERVED2_MASK        0xff
+   #define  Si2158_CONFIG_PINS_CMD_RESERVED2_MIN         1
+   #define  Si2158_CONFIG_PINS_CMD_RESERVED2_MAX         1
+    #define Si2158_CONFIG_PINS_CMD_RESERVED2_RESERVED  1
+   /* CONFIG_PINS command, RESERVED3 field definition (address 5,size 8, lsb 0, unsigned) */
+   #define  Si2158_CONFIG_PINS_CMD_RESERVED3_LSB         0
+   #define  Si2158_CONFIG_PINS_CMD_RESERVED3_MASK        0xff
+   #define  Si2158_CONFIG_PINS_CMD_RESERVED3_MIN         1
+   #define  Si2158_CONFIG_PINS_CMD_RESERVED3_MAX         1
+    #define Si2158_CONFIG_PINS_CMD_RESERVED3_RESERVED  1
+   /* CONFIG_PINS command, GPIO1_MODE field definition (address 1, size 7, lsb 0, unsigned)*/
+   #define  Si2158_CONFIG_PINS_RESPONSE_GPIO1_MODE_LSB         0
+   #define  Si2158_CONFIG_PINS_RESPONSE_GPIO1_MODE_MASK        0x7f
+    #define Si2158_CONFIG_PINS_RESPONSE_GPIO1_MODE_DISABLE  1
+    #define Si2158_CONFIG_PINS_RESPONSE_GPIO1_MODE_DRIVE_0  2
+    #define Si2158_CONFIG_PINS_RESPONSE_GPIO1_MODE_DRIVE_1  3
+   /* CONFIG_PINS command, GPIO1_STATE field definition (address 1, size 1, lsb 7, unsigned)*/
+   #define  Si2158_CONFIG_PINS_RESPONSE_GPIO1_STATE_LSB         7
+   #define  Si2158_CONFIG_PINS_RESPONSE_GPIO1_STATE_MASK        0x01
+    #define Si2158_CONFIG_PINS_RESPONSE_GPIO1_STATE_READ_0  0
+    #define Si2158_CONFIG_PINS_RESPONSE_GPIO1_STATE_READ_1  1
+   /* CONFIG_PINS command, GPIO2_MODE field definition (address 2, size 7, lsb 0, unsigned)*/
+   #define  Si2158_CONFIG_PINS_RESPONSE_GPIO2_MODE_LSB         0
+   #define  Si2158_CONFIG_PINS_RESPONSE_GPIO2_MODE_MASK        0x7f
+    #define Si2158_CONFIG_PINS_RESPONSE_GPIO2_MODE_DISABLE  1
+    #define Si2158_CONFIG_PINS_RESPONSE_GPIO2_MODE_DRIVE_0  2
+    #define Si2158_CONFIG_PINS_RESPONSE_GPIO2_MODE_DRIVE_1  3
+   /* CONFIG_PINS command, GPIO2_STATE field definition (address 2, size 1, lsb 7, unsigned)*/
+   #define  Si2158_CONFIG_PINS_RESPONSE_GPIO2_STATE_LSB         7
+   #define  Si2158_CONFIG_PINS_RESPONSE_GPIO2_STATE_MASK        0x01
+    #define Si2158_CONFIG_PINS_RESPONSE_GPIO2_STATE_READ_0  0
+    #define Si2158_CONFIG_PINS_RESPONSE_GPIO2_STATE_READ_1  1
+   /* CONFIG_PINS command, RESERVED1 field definition (address 3, size 8, lsb 0, unsigned)*/
+   #define  Si2158_CONFIG_PINS_RESPONSE_RESERVED1_LSB         0
+   #define  Si2158_CONFIG_PINS_RESPONSE_RESERVED1_MASK        0xff
+    #define Si2158_CONFIG_PINS_RESPONSE_RESERVED1_RESERVED1_MIN  1
+    #define Si2158_CONFIG_PINS_RESPONSE_RESERVED1_RESERVED1_MAX  1
+   /* CONFIG_PINS command, RESERVED2 field definition (address 4, size 8, lsb 0, unsigned)*/
+   #define  Si2158_CONFIG_PINS_RESPONSE_RESERVED2_LSB         0
+   #define  Si2158_CONFIG_PINS_RESPONSE_RESERVED2_MASK        0xff
+    #define Si2158_CONFIG_PINS_RESPONSE_RESERVED2_RESERVED2_MIN  1
+    #define Si2158_CONFIG_PINS_RESPONSE_RESERVED2_RESERVED2_MAX  1
+   /* CONFIG_PINS command, RESERVED3 field definition (address 5, size 8, lsb 0, unsigned)*/
+   #define  Si2158_CONFIG_PINS_RESPONSE_RESERVED3_LSB         0
+   #define  Si2158_CONFIG_PINS_RESPONSE_RESERVED3_MASK        0xff
+    #define Si2158_CONFIG_PINS_RESPONSE_RESERVED3_RESERVED3_MIN  1
+    #define Si2158_CONFIG_PINS_RESPONSE_RESERVED3_RESERVED3_MAX  1
+
+#endif /* Si2158_CONFIG_PINS_CMD */
+
+/* Si2158_DTV_RESTART command definition */
+#define   Si2158_DTV_RESTART_CMD 0x61
+
+#ifdef    Si2158_DTV_RESTART_CMD
+  #define Si2158_DTV_RESTART_CMD_CODE 0x010061
+
+    typedef struct { /* Si2158_DTV_RESTART_CMD_struct */
+         unsigned char   nothing;   } Si2158_DTV_RESTART_CMD_struct;
+
+
+    typedef struct { /* Si2158_DTV_RESTART_CMD_REPLY_struct */
+       Si2158_COMMON_REPLY_struct * STATUS;
+   }  Si2158_DTV_RESTART_CMD_REPLY_struct;
+
+#endif /* Si2158_DTV_RESTART_CMD */
+
+/* Si2158_DTV_STATUS command definition */
+#define   Si2158_DTV_STATUS_CMD 0x62
+
+#ifdef    Si2158_DTV_STATUS_CMD
+  #define Si2158_DTV_STATUS_CMD_CODE 0x010062
+
+    typedef struct { /* Si2158_DTV_STATUS_CMD_struct */
+     unsigned char   intack;
+   } Si2158_DTV_STATUS_CMD_struct;
+
+
+    typedef struct { /* Si2158_DTV_STATUS_CMD_REPLY_struct */
+       Si2158_COMMON_REPLY_struct * STATUS;
+      unsigned char   chlint;
+      unsigned char   chl;
+      unsigned char   bw;
+      unsigned char   modulation;
+   }  Si2158_DTV_STATUS_CMD_REPLY_struct;
+
+   /* DTV_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2158_DTV_STATUS_CMD_INTACK_LSB         0
+   #define  Si2158_DTV_STATUS_CMD_INTACK_MASK        0x01
+   #define  Si2158_DTV_STATUS_CMD_INTACK_MIN         0
+   #define  Si2158_DTV_STATUS_CMD_INTACK_MAX         1
+    #define Si2158_DTV_STATUS_CMD_INTACK_CLEAR  1
+    #define Si2158_DTV_STATUS_CMD_INTACK_OK     0
+   /* DTV_STATUS command, CHLINT field definition (address 1, size 1, lsb 0, unsigned)*/
+   #define  Si2158_DTV_STATUS_RESPONSE_CHLINT_LSB         0
+   #define  Si2158_DTV_STATUS_RESPONSE_CHLINT_MASK        0x01
+    #define Si2158_DTV_STATUS_RESPONSE_CHLINT_CHANGED    1
+    #define Si2158_DTV_STATUS_RESPONSE_CHLINT_NO_CHANGE  0
+   /* DTV_STATUS command, CHL field definition (address 2, size 1, lsb 0, unsigned)*/
+   #define  Si2158_DTV_STATUS_RESPONSE_CHL_LSB         0
+   #define  Si2158_DTV_STATUS_RESPONSE_CHL_MASK        0x01
+    #define Si2158_DTV_STATUS_RESPONSE_CHL_CHANNEL     1
+    #define Si2158_DTV_STATUS_RESPONSE_CHL_NO_CHANNEL  0
+   /* DTV_STATUS command, BW field definition (address 3, size 4, lsb 0, unsigned)*/
+   #define  Si2158_DTV_STATUS_RESPONSE_BW_LSB         0
+   #define  Si2158_DTV_STATUS_RESPONSE_BW_MASK        0x0f
+    #define Si2158_DTV_STATUS_RESPONSE_BW_BW_6MHZ  6
+    #define Si2158_DTV_STATUS_RESPONSE_BW_BW_7MHZ  7
+    #define Si2158_DTV_STATUS_RESPONSE_BW_BW_8MHZ  8
+   /* DTV_STATUS command, MODULATION field definition (address 3, size 4, lsb 4, unsigned)*/
+   #define  Si2158_DTV_STATUS_RESPONSE_MODULATION_LSB         4
+   #define  Si2158_DTV_STATUS_RESPONSE_MODULATION_MASK        0x0f
+    #define Si2158_DTV_STATUS_RESPONSE_MODULATION_ATSC    0
+    #define Si2158_DTV_STATUS_RESPONSE_MODULATION_DTMB    6
+    #define Si2158_DTV_STATUS_RESPONSE_MODULATION_DVBC    3
+    #define Si2158_DTV_STATUS_RESPONSE_MODULATION_DVBT    2
+    #define Si2158_DTV_STATUS_RESPONSE_MODULATION_ISDBC   5
+    #define Si2158_DTV_STATUS_RESPONSE_MODULATION_ISDBT   4
+    #define Si2158_DTV_STATUS_RESPONSE_MODULATION_QAM_US  1
+
+#endif /* Si2158_DTV_STATUS_CMD */
+
+/* Si2158_EXIT_BOOTLOADER command definition */
+#define   Si2158_EXIT_BOOTLOADER_CMD 0x01
+
+#ifdef    Si2158_EXIT_BOOTLOADER_CMD
+  #define Si2158_EXIT_BOOTLOADER_CMD_CODE 0x010001
+
+    typedef struct { /* Si2158_EXIT_BOOTLOADER_CMD_struct */
+     unsigned char   func;
+     unsigned char   ctsien;
+   } Si2158_EXIT_BOOTLOADER_CMD_struct;
+
+
+    typedef struct { /* Si2158_EXIT_BOOTLOADER_CMD_REPLY_struct */
+       Si2158_COMMON_REPLY_struct * STATUS;
+   }  Si2158_EXIT_BOOTLOADER_CMD_REPLY_struct;
+
+   /* EXIT_BOOTLOADER command, FUNC field definition (address 1,size 4, lsb 0, unsigned) */
+   #define  Si2158_EXIT_BOOTLOADER_CMD_FUNC_LSB         0
+   #define  Si2158_EXIT_BOOTLOADER_CMD_FUNC_MASK        0x0f
+   #define  Si2158_EXIT_BOOTLOADER_CMD_FUNC_MIN         0
+   #define  Si2158_EXIT_BOOTLOADER_CMD_FUNC_MAX         1
+    #define Si2158_EXIT_BOOTLOADER_CMD_FUNC_BOOTLOADER  0
+    #define Si2158_EXIT_BOOTLOADER_CMD_FUNC_TUNER       1
+   /* EXIT_BOOTLOADER command, CTSIEN field definition (address 1,size 1, lsb 7, unsigned) */
+   #define  Si2158_EXIT_BOOTLOADER_CMD_CTSIEN_LSB         7
+   #define  Si2158_EXIT_BOOTLOADER_CMD_CTSIEN_MASK        0x01
+   #define  Si2158_EXIT_BOOTLOADER_CMD_CTSIEN_MIN         0
+   #define  Si2158_EXIT_BOOTLOADER_CMD_CTSIEN_MAX         1
+    #define Si2158_EXIT_BOOTLOADER_CMD_CTSIEN_OFF  0
+    #define Si2158_EXIT_BOOTLOADER_CMD_CTSIEN_ON   1
+#endif /* Si2158_EXIT_BOOTLOADER_CMD */
+
+/* Si2158_FINE_TUNE command definition */
+#define   Si2158_FINE_TUNE_CMD 0x45
+
+#ifdef    Si2158_FINE_TUNE_CMD
+  #define Si2158_FINE_TUNE_CMD_CODE 0x010045
+
+    typedef struct { /* Si2158_FINE_TUNE_CMD_struct */
+     unsigned char   persistence;
+     unsigned char   apply_to_lif;
+              int    offset_500hz;
+   } Si2158_FINE_TUNE_CMD_struct;
+
+
+    typedef struct { /* Si2158_FINE_TUNE_CMD_REPLY_struct */
+       Si2158_COMMON_REPLY_struct * STATUS;
+   }  Si2158_FINE_TUNE_CMD_REPLY_struct;
+
+   /* FINE_TUNE command, PERSISTENCE field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2158_FINE_TUNE_CMD_PERSISTENCE_LSB         0
+   #define  Si2158_FINE_TUNE_CMD_PERSISTENCE_MASK        0x01
+   #define  Si2158_FINE_TUNE_CMD_PERSISTENCE_MIN         0
+   #define  Si2158_FINE_TUNE_CMD_PERSISTENCE_MAX         1
+    #define Si2158_FINE_TUNE_CMD_PERSISTENCE_NON_PERSISTENT  0
+    #define Si2158_FINE_TUNE_CMD_PERSISTENCE_PERSISTENT      1
+   /* FINE_TUNE command, APPLY_TO_LIF field definition (address 1,size 1, lsb 1, unsigned) */
+   #define  Si2158_FINE_TUNE_CMD_APPLY_TO_LIF_LSB         1
+   #define  Si2158_FINE_TUNE_CMD_APPLY_TO_LIF_MASK        0x01
+   #define  Si2158_FINE_TUNE_CMD_APPLY_TO_LIF_MIN         0
+   #define  Si2158_FINE_TUNE_CMD_APPLY_TO_LIF_MAX         1
+    #define Si2158_FINE_TUNE_CMD_APPLY_TO_LIF_APPLY_TO_LIF         1
+    #define Si2158_FINE_TUNE_CMD_APPLY_TO_LIF_DO_NOT_APPLY_TO_LIF  0
+   /* FINE_TUNE command, OFFSET_500HZ field definition (address 2,size 16, lsb 0, signed) */
+   #define  Si2158_FINE_TUNE_CMD_OFFSET_500HZ_LSB         0
+   #define  Si2158_FINE_TUNE_CMD_OFFSET_500HZ_MASK        0xffff
+   #define  Si2158_FINE_TUNE_CMD_OFFSET_500HZ_SHIFT       16
+   #define  Si2158_FINE_TUNE_CMD_OFFSET_500HZ_MIN         -4000
+   #define  Si2158_FINE_TUNE_CMD_OFFSET_500HZ_MAX         4000
+    #define Si2158_FINE_TUNE_CMD_OFFSET_500HZ_OFFSET_500HZ_MIN  -4000
+    #define Si2158_FINE_TUNE_CMD_OFFSET_500HZ_OFFSET_500HZ_MAX  4000
+#endif /* Si2158_FINE_TUNE_CMD */
+
+/* Si2158_GET_PROPERTY command definition */
+#define   Si2158_GET_PROPERTY_CMD 0x15
+
+#ifdef    Si2158_GET_PROPERTY_CMD
+  #define Si2158_GET_PROPERTY_CMD_CODE 0x010015
+
+    typedef struct { /* Si2158_GET_PROPERTY_CMD_struct */
+     unsigned char   reserved;
+     unsigned int    prop;
+   } Si2158_GET_PROPERTY_CMD_struct;
+
+
+    typedef struct { /* Si2158_GET_PROPERTY_CMD_REPLY_struct */
+       Si2158_COMMON_REPLY_struct * STATUS;
+      unsigned char   reserved;
+      unsigned int    data;
+   }  Si2158_GET_PROPERTY_CMD_REPLY_struct;
+
+   /* GET_PROPERTY command, RESERVED field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  Si2158_GET_PROPERTY_CMD_RESERVED_LSB         0
+   #define  Si2158_GET_PROPERTY_CMD_RESERVED_MASK        0xff
+   #define  Si2158_GET_PROPERTY_CMD_RESERVED_MIN         0
+   #define  Si2158_GET_PROPERTY_CMD_RESERVED_MAX         0
+    #define Si2158_GET_PROPERTY_CMD_RESERVED_RESERVED_MIN  0
+    #define Si2158_GET_PROPERTY_CMD_RESERVED_RESERVED_MAX  0
+   /* GET_PROPERTY command, PROP field definition (address 2,size 16, lsb 0, unsigned) */
+   #define  Si2158_GET_PROPERTY_CMD_PROP_LSB         0
+   #define  Si2158_GET_PROPERTY_CMD_PROP_MASK        0xffff
+   #define  Si2158_GET_PROPERTY_CMD_PROP_MIN         0
+   #define  Si2158_GET_PROPERTY_CMD_PROP_MAX         65535
+    #define Si2158_GET_PROPERTY_CMD_PROP_PROP_MIN  0
+    #define Si2158_GET_PROPERTY_CMD_PROP_PROP_MAX  65535
+   /* GET_PROPERTY command, RESERVED field definition (address 1, size 8, lsb 0, unsigned)*/
+   #define  Si2158_GET_PROPERTY_RESPONSE_RESERVED_LSB         0
+   #define  Si2158_GET_PROPERTY_RESPONSE_RESERVED_MASK        0xff
+   /* GET_PROPERTY command, DATA field definition (address 2, size 16, lsb 0, unsigned)*/
+   #define  Si2158_GET_PROPERTY_RESPONSE_DATA_LSB         0
+   #define  Si2158_GET_PROPERTY_RESPONSE_DATA_MASK        0xffff
+
+#endif /* Si2158_GET_PROPERTY_CMD */
+
+/* Si2158_GET_REV command definition */
+#define   Si2158_GET_REV_CMD 0x11
+
+#ifdef    Si2158_GET_REV_CMD
+  #define Si2158_GET_REV_CMD_CODE 0x010011
+
+    typedef struct { /* Si2158_GET_REV_CMD_struct */
+         unsigned char   nothing;   } Si2158_GET_REV_CMD_struct;
+
+
+    typedef struct { /* Si2158_GET_REV_CMD_REPLY_struct */
+       Si2158_COMMON_REPLY_struct * STATUS;
+      unsigned char   pn;
+      unsigned char   fwmajor;
+      unsigned char   fwminor;
+      unsigned int    patch;
+      unsigned char   cmpmajor;
+      unsigned char   cmpminor;
+      unsigned char   cmpbuild;
+      unsigned char   chiprev;
+   }  Si2158_GET_REV_CMD_REPLY_struct;
+
+   /* GET_REV command, PN field definition (address 1, size 8, lsb 0, unsigned)*/
+   #define  Si2158_GET_REV_RESPONSE_PN_LSB         0
+   #define  Si2158_GET_REV_RESPONSE_PN_MASK        0xff
+   /* GET_REV command, FWMAJOR field definition (address 2, size 8, lsb 0, unsigned)*/
+   #define  Si2158_GET_REV_RESPONSE_FWMAJOR_LSB         0
+   #define  Si2158_GET_REV_RESPONSE_FWMAJOR_MASK        0xff
+   /* GET_REV command, FWMINOR field definition (address 3, size 8, lsb 0, unsigned)*/
+   #define  Si2158_GET_REV_RESPONSE_FWMINOR_LSB         0
+   #define  Si2158_GET_REV_RESPONSE_FWMINOR_MASK        0xff
+   /* GET_REV command, PATCH field definition (address 4, size 16, lsb 0, unsigned)*/
+   #define  Si2158_GET_REV_RESPONSE_PATCH_LSB         0
+   #define  Si2158_GET_REV_RESPONSE_PATCH_MASK        0xffff
+   /* GET_REV command, CMPMAJOR field definition (address 6, size 8, lsb 0, unsigned)*/
+   #define  Si2158_GET_REV_RESPONSE_CMPMAJOR_LSB         0
+   #define  Si2158_GET_REV_RESPONSE_CMPMAJOR_MASK        0xff
+   /* GET_REV command, CMPMINOR field definition (address 7, size 8, lsb 0, unsigned)*/
+   #define  Si2158_GET_REV_RESPONSE_CMPMINOR_LSB         0
+   #define  Si2158_GET_REV_RESPONSE_CMPMINOR_MASK        0xff
+   /* GET_REV command, CMPBUILD field definition (address 8, size 8, lsb 0, unsigned)*/
+   #define  Si2158_GET_REV_RESPONSE_CMPBUILD_LSB         0
+   #define  Si2158_GET_REV_RESPONSE_CMPBUILD_MASK        0xff
+    #define Si2158_GET_REV_RESPONSE_CMPBUILD_CMPBUILD_MIN  0
+    #define Si2158_GET_REV_RESPONSE_CMPBUILD_CMPBUILD_MAX  255
+   /* GET_REV command, CHIPREV field definition (address 9, size 4, lsb 0, unsigned)*/
+   #define  Si2158_GET_REV_RESPONSE_CHIPREV_LSB         0
+   #define  Si2158_GET_REV_RESPONSE_CHIPREV_MASK        0x0f
+    #define Si2158_GET_REV_RESPONSE_CHIPREV_A  1
+    #define Si2158_GET_REV_RESPONSE_CHIPREV_B  2
+
+#endif /* Si2158_GET_REV_CMD */
+
+/* Si2158_PART_INFO command definition */
+#define   Si2158_PART_INFO_CMD 0x02
+
+#ifdef    Si2158_PART_INFO_CMD
+  #define Si2158_PART_INFO_CMD_CODE 0x010002
+
+    typedef struct { /* Si2158_PART_INFO_CMD_struct */
+         unsigned char   nothing;   } Si2158_PART_INFO_CMD_struct;
+
+
+    typedef struct { /* Si2158_PART_INFO_CMD_REPLY_struct */
+       Si2158_COMMON_REPLY_struct * STATUS;
+      unsigned char   chiprev;
+      unsigned char   romid;
+      unsigned char   part;
+      unsigned char   pmajor;
+      unsigned char   pminor;
+      unsigned char   pbuild;
+      unsigned int    reserved;
+      unsigned long   serial;
+   }  Si2158_PART_INFO_CMD_REPLY_struct;
+
+   /* PART_INFO command, CHIPREV field definition (address 1, size 4, lsb 0, unsigned)*/
+   #define  Si2158_PART_INFO_RESPONSE_CHIPREV_LSB         0
+   #define  Si2158_PART_INFO_RESPONSE_CHIPREV_MASK        0x0f
+    #define Si2158_PART_INFO_RESPONSE_CHIPREV_A  1
+    #define Si2158_PART_INFO_RESPONSE_CHIPREV_B  2
+   /* PART_INFO command, ROMID field definition (address 12, size 8, lsb 0, unsigned)*/
+   #define  Si2158_PART_INFO_RESPONSE_ROMID_LSB         0
+   #define  Si2158_PART_INFO_RESPONSE_ROMID_MASK        0xff
+   /* PART_INFO command, PART field definition (address 2, size 8, lsb 0, unsigned)*/
+   #define  Si2158_PART_INFO_RESPONSE_PART_LSB         0
+   #define  Si2158_PART_INFO_RESPONSE_PART_MASK        0xff
+   /* PART_INFO command, PMAJOR field definition (address 3, size 8, lsb 0, unsigned)*/
+   #define  Si2158_PART_INFO_RESPONSE_PMAJOR_LSB         0
+   #define  Si2158_PART_INFO_RESPONSE_PMAJOR_MASK        0xff
+   /* PART_INFO command, PMINOR field definition (address 4, size 8, lsb 0, unsigned)*/
+   #define  Si2158_PART_INFO_RESPONSE_PMINOR_LSB         0
+   #define  Si2158_PART_INFO_RESPONSE_PMINOR_MASK        0xff
+   /* PART_INFO command, PBUILD field definition (address 5, size 8, lsb 0, unsigned)*/
+   #define  Si2158_PART_INFO_RESPONSE_PBUILD_LSB         0
+   #define  Si2158_PART_INFO_RESPONSE_PBUILD_MASK        0xff
+   /* PART_INFO command, RESERVED field definition (address 6, size 16, lsb 0, unsigned)*/
+   #define  Si2158_PART_INFO_RESPONSE_RESERVED_LSB         0
+   #define  Si2158_PART_INFO_RESPONSE_RESERVED_MASK        0xffff
+   /* PART_INFO command, SERIAL field definition (address 8, size 32, lsb 0, unsigned)*/
+   #define  Si2158_PART_INFO_RESPONSE_SERIAL_LSB         0
+   #define  Si2158_PART_INFO_RESPONSE_SERIAL_MASK        0xffffffff
+
+#endif /* Si2158_PART_INFO_CMD */
+
+/* Si2158_POWER_DOWN command definition */
+#define   Si2158_POWER_DOWN_CMD 0x13
+
+#ifdef    Si2158_POWER_DOWN_CMD
+  #define Si2158_POWER_DOWN_CMD_CODE 0x010013
+
+    typedef struct { /* Si2158_POWER_DOWN_CMD_struct */
+         unsigned char   nothing;   } Si2158_POWER_DOWN_CMD_struct;
+
+
+    typedef struct { /* Si2158_POWER_DOWN_CMD_REPLY_struct */
+       Si2158_COMMON_REPLY_struct * STATUS;
+   }  Si2158_POWER_DOWN_CMD_REPLY_struct;
+
+#endif /* Si2158_POWER_DOWN_CMD */
+
+/* Si2158_POWER_DOWN_HW command definition */
+#define   Si2158_POWER_DOWN_HW_CMD 0xc0
+
+#ifdef    Si2158_POWER_DOWN_HW_CMD
+  #define Si2158_POWER_DOWN_HW_CMD_CODE 0x0200c0
+
+    typedef struct { /* Si2158_POWER_DOWN_HW_CMD_struct */
+     unsigned char   subcode;
+     unsigned char   pd_xo_osc;
+     unsigned char   reserved1;
+     unsigned char   en_xout;
+     unsigned char   reserved2;
+     unsigned char   pd_ldo;
+     unsigned char   reserved3;
+     unsigned char   reserved4;
+     unsigned char   reserved5;
+     unsigned char   reserved6;
+     unsigned char   reserved7;
+     unsigned char   reserved8;
+   } Si2158_POWER_DOWN_HW_CMD_struct;
+
+
+    typedef struct { /* Si2158_POWER_DOWN_HW_CMD_REPLY_struct */
+       Si2158_COMMON_REPLY_struct * STATUS;
+   }  Si2158_POWER_DOWN_HW_CMD_REPLY_struct;
+
+   /* POWER_DOWN_HW command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  Si2158_POWER_DOWN_HW_CMD_SUBCODE_LSB         0
+   #define  Si2158_POWER_DOWN_HW_CMD_SUBCODE_MASK        0xff
+   #define  Si2158_POWER_DOWN_HW_CMD_SUBCODE_MIN         0
+   #define  Si2158_POWER_DOWN_HW_CMD_SUBCODE_MAX         0
+    #define Si2158_POWER_DOWN_HW_CMD_SUBCODE_CODE  0
+   /* POWER_DOWN_HW command, PD_XO_OSC field definition (address 2,size 1, lsb 0, unsigned) */
+   #define  Si2158_POWER_DOWN_HW_CMD_PD_XO_OSC_LSB         0
+   #define  Si2158_POWER_DOWN_HW_CMD_PD_XO_OSC_MASK        0x01
+   #define  Si2158_POWER_DOWN_HW_CMD_PD_XO_OSC_MIN         0
+   #define  Si2158_POWER_DOWN_HW_CMD_PD_XO_OSC_MAX         1
+    #define Si2158_POWER_DOWN_HW_CMD_PD_XO_OSC_XO_OSC_POWER_DOWN  1
+    #define Si2158_POWER_DOWN_HW_CMD_PD_XO_OSC_XO_OSC_POWER_UP    0
+   /* POWER_DOWN_HW command, RESERVED1 field definition (address 2,size 1, lsb 1, unsigned) */
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED1_LSB         1
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED1_MASK        0x01
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED1_MIN         0
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED1_MAX         0
+    #define Si2158_POWER_DOWN_HW_CMD_RESERVED1_RESERVED  0
+   /* POWER_DOWN_HW command, EN_XOUT field definition (address 2,size 3, lsb 2, unsigned) */
+   #define  Si2158_POWER_DOWN_HW_CMD_EN_XOUT_LSB         2
+   #define  Si2158_POWER_DOWN_HW_CMD_EN_XOUT_MASK        0x07
+   #define  Si2158_POWER_DOWN_HW_CMD_EN_XOUT_MIN         0
+   #define  Si2158_POWER_DOWN_HW_CMD_EN_XOUT_MAX         3
+    #define Si2158_POWER_DOWN_HW_CMD_EN_XOUT_DIS_XOUT  0
+    #define Si2158_POWER_DOWN_HW_CMD_EN_XOUT_EN_XOUT   3
+   /* POWER_DOWN_HW command, RESERVED2 field definition (address 2,size 4, lsb 4, unsigned) */
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED2_LSB         4
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED2_MASK        0x0f
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED2_MIN         1
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED2_MAX         1
+    #define Si2158_POWER_DOWN_HW_CMD_RESERVED2_RESERVED  1
+   /* POWER_DOWN_HW command, PD_LDO field definition (address 3,size 1, lsb 0, unsigned) */
+   #define  Si2158_POWER_DOWN_HW_CMD_PD_LDO_LSB         0
+   #define  Si2158_POWER_DOWN_HW_CMD_PD_LDO_MASK        0x01
+   #define  Si2158_POWER_DOWN_HW_CMD_PD_LDO_MIN         0
+   #define  Si2158_POWER_DOWN_HW_CMD_PD_LDO_MAX         1
+    #define Si2158_POWER_DOWN_HW_CMD_PD_LDO_LDO_POWER_DOWN  1
+    #define Si2158_POWER_DOWN_HW_CMD_PD_LDO_LDO_POWER_UP    0
+   /* POWER_DOWN_HW command, RESERVED3 field definition (address 4,size 8, lsb 0, unsigned) */
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED3_LSB         0
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED3_MASK        0xff
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED3_MIN         0
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED3_MAX         0
+    #define Si2158_POWER_DOWN_HW_CMD_RESERVED3_RESERVED  0
+   /* POWER_DOWN_HW command, RESERVED4 field definition (address 5,size 8, lsb 0, unsigned) */
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED4_LSB         0
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED4_MASK        0xff
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED4_MIN         1
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED4_MAX         1
+    #define Si2158_POWER_DOWN_HW_CMD_RESERVED4_RESERVED  1
+   /* POWER_DOWN_HW command, RESERVED5 field definition (address 6,size 8, lsb 0, unsigned) */
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED5_LSB         0
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED5_MASK        0xff
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED5_MIN         0
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED5_MAX         0
+    #define Si2158_POWER_DOWN_HW_CMD_RESERVED5_RESERVED  0
+   /* POWER_DOWN_HW command, RESERVED6 field definition (address 7,size 8, lsb 0, unsigned) */
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED6_LSB         0
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED6_MASK        0xff
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED6_MIN         0
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED6_MAX         0
+    #define Si2158_POWER_DOWN_HW_CMD_RESERVED6_RESERVED  0
+   /* POWER_DOWN_HW command, RESERVED7 field definition (address 8,size 8, lsb 0, unsigned) */
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED7_LSB         0
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED7_MASK        0xff
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED7_MIN         0
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED7_MAX         0
+    #define Si2158_POWER_DOWN_HW_CMD_RESERVED7_RESERVED  0
+   /* POWER_DOWN_HW command, RESERVED8 field definition (address 9,size 8, lsb 0, unsigned) */
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED8_LSB         0
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED8_MASK        0xff
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED8_MIN         0
+   #define  Si2158_POWER_DOWN_HW_CMD_RESERVED8_MAX         0
+    #define Si2158_POWER_DOWN_HW_CMD_RESERVED8_RESERVED  0
+#endif /* Si2158_POWER_DOWN_HW_CMD */
+
+/* Si2158_POWER_UP command definition */
+#define   Si2158_POWER_UP_CMD 0xc0
+
+#ifdef    Si2158_POWER_UP_CMD
+  #define Si2158_POWER_UP_CMD_CODE 0x0300c0
+
+    typedef struct { /* Si2158_POWER_UP_CMD_struct */
+     unsigned char   subcode;
+     unsigned char   clock_mode;
+     unsigned char   en_xout;
+     unsigned char   pd_ldo;
+     unsigned char   reserved2;
+     unsigned char   reserved3;
+     unsigned char   reserved4;
+     unsigned char   reserved5;
+     unsigned char   reserved6;
+     unsigned char   reserved7;
+     unsigned char   reset;
+     unsigned char   clock_freq;
+     unsigned char   reserved8;
+     unsigned char   func;
+     unsigned char   ctsien;
+     unsigned char   wake_up;
+   } Si2158_POWER_UP_CMD_struct;
+
+
+    typedef struct { /* Si2158_POWER_UP_CMD_REPLY_struct */
+       Si2158_COMMON_REPLY_struct * STATUS;
+   }  Si2158_POWER_UP_CMD_REPLY_struct;
+
+   /* POWER_UP command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  Si2158_POWER_UP_CMD_SUBCODE_LSB         0
+   #define  Si2158_POWER_UP_CMD_SUBCODE_MASK        0xff
+   #define  Si2158_POWER_UP_CMD_SUBCODE_MIN         0
+   #define  Si2158_POWER_UP_CMD_SUBCODE_MAX         0
+    #define Si2158_POWER_UP_CMD_SUBCODE_CODE  0
+   /* POWER_UP command, CLOCK_MODE field definition (address 2,size 2, lsb 0, unsigned) */
+   #define  Si2158_POWER_UP_CMD_CLOCK_MODE_LSB         0
+   #define  Si2158_POWER_UP_CMD_CLOCK_MODE_MASK        0x03
+   #define  Si2158_POWER_UP_CMD_CLOCK_MODE_MIN         0
+   #define  Si2158_POWER_UP_CMD_CLOCK_MODE_MAX         2
+    #define Si2158_POWER_UP_CMD_CLOCK_MODE_EXTCLK  2
+    #define Si2158_POWER_UP_CMD_CLOCK_MODE_XTAL    0
+   /* POWER_UP command, EN_XOUT field definition (address 2,size 3, lsb 2, unsigned) */
+   #define  Si2158_POWER_UP_CMD_EN_XOUT_LSB         2
+   #define  Si2158_POWER_UP_CMD_EN_XOUT_MASK        0x07
+   #define  Si2158_POWER_UP_CMD_EN_XOUT_MIN         0
+   #define  Si2158_POWER_UP_CMD_EN_XOUT_MAX         3
+    #define Si2158_POWER_UP_CMD_EN_XOUT_DIS_XOUT  0
+    #define Si2158_POWER_UP_CMD_EN_XOUT_EN_XOUT   3
+   /* POWER_UP command, PD_LDO field definition (address 3,size 1, lsb 0, unsigned) */
+   #define  Si2158_POWER_UP_CMD_PD_LDO_LSB         0
+   #define  Si2158_POWER_UP_CMD_PD_LDO_MASK        0x01
+   #define  Si2158_POWER_UP_CMD_PD_LDO_MIN         0
+   #define  Si2158_POWER_UP_CMD_PD_LDO_MAX         1
+    #define Si2158_POWER_UP_CMD_PD_LDO_LDO_POWER_DOWN  1
+    #define Si2158_POWER_UP_CMD_PD_LDO_LDO_POWER_UP    0
+   /* POWER_UP command, RESERVED2 field definition (address 4,size 8, lsb 0, unsigned) */
+   #define  Si2158_POWER_UP_CMD_RESERVED2_LSB         0
+   #define  Si2158_POWER_UP_CMD_RESERVED2_MASK        0xff
+   #define  Si2158_POWER_UP_CMD_RESERVED2_MIN         0
+   #define  Si2158_POWER_UP_CMD_RESERVED2_MAX         0
+    #define Si2158_POWER_UP_CMD_RESERVED2_RESERVED  0
+   /* POWER_UP command, RESERVED3 field definition (address 5,size 8, lsb 0, unsigned) */
+   #define  Si2158_POWER_UP_CMD_RESERVED3_LSB         0
+   #define  Si2158_POWER_UP_CMD_RESERVED3_MASK        0xff
+   #define  Si2158_POWER_UP_CMD_RESERVED3_MIN         1
+   #define  Si2158_POWER_UP_CMD_RESERVED3_MAX         1
+    #define Si2158_POWER_UP_CMD_RESERVED3_RESERVED  1
+   /* POWER_UP command, RESERVED4 field definition (address 6,size 8, lsb 0, unsigned) */
+   #define  Si2158_POWER_UP_CMD_RESERVED4_LSB         0
+   #define  Si2158_POWER_UP_CMD_RESERVED4_MASK        0xff
+   #define  Si2158_POWER_UP_CMD_RESERVED4_MIN         1
+   #define  Si2158_POWER_UP_CMD_RESERVED4_MAX         1
+    #define Si2158_POWER_UP_CMD_RESERVED4_RESERVED  1
+   /* POWER_UP command, RESERVED5 field definition (address 7,size 8, lsb 0, unsigned) */
+   #define  Si2158_POWER_UP_CMD_RESERVED5_LSB         0
+   #define  Si2158_POWER_UP_CMD_RESERVED5_MASK        0xff
+   #define  Si2158_POWER_UP_CMD_RESERVED5_MIN         1
+   #define  Si2158_POWER_UP_CMD_RESERVED5_MAX         1
+    #define Si2158_POWER_UP_CMD_RESERVED5_RESERVED  1
+   /* POWER_UP command, RESERVED6 field definition (address 8,size 8, lsb 0, unsigned) */
+   #define  Si2158_POWER_UP_CMD_RESERVED6_LSB         0
+   #define  Si2158_POWER_UP_CMD_RESERVED6_MASK        0xff
+   #define  Si2158_POWER_UP_CMD_RESERVED6_MIN         1
+   #define  Si2158_POWER_UP_CMD_RESERVED6_MAX         1
+    #define Si2158_POWER_UP_CMD_RESERVED6_RESERVED  1
+   /* POWER_UP command, RESERVED7 field definition (address 9,size 8, lsb 0, unsigned) */
+   #define  Si2158_POWER_UP_CMD_RESERVED7_LSB         0
+   #define  Si2158_POWER_UP_CMD_RESERVED7_MASK        0xff
+   #define  Si2158_POWER_UP_CMD_RESERVED7_MIN         1
+   #define  Si2158_POWER_UP_CMD_RESERVED7_MAX         1
+    #define Si2158_POWER_UP_CMD_RESERVED7_RESERVED  1
+   /* POWER_UP command, RESET field definition (address 10,size 8, lsb 0, unsigned) */
+   #define  Si2158_POWER_UP_CMD_RESET_LSB         0
+   #define  Si2158_POWER_UP_CMD_RESET_MASK        0xff
+   #define  Si2158_POWER_UP_CMD_RESET_MIN         1
+   #define  Si2158_POWER_UP_CMD_RESET_MAX         1
+    #define Si2158_POWER_UP_CMD_RESET_RESET  1
+   /* POWER_UP command, CLOCK_FREQ field definition (address 11,size 2, lsb 0, unsigned) */
+   #define  Si2158_POWER_UP_CMD_CLOCK_FREQ_LSB         0
+   #define  Si2158_POWER_UP_CMD_CLOCK_FREQ_MASK        0x03
+   #define  Si2158_POWER_UP_CMD_CLOCK_FREQ_MIN         0
+   #define  Si2158_POWER_UP_CMD_CLOCK_FREQ_MAX         3
+    #define Si2158_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ  2
+   /* POWER_UP command, RESERVED8 field definition (address 12,size 8, lsb 0, unsigned) */
+   #define  Si2158_POWER_UP_CMD_RESERVED8_LSB         0
+   #define  Si2158_POWER_UP_CMD_RESERVED8_MASK        0xff
+   #define  Si2158_POWER_UP_CMD_RESERVED8_MIN         0
+   #define  Si2158_POWER_UP_CMD_RESERVED8_MAX         0
+    #define Si2158_POWER_UP_CMD_RESERVED8_RESERVED  0
+   /* POWER_UP command, FUNC field definition (address 13,size 4, lsb 0, unsigned) */
+   #define  Si2158_POWER_UP_CMD_FUNC_LSB         0
+   #define  Si2158_POWER_UP_CMD_FUNC_MASK        0x0f
+   #define  Si2158_POWER_UP_CMD_FUNC_MIN         0
+   #define  Si2158_POWER_UP_CMD_FUNC_MAX         1
+    #define Si2158_POWER_UP_CMD_FUNC_BOOTLOADER  0
+    #define Si2158_POWER_UP_CMD_FUNC_NORMAL      1
+   /* POWER_UP command, CTSIEN field definition (address 13,size 1, lsb 7, unsigned) */
+   #define  Si2158_POWER_UP_CMD_CTSIEN_LSB         7
+   #define  Si2158_POWER_UP_CMD_CTSIEN_MASK        0x01
+   #define  Si2158_POWER_UP_CMD_CTSIEN_MIN         0
+   #define  Si2158_POWER_UP_CMD_CTSIEN_MAX         1
+    #define Si2158_POWER_UP_CMD_CTSIEN_DISABLE  0
+    #define Si2158_POWER_UP_CMD_CTSIEN_ENABLE   1
+   /* POWER_UP command, WAKE_UP field definition (address 14,size 1, lsb 0, unsigned) */
+   #define  Si2158_POWER_UP_CMD_WAKE_UP_LSB         0
+   #define  Si2158_POWER_UP_CMD_WAKE_UP_MASK        0x01
+   #define  Si2158_POWER_UP_CMD_WAKE_UP_MIN         1
+   #define  Si2158_POWER_UP_CMD_WAKE_UP_MAX         1
+    #define Si2158_POWER_UP_CMD_WAKE_UP_WAKE_UP  1
+#endif /* Si2158_POWER_UP_CMD */
+
+/* Si2158_SET_PROPERTY command definition */
+#define   Si2158_SET_PROPERTY_CMD 0x14
+
+#ifdef    Si2158_SET_PROPERTY_CMD
+  #define Si2158_SET_PROPERTY_CMD_CODE 0x010014
+
+    typedef struct { /* Si2158_SET_PROPERTY_CMD_struct */
+     unsigned char   reserved;
+     unsigned int    prop;
+     unsigned int    data;
+   } Si2158_SET_PROPERTY_CMD_struct;
+
+
+    typedef struct { /* Si2158_SET_PROPERTY_CMD_REPLY_struct */
+       Si2158_COMMON_REPLY_struct * STATUS;
+      unsigned char   reserved;
+      unsigned int    data;
+   }  Si2158_SET_PROPERTY_CMD_REPLY_struct;
+
+   /* SET_PROPERTY command, RESERVED field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  Si2158_SET_PROPERTY_CMD_RESERVED_LSB         0
+   #define  Si2158_SET_PROPERTY_CMD_RESERVED_MASK        0xff
+   #define  Si2158_SET_PROPERTY_CMD_RESERVED_MIN         0
+   #define  Si2158_SET_PROPERTY_CMD_RESERVED_MAX         255.0
+   /* SET_PROPERTY command, PROP field definition (address 2,size 16, lsb 0, unsigned) */
+   #define  Si2158_SET_PROPERTY_CMD_PROP_LSB         0
+   #define  Si2158_SET_PROPERTY_CMD_PROP_MASK        0xffff
+   #define  Si2158_SET_PROPERTY_CMD_PROP_MIN         0
+   #define  Si2158_SET_PROPERTY_CMD_PROP_MAX         65535
+    #define Si2158_SET_PROPERTY_CMD_PROP_PROP_MIN  0
+    #define Si2158_SET_PROPERTY_CMD_PROP_PROP_MAX  65535
+   /* SET_PROPERTY command, DATA field definition (address 4,size 16, lsb 0, unsigned) */
+   #define  Si2158_SET_PROPERTY_CMD_DATA_LSB         0
+   #define  Si2158_SET_PROPERTY_CMD_DATA_MASK        0xffff
+   #define  Si2158_SET_PROPERTY_CMD_DATA_MIN         0
+   #define  Si2158_SET_PROPERTY_CMD_DATA_MAX         65535
+    #define Si2158_SET_PROPERTY_CMD_DATA_DATA_MIN  0
+    #define Si2158_SET_PROPERTY_CMD_DATA_DATA_MAX  65535
+   /* SET_PROPERTY command, RESERVED field definition (address 1, size 8, lsb 0, unsigned)*/
+   #define  Si2158_SET_PROPERTY_RESPONSE_RESERVED_LSB         0
+   #define  Si2158_SET_PROPERTY_RESPONSE_RESERVED_MASK        0xff
+    #define Si2158_SET_PROPERTY_RESPONSE_RESERVED_RESERVED_MIN  0
+    #define Si2158_SET_PROPERTY_RESPONSE_RESERVED_RESERVED_MAX  0
+   /* SET_PROPERTY command, DATA field definition (address 2, size 16, lsb 0, unsigned)*/
+   #define  Si2158_SET_PROPERTY_RESPONSE_DATA_LSB         0
+   #define  Si2158_SET_PROPERTY_RESPONSE_DATA_MASK        0xffff
+
+#endif /* Si2158_SET_PROPERTY_CMD */
+
+/* Si2158_STANDBY command definition */
+#define   Si2158_STANDBY_CMD 0x16
+
+#ifdef    Si2158_STANDBY_CMD
+  #define Si2158_STANDBY_CMD_CODE 0x010016
+
+    typedef struct { /* Si2158_STANDBY_CMD_struct */
+     unsigned char   type;
+   } Si2158_STANDBY_CMD_struct;
+
+
+    typedef struct { /* Si2158_STANDBY_CMD_REPLY_struct */
+       Si2158_COMMON_REPLY_struct * STATUS;
+   }  Si2158_STANDBY_CMD_REPLY_struct;
+
+   /* STANDBY command, TYPE field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2158_STANDBY_CMD_TYPE_LSB         0
+   #define  Si2158_STANDBY_CMD_TYPE_MASK        0x01
+   #define  Si2158_STANDBY_CMD_TYPE_MIN         0
+   #define  Si2158_STANDBY_CMD_TYPE_MAX         1
+    #define Si2158_STANDBY_CMD_TYPE_LNA_OFF  1
+    #define Si2158_STANDBY_CMD_TYPE_LNA_ON   0
+#endif /* Si2158_STANDBY_CMD */
+
+/* Si2158_TUNER_STATUS command definition */
+#define   Si2158_TUNER_STATUS_CMD 0x42
+
+#ifdef    Si2158_TUNER_STATUS_CMD
+  #define Si2158_TUNER_STATUS_CMD_CODE 0x010042
+
+    typedef struct { /* Si2158_TUNER_STATUS_CMD_struct */
+     unsigned char   intack;
+   } Si2158_TUNER_STATUS_CMD_struct;
+
+
+    typedef struct { /* Si2158_TUNER_STATUS_CMD_REPLY_struct */
+       Si2158_COMMON_REPLY_struct * STATUS;
+      unsigned char   tcint;
+      unsigned char   rssilint;
+      unsigned char   rssihint;
+               int    vco_code;
+      unsigned char   tc;
+      unsigned char   rssil;
+      unsigned char   rssih;
+               char   rssi;
+      unsigned long   freq;
+      unsigned char   mode;
+   }  Si2158_TUNER_STATUS_CMD_REPLY_struct;
+
+   /* TUNER_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2158_TUNER_STATUS_CMD_INTACK_LSB         0
+   #define  Si2158_TUNER_STATUS_CMD_INTACK_MASK        0x01
+   #define  Si2158_TUNER_STATUS_CMD_INTACK_MIN         0
+   #define  Si2158_TUNER_STATUS_CMD_INTACK_MAX         1
+    #define Si2158_TUNER_STATUS_CMD_INTACK_CLEAR  1
+    #define Si2158_TUNER_STATUS_CMD_INTACK_OK     0
+   /* TUNER_STATUS command, TCINT field definition (address 1, size 1, lsb 0, unsigned)*/
+   #define  Si2158_TUNER_STATUS_RESPONSE_TCINT_LSB         0
+   #define  Si2158_TUNER_STATUS_RESPONSE_TCINT_MASK        0x01
+    #define Si2158_TUNER_STATUS_RESPONSE_TCINT_CHANGED    1
+    #define Si2158_TUNER_STATUS_RESPONSE_TCINT_NO_CHANGE  0
+   /* TUNER_STATUS command, RSSILINT field definition (address 1, size 1, lsb 1, unsigned)*/
+   #define  Si2158_TUNER_STATUS_RESPONSE_RSSILINT_LSB         1
+   #define  Si2158_TUNER_STATUS_RESPONSE_RSSILINT_MASK        0x01
+    #define Si2158_TUNER_STATUS_RESPONSE_RSSILINT_CHANGED    1
+    #define Si2158_TUNER_STATUS_RESPONSE_RSSILINT_NO_CHANGE  0
+   /* TUNER_STATUS command, RSSIHINT field definition (address 1, size 1, lsb 2, unsigned)*/
+   #define  Si2158_TUNER_STATUS_RESPONSE_RSSIHINT_LSB         2
+   #define  Si2158_TUNER_STATUS_RESPONSE_RSSIHINT_MASK        0x01
+    #define Si2158_TUNER_STATUS_RESPONSE_RSSIHINT_CHANGED    1
+    #define Si2158_TUNER_STATUS_RESPONSE_RSSIHINT_NO_CHANGE  0
+   /* TUNER_STATUS command, VCO_CODE field definition (address 10, size 16, lsb 0, signed)*/
+   #define  Si2158_TUNER_STATUS_RESPONSE_VCO_CODE_LSB         0
+   #define  Si2158_TUNER_STATUS_RESPONSE_VCO_CODE_MASK        0xffff
+   #define  Si2158_TUNER_STATUS_RESPONSE_VCO_CODE_SHIFT       16
+   /* TUNER_STATUS command, TC field definition (address 2, size 1, lsb 0, unsigned)*/
+   #define  Si2158_TUNER_STATUS_RESPONSE_TC_LSB         0
+   #define  Si2158_TUNER_STATUS_RESPONSE_TC_MASK        0x01
+    #define Si2158_TUNER_STATUS_RESPONSE_TC_BUSY  0
+    #define Si2158_TUNER_STATUS_RESPONSE_TC_DONE  1
+   /* TUNER_STATUS command, RSSIL field definition (address 2, size 1, lsb 1, unsigned)*/
+   #define  Si2158_TUNER_STATUS_RESPONSE_RSSIL_LSB         1
+   #define  Si2158_TUNER_STATUS_RESPONSE_RSSIL_MASK        0x01
+    #define Si2158_TUNER_STATUS_RESPONSE_RSSIL_LOW  1
+    #define Si2158_TUNER_STATUS_RESPONSE_RSSIL_OK   0
+   /* TUNER_STATUS command, RSSIH field definition (address 2, size 1, lsb 2, unsigned)*/
+   #define  Si2158_TUNER_STATUS_RESPONSE_RSSIH_LSB         2
+   #define  Si2158_TUNER_STATUS_RESPONSE_RSSIH_MASK        0x01
+    #define Si2158_TUNER_STATUS_RESPONSE_RSSIH_HIGH  1
+    #define Si2158_TUNER_STATUS_RESPONSE_RSSIH_OK    0
+   /* TUNER_STATUS command, RSSI field definition (address 3, size 8, lsb 0, signed)*/
+   #define  Si2158_TUNER_STATUS_RESPONSE_RSSI_LSB         0
+   #define  Si2158_TUNER_STATUS_RESPONSE_RSSI_MASK        0xff
+   #define  Si2158_TUNER_STATUS_RESPONSE_RSSI_SHIFT       24
+   /* TUNER_STATUS command, FREQ field definition (address 4, size 32, lsb 0, unsigned)*/
+   #define  Si2158_TUNER_STATUS_RESPONSE_FREQ_LSB         0
+   #define  Si2158_TUNER_STATUS_RESPONSE_FREQ_MASK        0xffffffff
+   /* TUNER_STATUS command, MODE field definition (address 8, size 1, lsb 0, unsigned)*/
+   #define  Si2158_TUNER_STATUS_RESPONSE_MODE_LSB         0
+   #define  Si2158_TUNER_STATUS_RESPONSE_MODE_MASK        0x01
+    #define Si2158_TUNER_STATUS_RESPONSE_MODE_ATV  1
+    #define Si2158_TUNER_STATUS_RESPONSE_MODE_DTV  0
+
+#endif /* Si2158_TUNER_STATUS_CMD */
+
+/* Si2158_TUNER_TUNE_FREQ command definition */
+#define   Si2158_TUNER_TUNE_FREQ_CMD 0x41
+
+#ifdef    Si2158_TUNER_TUNE_FREQ_CMD
+  #define Si2158_TUNER_TUNE_FREQ_CMD_CODE 0x010041
+
+    typedef struct { /* Si2158_TUNER_TUNE_FREQ_CMD_struct */
+     unsigned char   mode;
+     unsigned long   freq;
+   } Si2158_TUNER_TUNE_FREQ_CMD_struct;
+
+
+    typedef struct { /* Si2158_TUNER_TUNE_FREQ_CMD_REPLY_struct */
+       Si2158_COMMON_REPLY_struct * STATUS;
+   }  Si2158_TUNER_TUNE_FREQ_CMD_REPLY_struct;
+
+   /* TUNER_TUNE_FREQ command, MODE field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2158_TUNER_TUNE_FREQ_CMD_MODE_LSB         0
+   #define  Si2158_TUNER_TUNE_FREQ_CMD_MODE_MASK        0x01
+   #define  Si2158_TUNER_TUNE_FREQ_CMD_MODE_MIN         0
+   #define  Si2158_TUNER_TUNE_FREQ_CMD_MODE_MAX         1
+    #define Si2158_TUNER_TUNE_FREQ_CMD_MODE_ATV  1
+    #define Si2158_TUNER_TUNE_FREQ_CMD_MODE_DTV  0
+   /* TUNER_TUNE_FREQ command, FREQ field definition (address 4,size 32, lsb 0, unsigned) */
+   #define  Si2158_TUNER_TUNE_FREQ_CMD_FREQ_LSB         0
+   #define  Si2158_TUNER_TUNE_FREQ_CMD_FREQ_MASK        0xffffffff
+   #define  Si2158_TUNER_TUNE_FREQ_CMD_FREQ_MIN         40000000
+   #define  Si2158_TUNER_TUNE_FREQ_CMD_FREQ_MAX         1002000000
+    #define Si2158_TUNER_TUNE_FREQ_CMD_FREQ_FREQ_MIN  40000000
+    #define Si2158_TUNER_TUNE_FREQ_CMD_FREQ_FREQ_MAX  1002000000
+#endif /* Si2158_TUNER_TUNE_FREQ_CMD */
+
+/* _commands_defines_insertion_point */
+
+/* _commands_struct_insertion_start */
+
+  /* --------------------------------------------*/
+  /* COMMANDS STRUCT                             */
+  /* This is used to store all command fields    */
+  /* --------------------------------------------*/
+  typedef struct { /* Si2158_CmdObj struct */
+    #ifdef    Si2158_AGC_OVERRIDE_CMD
+              Si2158_AGC_OVERRIDE_CMD_struct     agc_override;
+    #endif /* Si2158_AGC_OVERRIDE_CMD */
+    #ifdef    Si2158_ATV_CW_TEST_CMD
+              Si2158_ATV_CW_TEST_CMD_struct      atv_cw_test;
+    #endif /* Si2158_ATV_CW_TEST_CMD */
+    #ifdef    Si2158_ATV_RESTART_CMD
+              Si2158_ATV_RESTART_CMD_struct      atv_restart;
+    #endif /* Si2158_ATV_RESTART_CMD */
+    #ifdef    Si2158_ATV_STATUS_CMD
+              Si2158_ATV_STATUS_CMD_struct       atv_status;
+    #endif /* Si2158_ATV_STATUS_CMD */
+    #ifdef    Si2158_CONFIG_CLOCKS_CMD
+              Si2158_CONFIG_CLOCKS_CMD_struct    config_clocks;
+    #endif /* Si2158_CONFIG_CLOCKS_CMD */
+    #ifdef    Si2158_CONFIG_PINS_CMD
+              Si2158_CONFIG_PINS_CMD_struct      config_pins;
+    #endif /* Si2158_CONFIG_PINS_CMD */
+    #ifdef    Si2158_DTV_RESTART_CMD
+              Si2158_DTV_RESTART_CMD_struct      dtv_restart;
+    #endif /* Si2158_DTV_RESTART_CMD */
+    #ifdef    Si2158_DTV_STATUS_CMD
+              Si2158_DTV_STATUS_CMD_struct       dtv_status;
+    #endif /* Si2158_DTV_STATUS_CMD */
+    #ifdef    Si2158_EXIT_BOOTLOADER_CMD
+              Si2158_EXIT_BOOTLOADER_CMD_struct  exit_bootloader;
+    #endif /* Si2158_EXIT_BOOTLOADER_CMD */
+    #ifdef    Si2158_FINE_TUNE_CMD
+              Si2158_FINE_TUNE_CMD_struct        fine_tune;
+    #endif /* Si2158_FINE_TUNE_CMD */
+    #ifdef    Si2158_GET_PROPERTY_CMD
+              Si2158_GET_PROPERTY_CMD_struct     get_property;
+    #endif /* Si2158_GET_PROPERTY_CMD */
+    #ifdef    Si2158_GET_REV_CMD
+              Si2158_GET_REV_CMD_struct          get_rev;
+    #endif /* Si2158_GET_REV_CMD */
+    #ifdef    Si2158_PART_INFO_CMD
+              Si2158_PART_INFO_CMD_struct        part_info;
+    #endif /* Si2158_PART_INFO_CMD */
+    #ifdef    Si2158_POWER_DOWN_CMD
+              Si2158_POWER_DOWN_CMD_struct       power_down;
+    #endif /* Si2158_POWER_DOWN_CMD */
+    #ifdef    Si2158_POWER_DOWN_HW_CMD
+              Si2158_POWER_DOWN_HW_CMD_struct    power_down_hw;
+    #endif /* Si2158_POWER_DOWN_HW_CMD */
+    #ifdef    Si2158_POWER_UP_CMD
+              Si2158_POWER_UP_CMD_struct         power_up;
+    #endif /* Si2158_POWER_UP_CMD */
+    #ifdef    Si2158_SET_PROPERTY_CMD
+              Si2158_SET_PROPERTY_CMD_struct     set_property;
+    #endif /* Si2158_SET_PROPERTY_CMD */
+    #ifdef    Si2158_STANDBY_CMD
+              Si2158_STANDBY_CMD_struct          standby;
+    #endif /* Si2158_STANDBY_CMD */
+    #ifdef    Si2158_TUNER_STATUS_CMD
+              Si2158_TUNER_STATUS_CMD_struct     tuner_status;
+    #endif /* Si2158_TUNER_STATUS_CMD */
+    #ifdef    Si2158_TUNER_TUNE_FREQ_CMD
+              Si2158_TUNER_TUNE_FREQ_CMD_struct  tuner_tune_freq;
+    #endif /* Si2158_TUNER_TUNE_FREQ_CMD */
+  } Si2158_CmdObj;
+/* _commands_struct_insertion_point */
+
+/* _commands_reply_struct_insertion_start */
+
+  /* --------------------------------------------*/
+  /* COMMANDS REPLY STRUCT                       */
+  /* This stores all command reply fields        */
+  /* --------------------------------------------*/
+  typedef struct { /* Si2158_CmdReplyObj struct */
+    #ifdef    Si2158_AGC_OVERRIDE_CMD
+              Si2158_AGC_OVERRIDE_CMD_REPLY_struct     agc_override;
+    #endif /* Si2158_AGC_OVERRIDE_CMD */
+    #ifdef    Si2158_ATV_CW_TEST_CMD
+              Si2158_ATV_CW_TEST_CMD_REPLY_struct      atv_cw_test;
+    #endif /* Si2158_ATV_CW_TEST_CMD */
+    #ifdef    Si2158_ATV_RESTART_CMD
+              Si2158_ATV_RESTART_CMD_REPLY_struct      atv_restart;
+    #endif /* Si2158_ATV_RESTART_CMD */
+    #ifdef    Si2158_ATV_STATUS_CMD
+              Si2158_ATV_STATUS_CMD_REPLY_struct       atv_status;
+    #endif /* Si2158_ATV_STATUS_CMD */
+    #ifdef    Si2158_CONFIG_CLOCKS_CMD
+              Si2158_CONFIG_CLOCKS_CMD_REPLY_struct    config_clocks;
+    #endif /* Si2158_CONFIG_CLOCKS_CMD */
+    #ifdef    Si2158_CONFIG_PINS_CMD
+              Si2158_CONFIG_PINS_CMD_REPLY_struct      config_pins;
+    #endif /* Si2158_CONFIG_PINS_CMD */
+    #ifdef    Si2158_DTV_RESTART_CMD
+              Si2158_DTV_RESTART_CMD_REPLY_struct      dtv_restart;
+    #endif /* Si2158_DTV_RESTART_CMD */
+    #ifdef    Si2158_DTV_STATUS_CMD
+              Si2158_DTV_STATUS_CMD_REPLY_struct       dtv_status;
+    #endif /* Si2158_DTV_STATUS_CMD */
+    #ifdef    Si2158_EXIT_BOOTLOADER_CMD
+              Si2158_EXIT_BOOTLOADER_CMD_REPLY_struct  exit_bootloader;
+    #endif /* Si2158_EXIT_BOOTLOADER_CMD */
+    #ifdef    Si2158_FINE_TUNE_CMD
+              Si2158_FINE_TUNE_CMD_REPLY_struct        fine_tune;
+    #endif /* Si2158_FINE_TUNE_CMD */
+    #ifdef    Si2158_GET_PROPERTY_CMD
+              Si2158_GET_PROPERTY_CMD_REPLY_struct     get_property;
+    #endif /* Si2158_GET_PROPERTY_CMD */
+    #ifdef    Si2158_GET_REV_CMD
+              Si2158_GET_REV_CMD_REPLY_struct          get_rev;
+    #endif /* Si2158_GET_REV_CMD */
+    #ifdef    Si2158_PART_INFO_CMD
+              Si2158_PART_INFO_CMD_REPLY_struct        part_info;
+    #endif /* Si2158_PART_INFO_CMD */
+    #ifdef    Si2158_POWER_DOWN_CMD
+              Si2158_POWER_DOWN_CMD_REPLY_struct       power_down;
+    #endif /* Si2158_POWER_DOWN_CMD */
+    #ifdef    Si2158_POWER_DOWN_HW_CMD
+              Si2158_POWER_DOWN_HW_CMD_REPLY_struct    power_down_hw;
+    #endif /* Si2158_POWER_DOWN_HW_CMD */
+    #ifdef    Si2158_POWER_UP_CMD
+              Si2158_POWER_UP_CMD_REPLY_struct         power_up;
+    #endif /* Si2158_POWER_UP_CMD */
+    #ifdef    Si2158_SET_PROPERTY_CMD
+              Si2158_SET_PROPERTY_CMD_REPLY_struct     set_property;
+    #endif /* Si2158_SET_PROPERTY_CMD */
+    #ifdef    Si2158_STANDBY_CMD
+              Si2158_STANDBY_CMD_REPLY_struct          standby;
+    #endif /* Si2158_STANDBY_CMD */
+    #ifdef    Si2158_TUNER_STATUS_CMD
+              Si2158_TUNER_STATUS_CMD_REPLY_struct     tuner_status;
+    #endif /* Si2158_TUNER_STATUS_CMD */
+    #ifdef    Si2158_TUNER_TUNE_FREQ_CMD
+              Si2158_TUNER_TUNE_FREQ_CMD_REPLY_struct  tuner_tune_freq;
+    #endif /* Si2158_TUNER_TUNE_FREQ_CMD */
+  } Si2158_CmdReplyObj;
+/* _commands_reply_struct_insertion_point */
+
+#ifdef    Si2158_COMMAND_PROTOTYPES
+#define   Si2158_GET_COMMAND_STRINGS
+#endif /* Si2158_COMMAND_PROTOTYPES */
+
+#endif /* Si2158_COMMANDS_H */
+
+
+
+
+
diff -urN a/drivers/media/dvb-frontends/si2158_firmware_0_E_build_15.h b/drivers/media/dvb-frontends/si2158_firmware_0_E_build_15.h
--- a/drivers/media/dvb-frontends/si2158_firmware_0_E_build_15.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/si2158_firmware_0_E_build_15.h	2013-02-14 22:56:01.000000000 +0800
@@ -0,0 +1,1549 @@
+#ifndef _SI2158_FIRMWARE_0_E_BUILD_15_H_
+#define _SI2158_FIRMWARE_0_E_BUILD_15_H_
+
+#define FIRMWARE_MAJOR        0
+#define FIRMWARE_MINOR        E
+#define BUILD_VERSION        15
+
+unsigned char Si2158_FW_0_Eb15[] = {
+0x04,0x01,0x80,0x00,0xCC,0x58,0x98,0xD7,
+0x05,0xD3,0x99,0xC6,0xB2,0xBD,0x68,0x8B,
+0x05,0xDF,0xB3,0x1B,0x73,0x9E,0xAA,0x51,
+0x27,0xCF,0xF6,0x6C,0xCD,0xDD,0x5E,0x64,
+0x22,0xEB,0x8D,0x75,0xC2,0x4A,0xA8,0xFB,
+0x0F,0x04,0x3A,0x48,0x7C,0xCF,0x5A,0x5A,
+0x27,0x4B,0x3E,0x35,0x0D,0xBA,0xE9,0x2A,
+0x29,0x50,0x14,0x34,0xC1,0xD7,0x08,0x8B,
+0x07,0x1F,0xA0,0x69,0xFB,0xBD,0xA5,0x46,
+0x2E,0xF3,0xF8,0xBB,0xFD,0xC9,0x64,0xCB,
+0x0F,0x7E,0x43,0xA7,0xAA,0x87,0x5E,0x3B,
+0x2F,0x41,0xAB,0xE6,0xB5,0x5D,0xF0,0x86,
+0x2B,0x16,0x7D,0x1A,0x4C,0x72,0x68,0xFB,
+0x07,0x17,0x87,0x60,0x3C,0x6D,0x0C,0x60,
+0x26,0x8C,0xCD,0xE5,0x90,0x80,0x5C,0x53,
+0x07,0x6E,0xA1,0x0F,0x6A,0xBE,0x0D,0x3B,
+0x2F,0x15,0xB8,0x23,0xED,0x6D,0x1A,0xDE,
+0x24,0x6F,0xE7,0x95,0x1E,0x6F,0x9A,0x85,
+0x0F,0xE4,0x4F,0x35,0xA8,0xE6,0x37,0xBF,
+0x22,0x76,0xD4,0x39,0x4C,0xFA,0x73,0x59,
+0x0F,0xD6,0xB4,0xF1,0x43,0x6B,0xCE,0xF1,
+0x2A,0xE2,0xF6,0xC6,0x39,0x39,0x82,0x2A,
+0x0F,0xB9,0xF6,0x5D,0xD6,0x3C,0x25,0x17,
+0x2F,0x0C,0x63,0x24,0xC6,0xF1,0xB1,0x37,
+0x2F,0xF9,0xA4,0xED,0x41,0xD0,0xCA,0xED,
+0x23,0xD4,0x9D,0x4A,0xAB,0xF1,0x81,0x3C,
+0x07,0x79,0xF8,0xA4,0xB4,0x71,0x25,0xCE,
+0x2F,0xCC,0x0A,0x0C,0x1D,0x0F,0x79,0x1F,
+0x2F,0x2A,0xB8,0x84,0xE2,0x43,0x4E,0x1B,
+0x26,0xAA,0x6B,0x06,0x2B,0xB1,0x6F,0xB2,
+0x0F,0x12,0x4F,0xCB,0x29,0x04,0xFB,0xD0,
+0x25,0x3E,0xE7,0x17,0x64,0xF1,0x47,0xC0,
+0x0F,0x8F,0x43,0x9F,0x23,0x2A,0x50,0x36,
+0x2A,0x6C,0x03,0xD7,0x29,0x87,0xA5,0x99,
+0x07,0xC3,0x49,0x0D,0x73,0x77,0x0C,0xC6,
+0x07,0x3A,0x8E,0x3D,0x75,0xB8,0x48,0x55,
+0x0F,0xAB,0x62,0x72,0x46,0x0D,0xD6,0x80,
+0x27,0x75,0x1F,0x93,0x37,0x7A,0x0D,0x41,
+0x21,0xCB,0xD3,0x31,0x0E,0x28,0x7B,0x26,
+0x0F,0xBA,0x8F,0x86,0xC0,0xE7,0xE1,0x26,
+0x22,0xCD,0xE0,0x65,0x94,0x2F,0xBC,0x19,
+0x07,0x6E,0xDA,0xCB,0x11,0xFE,0x04,0x3B,
+0x22,0xE6,0x08,0x94,0xBC,0x66,0x71,0x25,
+0x07,0x1B,0x30,0xE8,0x18,0xA4,0xAD,0x50,
+0x2D,0xA7,0x33,0x7F,0xD8,0x5B,0xC1,0xFD,
+0x0F,0x5E,0xC5,0x85,0x19,0x54,0xE3,0x7F,
+0x22,0xEA,0x90,0xBB,0xB7,0x7C,0xFB,0xFF,
+0x07,0xE4,0x01,0x5A,0x01,0x51,0x1A,0x47,
+0x27,0xEC,0x3C,0x1D,0x21,0x79,0x16,0x9A,
+0x2C,0xE6,0x0B,0x70,0xDD,0xCC,0x12,0x8A,
+0x0F,0x1D,0x5C,0x4D,0x07,0x1A,0x95,0xE2,
+0x25,0x3C,0x22,0x25,0x82,0xC4,0x59,0xB7,
+0x07,0xDE,0xB8,0xE2,0xF4,0x47,0x47,0xFF,
+0x25,0xDD,0x02,0x19,0x2A,0x45,0xD2,0x31,
+0x0F,0xE3,0xF4,0xAA,0x14,0xEB,0x9D,0xF2,
+0x2F,0x74,0xF7,0x2B,0xD1,0xB6,0x18,0xFF,
+0x2F,0xDD,0x9C,0x99,0x0A,0x21,0x99,0x8E,
+0x23,0x3C,0x04,0x20,0xAC,0x1A,0xC5,0xCD,
+0x07,0x73,0xF1,0x31,0x2C,0x44,0x58,0x74,
+0x2F,0xEC,0x1B,0xB1,0x7B,0xAD,0x76,0x32,
+0x29,0x35,0xAF,0xE2,0x21,0x09,0xB4,0x79,
+0x07,0x66,0xC5,0xA6,0x16,0xCB,0xE9,0x5C,
+0x27,0xB5,0x4F,0xE6,0xE9,0x19,0x5E,0x25,
+0x27,0x72,0x69,0x1C,0xFB,0x30,0xE6,0xB3,
+0x0F,0xFB,0xA9,0x53,0x94,0x2A,0x75,0x61,
+0x25,0x66,0x1E,0xE7,0xC9,0x9D,0x79,0xF5,
+0x0F,0x73,0x01,0x7F,0xE9,0x0C,0x7E,0xED,
+0x2A,0xDF,0x41,0x2E,0x2D,0x50,0x72,0xC3,
+0x0F,0x49,0xDE,0xAB,0xBC,0xF8,0x8D,0x55,
+0x27,0xE6,0x18,0xE6,0x07,0xF1,0x84,0xE2,
+0x29,0x7B,0xA1,0x1E,0x13,0x4E,0xE7,0x3C,
+0x07,0xA3,0x01,0xEB,0x93,0xB2,0x36,0x16,
+0x0F,0xD3,0x86,0x31,0x67,0x4A,0xB0,0x79,
+0x07,0x01,0xD4,0x98,0x17,0x16,0xF3,0xB4,
+0x25,0xFD,0x6F,0xF1,0xDA,0x9A,0xBA,0x06,
+0x07,0x8D,0xD3,0xD6,0xFC,0xD9,0xD6,0x02,
+0x2A,0xF1,0x24,0x79,0xC5,0x25,0xBD,0xE1,
+0x07,0xB5,0xA7,0x60,0xBB,0xD5,0x39,0x5A,
+0x0F,0x08,0xA1,0x96,0xCB,0x4F,0x93,0x52,
+0x0F,0x6C,0x82,0xC2,0xE0,0x02,0x04,0x70,
+0x2A,0xB5,0x75,0x46,0x6E,0xDF,0x04,0x40,
+0x0F,0xF3,0xF7,0xD4,0xFB,0x54,0x68,0x5C,
+0x27,0x97,0xCB,0x54,0x5C,0x63,0x88,0xDF,
+0x27,0xF0,0x16,0x41,0x54,0xE0,0xF6,0xFC,
+0x27,0x1B,0x1D,0x50,0xE8,0x99,0x3C,0x0E,
+0x22,0x48,0xCB,0x3F,0xC2,0x7B,0x1E,0xF7,
+0x07,0x78,0xDA,0x29,0x4D,0xB9,0xBE,0x4C,
+0x2F,0x62,0x65,0x80,0x4B,0x86,0x44,0xC4,
+0x29,0x38,0x47,0x9D,0xEF,0x1D,0xC7,0x7C,
+0x07,0xB6,0x36,0x2D,0x07,0x57,0x4F,0x32,
+0x07,0x1F,0xB4,0xC3,0x7E,0xC3,0xD3,0xB0,
+0x0F,0x8E,0x90,0x8D,0xC1,0x1E,0x05,0x05,
+0x2F,0xFC,0x8C,0x2A,0x7E,0x9B,0x7E,0x72,
+0x2C,0xAB,0xE9,0xEF,0x08,0xF6,0x5B,0x24,
+0x07,0x48,0x19,0xA9,0x76,0x95,0x8A,0x75,
+0x2A,0x1F,0x74,0x4C,0xE6,0x81,0x61,0x4B,
+0x0F,0xA5,0xFF,0x5F,0x77,0x1C,0x7A,0x05,
+0x2A,0x47,0xAF,0x53,0x84,0x9B,0xDA,0x3D,
+0x0F,0xC9,0x90,0x35,0xDE,0xE3,0xFB,0xCA,
+0x27,0x99,0x88,0x5F,0xF6,0x47,0x3F,0x26,
+0x2F,0x32,0x4B,0x93,0x94,0x9C,0x6D,0x9A,
+0x0F,0x3E,0xE0,0x43,0x9B,0x46,0x55,0x0C,
+0x2A,0x57,0xF5,0x67,0x7B,0x16,0xC7,0x91,
+0x0F,0x2D,0xA7,0x3A,0x1F,0xE5,0x9C,0x84,
+0x25,0xE9,0x7F,0xC0,0xD4,0xE6,0xAA,0xA2,
+0x07,0x51,0xC0,0x9F,0x11,0xD9,0x05,0x50,
+0x07,0x58,0xC8,0x3A,0x83,0xFB,0x65,0x7D,
+0x07,0x8B,0xB2,0xE4,0x8B,0x39,0xFB,0xA4,
+0x2D,0x4B,0x48,0xC4,0x6B,0xF6,0xAC,0x0E,
+0x0F,0x46,0x87,0x58,0x0F,0xFB,0xA1,0x3A,
+0x27,0x8D,0xFF,0x73,0xBF,0xE9,0x1D,0x16,
+0x24,0x18,0xDD,0x33,0x35,0x60,0x5E,0x94,
+0x0F,0xF9,0xC4,0x00,0x32,0xBB,0x04,0x17,
+0x27,0xB6,0x18,0x19,0x23,0xB6,0xA8,0xBB,
+0x27,0xFF,0x27,0x44,0xBC,0x42,0x1B,0x78,
+0x07,0x6B,0x39,0x5D,0x45,0xB4,0x99,0xDC,
+0x22,0x02,0xF2,0x0C,0x5B,0x86,0x2E,0x0B,
+0x0F,0x82,0xB4,0xE3,0x91,0x47,0xE0,0x47,
+0x2A,0x02,0x13,0x80,0x76,0x73,0x28,0x9F,
+0x0F,0x87,0x3E,0xC7,0x4A,0x1D,0x7F,0x21,
+0x27,0xD7,0x2F,0xA5,0x7B,0xDF,0xFD,0x46,
+0x2C,0x5C,0x60,0xE9,0x8B,0x8B,0x1E,0xF4,
+0x07,0xDB,0x26,0x02,0x2F,0x35,0x81,0x69,
+0x22,0x56,0x17,0x3C,0xCB,0x13,0xAF,0x71,
+0x0F,0x9E,0x4A,0xAB,0x85,0x80,0x02,0x3B,
+0x2A,0xFC,0xE2,0x0D,0x2F,0x81,0xC3,0xD9,
+0x07,0x2A,0x59,0xF2,0x81,0x2C,0x6B,0xED,
+0x2F,0x17,0x1F,0x1B,0xE3,0x8A,0x3A,0x8D,
+0x2C,0xE8,0x24,0x30,0x5D,0x2E,0x79,0xFE,
+0x0F,0x8C,0x0E,0xC7,0xB7,0x8D,0x24,0xC0,
+0x07,0xEB,0xB0,0x26,0xE6,0xF0,0x46,0xB5,
+0x0F,0x4F,0xD0,0xF8,0x1F,0xBD,0x70,0x55,
+0x2A,0xF3,0x7E,0xD6,0x1B,0x12,0x69,0x5D,
+0x0F,0x8F,0x1A,0x10,0x2B,0x88,0x30,0xA9,
+0x2F,0xB8,0xF3,0xA4,0x06,0x07,0x29,0xFF,
+0x2F,0x01,0x43,0xD6,0xB0,0xC4,0x3B,0xEC,
+0x0F,0x27,0x05,0x37,0x3A,0x70,0x03,0x61,
+0x22,0xF4,0xBE,0xC4,0x2C,0x24,0xEC,0xF7,
+0x0F,0xA6,0x55,0x01,0x56,0x83,0xA9,0x0C,
+0x2F,0x6D,0x58,0xF4,0xCE,0x3F,0xEE,0xEB,
+0x27,0x36,0xDB,0x2E,0xDB,0xA1,0x19,0x15,
+0x2B,0xF0,0xC1,0x61,0xEB,0x69,0x33,0xFC,
+0x0F,0xF2,0x3F,0xCF,0xE7,0xB8,0x7A,0x36,
+0x27,0x8D,0x3C,0xF0,0x2B,0x96,0x53,0x87,
+0x27,0xC4,0x34,0xD0,0x97,0xCF,0x09,0x6D,
+0x27,0x80,0x27,0xF4,0x16,0x02,0xC6,0x68,
+0x22,0x59,0x26,0x8B,0xCD,0x33,0x5B,0x33,
+0x07,0x7F,0x1A,0x77,0x2E,0xAD,0xA6,0x73,
+0x2F,0xF4,0x63,0x96,0xD2,0xC7,0x82,0x50,
+0x2F,0x2D,0xA5,0x04,0xF7,0xD3,0x95,0x52,
+0x2F,0x72,0x8D,0x25,0xCC,0xDA,0x7D,0x15,
+0x27,0xD3,0xA9,0x03,0x1A,0xAC,0xE1,0x1B,
+0x2F,0xD4,0x0B,0x66,0x6A,0xBB,0xD1,0xDB,
+0x27,0xDE,0x79,0xC3,0x56,0x99,0x90,0x74,
+0x27,0xF1,0x5E,0x6B,0xFD,0x9A,0x55,0xD0,
+0x27,0xD0,0x78,0xF9,0x49,0x29,0x87,0xCD,
+0x2F,0x02,0x98,0xC9,0x89,0x58,0x3B,0x6C,
+0x27,0xC7,0x35,0x07,0x08,0x8B,0x12,0xE4,
+0x2F,0x41,0x54,0x4A,0xBB,0x0D,0x53,0x13,
+0x2F,0x37,0xC7,0x6D,0x6C,0x0A,0xE6,0xE0,
+0x2F,0x68,0x30,0x30,0xD6,0x96,0x51,0x09,
+0x2F,0x31,0x8A,0x38,0x0D,0xA6,0xFE,0x4C,
+0x2F,0x6E,0x44,0x89,0x42,0x4C,0x2D,0x62,
+0x27,0xED,0x16,0x32,0x0F,0x43,0x91,0xF2,
+0x2F,0x06,0x9B,0xBC,0x98,0x0F,0xA4,0xFC,
+0x2F,0x81,0x46,0x60,0x37,0x7F,0xBA,0xB2,
+0x21,0x64,0x93,0x15,0xFE,0x15,0x6B,0x4D,
+0x0F,0xC8,0x53,0xAF,0x7D,0x4A,0x0F,0xAE,
+0x2F,0x03,0xFD,0x13,0x13,0xFD,0xB9,0xB5,
+0x27,0xB5,0x5C,0x7E,0x14,0xD4,0x31,0xB1,
+0x2F,0x56,0xF3,0x70,0xA0,0xE3,0x20,0xD2,
+0x2F,0xB8,0xA8,0x39,0x36,0x23,0x9F,0x8E,
+0x27,0x01,0x83,0xB8,0x38,0x6B,0x54,0x59,
+0x2F,0xFC,0x27,0xF8,0xB6,0x5C,0xF5,0x1C,
+0x2F,0x6D,0xD1,0x4D,0x3D,0x57,0x1F,0x63,
+0x27,0xBA,0xDD,0x2E,0x43,0xA6,0xB3,0x8F,
+0x2F,0x8B,0x7A,0x9E,0xF6,0xFD,0x69,0xC2,
+0x26,0x5B,0x45,0x2F,0xA2,0xDA,0x5B,0x5B,
+0x07,0xDE,0xD3,0xDA,0xCB,0x6B,0xD3,0xB3,
+0x07,0xA6,0x63,0xC2,0x67,0x78,0xAC,0xC4,
+0x2F,0xE3,0x75,0xB2,0xC9,0x88,0xB2,0x8E,
+0x27,0x3C,0x34,0x26,0xDE,0x91,0x2C,0xD5,
+0x2F,0xC0,0x91,0x75,0x7D,0xBF,0xEF,0xDF,
+0x27,0x4A,0x25,0x4B,0xB1,0x59,0x2C,0xF7,
+0x27,0xF5,0xFB,0xFD,0x95,0xAD,0x12,0xF2,
+0x27,0xA1,0x6D,0xD6,0xFD,0x80,0x91,0xF6,
+0x27,0x03,0x6F,0xE0,0x8B,0x36,0x58,0xBC,
+0x2F,0x98,0xF2,0x0B,0xE1,0xD1,0x65,0x11,
+0x2F,0x77,0xA5,0x32,0x8E,0x29,0x3D,0x76,
+0x2F,0x90,0x17,0xDA,0x3A,0x62,0xFC,0x57,
+0x27,0x80,0xD9,0x58,0x03,0xAF,0x1A,0xDE,
+0x2F,0xBC,0x01,0xD2,0x74,0xB0,0x3C,0x5A,
+0x2F,0x8A,0x13,0x1D,0x29,0x77,0xBB,0x59,
+0x2F,0x28,0xD9,0xA2,0x28,0xDA,0xBC,0x14,
+0x2F,0xFD,0x1D,0x3B,0xA1,0x58,0xF5,0xCA,
+0x2F,0xE1,0xEA,0x52,0x38,0x8F,0xF0,0x5F,
+0x2F,0xD6,0x2F,0xD2,0x0E,0xB4,0xDF,0x33,
+0x27,0xC8,0x6E,0x63,0x64,0x42,0x28,0x32,
+0x27,0x96,0x44,0xF9,0x47,0x6B,0xC7,0xC7,
+0x22,0xA4,0xF9,0x54,0x66,0x87,0x6A,0xCF,
+0x07,0x8C,0xFF,0x74,0xC5,0x29,0xFF,0xB9,
+0x0F,0x14,0x12,0xD0,0x19,0x2B,0xCF,0x6F,
+0x07,0x8D,0xA1,0x1A,0x4E,0xCC,0xF9,0x79,
+0x0F,0x69,0x19,0x4B,0x70,0x95,0xE0,0x38,
+0x07,0x70,0x85,0x50,0x32,0x42,0xA6,0x38,
+0x07,0xF4,0xE6,0xE4,0x2E,0x17,0xF0,0x51,
+0x0F,0x5B,0x0E,0xE6,0x51,0x3A,0x5E,0x8B,
+0x27,0x0A,0xC1,0x97,0x47,0x25,0x9C,0x11,
+0x27,0x43,0x28,0xCC,0xFD,0xBB,0xD2,0xD9,
+0x27,0xA9,0x84,0x32,0x5A,0x74,0xBA,0xA6,
+0x27,0x65,0x77,0xAD,0x35,0x2D,0xE4,0xCC,
+0x2D,0x1F,0x3F,0xB8,0x31,0x18,0x42,0x99,
+0x0F,0xA7,0x88,0x12,0x1E,0x68,0x48,0x70,
+0x2F,0x12,0x22,0x4F,0x63,0x39,0x19,0x25,
+0x27,0x07,0xCE,0xBF,0x8D,0x8A,0x58,0x55,
+0x27,0x93,0xCF,0x3E,0xB2,0xF1,0xC5,0x0C,
+0x26,0x62,0xD0,0x69,0x81,0x07,0xE1,0xFD,
+0x07,0x21,0x5A,0x26,0x9F,0xCA,0x93,0x31,
+0x2F,0x34,0xFB,0xEB,0xBF,0x07,0xBD,0xF3,
+0x27,0x8C,0x0D,0xE9,0xE4,0xF3,0xAD,0xBB,
+0x25,0xC7,0x5A,0xA0,0xB3,0x09,0xCC,0x9F,
+0x0F,0xDA,0xC1,0xE3,0xCD,0xED,0x60,0xC5,
+0x2E,0xF4,0xC5,0x03,0x26,0xAC,0x7E,0xE0,
+0x0F,0x50,0x8B,0x90,0xF1,0xFB,0x6E,0x58,
+0x0F,0x3C,0x53,0x76,0xFB,0xAA,0x44,0xAD,
+0x0F,0x4B,0xA4,0x5D,0x17,0xC8,0x88,0xE9,
+0x2F,0x9F,0x61,0x47,0x83,0xC9,0x5D,0x95,
+0x2F,0x18,0xA7,0x74,0x2D,0x5D,0x09,0xC4,
+0x27,0x83,0xB7,0xC1,0x23,0xE5,0x9D,0x0B,
+0x2F,0xF2,0x68,0xAF,0xA2,0x10,0xEF,0xC2,
+0x2F,0x96,0xFB,0x85,0x89,0x3D,0xAD,0x09,
+0x27,0xBA,0xF3,0x7B,0xEA,0x0E,0xB7,0xC4,
+0x27,0x36,0xBD,0xC2,0x05,0x47,0xDD,0x23,
+0x2F,0x17,0x09,0x79,0x6E,0xB0,0x69,0x58,
+0x2F,0x13,0xB1,0xFC,0x4D,0x12,0x57,0x30,
+0x2F,0xA8,0x02,0x53,0x7A,0xD8,0x05,0x60,
+0x25,0x98,0xC5,0xAD,0xAF,0x2B,0x9B,0x0E,
+0x07,0x07,0xEB,0xC9,0x7B,0x20,0x62,0xB4,
+0x27,0x68,0xB4,0x0C,0x3C,0x6C,0xB8,0xEC,
+0x0F,0xCF,0x24,0xBF,0xDA,0xC7,0xBE,0x93,
+0x27,0x8D,0xAE,0xA3,0xD0,0x58,0x99,0x3D,
+0x2F,0x50,0x54,0x87,0xFC,0xC5,0xB4,0xF8,
+0x2F,0x68,0xE4,0xD4,0xF3,0x5A,0x3C,0x93,
+0x2F,0xAA,0xE2,0xCD,0xC7,0xCB,0x5D,0xCC,
+0x2F,0x6D,0x0F,0xFA,0xA6,0x26,0xDF,0xBD,
+0x2F,0x55,0x0E,0xAC,0xDF,0x8E,0x4A,0xFF,
+0x27,0xB2,0x31,0xA5,0xEB,0x9E,0x7F,0x5C,
+0x27,0x38,0x96,0x01,0xFE,0x95,0xF2,0xBA,
+0x2D,0xC3,0x24,0xCE,0x2E,0xE6,0xB9,0x9D,
+0x07,0xDF,0xB6,0x66,0xC7,0xC7,0xF0,0xBA,
+0x2F,0x30,0x29,0x65,0xDE,0x39,0x22,0x22,
+0x27,0x6F,0xA4,0x35,0xA1,0x0C,0x80,0x5D,
+0x27,0x8F,0x21,0x3C,0xC1,0x21,0x83,0x0E,
+0x27,0xE1,0x4B,0xC3,0x70,0xA0,0x34,0x0D,
+0x27,0x62,0xF1,0x80,0x17,0x8B,0x88,0xE7,
+0x2F,0x96,0x84,0x5E,0x1A,0xFA,0x32,0x7A,
+0x2F,0xBA,0xF8,0x30,0x2E,0x28,0x29,0x93,
+0x27,0xD8,0x01,0x42,0x89,0x1E,0x59,0xC8,
+0x2F,0xC4,0x8B,0x8D,0x0C,0x2B,0x63,0x6C,
+0x27,0x9F,0xC0,0xFC,0xB3,0xB6,0x6D,0xFF,
+0x2F,0x69,0xC4,0xD7,0xA2,0xD6,0xB6,0x58,
+0x27,0x3E,0x7E,0x81,0x59,0xD9,0x39,0x03,
+0x2F,0x0D,0xFD,0x6C,0x1F,0x69,0x9A,0x4F,
+0x27,0xBB,0x4B,0xD3,0x27,0x83,0x9A,0x82,
+0x2F,0x6C,0x35,0x3E,0xAA,0x42,0xE0,0x83,
+0x27,0xD7,0xE3,0x9C,0x3A,0xBD,0x63,0x1B,
+0x27,0x5F,0x62,0xE9,0x97,0x06,0x7C,0xAF,
+0x2F,0xB1,0x6A,0xAB,0x56,0x8F,0xF5,0x37,
+0x2F,0xD8,0xC2,0x84,0x22,0x37,0xC3,0x68,
+0x2F,0xCE,0x69,0x3E,0x93,0x92,0x25,0x0A,
+0x2F,0x82,0x9B,0x04,0x16,0x62,0x38,0x0D,
+0x2F,0xA5,0x9B,0x08,0xD6,0xD5,0x1A,0xE2,
+0x27,0x58,0x2F,0x61,0xE0,0x3F,0xB3,0x5F,
+0x2F,0x44,0x1F,0x53,0x54,0xB3,0xF0,0x0B,
+0x27,0xC5,0x61,0xD4,0x10,0x23,0x8E,0x53,
+0x27,0x6D,0x70,0xB6,0x8F,0xAB,0xF7,0xF0,
+0x2F,0xF5,0x44,0x86,0x10,0x72,0xB5,0x41,
+0x27,0x86,0xE6,0x0E,0x07,0x44,0xAF,0x42,
+0x27,0x25,0x29,0x60,0x59,0x78,0x39,0xB6,
+0x27,0xC2,0xE2,0x16,0xDD,0xC5,0x4C,0x0E,
+0x27,0x5D,0x77,0x9C,0xA4,0x77,0xC6,0xD3,
+0x27,0x56,0x7A,0xB0,0x94,0x36,0x94,0x71,
+0x27,0xA1,0x00,0x37,0x28,0x8C,0x7E,0x5A,
+0x27,0xFB,0x7B,0x7A,0x2E,0x0C,0x74,0x94,
+0x27,0x98,0x96,0xC0,0x93,0x44,0xC0,0x0E,
+0x2F,0xA2,0x9E,0x73,0xDB,0x28,0x30,0x67,
+0x2B,0x54,0x99,0xA0,0x36,0xFA,0xE0,0x0E,
+0x27,0xA6,0xC7,0x09,0x05,0xF3,0xF6,0x79,
+0x2F,0xE6,0x31,0xFB,0x3B,0xFD,0xC7,0x19,
+0x2F,0x74,0x34,0x09,0x0B,0xCB,0x23,0x0D,
+0x27,0xA1,0xD1,0xE5,0x15,0x2C,0x28,0x1A,
+0x27,0xFF,0x6D,0xF4,0x8A,0xD1,0xBB,0x2F,
+0x2F,0x7C,0x9F,0x73,0x05,0x5A,0xBD,0x6F,
+0x27,0x70,0xFF,0xAA,0xA9,0x5F,0xD8,0xBF,
+0x23,0x11,0xF8,0xEC,0x09,0x7B,0xA3,0xB4,
+0x0F,0x2B,0xCC,0x07,0x26,0x3E,0xAA,0x85,
+0x0F,0x0C,0xD6,0x7F,0x56,0x59,0xA4,0x80,
+0x07,0xD3,0xDB,0x8A,0x83,0x71,0x0B,0xC6,
+0x07,0x9C,0xA8,0x42,0x7C,0x52,0xF7,0x7A,
+0x0F,0x3F,0xC6,0xF6,0x2C,0x76,0xD6,0xF7,
+0x27,0x26,0x93,0x83,0x9F,0xA8,0x19,0x9D,
+0x22,0x4A,0x2E,0x56,0x0C,0x05,0x6A,0xDD,
+0x0F,0x67,0xAC,0xCF,0x70,0x7A,0x99,0x70,
+0x27,0x6A,0x5C,0x33,0xE2,0xFF,0x69,0x1A,
+0x27,0x0A,0xC6,0xED,0x2A,0xEE,0x1E,0xA9,
+0x2F,0x3E,0x76,0xB1,0x0D,0x1F,0xC1,0x09,
+0x27,0x98,0xA7,0xC3,0xB4,0x73,0xD3,0x8C,
+0x2F,0x8D,0x61,0xA8,0xFC,0x20,0x9C,0x71,
+0x2F,0x1E,0xDA,0xC7,0xFD,0x83,0x75,0x34,
+0x27,0x17,0x6F,0x90,0x8C,0x18,0x25,0x1A,
+0x2F,0xCF,0xC6,0x8E,0x96,0xF2,0xDC,0xEA,
+0x2F,0x05,0xC9,0x10,0x99,0xD6,0x99,0x59,
+0x2F,0x1A,0x2D,0x82,0xCF,0xCA,0xE2,0x65,
+0x27,0x3B,0xC2,0x9F,0x09,0x3B,0x8F,0xF4,
+0x27,0x7B,0x26,0x24,0x46,0xDE,0x7B,0x7F,
+0x27,0x6E,0xF2,0xF8,0x68,0xFC,0x68,0xAB,
+0x27,0x1C,0x74,0xA7,0x48,0xB4,0xDE,0x59,
+0x27,0xC2,0xE7,0x18,0x14,0x33,0xAB,0x02,
+0x07,0x01,0x89,0xE7,0x85,0xAB,0xD1,0x19,
+0x2F,0x5A,0x73,0x10,0x0A,0xE1,0x9F,0xF8,
+0x2F,0x33,0x2D,0xC4,0x51,0x73,0x07,0xFC,
+0x2F,0x78,0xFA,0x10,0x5E,0xDA,0x83,0xB8,
+0x27,0x29,0x53,0xC3,0x9B,0x02,0x3B,0x07,
+0x27,0x09,0x7A,0xF4,0xB6,0xFF,0xEC,0x9F,
+0x2F,0x21,0x49,0x40,0x49,0x74,0x99,0xA9,
+0x2F,0x42,0x51,0xFC,0x11,0x11,0x58,0x17,
+0x27,0x5A,0xD1,0x69,0xE9,0xC7,0xC0,0x32,
+0x07,0x70,0x28,0x7C,0x89,0x1F,0x74,0x9E,
+0x2F,0x06,0x06,0x08,0x49,0xD7,0x13,0x4F,
+0x2F,0xD5,0x71,0x5D,0x6F,0x66,0xB4,0x70,
+0x27,0x52,0x6E,0x78,0xB6,0x0C,0x59,0xB8,
+0x2F,0x94,0x84,0x3F,0xEC,0xAE,0x59,0xEC,
+0x2F,0x00,0x66,0x02,0x64,0x73,0xD1,0x86,
+0x27,0x30,0x52,0x96,0x42,0x9E,0x9A,0xD7,
+0x2F,0xDC,0x52,0x87,0x6E,0x56,0x3D,0x9C,
+0x27,0x8F,0x4D,0x09,0xC6,0x80,0xB9,0x70,
+0x26,0x3F,0x89,0x6A,0xCA,0xCC,0x8E,0x15,
+0x0F,0xC3,0x42,0xEF,0x5D,0x46,0xBA,0xC0,
+0x2F,0xAB,0xE2,0x2C,0x22,0xE8,0xAA,0x77,
+0x2F,0x9F,0xF2,0x5A,0x22,0x7C,0x5F,0x59,
+0x2B,0xDC,0x4A,0x8B,0x8D,0x9E,0xCC,0xA5,
+0x0F,0xB6,0x22,0xC3,0xC7,0xE1,0x44,0x93,
+0x27,0x38,0xE4,0x24,0x4B,0x1C,0x32,0xB0,
+0x2F,0xCB,0x77,0xD9,0x75,0x98,0xFE,0x93,
+0x2A,0x19,0xC5,0x04,0x48,0x26,0x97,0x86,
+0x07,0x3F,0x57,0xCA,0xDE,0xB6,0xB6,0xFC,
+0x27,0x12,0x36,0x5A,0xC7,0xE2,0xA5,0x83,
+0x2F,0x3F,0x91,0x6D,0xCF,0x8E,0x8D,0x30,
+0x27,0x3B,0x20,0x62,0x2B,0x38,0xC0,0x19,
+0x27,0xBA,0x2D,0x92,0xE4,0xD7,0x21,0x54,
+0x2F,0x62,0x09,0x70,0x89,0x4A,0xEE,0x40,
+0x07,0xBE,0x30,0xF1,0x4F,0x56,0xA8,0x6E,
+0x2F,0x5D,0x82,0xC5,0x24,0x87,0xA5,0xA2,
+0x2F,0x96,0xF0,0xD2,0x74,0x43,0x26,0x34,
+0x2F,0xAA,0x22,0x1F,0x93,0x87,0x56,0x2C,
+0x07,0x1F,0xBD,0x7B,0x6C,0xE6,0x19,0x82,
+0x27,0x36,0x85,0x50,0x38,0xCC,0x2C,0x39,
+0x2F,0xE2,0xE7,0xB3,0x67,0x08,0x07,0xE2,
+0x27,0xE6,0xF0,0xED,0x6D,0x23,0x1F,0xA9,
+0x27,0x85,0xA5,0xF6,0x20,0x3B,0xC7,0x18,
+0x27,0xC6,0x1D,0xB2,0xAC,0x2C,0xB1,0x53,
+0x2B,0x06,0xB8,0x47,0xC8,0x3A,0xDA,0xFF,
+0x0F,0x5A,0x6E,0x4A,0xD9,0x87,0xA6,0xAC,
+0x27,0x44,0xF4,0x69,0xC9,0x45,0x1B,0xF3,
+0x2F,0x95,0x35,0x58,0xB8,0x21,0x34,0x8D,
+0x27,0x7A,0x8B,0xCD,0x94,0xD3,0x6B,0x0A,
+0x2F,0x47,0x55,0x74,0x10,0x7D,0x91,0xF8,
+0x2F,0xC0,0xAA,0x3A,0xD1,0x4C,0xA6,0xE2,
+0x22,0x87,0xCA,0xBF,0xE2,0xFA,0x5C,0xFF,
+0x0F,0x76,0xBA,0xAD,0x5F,0xBC,0x79,0x55,
+0x27,0xF8,0xC1,0x39,0x8E,0x04,0x66,0x48,
+0x27,0xC8,0x9D,0xC4,0x74,0xC3,0x30,0x72,
+0x2F,0x6D,0xCB,0x9A,0xBF,0x91,0x44,0x16,
+0x27,0xF3,0x10,0x5A,0xCC,0x2B,0x09,0x40,
+0x27,0x60,0xFA,0x25,0xFF,0x71,0x02,0xC9,
+0x2F,0x69,0x9D,0xA7,0x08,0xA1,0x4B,0xA0,
+0x27,0x8D,0x5C,0x1B,0x7C,0xBD,0xC7,0x2A,
+0x27,0xD9,0x2F,0x58,0xE3,0x27,0xCA,0x59,
+0x27,0x12,0x5C,0x91,0x96,0x14,0xC3,0x50,
+0x2F,0x6C,0x6F,0x83,0xA7,0x0A,0x8E,0x8E,
+0x2F,0x4E,0x37,0x7F,0xB8,0x1A,0x8E,0x83,
+0x27,0x5A,0x40,0xA0,0xFE,0xC3,0xDE,0xE9,
+0x27,0xD0,0xE5,0xA6,0xE5,0x28,0x11,0x46,
+0x27,0xE0,0x6B,0x3E,0xBC,0x5A,0x8C,0xDB,
+0x27,0xAA,0x8F,0x45,0x4E,0x7E,0xC4,0xEC,
+0x24,0x2E,0x5E,0x4B,0x44,0xB6,0x45,0x0C,
+0x07,0x78,0x54,0xB3,0x24,0xEE,0xB9,0x6A,
+0x27,0x5C,0xDF,0xEC,0x63,0x54,0x69,0x24,
+0x2F,0x89,0x9A,0x4D,0x80,0x3F,0x8F,0xB1,
+0x27,0x86,0x4C,0x02,0x07,0x7E,0x13,0x7E,
+0x2F,0x4D,0x0E,0xFA,0x6B,0xEE,0xE3,0x4E,
+0x2F,0x9A,0x51,0x1D,0x18,0x1D,0xA2,0x5B,
+0x27,0x47,0xF9,0x76,0x79,0x17,0x81,0x3F,
+0x2F,0x7E,0x24,0xD7,0xA6,0x14,0xA5,0x3B,
+0x2F,0x53,0xAA,0x09,0xF7,0x65,0xC8,0xEE,
+0x27,0x4A,0xFC,0x61,0x5F,0x7B,0xAB,0xFB,
+0x26,0x49,0xA5,0x7C,0xC8,0xAA,0x4B,0xDD,
+0x07,0x15,0x2E,0x15,0x14,0xA7,0xE7,0xC4,
+0x07,0x1C,0x68,0xD8,0x61,0x8D,0xB6,0x9B,
+0x27,0x07,0x18,0x32,0xBA,0x4E,0x93,0xD1,
+0x27,0x53,0xF0,0xD1,0x94,0xA3,0x80,0x06,
+0x22,0x95,0x51,0x30,0x4D,0x6F,0x16,0x52,
+0x07,0xDD,0xDC,0x2D,0xF5,0x6A,0x0A,0xFE,
+0x2F,0xFD,0x00,0x06,0x6E,0xC2,0x7F,0x31,
+0x2F,0x96,0x74,0xB6,0xDE,0x9C,0xD3,0xDD,
+0x2F,0x16,0x59,0xB0,0x6D,0xFC,0xA6,0x76,
+0x29,0xF4,0xDD,0x3D,0xE6,0x68,0x21,0xC4,
+0x07,0x10,0x8E,0x65,0x84,0x3F,0xC8,0x6E,
+0x2F,0xB5,0x9B,0x84,0x0B,0x86,0xD6,0x5E,
+0x2F,0x25,0x80,0xF3,0xC4,0xF5,0x21,0x66,
+0x27,0x12,0xCF,0x43,0x77,0xB8,0xED,0x45,
+0x27,0x55,0x48,0xD3,0x7D,0x1F,0x95,0x6C,
+0x2D,0x34,0xD7,0x8B,0x3F,0x10,0xA3,0x47,
+0x0F,0x96,0xD4,0x5C,0x81,0xB2,0x84,0x25,
+0x2F,0xBA,0x9B,0xB2,0x8D,0x79,0xB8,0x3E,
+0x27,0x04,0xA7,0x4C,0x7A,0x45,0x92,0x66,
+0x27,0x3F,0x7B,0x39,0xA5,0x67,0x21,0xC2,
+0x27,0xA1,0x3E,0x67,0x17,0x7B,0x0F,0x11,
+0x27,0xB1,0x55,0x7B,0x24,0x80,0x1C,0x36,
+0x2F,0xAE,0x40,0x86,0xCA,0xA8,0xA6,0x13,
+0x27,0xC7,0xE0,0x9A,0x79,0x9C,0xF2,0xC8,
+0x2F,0x96,0x66,0x20,0xCF,0x41,0x82,0x09,
+0x2F,0x3F,0xC4,0x25,0x41,0xEC,0x7B,0xEA,
+0x2F,0x3B,0xE6,0xB4,0x99,0xED,0x42,0xCF,
+0x2F,0x0A,0x9F,0x49,0x5A,0xD9,0x0A,0xC6,
+0x07,0xEF,0x47,0xE4,0x0E,0x69,0xF7,0xF6,
+0x0F,0x57,0xEE,0x7E,0xD5,0x18,0xCD,0x17,
+0x0F,0x5E,0x2E,0x58,0xF1,0x14,0x0D,0x99,
+0x0F,0x2B,0xD2,0x01,0x16,0x81,0x7E,0xFF,
+0x2F,0x42,0x0F,0xC4,0x97,0xFF,0x94,0x91,
+0x2F,0x2F,0x1E,0x65,0xD4,0xCA,0x10,0x4B,
+0x25,0x96,0x7F,0xC3,0x25,0xFD,0xE0,0x9E,
+0x0F,0x77,0x27,0xE4,0x13,0xC0,0xBB,0x3C,
+0x27,0x0E,0xBB,0x60,0xFF,0xC0,0x88,0xA4,
+0x27,0x42,0xCC,0x24,0x2A,0xCB,0xA5,0xFF,
+0x27,0x74,0xD9,0xE9,0xFD,0x6D,0x30,0xFC,
+0x27,0x3B,0x39,0xCC,0x41,0x8D,0x01,0xCA,
+0x2F,0x70,0xBD,0xF1,0x38,0xEF,0x22,0x63,
+0x24,0x5E,0x54,0xB3,0x79,0xBA,0x7B,0xBA,
+0x07,0x3A,0xC5,0xBA,0x83,0x85,0x61,0xB9,
+0x0F,0x8A,0x97,0x6A,0x93,0x08,0x72,0x4A,
+0x07,0xAF,0x46,0x26,0x27,0xBE,0x5F,0x30,
+0x0F,0x79,0x53,0xFA,0xEC,0xDD,0xF5,0xDF,
+0x2F,0xA1,0xBF,0x3B,0x6B,0xF6,0x65,0xF5,
+0x2F,0xC3,0xC3,0xC3,0x63,0xD0,0x2E,0x56,
+0x2F,0xD2,0xE0,0x1C,0xAC,0xA9,0x37,0x5F,
+0x27,0x9B,0xC5,0x5C,0x8F,0xC7,0x7A,0x3C,
+0x2B,0x9E,0x00,0x31,0x2F,0x62,0x83,0x17,
+0x0F,0x66,0x40,0x34,0xAE,0x82,0x56,0x07,
+0x27,0x09,0xA8,0x95,0x20,0x26,0x09,0xFC,
+0x2A,0x16,0xA0,0xED,0x5C,0xE6,0xB9,0x80,
+0x0F,0x5A,0x6C,0x1A,0x09,0x2F,0x35,0xCD,
+0x27,0x50,0x2E,0xBB,0x6C,0x51,0x14,0xB5,
+0x27,0x70,0x54,0x56,0x07,0x7C,0x1B,0x61,
+0x2F,0x29,0x81,0x08,0x41,0xCA,0x3D,0xCD,
+0x2F,0xC5,0x37,0x1E,0xCA,0x96,0x0A,0x82,
+0x27,0x21,0x0D,0xD8,0xD7,0x4C,0xF7,0x4B,
+0x2F,0xD3,0x35,0xF0,0x84,0xFD,0xCF,0xB4,
+0x27,0xD1,0x5C,0xD3,0x8A,0xB4,0x1E,0xD6,
+0x2F,0x04,0xFA,0x28,0x48,0x05,0xC2,0x94,
+0x2F,0xC9,0x66,0xCD,0x2D,0x77,0xBC,0x58,
+0x2F,0x63,0x20,0x0F,0x8E,0x18,0x99,0x74,
+0x27,0xF2,0x78,0x1A,0x5E,0x17,0x43,0x61,
+0x2F,0x26,0xA5,0x5B,0x14,0x9B,0x6C,0x4C,
+0x2F,0xBA,0xC4,0x03,0x3E,0xE5,0xAC,0xEC,
+0x27,0x5E,0x8D,0x0D,0xAF,0x0F,0x44,0x77,
+0x27,0x29,0x3C,0xC4,0xFC,0x64,0x6B,0x4C,
+0x2F,0x4B,0x8C,0xE0,0x06,0x31,0x93,0xCB,
+0x27,0xF4,0x4D,0x38,0x7F,0x98,0x3D,0xB4,
+0x27,0xEB,0x1A,0xB4,0x2F,0x15,0x1E,0xEA,
+0x27,0x6B,0xED,0xE0,0xA3,0x13,0x4C,0xC5,
+0x2F,0x77,0xAA,0x58,0x31,0x0C,0xAB,0xF5,
+0x23,0x05,0xA1,0x61,0x4A,0xEC,0xDB,0xE1,
+0x0F,0x67,0x02,0xC2,0xAA,0x83,0x51,0x5F,
+0x2F,0x02,0xE4,0x30,0x84,0x05,0x10,0xEB,
+0x2A,0xCF,0x84,0x1A,0xD0,0x10,0x6D,0x7B,
+0x07,0x09,0x53,0xAB,0xBE,0xC4,0x91,0x33,
+0x2F,0x7D,0xF4,0xED,0x7F,0xBC,0x84,0x7F,
+0x27,0x49,0xB2,0xCE,0xB1,0xF2,0xFD,0x27,
+0x27,0x9C,0xB5,0xB8,0x91,0xDF,0xD1,0xE7,
+0x27,0x5E,0x32,0x21,0xC4,0x4B,0x64,0x91,
+0x27,0x42,0xD5,0x8A,0x5C,0xC5,0xC7,0x42,
+0x27,0xAD,0x05,0x97,0xAF,0xDB,0x74,0x5A,
+0x27,0x8D,0xB8,0x82,0x0D,0xFD,0x57,0x82,
+0x27,0x66,0x4E,0xC5,0x0E,0x7B,0xFE,0xED,
+0x0F,0xAC,0x4C,0x29,0x56,0xCB,0x36,0xA6,
+0x0F,0xDB,0x09,0x8B,0x3D,0x71,0x85,0x45,
+0x0F,0x32,0xC5,0x4B,0x1D,0x3B,0x08,0xB7,
+0x07,0x49,0xF4,0x32,0x1C,0x0E,0x75,0xC1,
+0x27,0x5F,0x11,0xDC,0x0B,0x76,0x9D,0xB4,
+0x2E,0xB0,0x17,0xAD,0x6E,0x6A,0x89,0x9B,
+0x0F,0xAF,0x1B,0x5C,0x92,0xE3,0xCE,0x17,
+0x0F,0x85,0x55,0x70,0x25,0xE7,0xF5,0x33,
+0x25,0x42,0xF3,0x1F,0xF7,0x69,0xAF,0xEE,
+0x0F,0xD5,0x85,0xBE,0x6C,0xD9,0x60,0xBD,
+0x07,0xE4,0xA0,0x9C,0x20,0x2E,0xAD,0xE6,
+0x07,0x09,0x04,0x83,0xD1,0xF5,0xA9,0xFF,
+0x27,0x72,0x86,0xBD,0xFE,0x36,0xF6,0xC2,
+0x2F,0x99,0x79,0xD4,0x09,0xDE,0x0E,0x9E,
+0x2F,0xD0,0x57,0x2E,0x51,0x89,0x0A,0xA7,
+0x27,0x91,0x76,0x58,0x66,0xA2,0x6B,0x6F,
+0x24,0x4F,0x09,0x68,0xAA,0x8C,0xAA,0x40,
+0x07,0x70,0x93,0x6B,0x23,0x8B,0xEC,0x2A,
+0x0F,0x20,0xE4,0x4A,0xC8,0x26,0x78,0x28,
+0x2A,0x92,0x35,0x37,0xD5,0xB4,0xC1,0xE3,
+0x07,0xBC,0x34,0x5C,0xA0,0x5B,0x6F,0x52,
+0x25,0xC3,0x39,0xD8,0x7E,0x44,0xBD,0x7C,
+0x0F,0xC4,0x52,0x72,0xB9,0xC0,0x99,0xF6,
+0x27,0xEB,0xFC,0x6B,0x09,0x5F,0xE5,0x06,
+0x27,0xE0,0x05,0xA2,0x27,0x32,0x7F,0xB7,
+0x27,0xB1,0xCF,0x4D,0x11,0x0A,0xCA,0xBB,
+0x23,0x12,0xA5,0x18,0x01,0xBE,0x6C,0x8D,
+0x0F,0xF0,0x14,0xA9,0xF2,0x94,0xFD,0x5A,
+0x2F,0xD1,0x32,0x70,0xCC,0xA0,0x99,0xD6,
+0x27,0x4A,0xD8,0x57,0xD0,0x49,0x99,0x2A,
+0x2F,0x4F,0x93,0xC1,0xDB,0x54,0xEE,0x29,
+0x2F,0x4B,0x25,0x9A,0xFC,0xED,0x87,0x52,
+0x27,0x64,0x9F,0x82,0xE0,0xC3,0x8C,0x84,
+0x2F,0x90,0x91,0xAB,0x03,0x42,0x74,0x12,
+0x2F,0x60,0x53,0x89,0xF5,0xAF,0xC9,0x89,
+0x2F,0x47,0xBE,0xEF,0x42,0xE8,0xA4,0x51,
+0x27,0x39,0x05,0x38,0xE5,0x79,0x78,0xE5,
+0x27,0x5D,0x2C,0x62,0x28,0xDF,0xB4,0x5F,
+0x27,0xE2,0x9A,0x7E,0x28,0xEB,0x21,0xC3,
+0x2D,0xDB,0x43,0x0D,0x55,0x18,0x74,0x46,
+0x0F,0xCF,0x0F,0x90,0x21,0xC5,0x32,0x0C,
+0x2F,0x13,0xB4,0x48,0x3B,0x35,0xFD,0x66,
+0x2F,0x27,0x92,0x64,0xE8,0xC0,0xF1,0xB1,
+0x2F,0x38,0xCD,0xCA,0xDF,0x48,0x66,0x7D,
+0x2F,0x36,0x80,0x2F,0x2A,0xDA,0x68,0xDC,
+0x27,0xB4,0x9C,0xF3,0xAC,0xC7,0x70,0x64,
+0x2F,0x16,0x69,0xF0,0x33,0xF3,0x42,0x7A,
+0x27,0x90,0x0C,0xB5,0x6E,0xDB,0xD3,0x6B,
+0x2F,0xEE,0x4E,0xD5,0xEB,0x22,0x69,0xD2,
+0x2F,0x44,0x9F,0xF2,0x60,0xA9,0xC2,0xB6,
+0x2F,0x4D,0x44,0xB6,0x86,0x1D,0x6E,0xD1,
+0x27,0xD3,0x19,0x67,0x29,0x8C,0xC5,0x74,
+0x2F,0x7D,0x4C,0x0C,0x7F,0x3F,0x9E,0xE8,
+0x27,0x0A,0x7C,0x47,0xE0,0x58,0x46,0xF5,
+0x23,0x67,0x71,0x1B,0x71,0xF5,0x2B,0x63,
+0x07,0x9C,0x65,0x3C,0xB9,0x3F,0x9C,0x98,
+0x2F,0x22,0x40,0xAB,0x08,0xB6,0xAE,0xED,
+0x2F,0xC0,0xAE,0x06,0x5B,0x2D,0x19,0x43,
+0x27,0xD1,0xE4,0xAA,0x4C,0xAD,0xD5,0x80,
+0x27,0xE1,0x7F,0x7C,0xFC,0x8A,0xC6,0xCC,
+0x27,0x84,0x4C,0x37,0xB5,0x32,0x60,0x67,
+0x27,0xCC,0xE7,0x44,0x99,0xE0,0x25,0x92,
+0x2F,0x34,0x5E,0xBA,0x0F,0x90,0x1C,0xC0,
+0x27,0x0C,0x07,0xF8,0x47,0xA6,0xF1,0x95,
+0x2F,0x52,0xF9,0x84,0x82,0x4D,0xB4,0x6B,
+0x2F,0x91,0x3A,0xA3,0xB4,0x8E,0xD3,0x1D,
+0x2F,0x5D,0xC7,0x5B,0x3D,0x3E,0x4F,0x11,
+0x2E,0x23,0x91,0xA8,0x4D,0x31,0xDC,0x06,
+0x07,0x45,0xB3,0x91,0x45,0x24,0x65,0x0F,
+0x27,0x74,0xCF,0x30,0xAE,0x89,0xE1,0xAB,
+0x0F,0x0F,0xC2,0xB5,0xD4,0xCA,0xB4,0x98,
+0x2F,0x4A,0xB0,0x1D,0x7C,0xBF,0x1F,0x76,
+0x2F,0xB4,0x14,0xFC,0x16,0x85,0x5A,0xC5,
+0x2F,0x82,0xAA,0xE4,0xF4,0x12,0x0F,0x64,
+0x27,0x1F,0x40,0xAC,0x00,0x89,0xF4,0x9D,
+0x0F,0x00,0x73,0xF2,0xC6,0x20,0xBF,0xEF,
+0x2F,0x07,0x1A,0x8C,0x7C,0x49,0x84,0x1C,
+0x21,0x13,0x08,0x30,0x44,0xDB,0xB5,0xED,
+0x07,0x1B,0x88,0xDE,0xB1,0x8E,0xA0,0xED,
+0x2F,0x60,0x10,0x40,0x40,0xE7,0x7F,0x8B,
+0x2F,0x27,0x51,0x4F,0xC3,0x18,0xB2,0x14,
+0x2D,0x0E,0xBD,0x51,0x11,0x20,0x2D,0x20,
+0x0F,0xB6,0x74,0xB4,0xB8,0x33,0x7B,0xA1,
+0x2A,0x21,0xC7,0x3C,0x7A,0xCD,0x07,0x09,
+0x07,0xA2,0x85,0x93,0xE5,0x07,0x00,0x9A,
+0x25,0xAB,0x10,0x72,0xEE,0x95,0xD4,0xD4,
+0x0F,0xA1,0x3E,0x1E,0xF3,0x09,0x3D,0x15,
+0x2F,0x08,0xB4,0x2D,0xD6,0x95,0xD9,0x14,
+0x27,0xA2,0x3E,0xAA,0x79,0x4E,0x78,0x5F,
+0x2F,0x53,0xD2,0x3D,0xE6,0x6B,0x93,0x27,
+0x27,0x7B,0xD9,0xC1,0xE5,0x08,0x9C,0xF1,
+0x2F,0xAA,0x20,0x6B,0x6C,0xBD,0x1E,0x9D,
+0x2F,0x7B,0x3A,0x39,0x52,0x51,0x83,0xED,
+0x27,0x92,0xB7,0x38,0x75,0x0E,0xB1,0x2B,
+0x27,0x9A,0x40,0x11,0xDC,0x06,0x2B,0x1E,
+0x27,0xFE,0x34,0xBC,0x59,0x6E,0x31,0xF3,
+0x2F,0x8D,0xFC,0xB5,0x4F,0x4C,0xB5,0x52,
+0x27,0xA0,0x4A,0x70,0x02,0xFB,0xD7,0xD1,
+0x27,0xEA,0x01,0x87,0xBE,0x8D,0x29,0xC6,
+0x2F,0x39,0xC3,0x8B,0xB7,0x96,0xC2,0x56,
+0x2F,0x50,0xE6,0xF4,0x50,0x03,0xBA,0x61,
+0x27,0x02,0xCC,0x03,0xAF,0x2F,0x3F,0xAC,
+0x27,0xAB,0x69,0xD0,0xCF,0xA7,0x4B,0x76,
+0x27,0xDF,0x31,0x4B,0xDE,0x55,0x54,0x19,
+0x2F,0x98,0xCB,0x8A,0x7F,0x1F,0xE3,0x62,
+0x2F,0x45,0x33,0x58,0xAD,0x03,0x57,0x81,
+0x2F,0x6D,0xC9,0xAA,0xDF,0x20,0x6E,0xF0,
+0x27,0xBC,0x1F,0x99,0xF3,0xDC,0x86,0xB5,
+0x27,0x19,0xE3,0x17,0x86,0x74,0xB8,0xFE,
+0x2F,0xED,0xCC,0x7F,0x97,0x47,0xFA,0xBB,
+0x27,0xB5,0xD9,0xC0,0xD1,0x7B,0x5E,0x9C,
+0x27,0xDA,0x1F,0x04,0xD9,0x0B,0xE2,0xB4,
+0x27,0xFF,0x8B,0xEF,0x7E,0x3A,0x4E,0xB9,
+0x2B,0xB0,0x49,0x12,0xA0,0x7E,0x02,0x5B,
+0x07,0x7D,0xAF,0x99,0x07,0xCC,0x75,0xF7,
+0x26,0x7C,0x3B,0xDC,0xBC,0xFC,0x49,0xCA,
+0x0F,0x8A,0x20,0x87,0x5D,0x14,0xF8,0xA6,
+0x27,0xB0,0xD5,0x65,0xFA,0xD1,0x0A,0xD7,
+0x27,0x3C,0x1A,0x67,0xE4,0x22,0x02,0xC8,
+0x27,0xA9,0x1B,0x72,0x33,0x88,0xAA,0x85,
+0x27,0x0E,0xCD,0x9D,0x2B,0x7F,0x2D,0xD7,
+0x27,0x78,0xA1,0xA1,0xF3,0x7C,0x03,0x6F,
+0x2F,0x1B,0x8D,0x6C,0xD7,0xF4,0xB1,0x05,
+0x2F,0x70,0x87,0x41,0xA8,0x8C,0x10,0xA6,
+0x2C,0x35,0x20,0x16,0x97,0x0B,0x8A,0xED,
+0x0F,0x15,0x1D,0xA2,0x5E,0x45,0xD3,0xC5,
+0x27,0x2C,0x0F,0xBD,0x38,0x35,0xC6,0x5F,
+0x2F,0x57,0x2A,0x4E,0x04,0xEB,0x1D,0x7C,
+0x27,0xBE,0x8B,0x7C,0x95,0x61,0xE8,0xCB,
+0x2F,0xBC,0xD4,0xC3,0xE3,0x0D,0x7A,0x30,
+0x27,0xC4,0x21,0x3B,0x73,0x01,0x99,0xDE,
+0x25,0x34,0x18,0xBB,0x31,0xC5,0x15,0x08,
+0x0F,0x50,0x89,0x4D,0x52,0x71,0x92,0xE3,
+0x2B,0x74,0xF0,0x5D,0xE7,0x28,0x74,0x47,
+0x0F,0x9B,0x52,0x53,0x3D,0x32,0x1F,0x7E,
+0x27,0x38,0x66,0xA1,0x48,0x1E,0x0E,0xD0,
+0x2F,0x13,0xF7,0x78,0x24,0xE7,0x4C,0xB6,
+0x29,0x11,0x9F,0xBA,0xA8,0x82,0x76,0x88,
+0x0F,0xC5,0x68,0x52,0xA8,0x98,0x41,0x7B,
+0x27,0xF4,0x5D,0x97,0x5B,0x2A,0xB5,0x9E,
+0x2F,0xF4,0x8A,0xE9,0x82,0xED,0x88,0x0F,
+0x27,0xC0,0x5B,0xB8,0xF8,0x53,0xC0,0x78,
+0x22,0x96,0x2E,0x0C,0x35,0xD3,0x60,0xB6,
+0x07,0x8F,0xDD,0x53,0xEE,0x41,0x75,0xC7,
+0x23,0xFB,0xC4,0xEB,0x71,0x45,0x70,0xCA,
+0x07,0x55,0x30,0xCF,0xEB,0xD0,0x69,0x85,
+0x2F,0x19,0xB4,0xB2,0xE0,0x96,0x3D,0x7D,
+0x2F,0xD4,0xDE,0x25,0xFF,0xCD,0x9B,0xAD,
+0x29,0xD9,0x0F,0x39,0xF5,0xCF,0x6C,0xF5,
+0x07,0x16,0xAA,0x3E,0x5D,0xE8,0xDC,0xE5,
+0x0F,0xFA,0x0B,0xA3,0xA6,0xC1,0x28,0x24,
+0x07,0x4E,0x25,0xA6,0x64,0x41,0xE4,0xDD,
+0x2C,0xED,0x9B,0x2D,0x69,0x43,0x68,0x8B,
+0x0F,0x2C,0xB0,0x8D,0x2F,0x87,0x58,0x82,
+0x2F,0xCF,0xA3,0xA6,0x34,0x85,0x77,0x3F,
+0x2F,0x9F,0x74,0x2E,0x81,0x54,0x64,0x40,
+0x2A,0xA6,0xEA,0xC1,0xDE,0xF0,0x4F,0xFC,
+0x07,0x09,0x4E,0x1E,0xD1,0x2D,0x91,0x04,
+0x07,0x81,0x03,0xE9,0x60,0x92,0x34,0xC8,
+0x07,0x56,0xD8,0x69,0xCA,0xD0,0x9C,0x50,
+0x2F,0x24,0x86,0x22,0x65,0xC2,0x00,0xB6,
+0x27,0xA9,0x07,0x54,0x03,0x61,0x4D,0x31,
+0x2F,0x26,0x00,0x6F,0x75,0x5E,0x60,0x5D,
+0x27,0xB2,0xA8,0xD5,0x5A,0xEE,0xE7,0xC5,
+0x22,0x43,0x1E,0x8E,0xB1,0x9A,0x9F,0x5C,
+0x0F,0x0B,0xD5,0x21,0x6A,0x6B,0xA2,0xF7,
+0x27,0x84,0xC6,0x1F,0x77,0xCF,0x40,0xBF,
+0x2F,0x1D,0xAA,0x6E,0x17,0x04,0x91,0x12,
+0x25,0xE6,0x94,0xB8,0x4B,0x56,0xAC,0xAB,
+0x07,0x43,0x87,0xC3,0xA1,0xE1,0xF5,0x35,
+0x2F,0x82,0xEC,0x75,0xEE,0x18,0x86,0xC8,
+0x2F,0xD4,0x89,0xB1,0x05,0x1C,0x87,0x1E,
+0x2F,0xA0,0xC9,0x6D,0x82,0x88,0x91,0xBE,
+0x2F,0x11,0xB4,0x4D,0x77,0xC0,0x1B,0x51,
+0x27,0x94,0x19,0xBE,0xB9,0x4B,0xAF,0x8A,
+0x27,0x20,0x2B,0xA5,0xB0,0xCB,0x00,0x53,
+0x2F,0x3F,0x77,0xD8,0xF1,0x9F,0xE3,0x5A,
+0x27,0xF6,0x3D,0x86,0xCA,0x8C,0x1A,0xD0,
+0x2D,0xD4,0x5E,0x18,0xAE,0x72,0x4D,0x60,
+0x0F,0xC4,0x8F,0xFB,0x7B,0xBB,0xDC,0x6B,
+0x2F,0x66,0x6D,0x58,0x1B,0x72,0xD1,0x84,
+0x27,0x31,0x44,0x6C,0x2A,0x18,0xDB,0x48,
+0x24,0x52,0xE5,0x00,0x0A,0x04,0xA7,0xDD,
+0x0F,0xA9,0xCC,0x71,0x35,0x7B,0xC0,0xDB,
+0x22,0x05,0xB3,0x25,0xAE,0x4F,0x1D,0x7C,
+0x07,0x23,0x9A,0x73,0x0F,0x3A,0xE6,0x6C,
+0x07,0xA3,0x4D,0xE1,0x80,0x1F,0xBF,0xC8,
+0x07,0x40,0x8D,0x7C,0x63,0xB9,0x6A,0x67,
+0x27,0x94,0x3C,0xB2,0x77,0x08,0x74,0x7B,
+0x27,0xD0,0xB6,0x69,0x26,0xAE,0x0F,0x80,
+0x2F,0x08,0x05,0x93,0xF3,0xB5,0x72,0x58,
+0x2F,0x90,0x96,0x7B,0xFD,0x27,0x09,0x6C,
+0x2F,0xEC,0xE4,0x48,0x31,0x65,0x93,0x1B,
+0x27,0x4F,0xB0,0xA9,0xD7,0xF6,0xC0,0xB2,
+0x27,0x62,0x89,0x87,0xD8,0xFA,0x05,0x02,
+0x27,0x65,0xAE,0xDE,0xBB,0x4D,0x24,0x8D,
+0x2B,0xD7,0x1A,0xE7,0x6E,0x85,0x07,0xF1,
+0x0F,0x32,0x40,0xA9,0x86,0xB4,0x46,0x81,
+0x2F,0x6D,0x19,0x7C,0xC8,0x15,0x81,0xC2,
+0x2C,0xC6,0x93,0x32,0x55,0xA0,0x4F,0xBC,
+0x07,0x63,0x01,0x3A,0xF7,0x3B,0x3A,0x59,
+0x26,0x66,0xBC,0xDB,0xD5,0xFE,0xBE,0x4B,
+0x07,0xCF,0xC8,0x2C,0x5D,0x60,0xF5,0x97,
+0x26,0xDF,0xF9,0x7C,0x9E,0xCC,0xB1,0xAA,
+0x07,0x3D,0xAA,0x99,0x80,0x8D,0x52,0xA5,
+0x27,0x12,0x8D,0x24,0xE8,0xAB,0xC8,0xA0,
+0x22,0xD1,0x1D,0xD7,0x21,0xC5,0xAB,0x4E,
+0x0F,0x61,0x23,0x71,0xB5,0xEF,0x60,0x59,
+0x2F,0xFC,0xF7,0x8A,0xE8,0x40,0x06,0x44,
+0x27,0xC2,0x4F,0x73,0xAE,0xC4,0x91,0x8E,
+0x2F,0xD7,0xC3,0x42,0x62,0x20,0x89,0x66,
+0x27,0xAE,0xEB,0x79,0x23,0x35,0xC3,0x6B,
+0x2A,0xB0,0x72,0x3E,0x71,0xA8,0xC8,0x30,
+0x07,0x44,0x80,0xE0,0xD8,0x3D,0x79,0x93,
+0x2F,0xA1,0x23,0x1E,0xCB,0x35,0x35,0x66,
+0x2F,0xA6,0xC1,0xC4,0x31,0x10,0x17,0xAD,
+0x27,0x8A,0xC1,0x1E,0xD6,0xA2,0x9B,0x31,
+0x27,0xA8,0x78,0xC6,0x36,0xEF,0x7A,0x2A,
+0x2F,0x48,0xCF,0xBB,0x3D,0xFF,0x05,0x5F,
+0x27,0xBB,0x68,0x9A,0xB2,0xDD,0xA4,0x64,
+0x27,0x82,0x2C,0x7D,0x2F,0x8D,0x51,0xBF,
+0x2F,0xEA,0x36,0xA6,0xEE,0x18,0x66,0x2F,
+0x2F,0x44,0xBA,0xB1,0xBD,0x2A,0x2B,0x45,
+0x25,0xD8,0xCB,0x36,0x86,0xF6,0x09,0xFC,
+0x07,0x20,0xAE,0x4B,0xD2,0xB5,0x1D,0x79,
+0x27,0xE7,0x9D,0xB3,0xA1,0xB5,0x5D,0xBE,
+0x2F,0xB3,0x64,0xFC,0xC5,0x56,0xE7,0xED,
+0x2F,0x1C,0x4C,0xBA,0x51,0x70,0x0A,0xEB,
+0x2F,0x3E,0x68,0xA5,0x6E,0xF0,0x2A,0xCF,
+0x22,0xB7,0x97,0x9B,0x8C,0x1B,0x51,0x79,
+0x07,0x76,0x72,0x71,0xA3,0xA4,0xFD,0x7C,
+0x27,0x02,0xC8,0x5F,0x35,0x96,0xDF,0xAA,
+0x2F,0xF8,0x13,0x5D,0x35,0x2D,0x44,0x88,
+0x27,0x6D,0x1C,0xBE,0x74,0xC5,0x3D,0xF8,
+0x27,0x84,0xBF,0x3D,0x01,0x88,0xC4,0x6A,
+0x27,0x47,0xE1,0x6D,0x99,0x9E,0x7A,0x93,
+0x27,0x83,0xCA,0xF0,0x90,0x88,0xEC,0xEB,
+0x2F,0x22,0x89,0x70,0x18,0xF1,0x01,0x9E,
+0x27,0x8A,0x3B,0x8D,0x03,0xC0,0x4E,0x6B,
+0x27,0xF0,0x3B,0x24,0x67,0xB8,0x0A,0xCD,
+0x27,0x7D,0x85,0x3C,0x2F,0x18,0xB9,0x83,
+0x27,0xB1,0x41,0xDD,0x7D,0x11,0xD4,0x27,
+0x2F,0xE3,0xBE,0x5E,0x32,0x71,0xDB,0x59,
+0x27,0x73,0xDD,0xE1,0xB0,0x9A,0xA2,0x0A,
+0x27,0xB3,0x05,0xE9,0x25,0x74,0xB2,0x54,
+0x27,0x5B,0xAD,0xF4,0x3C,0x36,0xA4,0xF7,
+0x2F,0x5C,0xA3,0x0C,0x91,0xC6,0x8F,0x9D,
+0x27,0xB7,0x23,0x4B,0x3F,0xBC,0x54,0xD2,
+0x27,0x6D,0x77,0x19,0x5B,0x7A,0x58,0x36,
+0x2F,0x66,0x04,0xDE,0x62,0xCE,0xFB,0xFF,
+0x2F,0xA9,0xD2,0x06,0xBC,0x93,0xE9,0xA3,
+0x27,0x94,0x2A,0xA5,0xF9,0x38,0x21,0xEA,
+0x2F,0x87,0x8E,0x3E,0x7C,0x87,0x96,0xAB,
+0x27,0xAB,0x89,0x5F,0x6F,0xA7,0xB1,0x1C,
+0x2F,0x71,0xB5,0x90,0x2E,0xD6,0xA2,0xC4,
+0x2F,0x0B,0x1F,0xFC,0x60,0x4B,0x20,0xC3,
+0x2F,0x6A,0x36,0xA5,0xC4,0xE0,0x6C,0xD7,
+0x23,0x18,0xC1,0x26,0x30,0x42,0xEA,0x7C,
+0x07,0x26,0x5F,0x0B,0xA2,0xA2,0x5E,0x0F,
+0x2F,0xA4,0x1D,0x41,0x4C,0xA8,0xFF,0x60,
+0x22,0xB3,0x40,0x69,0x6B,0x2D,0x6A,0x0C,
+0x07,0x85,0x63,0xF2,0x37,0x0E,0xE1,0xAD,
+0x07,0x65,0x0F,0x17,0xAF,0x05,0x10,0xF4,
+0x2D,0x1C,0xFE,0xFE,0xCB,0x8A,0xD0,0x41,
+0x0F,0xB5,0x42,0x10,0x22,0x74,0x40,0x48,
+0x27,0x2F,0x6A,0x9F,0x55,0xBE,0x0D,0x2D,
+0x2F,0xB5,0xDE,0xD6,0x02,0x3A,0x28,0x49,
+0x2F,0xFD,0x1D,0x5D,0x69,0xB6,0xEC,0x23,
+0x2F,0xC9,0x5F,0x89,0x13,0xC3,0x14,0xDB,
+0x27,0xE2,0xC9,0x07,0x8C,0xA2,0x40,0xA7,
+0x27,0x53,0x06,0xCB,0xEB,0xCE,0x1E,0x40,
+0x2A,0xA6,0x21,0x81,0x1A,0xD4,0x7E,0x39,
+0x0F,0xCE,0x0A,0xCD,0x7F,0x2B,0x83,0x36,
+0x27,0xBE,0xB8,0x80,0x33,0x67,0x55,0x33,
+0x27,0xB6,0xC8,0x4C,0x25,0x1B,0x5F,0xCA,
+0x2F,0x65,0x1B,0x22,0xF6,0x29,0x9D,0xF1,
+0x27,0x7A,0xE7,0x46,0x25,0x2E,0xC1,0x6D,
+0x0F,0x50,0x4E,0x47,0x9F,0x3F,0x99,0xE7,
+0x07,0xDE,0xA2,0x39,0xF7,0x48,0x24,0x2B,
+0x25,0x77,0x68,0x1A,0xF6,0xF7,0x5C,0x55,
+0x0F,0x04,0xA0,0x1F,0x15,0xD8,0xDF,0x26,
+0x27,0x7B,0x6E,0xBA,0x24,0x7B,0xB9,0xE0,
+0x27,0x11,0x99,0xAD,0xF8,0xB3,0x6E,0x04,
+0x2F,0xE5,0x26,0x2B,0x70,0xE3,0xDF,0xF7,
+0x27,0xF8,0x7A,0xCB,0x99,0x91,0x4B,0x54,
+0x27,0xA9,0x68,0x25,0x0D,0xEE,0x28,0x3B,
+0x27,0xFD,0xE4,0xB8,0x1C,0x74,0x88,0x0A,
+0x2F,0x57,0x01,0xCE,0xB1,0xEE,0x36,0xCF,
+0x21,0x41,0xDA,0x5B,0x24,0x66,0x8F,0x19,
+0x0F,0x93,0xD7,0x88,0x22,0x93,0xAC,0x34,
+0x2F,0xD1,0x30,0x86,0x0F,0x5F,0xF1,0x1D,
+0x27,0x28,0x4A,0xF0,0x44,0xBE,0xC7,0xBE,
+0x26,0x98,0xC4,0x0E,0xDB,0x11,0x39,0xCA,
+0x07,0x3A,0x15,0x01,0x3E,0xA0,0x4E,0x1B,
+0x0F,0xFF,0xE0,0xC5,0xA0,0x22,0x66,0xF5,
+0x2F,0x04,0xEF,0x2B,0x6A,0xFE,0xE7,0xB8,
+0x2E,0x1D,0x61,0xEC,0xDD,0x66,0x22,0xB5,
+0x07,0x0E,0x87,0x8D,0x6B,0x70,0xBA,0x75,
+0x2F,0x55,0xDB,0x50,0xEA,0x37,0xD0,0xD2,
+0x21,0x96,0xFC,0x00,0xC2,0x5A,0x07,0xBB,
+0x07,0xC5,0x30,0xD6,0x7B,0x9F,0xC7,0x46,
+0x2E,0x5C,0x6F,0x0B,0x2C,0x9D,0x97,0x86,
+0x0F,0xC3,0xB6,0x94,0x98,0x38,0x67,0x4E,
+0x27,0xDC,0x9A,0x2B,0x74,0x50,0x37,0x8F,
+0x27,0x40,0xF8,0x7F,0x38,0xA1,0x88,0x22,
+0x21,0xEF,0x32,0x74,0x59,0xAB,0x3E,0xB7,
+0x07,0xEF,0x73,0xA1,0xE5,0x52,0x6F,0xD9,
+0x2F,0x3B,0x5C,0xA2,0xFE,0x57,0x71,0x3D,
+0x27,0x71,0xD6,0xD2,0x6F,0xA1,0x57,0xAF,
+0x29,0x80,0x58,0xA6,0xC2,0x3B,0x79,0x07,
+0x07,0x87,0x89,0xB8,0x58,0xC4,0xE1,0xEF,
+0x2F,0x42,0xC8,0x29,0x21,0x3B,0xA5,0x4D,
+0x27,0x70,0xBE,0xCB,0x27,0xFF,0xA8,0x32,
+0x27,0x15,0x20,0x00,0xBE,0x53,0x17,0x3C,
+0x24,0x74,0x9F,0xCC,0xB8,0x3C,0x0B,0xC0,
+0x07,0xC3,0x7B,0x30,0x31,0xBD,0xCC,0x71,
+0x27,0x54,0x84,0x7F,0x44,0x70,0x5C,0xDF,
+0x2E,0x3C,0x44,0x61,0x84,0x31,0x45,0x33,
+0x07,0x89,0xF4,0x7C,0xFD,0x29,0xDF,0x6B,
+0x0F,0xB7,0xC6,0x9A,0xAE,0xA0,0x7F,0xA7,
+0x07,0xB3,0x2B,0x76,0x10,0x6C,0x4D,0xB5,
+0x0F,0x4E,0x2D,0xA4,0xBD,0x9B,0x28,0x11,
+0x27,0xDC,0xE5,0xCA,0xD1,0x38,0x9C,0xED,
+0x21,0xD0,0x50,0x3E,0xD6,0xEE,0x51,0xD6,
+0x07,0xC9,0x09,0xEB,0x81,0x08,0xCD,0xD5,
+0x0F,0x3D,0x95,0xCA,0xD0,0xCB,0xB7,0x1D,
+0x24,0x85,0x36,0xFE,0x13,0xE2,0xA3,0xB0,
+0x0F,0x7A,0xEE,0xF6,0x31,0xB3,0xED,0x5A,
+0x2F,0x08,0xE6,0x8D,0x1A,0x33,0x46,0x6A,
+0x2A,0x28,0x7C,0x3A,0x09,0x17,0xB9,0xF6,
+0x0F,0xF6,0x76,0x59,0xB4,0x34,0x85,0x04,
+0x0F,0x8F,0xF4,0x4D,0x53,0xFE,0xB0,0xAC,
+0x07,0xB8,0x8B,0x7A,0xFC,0xDA,0xB9,0xB3,
+0x2F,0xCB,0x49,0x90,0x3E,0x4F,0xB7,0xC2,
+0x2F,0x96,0x4D,0x2B,0xD0,0xD5,0x0C,0xCD,
+0x24,0x6C,0x76,0xCB,0xFE,0xAA,0xE8,0x19,
+0x07,0xC5,0xFA,0x8E,0x11,0x27,0x44,0x7E,
+0x07,0x23,0x6A,0x88,0x96,0x3C,0x0E,0x99,
+0x2F,0x88,0xFE,0xD8,0xC3,0xA9,0xFE,0xBF,
+0x2F,0x1B,0xC0,0xA6,0xAC,0x46,0x26,0xA5,
+0x27,0x04,0x76,0x3B,0xAD,0x58,0x86,0x97,
+0x27,0x90,0x32,0xA1,0x0C,0x71,0x6A,0x71,
+0x2F,0x15,0xC0,0x9F,0xAC,0xF8,0x1D,0x7A,
+0x2F,0x55,0x31,0x69,0x4F,0x65,0x84,0xC2,
+0x27,0x71,0x7E,0xBF,0x94,0x3D,0xD9,0x2E,
+0x27,0x9C,0x0A,0xD7,0x84,0x50,0x49,0x47,
+0x2A,0xE6,0xB1,0xE9,0x90,0xEA,0xCF,0xE0,
+0x0F,0xDD,0x1F,0x02,0x0D,0x4D,0x52,0x96,
+0x2F,0x50,0x33,0x58,0x7F,0xAB,0x25,0xF7,
+0x2A,0xD6,0x8B,0x4B,0x18,0xEB,0xF0,0x73,
+0x07,0xC2,0x19,0x96,0x72,0x18,0x83,0xA9,
+0x27,0x34,0x62,0x63,0x13,0x17,0x0E,0xBA,
+0x2F,0x23,0x22,0x98,0xC3,0xBB,0x1D,0x7E,
+0x2F,0x55,0x82,0xC1,0x7A,0x77,0x1F,0xBB,
+0x2D,0xA2,0x0A,0xF7,0xDF,0xE6,0x39,0xEC,
+0x07,0xC2,0x9B,0xD4,0x8F,0xFF,0x76,0x3A,
+0x27,0xDF,0xDC,0xB1,0xAE,0xD2,0x9C,0x8D,
+0x2F,0x38,0x4E,0x60,0x4B,0xDC,0x4A,0x47,
+0x27,0x1C,0xDE,0x42,0x96,0x3F,0xD1,0x78,
+0x2F,0x64,0x3B,0x73,0xCC,0x59,0x5D,0xD6,
+0x2F,0xB1,0x49,0x96,0xA2,0xC8,0x07,0xE6,
+0x23,0x42,0x4A,0x75,0x20,0x70,0xBA,0x34,
+0x07,0x07,0xA9,0xF7,0x72,0xE4,0xF9,0x3B,
+0x2F,0x8A,0xB3,0x65,0xC7,0x1D,0x21,0xF2,
+0x27,0xBF,0x6B,0x3F,0x40,0x34,0x35,0x9D,
+0x27,0xAD,0x1D,0x70,0x70,0xB0,0x4B,0xBD,
+0x27,0xC8,0xED,0x1A,0x70,0xD9,0x88,0x2E,
+0x2A,0xC8,0xE2,0x87,0x53,0xD0,0xB3,0xC6,
+0x07,0x47,0x08,0xAE,0xEE,0x6D,0x5A,0x4F,
+0x2F,0x34,0x6C,0xF2,0x4E,0x54,0x08,0x05,
+0x25,0xAC,0xEB,0x95,0x91,0xF4,0x7E,0x30,
+0x0F,0x41,0xD9,0xB5,0xD3,0x6C,0xAB,0x40,
+0x2F,0x0C,0xCF,0x3F,0xD8,0x2A,0xEA,0x62,
+0x2F,0x83,0xC8,0x69,0xF8,0xF4,0x7A,0x3F,
+0x2F,0x5D,0xBA,0xF4,0x05,0xFD,0x64,0x85,
+0x22,0x7E,0x70,0x08,0xDF,0xE2,0x65,0x68,
+0x07,0x3B,0xC2,0xA4,0xDF,0x52,0xFA,0xAD,
+0x2F,0xE4,0x44,0xDD,0x33,0x8D,0x2C,0x65,
+0x27,0x9B,0x7A,0xF9,0x6C,0xBF,0x3E,0x6A,
+0x27,0xE7,0xF2,0xBD,0xC4,0xD7,0x7D,0x72,
+0x2F,0x06,0x22,0x2F,0x8C,0x99,0x74,0x76,
+0x27,0x8F,0x7E,0xFE,0x72,0x85,0xCC,0xF2,
+0x27,0xA7,0x8D,0xFD,0x42,0x8F,0x7A,0xC4,
+0x21,0x08,0x47,0x9B,0x35,0x0B,0xCB,0x6F,
+0x0F,0x79,0xC5,0xFD,0x27,0xE5,0xAE,0x6F,
+0x27,0x75,0x1E,0x56,0x9E,0xB7,0x03,0x35,
+0x2C,0x6A,0x8B,0x09,0x76,0xA5,0x32,0xF1,
+0x07,0x58,0xD3,0x55,0x9D,0x35,0x7A,0x2E,
+0x2F,0x74,0x2B,0xE0,0xFA,0x4C,0xF0,0x94,
+0x27,0xB9,0xAD,0xA5,0x57,0x6B,0x73,0x85,
+0x27,0xDF,0xE2,0x48,0x95,0x82,0x06,0x9E,
+0x21,0x09,0x8F,0x08,0x33,0xD2,0x44,0xAE,
+0x0F,0x01,0x09,0x0E,0xE8,0xCE,0x55,0xAF,
+0x2F,0x06,0xC3,0x3C,0x45,0x3D,0x6F,0x47,
+0x2B,0x78,0x42,0xB5,0xCB,0xFB,0xE9,0xB4,
+0x0F,0xDC,0x5D,0xCD,0x54,0x5E,0x2A,0x87,
+0x07,0xDD,0x50,0x14,0xC4,0x10,0x65,0xF9,
+0x0F,0xCA,0x75,0x48,0xFA,0x62,0x1B,0x5A,
+0x07,0x46,0x26,0xB8,0x91,0x94,0xC4,0x4D,
+0x07,0xDB,0xB4,0x18,0x8B,0x72,0xD9,0x29,
+0x0F,0xBC,0x66,0x4D,0x47,0xD6,0x49,0xEE,
+0x0F,0x0A,0xA3,0x8C,0x98,0xA7,0xE3,0x53,
+0x27,0xB5,0x26,0xD7,0x2E,0x6E,0xB4,0x74,
+0x22,0x3A,0x81,0xF3,0xF2,0xBF,0x01,0x7D,
+0x07,0xCB,0xF6,0x19,0xDA,0xC8,0x29,0xF0,
+0x26,0x0C,0x37,0x76,0xA6,0x20,0x6E,0x11,
+0x07,0x7E,0xE4,0x92,0x02,0x37,0x81,0xB4,
+0x27,0x02,0x82,0x4D,0xD6,0x53,0x10,0x6C,
+0x26,0xB7,0x93,0x39,0x03,0x73,0x2D,0xC9,
+0x0F,0x61,0xA8,0x64,0x31,0xFF,0xA6,0x3B,
+0x27,0xEF,0x92,0x83,0xB0,0xC9,0x91,0x8A,
+0x27,0x36,0x10,0x8C,0x0F,0x7B,0xA2,0x6F,
+0x2C,0x2B,0xBB,0xAC,0xA2,0x2F,0x41,0x7D,
+0x0F,0x96,0x06,0x2F,0x0E,0x9C,0xE5,0xC4,
+0x07,0xC7,0x0D,0xA3,0x73,0x83,0x5B,0xFE,
+0x07,0xCC,0x4A,0x0E,0x31,0x2F,0xA4,0x5E,
+0x2F,0xBC,0xAA,0x4F,0x6C,0x86,0x20,0x5C,
+0x27,0xF3,0x9B,0x22,0xFF,0x0C,0x5C,0x77,
+0x2F,0xA1,0x3E,0x50,0xB8,0x06,0xE3,0x50,
+0x2F,0x5E,0x79,0xDA,0xA3,0x7B,0xAB,0x3B,
+0x2F,0xD7,0x17,0x68,0xCD,0x39,0xF4,0x4D,
+0x2F,0x2C,0xE1,0xF9,0x0B,0x1F,0x77,0xD4,
+0x2F,0xD0,0x4C,0x8A,0x1F,0x90,0x56,0x31,
+0x2F,0x60,0x11,0xE1,0x0F,0xD5,0x91,0x8D,
+0x2F,0x78,0xCF,0xCA,0x9E,0xFF,0x68,0x5C,
+0x27,0xE5,0x03,0xC2,0x8B,0x5B,0xBE,0xC2,
+0x27,0xBC,0x12,0x48,0x79,0xDE,0x24,0x2E,
+0x27,0x6F,0x36,0xA9,0x5E,0xCC,0x2F,0xEE,
+0x2F,0x57,0x89,0xD4,0x7C,0xCB,0xC2,0xCF,
+0x27,0x1B,0xCF,0x7E,0x10,0xF0,0xDB,0x1D,
+0x27,0xC8,0x14,0x51,0x41,0x22,0xCD,0xCE,
+0x27,0x86,0x90,0xBB,0xA4,0x60,0xB5,0x38,
+0x2F,0xFC,0x26,0x6D,0x26,0x4F,0x07,0xA5,
+0x26,0x8B,0xBE,0x3A,0x86,0x4C,0x1E,0xFD,
+0x07,0xC2,0xA7,0xDE,0x06,0x63,0x17,0xCF,
+0x27,0x97,0x06,0x66,0x20,0x78,0xBE,0x49,
+0x2F,0x92,0x39,0x99,0x02,0x45,0x50,0x43,
+0x22,0x6A,0xAC,0x8E,0x09,0x48,0x5E,0xDE,
+0x0F,0x4F,0xC4,0xF8,0xAF,0x1E,0x68,0x3D,
+0x27,0x82,0x99,0x89,0x6F,0x92,0x52,0xFD,
+0x22,0xEE,0xBD,0xE7,0xBE,0x1B,0x3D,0x93,
+0x0F,0x11,0x2C,0x9F,0xC0,0x70,0x29,0xD9,
+0x0F,0xD7,0x2C,0x5C,0x0E,0x47,0xDF,0xFF,
+0x2F,0x14,0xA3,0xCA,0xE5,0x12,0xFB,0xEA,
+0x29,0x26,0x89,0x15,0xAE,0xCE,0xD0,0x68,
+0x0F,0xCF,0x38,0x06,0x11,0xD6,0x88,0x9C,
+0x2F,0x4A,0x16,0xF0,0xAB,0xF8,0x24,0x6C,
+0x27,0xD1,0xF4,0xEA,0x80,0x49,0xA5,0x2B,
+0x27,0x5F,0x4A,0x55,0xB8,0x43,0x5B,0xF5,
+0x23,0xFE,0x16,0x7A,0x7A,0x8E,0x22,0x9A,
+0x0F,0xE3,0xE5,0xA4,0xD9,0x3D,0xE5,0xF1,
+0x2F,0x02,0x3D,0xC8,0x77,0xC0,0xD9,0x36,
+0x2F,0x36,0x25,0x73,0xBF,0xA0,0x18,0x1C,
+0x2E,0x10,0x99,0x23,0x6A,0x34,0x59,0xB6,
+0x07,0x94,0x68,0xA5,0xEB,0xE8,0xFB,0x57,
+0x26,0x20,0x37,0x97,0x5B,0xF3,0xAD,0x91,
+0x07,0x34,0xD2,0x2C,0xAC,0xB4,0xF1,0x2D,
+0x2A,0xC0,0xEF,0x25,0x8C,0xF4,0xBA,0x35,
+0x0F,0x9B,0x27,0xD8,0x42,0x16,0x2F,0xB3,
+0x27,0x84,0x62,0x19,0x07,0xB8,0x4A,0xC4,
+0x27,0x2E,0x24,0x74,0x74,0x5C,0xF6,0xA2,
+0x2F,0xA8,0x2C,0x00,0x99,0xA9,0xAE,0xB8,
+0x27,0x51,0x5F,0x89,0x1F,0xC5,0xEB,0xF2,
+0x2F,0x9F,0x6E,0xFF,0x1C,0xE8,0xD5,0x12,
+0x2A,0xB5,0xCE,0x4F,0xEE,0x62,0x6B,0x01,
+0x07,0xF4,0x0E,0x27,0xD7,0xFE,0x60,0x50,
+0x27,0x6B,0x5F,0x4C,0x13,0x17,0xDB,0x4E,
+0x07,0x6B,0xA6,0xD6,0x64,0xE6,0x40,0xB4,
+0x27,0xAB,0xC3,0x98,0xB5,0x90,0x35,0xDA,
+0x27,0x1D,0xAA,0x49,0x00,0x9D,0x13,0xD4,
+0x2E,0x48,0x6E,0xFA,0x0A,0xC6,0xF3,0x49,
+0x07,0xCD,0x91,0x26,0x0E,0x77,0x69,0xEC,
+0x2F,0x31,0x38,0xCA,0x7F,0x0D,0xB3,0x60,
+0x27,0xF0,0x6E,0x1B,0xBF,0x2E,0x81,0x8C,
+0x27,0x49,0xAB,0xBB,0x8E,0x42,0x55,0x44,
+0x2F,0xB1,0x03,0x87,0x75,0xBC,0x77,0xD5,
+0x2F,0x5F,0x8F,0x62,0x5E,0xE3,0x89,0xB6,
+0x2F,0x99,0xFD,0xC3,0x01,0x2D,0xE7,0xB9,
+0x27,0x7C,0xBF,0xE9,0xBA,0x81,0x97,0xC4,
+0x2F,0x5A,0x5E,0xB2,0xBD,0x2E,0x82,0xC0,
+0x27,0xB7,0xC3,0x11,0xAA,0xFB,0x86,0xE4,
+0x2F,0x60,0x28,0x66,0xA8,0x87,0x56,0xE3,
+0x27,0xCC,0x5A,0x8F,0x5E,0xF3,0x83,0x1B,
+0x2F,0xC1,0x82,0x20,0x82,0x1D,0x4C,0x36,
+0x27,0x00,0x03,0x04,0xC5,0x86,0x5B,0x30,
+0x2F,0xFA,0xBD,0x6B,0xB8,0xAB,0xDB,0x0C,
+0x27,0x09,0x03,0xBC,0xED,0xBC,0xBD,0xF7,
+0x2F,0xE2,0xBA,0xD1,0x90,0x52,0xFB,0xD3,
+0x2F,0x5F,0x84,0x71,0x32,0x2C,0xDC,0xE4,
+0x27,0xA1,0x2A,0x6E,0xEF,0x09,0x67,0xC7,
+0x2F,0x64,0x7E,0xCC,0x3B,0xDF,0x85,0xCC,
+0x2F,0x2C,0x9C,0xC8,0xEE,0x7E,0xB9,0x16,
+0x2F,0x20,0xFF,0x70,0x65,0xC5,0x2E,0x72,
+0x2F,0x86,0x13,0x7B,0xCB,0x99,0xE2,0x21,
+0x2B,0xF8,0x5A,0x7E,0x9B,0x61,0xCF,0x56,
+0x07,0x2C,0x23,0xE2,0x86,0x26,0x20,0x6C,
+0x2F,0x5A,0x6B,0x8E,0xA6,0x99,0x79,0xAC,
+0x2F,0x6B,0x5D,0x84,0x10,0xF8,0x1A,0x10,
+0x27,0x6D,0xA8,0x8D,0x49,0x1B,0x71,0x06,
+0x27,0x2E,0x4C,0xA2,0xAC,0x10,0xD5,0x44,
+0x2F,0xF0,0xFF,0x21,0x4B,0x36,0x47,0xAE,
+0x2F,0xFF,0x33,0x5F,0x59,0xF4,0xB9,0x00,
+0x27,0x1F,0x4D,0x9B,0x07,0x13,0x85,0x73,
+0x27,0x95,0x8E,0xA3,0x6E,0x1E,0x83,0x78,
+0x27,0xB7,0xF7,0x33,0x2E,0xE0,0x0E,0x8A,
+0x27,0xB9,0xBB,0xA8,0xE3,0x9F,0xE4,0xB8,
+0x2F,0x1D,0x2A,0xFF,0x63,0x32,0x54,0xDA,
+0x2F,0x3B,0x50,0x74,0x42,0x35,0x60,0x9A,
+0x2F,0xEC,0xF8,0x4D,0xC2,0x9B,0x46,0x77,
+0x2F,0x68,0x74,0xF7,0xD6,0x10,0x92,0x27,
+0x2F,0x18,0x72,0xBF,0x52,0x4C,0x6E,0xB4,
+0x2F,0x1C,0xE9,0x82,0x82,0x56,0x48,0xAE,
+0x27,0xE2,0xC1,0xB4,0x76,0x9E,0x0F,0x16,
+0x2F,0x61,0x36,0x92,0x14,0x1E,0x8B,0x4E,
+0x2F,0xE9,0x70,0xBA,0xB2,0x9D,0x93,0x4F,
+0x29,0x5D,0xD7,0x3C,0x6C,0xF1,0xDF,0x3E,
+0x07,0xEC,0xAE,0xF0,0x46,0x07,0x9D,0xF8,
+0x27,0x84,0xE6,0x80,0x83,0xCA,0x1D,0x73,
+0x2D,0x22,0x93,0x89,0x54,0xCE,0xF0,0xC8,
+0x0F,0x46,0x7B,0x6A,0x3C,0x40,0xCE,0x1E,
+0x27,0x8C,0x25,0xE5,0x9B,0x12,0x2C,0x07,
+0x2F,0xE6,0x74,0xBE,0xD2,0x28,0xAE,0xD3,
+0x2F,0xB2,0xEB,0xDF,0xC9,0x59,0xC0,0x03,
+0x27,0x1D,0x1F,0x95,0x1F,0x5E,0xA6,0x15,
+0x2B,0x32,0x13,0xCD,0x8F,0xC8,0x77,0x61,
+0x0F,0xD6,0x5B,0x3A,0x6E,0xF3,0x60,0xDA,
+0x2F,0x0C,0x9A,0x06,0x4B,0x4B,0x1F,0x87,
+0x22,0xD1,0x0B,0x11,0x16,0x8C,0xA4,0xFD,
+0x07,0x8F,0x8A,0xFB,0x7D,0x94,0xAC,0xFE,
+0x2A,0xC1,0x1C,0x44,0xEB,0xE6,0x1F,0x60,
+0x0F,0xBB,0xB0,0xB4,0x83,0x61,0x4D,0xE6,
+0x27,0x28,0xA9,0xB8,0xF6,0xA8,0xCD,0x43,
+0x27,0x89,0xAA,0x8B,0x29,0x8A,0x7A,0x4D,
+0x2F,0xB1,0x0B,0x76,0xA1,0x33,0x87,0x99,
+0x27,0x0B,0xD9,0x56,0x14,0x2E,0x10,0xEC,
+0x27,0xED,0x2E,0x28,0xD1,0x51,0x67,0x38,
+0x27,0xEB,0xA2,0xBF,0xC8,0x6C,0x2B,0xAD,
+0x2F,0x68,0x26,0x16,0xFE,0xDD,0x74,0xFA,
+0x27,0x88,0xC5,0x35,0x9E,0x2D,0x1D,0x30,
+0x2F,0xAC,0xED,0x64,0x43,0x23,0x05,0x79,
+0x27,0x57,0x0B,0x26,0x32,0xFC,0x83,0x2D,
+0x2F,0xBC,0x7F,0x66,0x05,0xCB,0x6C,0xCC,
+0x2F,0xEC,0xDD,0x1E,0x44,0x3E,0x20,0x1E,
+0x2F,0x21,0x64,0x7D,0xEC,0xDB,0xA4,0x76,
+0x2F,0x58,0x18,0xA2,0xB6,0xA8,0x2B,0x33,
+0x24,0xB2,0x6A,0x10,0xA7,0xDD,0x6F,0xB4,
+0x07,0x0B,0x54,0xE7,0x88,0xCC,0x20,0x6B,
+0x2F,0x65,0x91,0xAD,0xD9,0xB3,0x19,0x51,
+0x29,0xE1,0x74,0x79,0xE1,0xF7,0xB2,0x98,
+0x0F,0x16,0xAD,0x9C,0xBC,0x51,0x5B,0xDE,
+0x2F,0x43,0x4C,0x92,0x39,0x2D,0x33,0x55,
+0x2B,0x7A,0x65,0xF8,0x5E,0x67,0x86,0x32,
+0x07,0x9F,0x96,0xFC,0x28,0xD1,0x20,0xA5,
+0x0F,0x7B,0xFD,0x4C,0x75,0xD8,0x69,0x9F,
+0x27,0x38,0x8A,0x4D,0xD6,0x50,0xBB,0xA5,
+0x2C,0xD6,0x5F,0x8E,0xEA,0xB3,0x67,0x68,
+0x07,0x86,0x77,0xD3,0x65,0xF9,0x3A,0xD9,
+0x27,0x00,0x0E,0x3F,0x45,0x48,0x20,0xFD,
+0x29,0x9C,0x6A,0xEC,0x96,0xAE,0x32,0x51,
+0x07,0x3B,0xF0,0x38,0xE7,0xBB,0x06,0x07,
+0x2F,0x16,0x10,0x2F,0x3F,0x5B,0xA5,0x82,
+0x2E,0x5D,0xDF,0x02,0x7C,0x30,0x5B,0xFD,
+0x0F,0x41,0x93,0xA5,0xD2,0xD8,0x32,0x28,
+0x2F,0xA0,0xBC,0x6D,0x47,0x12,0x41,0x53,
+0x0F,0x59,0x00,0xB0,0xF8,0xE0,0x59,0x2B,
+0x2F,0x95,0x18,0xBF,0xDA,0xFF,0xBF,0x26,
+0x24,0x94,0x29,0xA6,0x5C,0xA9,0x6E,0x85,
+0x0F,0xC6,0xD5,0x71,0x62,0xAE,0xF4,0xF8,
+0x07,0xF2,0x12,0x15,0xB3,0x84,0x5B,0x53,
+0x0F,0x8D,0xF3,0x42,0xE8,0xEE,0xB4,0xB1,
+0x27,0x62,0x1A,0x8C,0xF2,0xD0,0xF9,0x35,
+0x27,0xC3,0x49,0x39,0xBA,0xEF,0x7D,0xD5,
+0x2F,0x96,0x8F,0x22,0xCB,0x19,0x08,0x76,
+0x2F,0x58,0x37,0xBD,0x96,0x3A,0x0B,0xBF,
+0x2F,0xC2,0x57,0xA1,0x5E,0xB5,0x6B,0xFC,
+0x2C,0xE0,0x77,0x20,0xE6,0x93,0xDE,0x89,
+0x07,0x0E,0x3C,0xD9,0xA8,0x0C,0x0E,0xEE,
+0x27,0x1A,0xFF,0xAB,0x16,0xCE,0xE9,0x4D,
+0x0F,0x5E,0x49,0xA5,0x70,0x6B,0x74,0x98,
+0x0F,0xD8,0x35,0xB2,0x21,0xC8,0xAA,0x75,
+0x27,0xFF,0xC2,0x41,0xED,0x83,0xE3,0x63,
+0x2F,0x0C,0x8F,0x40,0x81,0x22,0x31,0x47,
+0x2F,0x00,0x41,0xEB,0x9F,0x99,0x32,0x2E,
+0x27,0xA0,0x44,0x11,0xAF,0xE0,0x03,0xAD,
+0x2F,0xE6,0x17,0x58,0x9E,0xD9,0x9B,0x6E,
+0x25,0xA0,0x8D,0xF0,0x8A,0x48,0x5B,0xBD,
+0x0F,0x83,0xA9,0xE1,0xDC,0x46,0x62,0x86,
+0x0F,0xA8,0xAB,0xF2,0x07,0xBB,0x87,0xA6,
+0x07,0x1B,0xAF,0x1E,0xCC,0xD2,0x34,0x5D,
+0x27,0x34,0xD3,0x5A,0xC7,0x6A,0x40,0x4E,
+0x27,0x65,0x3D,0xF2,0xA4,0xEA,0x4C,0xFB,
+0x07,0x18,0xAE,0xE6,0x58,0xE3,0xF9,0xD4,
+0x27,0x13,0x1B,0x85,0x8C,0xF1,0xC1,0x9C,
+0x22,0xBF,0xF7,0xB8,0x53,0xE8,0x97,0xCF,
+0x07,0x4B,0xE5,0xA0,0x84,0x67,0xA8,0xA1,
+0x2F,0x84,0xD2,0x6E,0x57,0x23,0x89,0x3E,
+0x2F,0x19,0xE5,0xB7,0xF0,0xB6,0x36,0x3C,
+0x27,0xD2,0x97,0x3F,0x47,0x74,0xF0,0x13,
+0x22,0xA8,0xEA,0x8E,0x31,0xA4,0xF4,0xA5,
+0x07,0x4D,0x6E,0x59,0x3E,0x99,0x31,0x3D,
+0x07,0x37,0x6F,0x83,0x06,0x76,0xC1,0x44,
+0x07,0x67,0x2B,0x91,0x3D,0xC7,0x1A,0xE5,
+0x27,0xBC,0xBC,0x76,0xA0,0x3D,0x6F,0x69,
+0x2F,0x41,0xBF,0xC7,0xB5,0x1E,0x13,0x0D,
+0x07,0xC8,0x82,0xA0,0xFD,0xE8,0xD1,0xF1,
+0x0F,0x8F,0x3C,0x44,0xD0,0x6B,0xD9,0xAE,
+0x2F,0xA7,0x21,0x1E,0xDE,0x3F,0x3A,0x74,
+0x27,0x79,0xBD,0x5C,0xAC,0xDC,0x44,0xDF,
+0x27,0x89,0x5A,0xC9,0x99,0xBE,0x07,0xF8,
+0x2A,0x9B,0x11,0x8D,0xCD,0x9B,0x99,0x82,
+0x07,0x5D,0xFE,0xC5,0xF0,0x36,0xB5,0x2B,
+0x2F,0x82,0x40,0xA3,0xED,0x4F,0x2E,0xA1,
+0x2F,0x83,0xDC,0xB0,0x88,0xAC,0x15,0x2C,
+0x27,0xAF,0x43,0x4A,0x42,0x9F,0x5A,0x50,
+0x2A,0xE6,0x3F,0x0E,0x35,0xA5,0xFC,0x28,
+0x0F,0xF0,0x2B,0x7A,0x3D,0x4E,0xC8,0x8A,
+0x27,0x1D,0x72,0xD7,0x9A,0x40,0x98,0xEA,
+0x27,0x3D,0x1F,0xA8,0xD6,0xC4,0x03,0x88,
+0x27,0x4F,0x48,0xE9,0x82,0x03,0x57,0x19,
+0x29,0x4E,0xC4,0xE2,0x9B,0x96,0x18,0x06,
+0x07,0x1E,0xDE,0x8C,0xD9,0xF5,0xB6,0x48,
+0x2D,0x46,0x36,0xCD,0xDB,0x96,0x2D,0x6E,
+0x07,0xB6,0xF1,0x40,0xE9,0x23,0x71,0xAE,
+0x07,0x52,0x9C,0x83,0x0E,0x8D,0x47,0x40,
+0x07,0x71,0x98,0x49,0xD6,0xF1,0x88,0x51,
+0x07,0x1F,0x22,0x63,0x56,0x41,0xCD,0x4C,
+0x2F,0xA3,0xF3,0x02,0xF0,0x87,0xF3,0x05,
+0x2F,0xFD,0x4A,0x64,0x4C,0xA5,0x55,0x19,
+0x27,0xB0,0x8B,0x10,0x5F,0x65,0x68,0xC2,
+0x27,0xB3,0x21,0x8B,0xCB,0xF4,0xE3,0x0E,
+0x27,0x47,0x75,0x5E,0xB7,0x1E,0x9F,0xF8,
+0x2E,0x01,0xC9,0x0F,0x26,0xB7,0xA6,0x9C,
+0x07,0x0B,0xAD,0x07,0xA6,0xF6,0xC3,0xAD,
+0x22,0x19,0xB7,0x88,0x85,0x95,0x44,0x10,
+0x0F,0x5C,0xFD,0xCB,0x1B,0x66,0xCD,0xA7,
+0x07,0x42,0xAD,0xC2,0xD3,0xE6,0xE0,0x9D,
+0x07,0xA0,0x9B,0x44,0x03,0x54,0xAB,0x1C,
+0x07,0x55,0x55,0x65,0x32,0x9D,0xC9,0xF4,
+0x27,0x33,0xE4,0xED,0x63,0xFF,0x61,0x6D,
+0x2A,0xB9,0x32,0x31,0x75,0x20,0xAE,0x1E,
+0x0F,0xBB,0xEF,0xCE,0xAF,0x23,0x79,0xEB,
+0x2B,0x6B,0xA3,0xF8,0xAB,0x35,0x49,0xA2,
+0x0F,0x42,0xEA,0x72,0x5B,0xC0,0x65,0xA6,
+0x25,0xDA,0x6C,0x31,0x6B,0xC2,0x60,0x92,
+0x07,0xA5,0xCE,0x5C,0xB1,0xD7,0x95,0x2E,
+0x27,0x41,0xCC,0x30,0x61,0x48,0xB0,0xBB,
+0x2F,0xD7,0x5A,0x16,0x0D,0xAD,0x83,0xD1,
+0x2F,0x53,0x85,0x0B,0x54,0x37,0xB5,0x9D,
+0x27,0x47,0xA2,0xF5,0x48,0x09,0x1F,0x4F,
+0x2F,0xA4,0xCE,0x27,0xA1,0x67,0x49,0x06,
+0x27,0x8B,0x3B,0x0D,0x36,0x51,0x5F,0xB4,
+0x27,0x71,0xE4,0xCE,0x7E,0x2D,0xAF,0x84,
+0x2D,0x17,0x74,0x8D,0x47,0x11,0x60,0x77,
+0x0F,0xAC,0xED,0x36,0x16,0x91,0x86,0x1A,
+0x27,0x2F,0x1F,0x4B,0x91,0x40,0xD0,0xA8,
+0x2F,0xD9,0x65,0x9F,0x4F,0x07,0x34,0xD8,
+0x2F,0x0B,0xDA,0x25,0x46,0xC4,0xC0,0x8D,
+0x27,0x86,0xBE,0x26,0x4F,0xD0,0xB4,0x3C,
+0x29,0x05,0xE4,0x55,0x9E,0x2F,0xEE,0x12,
+0x07,0xD1,0x35,0xBC,0x90,0x8C,0x89,0x96,
+0x0F,0x82,0xA3,0xCE,0x30,0xFE,0x3B,0x84,
+0x0F,0xC3,0x13,0x33,0xBB,0x0D,0x43,0x84,
+0x07,0xE9,0x69,0xD1,0xCA,0xF5,0x56,0xD7,
+0x0F,0x60,0x19,0xE8,0x41,0xE2,0xA3,0x70,
+0x27,0xBE,0xD8,0x29,0x29,0x9B,0x63,0x4B,
+0x2F,0xA0,0x91,0xD7,0x54,0xC8,0x4A,0xB9,
+0x07,0x4C,0x89,0x15,0x1C,0x20,0x25,0x8A,
+0x07,0xA4,0x4F,0x42,0x59,0xC1,0x58,0x6B,
+0x07,0x41,0x62,0x28,0x73,0x87,0xEF,0x5A,
+0x27,0x42,0x72,0x1C,0xE3,0xBA,0xFB,0x27,
+0x2F,0x83,0x5C,0x8D,0x3F,0x2B,0xC7,0xF2,
+0x2F,0x0C,0xBB,0x85,0x96,0x1A,0xCF,0x3B,
+0x27,0xE1,0xB8,0x39,0xFE,0x30,0xDC,0x68,
+0x27,0xBD,0x90,0x8E,0x94,0x78,0xEA,0x6C,
+0x2F,0x9A,0xFE,0x85,0x9D,0xF2,0xC6,0x2D,
+0x27,0x71,0x36,0xFF,0x15,0x75,0x4A,0x36,
+0x27,0xDC,0x70,0x3C,0xAF,0xFD,0x6E,0x54,
+0x27,0x96,0x07,0x2E,0x50,0x9E,0xE5,0xFE,
+0x2F,0xBC,0x7E,0xCB,0x7B,0xB8,0xA9,0x9A,
+0x2F,0x26,0x82,0x68,0x6A,0x82,0xF7,0xD9,
+0x27,0x02,0xD5,0x79,0x01,0xE0,0x97,0x13,
+0x27,0xC8,0xFD,0x78,0xB3,0xF2,0xF2,0xDB,
+0x2F,0x09,0x03,0x67,0x8E,0xB7,0x9F,0x15,
+0x2F,0xCD,0xD1,0xCC,0x36,0x2D,0xDD,0xB1,
+0x27,0x3E,0x42,0xC2,0xB4,0xEE,0x8B,0xEC,
+0x2F,0x08,0x87,0x07,0x03,0xC7,0xFF,0x84,
+0x27,0xBC,0x71,0x93,0xD9,0xAB,0xC6,0xE4,
+0x2F,0x84,0x15,0xA1,0xF0,0x46,0xAA,0xB1,
+0x2F,0xDD,0x3D,0xDB,0xDC,0x70,0x2E,0xDE,
+0x2F,0x28,0x3A,0x17,0x2A,0xE1,0xCB,0x60,
+0x27,0x61,0x3C,0xCF,0x2F,0x21,0xD7,0x96,
+0x2F,0xB9,0x56,0x60,0xCF,0x0B,0xF2,0xCB,
+0x07,0xD3,0xA6,0xF9,0xCC,0xDD,0xC5,0xAC,
+0x07,0xC7,0xA6,0x5F,0x5D,0x32,0xBE,0x91,
+0x27,0x55,0x54,0x1F,0x91,0x85,0x76,0xFF,
+0x27,0xB2,0x9F,0x8F,0x9D,0x71,0xBA,0x9E,
+0x27,0xAF,0x0D,0xCE,0x7C,0xA9,0x83,0xD3,
+0x27,0x1D,0x1B,0x81,0x60,0x1A,0xEE,0x9A,
+0x2F,0xF4,0x4C,0x29,0xE2,0x22,0x4A,0x6E,
+0x27,0x52,0x8C,0xFE,0xE7,0x98,0xF7,0xF6,
+0x24,0x06,0xB4,0xDA,0x51,0x87,0x8F,0x43,
+0x07,0xA6,0x4C,0xB5,0x78,0xE0,0x9D,0xB8,
+0x27,0xAC,0x24,0x74,0x88,0xF0,0x02,0x73,
+0x2F,0x51,0xD3,0x63,0x2E,0xC0,0xC8,0x8F,
+0x27,0x5E,0xB1,0x90,0xA6,0x9E,0xA1,0xD6,
+0x27,0x5F,0x8F,0xBD,0xEC,0x2F,0xDE,0x6F,
+0x27,0x40,0x46,0x2C,0xED,0x29,0xD8,0xC7,
+0x2F,0x8C,0x53,0xE4,0x5E,0xC9,0xD6,0x62,
+0x2F,0x7B,0x5A,0x08,0x67,0x80,0x4B,0x17,
+0x2F,0x31,0x21,0x06,0x58,0x3E,0xC4,0x35,
+0x2F,0x5F,0xCB,0x13,0xB6,0xBD,0x89,0xAE,
+0x23,0xAA,0x75,0xDC,0x5B,0xBA,0xC4,0x63,
+0x07,0x6C,0xE8,0x2F,0x00,0xD6,0x14,0x74,
+0x2F,0x65,0x42,0x40,0x55,0x36,0x8C,0x79,
+0x2F,0xA2,0x2F,0x2F,0xDD,0xB7,0x4C,0x91,
+0x2A,0x20,0xF1,0xE9,0xAC,0xE1,0xE5,0xA2,
+0x07,0x1D,0xBD,0x68,0x65,0xE7,0xFE,0x54,
+0x05,0xC9,0x72,0xB8,0x85,0x42,0x17,0x93,
+0x2D,0xB8,0xAD,0xAF,0x93,0x9B,0xE6,0x65,
+0x0F,0xEC,0x5A,0x0A,0x08,0x3B,0x38,0xFD,
+0x27,0x33,0x56,0xB5,0xEA,0xE5,0xC8,0x12,
+0x2F,0x42,0x93,0x5C,0xDB,0x0C,0xFC,0x87,
+0x27,0xA3,0x46,0xED,0x25,0x93,0xF3,0xA8,
+0x27,0x25,0xEB,0x58,0xD1,0x38,0xEF,0x48,
+0x2F,0x19,0xCA,0x26,0x15,0x60,0x73,0x6E,
+0x27,0x5C,0x7A,0x54,0xC3,0x92,0xD2,0x7C,
+0x27,0x6F,0x36,0xE1,0xD4,0xCB,0xF0,0xA0,
+0x27,0xE6,0x68,0xB3,0x8C,0x1F,0x09,0x7F,
+0x27,0x5B,0xAD,0x4B,0x1E,0x90,0x18,0x8F,
+0x27,0xDE,0xD8,0x4A,0x0C,0xCC,0xBF,0x78,
+0x2F,0x4A,0x8B,0xB9,0xA4,0xCD,0x5F,0xF9,
+0x2F,0x8F,0x4F,0x37,0x5E,0x02,0x50,0xFF,
+0x2F,0xF3,0xE6,0xC6,0xA9,0x6D,0xB4,0xBE,
+0x2F,0x54,0x13,0x9A,0x7E,0xB1,0xDF,0xC9,
+0x2F,0x32,0xAA,0x5A,0x88,0x86,0x1F,0x17,
+0x27,0x71,0xD5,0xB8,0x42,0xF1,0xAC,0xB0,
+0x2F,0x50,0x9B,0x8F,0x99,0xBD,0x15,0x70,
+0x2F,0xBA,0x18,0xE8,0x71,0xCA,0x51,0xA2,
+0x27,0xE2,0xF7,0xB5,0xF7,0x45,0x23,0x97,
+0x2F,0x7E,0xC7,0x5C,0x9F,0x8A,0x25,0x40,
+0x27,0x15,0xE2,0x81,0x05,0x2D,0x46,0xD6,
+0x27,0x44,0xAD,0xA0,0xDB,0x83,0x83,0x2F,
+0x27,0xD8,0x41,0x1C,0x3B,0xBE,0xF9,0x9B,
+0x27,0xB5,0x16,0xEC,0x2E,0x29,0x5E,0x08,
+0x2F,0x40,0x96,0x7A,0xD8,0x95,0xE6,0xC0,
+0x27,0x38,0xE7,0xFE,0x9C,0xC9,0x57,0x26,
+0x27,0x97,0x19,0x8B,0x8E,0x54,0x3F,0xBB,
+0x27,0x4E,0x18,0xB4,0xE0,0x60,0x11,0x9B,
+0x2F,0x67,0xF4,0xFE,0xE7,0x03,0xBD,0x19,
+0x2F,0x4D,0x78,0x06,0xBC,0xD3,0xC4,0x11,
+0x27,0x34,0xF0,0x24,0x88,0x9D,0x5A,0xCB,
+0x2F,0xEF,0xD7,0x93,0x32,0xE1,0x18,0x07,
+0x27,0x87,0xAF,0x51,0x01,0xE1,0x95,0x7C,
+0x27,0x4A,0xE1,0x39,0xDC,0xF9,0xF0,0xC8,
+0x27,0x18,0x65,0x5C,0x1A,0xA4,0x8C,0x5B,
+0x2F,0xE4,0xE2,0xD2,0xC4,0xF5,0x9E,0x58,
+0x23,0x3F,0x4E,0x68,0xD8,0x35,0xC9,0x90,
+0x27,0x3D,0x43,0x65,0xEE,0xA7,0xD2,0x8C,
+0x2F,0x1E,0x50,0x2C,0x54,0x0D,0x8A,0xEA,
+0x27,0xE5,0xE8,0xCE,0xC4,0x56,0xF3,0xF2,
+0x27,0x51,0x42,0xB0,0x9D,0x96,0xFC,0x3E,
+0x2F,0x2F,0xAA,0x4E,0xA0,0xF6,0x4B,0xD3,
+0x2F,0x7D,0xE9,0x47,0x60,0x63,0xC9,0x21,
+0x27,0x36,0x31,0xAB,0x7A,0x89,0xA4,0x51,
+0x2F,0xC9,0x16,0x05,0x9D,0x0E,0xEB,0xC7,
+0x2F,0x4C,0x14,0x23,0x1E,0x8E,0x76,0x4F,
+0x2F,0x01,0x71,0xA1,0xFE,0x88,0xCD,0x3B,
+0x27,0x2C,0x71,0xAA,0x8F,0xCA,0x71,0x20,
+0x27,0xB9,0x5E,0x57,0xED,0x5F,0xBF,0x93,
+0x2F,0x33,0xB1,0xFF,0x1C,0xDA,0x6F,0x7A,
+0x2F,0x4A,0xC1,0x9E,0x84,0x87,0xB5,0x32,
+0x2F,0x4E,0xF8,0x25,0xDF,0x69,0xCA,0xAF,
+0x27,0x05,0x75,0x0F,0xDC,0xD3,0xD7,0x18,
+0x2F,0x37,0xCA,0x47,0xD8,0x9E,0xD3,0xAD,
+0x27,0x73,0xCE,0x0C,0xEC,0xF9,0xAC,0x79,
+0x27,0x1E,0x02,0xB1,0x21,0xF3,0xC0,0xFA,
+0x2F,0xCA,0x6E,0x29,0x6D,0xD1,0xD3,0xB6,
+0x27,0x7B,0x0B,0x11,0x9E,0xED,0x8F,0x02,
+0x27,0xD5,0x29,0x1A,0xE3,0xB7,0x7C,0x47,
+0x2F,0xC7,0x5D,0x86,0x7E,0xDC,0xB4,0x09,
+0x2F,0x29,0x08,0xC0,0x57,0x17,0x2F,0x3A,
+0x2F,0x0B,0x14,0xCB,0xB5,0xF7,0xC2,0xA2,
+0x2F,0x20,0x17,0x0A,0x80,0x98,0x56,0xBB,
+0x2F,0xA6,0x1A,0x8E,0x43,0xCA,0x20,0xE7,
+0x2F,0xE5,0xCE,0xA7,0xC3,0xA6,0x74,0xFC,
+0x27,0x4B,0xF2,0x16,0x88,0xA3,0x67,0xCE,
+0x2F,0xD6,0x0C,0xC7,0x39,0x88,0x87,0xBB,
+0x27,0x57,0x64,0xCF,0xDD,0x45,0x69,0x1E,
+0x27,0xE2,0xF5,0x2F,0x79,0x58,0x4B,0x95,
+0x27,0xD9,0x6A,0x7A,0x05,0x11,0x68,0x6E,
+0x27,0xDF,0x9B,0xDF,0xD8,0x89,0xDF,0x7B,
+0x27,0x55,0x47,0xA4,0x4D,0x1C,0xBD,0xC9,
+0x27,0x43,0x0A,0x75,0xC3,0xF9,0x59,0xBD,
+0x2B,0x30,0x1A,0x70,0x07,0xD7,0x3D,0xA5,
+0x27,0x84,0xA2,0x33,0xBC,0xE1,0x70,0x75,
+0x27,0x79,0x87,0xD8,0x4F,0x3F,0xEB,0x8C,
+0x27,0x76,0xCA,0xD2,0xA2,0x3B,0x35,0xD3,
+0x27,0x2D,0x06,0x13,0x76,0x7E,0xE3,0x57,
+0x27,0x90,0x99,0xE9,0x06,0x2A,0x71,0xF6,
+0x2F,0x70,0xB5,0x04,0x80,0x4B,0x07,0xCF,
+0x22,0x77,0x70,0x3F,0x96,0x4A,0x08,0xB7,
+0x07,0x6E,0x62,0xBA,0x1E,0x92,0xA1,0xE6,
+0x2F,0x31,0xB6,0x1D,0x0F,0x07,0x49,0x1B,
+0x2A,0xBC,0x52,0x35,0xAF,0x0E,0x17,0xE7,
+0x07,0x03,0xEB,0x38,0x38,0xBB,0x5B,0x08,
+0x26,0x2C,0x1F,0xEA,0x14,0xEB,0xB0,0x07,
+0x07,0xA6,0xAA,0x2C,0x3F,0x9C,0x1A,0x5C,
+0x07,0x7D,0x4F,0xDC,0x14,0x19,0x66,0x48,
+0x27,0xA3,0x39,0x90,0xE1,0xEE,0x81,0x90,
+0x21,0x73,0x87,0x44,0x11,0x85,0x49,0x25,
+0x0F,0xBA,0xAF,0x40,0x4D,0x9E,0x10,0x0F,
+0x27,0x90,0x52,0x55,0x09,0x8E,0x4A,0x5F,
+0x21,0xAA,0x3B,0x01,0xE8,0xC6,0x5E,0xDC,
+0x0F,0xC2,0xA5,0x37,0x21,0x06,0x94,0x69,
+0x0F,0x5F,0xCD,0x94,0xDB,0xF0,0x21,0x4C,
+0x27,0x69,0x34,0x86,0x82,0x8F,0xBD,0xB1,
+0x29,0x37,0xD2,0x8E,0x66,0x28,0x38,0x1A,
+0x0F,0x77,0xE4,0x2D,0xCC,0x34,0x01,0xC8,
+0x0F,0xC0,0x3A,0x74,0x78,0xC3,0x33,0xA9,
+0x2F,0x8D,0xB3,0x1D,0x0C,0x57,0xC2,0x5D,
+0x29,0x8E,0xC2,0xB5,0x31,0x34,0x12,0xB5,
+0x07,0x38,0xD7,0xF8,0x38,0x3A,0x6E,0xF0,
+0x27,0x8D,0x74,0xA2,0x55,0x38,0x5A,0xB9,
+0x29,0x21,0x4B,0x99,0xE7,0xFF,0xE2,0xCB,
+0x0F,0xA9,0xA2,0x82,0xC3,0xF1,0x07,0x74,
+0x27,0x98,0x2A,0xD3,0xE3,0x5E,0x22,0x98,
+0x21,0x0A,0x00,0x1A,0x44,0x72,0x8B,0x05,
+0x07,0xEA,0xEE,0xFA,0x3F,0xD3,0x17,0xBA,
+0x27,0xB1,0x89,0x44,0xB3,0x5F,0x88,0x5D,
+0x29,0x03,0x37,0x09,0x99,0xEC,0x8E,0xA0,
+0x07,0x38,0xE2,0x39,0x11,0x4C,0x80,0x2E,
+0x27,0x98,0x4E,0x18,0x70,0xA0,0x6E,0x8D,
+0x2A,0x24,0x82,0x6D,0xC9,0x5A,0x67,0x4D,
+0x07,0x34,0xAA,0x51,0xB5,0x4F,0x3C,0xE4,
+0x27,0x28,0xFD,0x15,0xFC,0x45,0x8A,0x03,
+0x21,0xE7,0x0E,0xD4,0x7B,0xDE,0x72,0x94,
+0x07,0xB6,0xE8,0xBD,0x35,0x8B,0x1B,0x64,
+0x2F,0x27,0x42,0x9B,0x7B,0xFA,0x51,0x1A,
+0x2A,0x5F,0x58,0xE1,0x84,0xB9,0x69,0xC3,
+0x0F,0xE2,0x1C,0xE3,0xB5,0xFD,0xEA,0xF3,
+0x27,0x6C,0x54,0x14,0x6B,0x39,0xEA,0xDC,
+0x22,0xA5,0xB0,0xBF,0x99,0xD7,0xBA,0x84,
+0x0F,0x13,0x40,0x0F,0x79,0x46,0xAD,0x4A,
+0x27,0xFD,0xF1,0xED,0x39,0x93,0x95,0xCE,
+0x22,0xAF,0xC3,0x8F,0x60,0xD7,0xB2,0x58,
+0x07,0x86,0xE6,0x0E,0x7C,0x1F,0x0B,0x80,
+0x27,0x05,0x0B,0xBA,0xDA,0xD9,0x03,0x13,
+0x2B,0x9F,0x2D,0x9E,0xC0,0x46,0x4C,0x59,
+0x07,0x6E,0x77,0x67,0x4C,0xAA,0xDE,0xBA,
+0x2F,0x24,0x45,0x78,0x63,0x12,0x6D,0x25,
+0x07,0x61,0x67,0x20,0xCE,0xA3,0xCC,0x1E,
+0x2F,0x92,0xCE,0x1A,0x19,0x01,0x9D,0x19,
+0x23,0xDD,0xF4,0x07,0x66,0x58,0xC2,0x12,
+0x07,0x90,0x94,0x02,0x67,0xAE,0x89,0xE6,
+0x2F,0x05,0xEF,0x23,0x1E,0x45,0x73,0xD9,
+0x22,0x55,0x57,0xAD,0xA0,0xEF,0x2C,0x65,
+0x0F,0x6B,0x35,0x28,0xBA,0xD8,0xA3,0x78,
+0x27,0xAF,0x24,0x92,0x35,0x57,0xA6,0x1A,
+0x22,0x81,0xB3,0x5D,0x1F,0x8C,0x94,0x00,
+0x07,0xE0,0xFF,0x89,0x43,0xB1,0x05,0x4C,
+0x27,0x92,0x16,0xFB,0x7E,0xE0,0xC4,0x6D,
+0x29,0xA9,0x2D,0x73,0xEB,0xD7,0x2E,0xC1,
+0x07,0x4D,0x86,0x93,0xF8,0xAD,0xAC,0x8C,
+0x2F,0xE7,0x47,0xDA,0xE6,0x47,0xEA,0xC8,
+0x2A,0x4A,0x0B,0xA4,0xF8,0x15,0x9A,0x70,
+0x07,0x96,0xB7,0x90,0x05,0x25,0xFE,0xFA,
+0x27,0x7C,0xB1,0xF3,0x81,0x6D,0xCA,0x96,
+0x22,0xC2,0x5F,0x96,0x8B,0x5F,0x96,0x86,
+0x07,0x6E,0xE8,0xEE,0xE9,0xC0,0xC7,0xBB,
+0x27,0xFF,0x8C,0x64,0xDC,0x9A,0xE2,0xAF,
+0x2A,0xA2,0xBF,0xE0,0x70,0x83,0xFF,0xDD,
+0x0F,0x5A,0xC2,0x91,0x0A,0x32,0x5C,0xA9,
+0x27,0xD8,0x1F,0x43,0x7C,0x93,0x0F,0xC6,
+0x22,0x0E,0x19,0x88,0x9F,0xAE,0xB0,0x86,
+0x0F,0x40,0xB2,0x76,0x77,0x64,0xD7,0x63,
+0x2F,0x52,0x03,0xFF,0xF6,0x05,0x4A,0x65,
+0x2A,0xE0,0xC0,0xEB,0xE4,0x0F,0x4C,0xCB,
+0x0F,0x55,0xC8,0xA7,0x01,0x72,0x78,0xF8,
+0x2F,0xC5,0x2A,0xD2,0x81,0x53,0x40,0xBC,
+0x21,0x52,0x1D,0xA4,0xB7,0x6D,0xC1,0xE6,
+0x07,0xF2,0x49,0x60,0x4E,0x77,0x27,0x8C,
+0x27,0x58,0x1B,0xFF,0x51,0xEF,0xA7,0xAA,
+0x22,0x32,0x08,0xEB,0x27,0x95,0x8D,0x28,
+0x0F,0x07,0x2C,0xFA,0x76,0xCB,0xC0,0xBE,
+0x2F,0x40,0xC8,0x89,0x62,0xCD,0xC3,0x2E,
+0x2A,0x2E,0xFE,0x62,0x40,0xA0,0x91,0x79,
+0x07,0xF1,0xFF,0xEF,0x77,0xEB,0x81,0x5B,
+0x2D,0x22,0x33,0xC0,0xE8,0x86,0xCA,0xD8,
+0x0F,0x6D,0xF8,0x2E,0x72,0xBA,0x29,0x56,
+0x2F,0x6F,0x81,0x79,0x57,0x24,0x42,0xC0,
+0x2A,0xC4,0xF3,0x1E,0x5B,0x3A,0x98,0x82,
+0x0F,0x49,0x64,0xE1,0x4A,0x1E,0x6A,0x05,
+0x2F,0x27,0xED,0x72,0xFD,0x1A,0x58,0xDC,
+0x22,0x9B,0x50,0xAA,0xFD,0x4F,0xA1,0x8E,
+0x0F,0xE9,0x5C,0xA9,0xB3,0x94,0xF0,0x68,
+0x27,0x1C,0x13,0x06,0xE1,0xC1,0xC3,0x12,
+0x22,0x70,0x8F,0xDA,0xC4,0x43,0x98,0xAF,
+0x0F,0x9B,0x10,0xAC,0x80,0x56,0xD7,0xD2,
+0x25,0xB1,0x56,0x71,0xC7,0x7A,0x35,0x91,
+0x07,0x21,0xE4,0x7D,0xE0,0xBA,0x73,0x2E,
+0x27,0x73,0x75,0xFE,0x9D,0xE6,0x1F,0x6D,
+0x2A,0x7B,0x5F,0x96,0x09,0x58,0x7F,0xC2,
+0x07,0x91,0xEB,0x89,0x43,0x58,0x2C,0x7F,
+0x2F,0xDE,0x00,0x58,0xC3,0xDE,0x74,0x0C,
+0x2A,0x94,0x21,0x74,0x45,0x2C,0x8A,0xC2,
+0x0F,0x01,0x39,0xC4,0xC6,0x64,0x79,0xFC,
+0x27,0xB5,0x64,0x24,0xFD,0xA6,0xE9,0x46,
+0x0F,0xD0,0x98,0x52,0xFF,0xDE,0x21,0xDC,
+0x27,0xCC,0x40,0x70,0xBD,0x24,0xB2,0x40,
+0x2A,0xFE,0x20,0x77,0xBC,0x73,0x6E,0x36,
+0x0F,0xC8,0x03,0xF3,0x3B,0x64,0x2E,0xC9,
+0x27,0x46,0x0F,0x46,0x8E,0x57,0x83,0xC4,
+0x2A,0x24,0xCD,0xCB,0x45,0xED,0xD1,0x23,
+0x07,0x2A,0x38,0x14,0xE8,0x9D,0x13,0x49,
+0x0F,0xDD,0xEF,0x67,0x1E,0x1E,0x83,0xAF,
+0x27,0x30,0x26,0xD9,0xD8,0x18,0x5A,0xA3,
+0x2B,0x3D,0x70,0xCC,0xFB,0xE2,0xDA,0x5D,
+0x0F,0xAF,0x77,0x5A,0x46,0x32,0x3B,0x28,
+0x2F,0x67,0x02,0xFA,0x0E,0x27,0x70,0x8A,
+0x23,0x62,0x15,0xFB,0xCE,0xD0,0xC6,0x4D,
+0x0F,0xA8,0xBF,0xEB,0x17,0xD2,0x6C,0xCC,
+0x2F,0xC1,0xE0,0x39,0xFE,0x3C,0x09,0x10,
+0x2B,0xC0,0xBE,0xDF,0x7E,0x61,0x6D,0xC5,
+0x0F,0x97,0x3F,0x8F,0xEE,0x9E,0x80,0xB2,
+0x2F,0x89,0x28,0xB5,0xCE,0x93,0x65,0x13,
+0x22,0x27,0x88,0x4D,0x02,0xDE,0x04,0x7D,
+0x0F,0x1A,0xA6,0x41,0x94,0x67,0xCA,0x79,
+0x27,0xFE,0x53,0xA1,0xBC,0xB2,0xC5,0x7D,
+0x23,0x4B,0xFF,0xF3,0x88,0x21,0x27,0x58,
+0x07,0xEB,0xAB,0x49,0x69,0x85,0xE8,0x2D,
+0x2F,0x1D,0xFE,0x8C,0x1B,0x08,0x7D,0x57,
+0x23,0xDF,0xD6,0x43,0xC7,0xD2,0x2A,0x3C,
+0x0F,0x59,0x85,0xAE,0x5E,0xBE,0xF1,0xE9,
+0x2F,0x4C,0x06,0x7A,0x2F,0xFC,0x8E,0x9F,
+0x07,0x13,0x4B,0x58,0x7C,0x7C,0xC7,0x70,
+0x2F,0x11,0x2A,0xF5,0xF3,0xF6,0x77,0x9C,
+0x22,0x1C,0xC9,0x3C,0x16,0xBA,0x17,0x4C,
+0x0F,0xF4,0xD5,0x22,0x81,0xAA,0xD4,0x13,
+0x27,0xF5,0x58,0x06,0xDB,0x06,0xD6,0x90,
+0x2D,0x10,0x92,0x8F,0x6D,0xB4,0x57,0x75,
+0x0F,0x20,0x11,0x86,0xB5,0x2A,0x68,0xF2,
+0x27,0x6E,0xFA,0x08,0xD6,0xEB,0xE7,0x9D,
+0x24,0x66,0x95,0xAC,0x68,0xF3,0xE0,0x03,
+0x07,0x78,0x8D,0xD1,0xD8,0x7A,0x4D,0x72,
+0x27,0x50,0xD3,0x8D,0xB3,0x58,0x04,0x26,
+0x27,0x9E,0xEF,0x7A,0xE5,0x40,0xF1,0x43,
+0x07,0x8E,0x8D,0xED,0xEA,0xCF,0xC7,0x3B,
+0x27,0xC3,0x59,0x7B,0xAB,0x73,0xC5,0x7C,
+0x27,0xC0,0xF2,0x8F,0xF7,0x07,0xFF,0x0D,
+0x07,0xCE,0x74,0x6C,0x2C,0xDD,0x68,0x6D,
+0x2F,0x69,0x21,0x1F,0xEF,0x9A,0xEE,0xF9,
+0x2F,0xEE,0x69,0x55,0xB3,0x15,0x58,0x35,
+0x07,0xF1,0x17,0x33,0x20,0xE8,0x41,0x80,
+0x2F,0x7D,0x4E,0x68,0x4E,0xA2,0x50,0x94,
+0x2F,0x31,0xB2,0x9A,0x37,0xF3,0xBB,0x05,
+0x07,0xBC,0x11,0xB1,0x3C,0xED,0xFF,0x44,
+0x27,0x93,0x2D,0x61,0x43,0x38,0x6B,0xC2,
+0x2F,0x1F,0x3E,0xEE,0x05,0xF2,0xCA,0x91,
+0x07,0x05,0x9A,0xFF,0x85,0xD3,0x21,0x17,
+0x27,0x22,0x3C,0x60,0x1C,0xBA,0xA2,0xD6,
+0x2F,0x07,0xFF,0x12,0xEE,0x5E,0x1C,0x1C,
+0x07,0x2F,0x39,0xA3,0x8E,0xDC,0x29,0xED,
+0x0F,0x78,0x1C,0x7E,0xF3,0x9B,0x8A,0xE5,
+0x0F,0xB3,0x57,0xCA,0xA5,0xC6,0x70,0x94,
+0x07,0x3F,0x54,0x83,0xF1,0x1D,0xEB,0x1C,
+0x0F,0x71,0xCB,0xCB,0x35,0x16,0x70,0xCF,
+0x07,0x9B,0x6C,0x52,0xBE,0xDC,0xE9,0x53,
+0x07,0x1E,0xA5,0xB4,0xE5,0xDB,0x90,0xC8,
+0x07,0x09,0x8A,0xC3,0xD0,0x44,0xA3,0xC2,
+0x27,0x88,0x28,0x62,0xFD,0x5D,0x04,0x32,
+0x23,0xE6,0xBE,0xD2,0x75,0x3D,0xF2,0x31,
+0x0F,0x24,0x16,0xFE,0x9F,0x59,0x7F,0xF6,
+0x0F,0x9D,0x27,0xEF,0x9B,0x9D,0x73,0x37,
+0x05,0xDC,0x6B,0xF9,0xA2,0xC7,0xD9,0x10,
+0x27,0x78,0x0D,0x95,0x0C,0x68,0xF1,0x1E,
+0x29,0x73,0x97,0x66,0x65,0xD2,0x5F,0xE3,
+0x07,0x6E,0xF8,0x1F,0xAA,0x15,0xA1,0x2D,
+0x0F,0xB3,0x8F,0x2C,0x08,0x51,0x96,0xE3,
+0x07,0xDF,0x6E,0x4A,0x2F,0x82,0x86,0x2D,
+0x0F,0x72,0xAA,0x0B,0xF3,0x22,0xF1,0x8E,
+0x07,0x84,0x6C,0x74,0xD3,0x32,0x80,0xE5,
+0x0F,0x62,0xC0,0x47,0xD5,0xF6,0xAB,0xDE,
+0x0F,0xBF,0xC1,0x20,0x97,0x19,0xBF,0x96,
+0x07,0x56,0x96,0xC3,0x74,0x0A,0x44,0x5A,
+0x26,0x93,0x78,0x0F,0x1F,0xF3,0x8B,0xC0,
+0x07,0xCC,0x52,0x10,0x0B,0x36,0x2E,0x4A,
+0x07,0x13,0x9D,0x25,0x52,0x95,0x90,0xE0,
+0x07,0xEF,0x65,0xC1,0x0E,0x43,0x18,0x49,
+0x05,0x19,0x6E,0xD4,0x67,0xBE,0x84,0xE9,
+0x27,0x7C,0x05,0xEA,0x57,0xBA,0x1E,0xEF,
+0x29,0x5A,0x88,0x54,0x89,0x9F,0x69,0x00,
+0x0F,0xE9,0xF6,0x6F,0x62,0xA0,0xA9,0x81,
+0x07,0x59,0xE1,0x41,0xBD,0x9B,0xAB,0x04,
+0x07,0xE4,0xD1,0x8E,0x35,0x9E,0xCD,0xD0,
+0x07,0x63,0x61,0x1A,0xD5,0x0B,0xED,0x8D,
+0x05,0xFA,0x25,0x5E,0x79,0x75,0x93,0x40,
+0x2D,0x56,0x6B,0x14,0x24,0x4F,0x62,0xCA,
+0x07,0x2F,0x0D,0x7D,0xB2,0xBA,0xD6,0xCC,
+0x0F,0x25,0xBA,0xD6,0x20,0x15,0xA2,0x8C,
+0x05,0x82,0x31,0x96,0x3A,0xD0,0x48,0x95,
+0x27,0xBD,0x4A,0x80,0x4C,0xD1,0x93,0x61,
+0x27,0x8A,0xD7,0x55,0xC2,0x82,0xBF,0x82,
+0x2F,0x34,0x42,0x4C,0x4F,0xAF,0x7C,0x57,
+0x27,0xB5,0x5B,0xE6,0x5B,0xA0,0x4D,0xFE,
+0x2C,0x1F,0x8E,0x76,0xB2,0xCF,0xD5,0xED,
+0x07,0x72,0x0F,0x0E,0x29,0x1C,0xD9,0xB0,
+0x2B,0xDC,0x0B,0x98,0xFA,0x34,0xD5,0x69,
+0x07,0x5F,0x24,0xAD,0x22,0xF9,0x90,0x2D,
+0x07,0xE3,0x21,0x4B,0xDF,0x46,0x09,0x62,
+0x07,0xF1,0x8A,0x19,0x92,0xF3,0x4C,0xAF,
+0x0F,0xBB,0xFA,0x83,0x0C,0x3F,0x49,0x79,
+0x07,0x16,0xF4,0xA4,0x4D,0x82,0x5C,0xF2,
+0x24,0x4B,0xE4,0x69,0xB1,0xD2,0x0D,0xDF,
+0x0F,0x21,0x9D,0xC8,0xCF,0xE2,0xB5,0x58,
+0x0F,0x2F,0xD6,0x94,0xCD,0x52,0x1E,0x5F,
+0x0F,0xFC,0xA6,0xC8,0x3C,0x20,0xAD,0x07,
+0x07,0x6A,0x13,0x7B,0xAD,0x5C,0x57,0x42,
+0x07,0xEC,0x4E,0x2A,0x3A,0x04,0xD3,0x86,
+0x27,0x72,0x2A,0x4D,0xC0,0xDA,0x3F,0xA5,
+0x24,0x32,0x26,0x8D,0xA2,0x66,0xDB,0x69,
+0x0F,0x58,0x83,0x18,0x14,0xFB,0x88,0x0C,
+0x0F,0x8A,0xE6,0x04,0x2C,0x71,0x0C,0x54,
+0x2F,0x34,0xC3,0xD8,0x00,0x1C,0x38,0xDD,
+0x21,0x1D,0x44,0x05,0x28,0xF8,0xC5,0x85,
+0x07,0xA3,0x17,0x50,0x3A,0x03,0x6A,0xF0,
+0x07,0x40,0xA7,0xFC,0x81,0x15,0x58,0x9E,
+0x0F,0xB2,0x91,0x6B,0xB9,0x17,0xCE,0xE2,
+0x0F,0xE5,0x50,0xDD,0x47,0xE6,0xEE,0x6D,
+0x07,0x84,0x20,0xD6,0xA9,0x5A,0x8C,0x02,
+0x0F,0xEE,0xA5,0x18,0xD6,0x38,0xD5,0x46,
+0x0F,0xBE,0xB4,0x03,0xE7,0x04,0x10,0x04,
+0x05,0x53,0xF1,0x43,0xCC,0xD1,0xCA,0x3E,
+0x2E,0x87,0xD9,0xD1,0x9A,0x54,0x46,0x77,
+0x05,0xB7,0xF5,0x3D,0x7C,0xE4,0x58,0xA3,
+0x27,0xE7,0xA3,0x7B,0xB8,0x2C,0xCC,0xB3,
+0x2A,0x8D,0x21,0xD6,0xC6,0xCF,0x99,0x7A,
+0x0F,0x27,0x92,0xE1,0x4A,0x9C,0x02,0x9D,
+0x07,0x52,0x8E,0x05,0xCC,0xC9,0xC3,0xFA,
+0x22,0x05,0xC3,0x5A,0x3D,0x72,0x70,0x0D,
+0x0F,0x52,0xEE,0x30,0x16,0xC0,0x8F,0xE7,
+0x0F,0x44,0x3E,0x46,0xE7,0xF6,0xD0,0x64,
+0x07,0x06,0xDD,0xCC,0xF8,0x4E,0x23,0x82,
+0x0F,0x9F,0x05,0xC0,0xA9,0x91,0x9E,0x0B,
+0x2F,0x60,0xD8,0x39,0x2B,0x95,0x38,0x22,
+0x22,0x9C,0x32,0xAC,0x8A,0x8F,0x89,0xCF,
+0x05,0xD2,0x48,0x9C,0x7A,0x99,0x9C,0xAC,
+0x2A,0xCD,0x32,0x74,0xED,0xF8,0x63,0xBA,
+0x0F,0xB2,0xFE,0x1B,0x00,0x53,0x0F,0x3A,
+0x24,0xAB,0xA2,0xC1,0x5B,0x1D,0xAD,0x83,
+0x07,0xDB,0x87,0x28,0x0E,0x1E,0x5A,0xEC,
+0x05,0x93,0x50,0x53,0x13,0x2C,0x0C,0xAD
+};
+
+#define FIRMWARE_LINES_0_Eb15 (sizeof(Si2158_FW_0_Eb15)/(8*sizeof(unsigned char)))
+
+#endif /* _SI2158_FIRMWARE_0_E_BUILD_15_H_ */
diff -urN a/drivers/media/dvb-frontends/si2158_firmware_2_0_build_x.h b/drivers/media/dvb-frontends/si2158_firmware_2_0_build_x.h
--- a/drivers/media/dvb-frontends/si2158_firmware_2_0_build_x.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/si2158_firmware_2_0_build_x.h	2013-02-17 18:09:10.000000000 +0800
@@ -0,0 +1,19 @@
+/****************************************************************************************/
+#ifndef _Si2158_FIRMWARE_2_0_BUILD_X_H_
+#define _Si2158_FIRMWARE_2_0_BUILD_X_H_
+
+#ifndef __FIRMWARE_STRUCT__
+#define __FIRMWARE_STRUCT__
+typedef struct firmware_struct {
+	unsigned char firmware_len;
+	unsigned char firmware_table[16];
+} firmware_struct;
+#endif /* __FIRMWARE_STRUCT__ */
+
+firmware_struct Si2158_FW_2_0bx[] = {
+{ 0 , { 0x00} }
+};
+
+#define FIRMWARE_LINES_2_0bx (sizeof(Si2158_FW_2_0bx)/(sizeof(firmware_struct)))
+
+#endif /* _Si2158_FIRMWARE_2_0_BUILD_X_H_ */
diff -urN a/drivers/media/dvb-frontends/si2158_properties.h b/drivers/media/dvb-frontends/si2158_properties.h
--- a/drivers/media/dvb-frontends/si2158_properties.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/si2158_properties.h	2013-02-17 18:05:42.000000000 +0800
@@ -0,0 +1,1468 @@
+/*************************************************************************************/
+#ifndef   _Si2158_PROPERTIES_H_
+#define   _Si2158_PROPERTIES_H_
+
+/* _properties_defines_insertion_start */
+/* Si2158 ATV_AFC_RANGE property definition */
+#define   Si2158_ATV_AFC_RANGE_PROP 0x0610
+
+#ifdef    Si2158_ATV_AFC_RANGE_PROP
+  #define Si2158_ATV_AFC_RANGE_PROP_CODE 0x000610
+
+
+    typedef struct { /* Si2158_ATV_AFC_RANGE_PROP_struct */
+      unsigned int    range_khz;
+   } Si2158_ATV_AFC_RANGE_PROP_struct;
+
+   /* ATV_AFC_RANGE property, RANGE_KHZ field definition (NO TITLE)*/
+   #define  Si2158_ATV_AFC_RANGE_PROP_RANGE_KHZ_LSB         0
+   #define  Si2158_ATV_AFC_RANGE_PROP_RANGE_KHZ_MASK        0xffff
+   #define  Si2158_ATV_AFC_RANGE_PROP_RANGE_KHZ_DEFAULT    1000
+    #define Si2158_ATV_AFC_RANGE_PROP_RANGE_KHZ_RANGE_KHZ_MIN  0
+    #define Si2158_ATV_AFC_RANGE_PROP_RANGE_KHZ_RANGE_KHZ_MAX  65535
+
+#endif /* Si2158_ATV_AFC_RANGE_PROP */
+
+/* Si2158 ATV_AGC_SPEED property definition */
+#define   Si2158_ATV_AGC_SPEED_PROP 0x0611
+
+#ifdef    Si2158_ATV_AGC_SPEED_PROP
+  #define Si2158_ATV_AGC_SPEED_PROP_CODE 0x000611
+
+
+    typedef struct { /* Si2158_ATV_AGC_SPEED_PROP_struct */
+      unsigned char   if_agc_speed;
+   } Si2158_ATV_AGC_SPEED_PROP_struct;
+
+   /* ATV_AGC_SPEED property, IF_AGC_SPEED field definition (NO TITLE)*/
+   #define  Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB         0
+   #define  Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK        0xff
+   #define  Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_DEFAULT    0
+    #define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO    0
+    #define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_89      89
+    #define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_105     105
+    #define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_121     121
+    #define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_137     137
+    #define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_158     158
+    #define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_172     172
+    #define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_178     178
+    #define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_185     185
+    #define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_196     196
+    #define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_206     206
+    #define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_216     216
+    #define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_219     219
+    #define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_222     222
+    #define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_248     248
+    #define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_250     250
+    #define Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_251     251
+
+#endif /* Si2158_ATV_AGC_SPEED_PROP */
+
+/* Si2158 ATV_AGC_SPEED_LOW_RSSI property definition */
+#define   Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP 0x0623
+
+#ifdef    Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP
+  #define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_CODE 0x000623
+
+
+    typedef struct { /* Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_struct */
+      unsigned char   if_agc_speed;
+               char   thld;
+   } Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_struct;
+
+   /* ATV_AGC_SPEED_LOW_RSSI property, IF_AGC_SPEED field definition (NO TITLE)*/
+   #define  Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_LSB         0
+   #define  Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_MASK        0xff
+   #define  Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_DEFAULT    158
+    #define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_89      89
+    #define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_105     105
+    #define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_121     121
+    #define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_137     137
+    #define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_158     158
+    #define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_172     172
+    #define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_178     178
+    #define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_185     185
+    #define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_196     196
+    #define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_206     206
+    #define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_216     216
+    #define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_219     219
+    #define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_222     222
+    #define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_248     248
+    #define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_250     250
+    #define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_251     251
+
+   /* ATV_AGC_SPEED_LOW_RSSI property, THLD field definition (NO TITLE)*/
+   #define  Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_LSB         8
+   #define  Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_MASK        0xff
+   #define  Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_DEFAULT    -128
+    #define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_THLD_MIN  -128
+    #define Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_THLD_MAX  127
+
+#endif /* Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP */
+
+/* Si2158 ATV_ARTIFICIAL_SNOW property definition */
+#define   Si2158_ATV_ARTIFICIAL_SNOW_PROP 0x0624
+
+#ifdef    Si2158_ATV_ARTIFICIAL_SNOW_PROP
+  #define Si2158_ATV_ARTIFICIAL_SNOW_PROP_CODE 0x000624
+
+
+    typedef struct { /* Si2158_ATV_ARTIFICIAL_SNOW_PROP_struct */
+      unsigned char   gain;
+               char   offset;
+   } Si2158_ATV_ARTIFICIAL_SNOW_PROP_struct;
+
+   /* ATV_ARTIFICIAL_SNOW property, GAIN field definition (NO TITLE)*/
+   #define  Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_LSB         0
+   #define  Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_MASK        0xff
+   #define  Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_DEFAULT    0
+    #define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_AUTO  0
+    #define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_0DB   1
+    #define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_6DB   2
+    #define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_12DB  3
+    #define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_18DB  4
+    #define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_24DB  5
+    #define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_30DB  6
+    #define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_36DB  7
+    #define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_42DB  8
+    #define Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_OFF   9
+
+   /* ATV_ARTIFICIAL_SNOW property, OFFSET field definition (NO TITLE)*/
+   #define  Si2158_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_LSB         8
+   #define  Si2158_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_MASK        0xff
+   #define  Si2158_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_DEFAULT    0
+    #define Si2158_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_OFFSET_MIN  -128
+    #define Si2158_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_OFFSET_MAX  127
+
+#endif /* Si2158_ATV_ARTIFICIAL_SNOW_PROP */
+
+/* Si2158 ATV_CONFIG_IF_PORT property definition */
+#define   Si2158_ATV_CONFIG_IF_PORT_PROP 0x0603
+
+#ifdef    Si2158_ATV_CONFIG_IF_PORT_PROP
+  #define Si2158_ATV_CONFIG_IF_PORT_PROP_CODE 0x000603
+
+
+    typedef struct { /* Si2158_ATV_CONFIG_IF_PORT_PROP_struct */
+      unsigned char   atv_agc_source;
+      unsigned char   atv_out_type;
+   } Si2158_ATV_CONFIG_IF_PORT_PROP_struct;
+
+   /* ATV_CONFIG_IF_PORT property, ATV_AGC_SOURCE field definition (NO TITLE)*/
+   #define  Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_LSB         8
+   #define  Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_MASK        0x07
+   #define  Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_DEFAULT    0
+    #define Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_INTERNAL  0
+    #define Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_AGC1_3DB  1
+    #define Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_AGC2_3DB  2
+
+   /* ATV_CONFIG_IF_PORT property, ATV_OUT_TYPE field definition (NO TITLE)*/
+   #define  Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LSB         0
+   #define  Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_MASK        0x0f
+   #define  Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_DEFAULT    8
+    #define Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LIF_DIFF_IF1  8
+    #define Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LIF_DIFF_IF2  10
+    #define Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LIF_SE_IF1A   12
+    #define Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LIF_SE_IF2A   14
+
+#endif /* Si2158_ATV_CONFIG_IF_PORT_PROP */
+
+/* Si2158 ATV_EXT_AGC property definition */
+#define   Si2158_ATV_EXT_AGC_PROP 0x0607
+
+#ifdef    Si2158_ATV_EXT_AGC_PROP
+  #define Si2158_ATV_EXT_AGC_PROP_CODE 0x000607
+
+
+    typedef struct { /* Si2158_ATV_EXT_AGC_PROP_struct */
+      unsigned char   max_10mv;
+      unsigned char   min_10mv;
+   } Si2158_ATV_EXT_AGC_PROP_struct;
+
+   /* ATV_EXT_AGC property, MAX_10MV field definition (NO TITLE)*/
+   #define  Si2158_ATV_EXT_AGC_PROP_MAX_10MV_LSB         8
+   #define  Si2158_ATV_EXT_AGC_PROP_MAX_10MV_MASK        0xff
+   #define  Si2158_ATV_EXT_AGC_PROP_MAX_10MV_DEFAULT    200
+    #define Si2158_ATV_EXT_AGC_PROP_MAX_10MV_MAX_10MV_MIN  0
+    #define Si2158_ATV_EXT_AGC_PROP_MAX_10MV_MAX_10MV_MAX  255
+
+   /* ATV_EXT_AGC property, MIN_10MV field definition (NO TITLE)*/
+   #define  Si2158_ATV_EXT_AGC_PROP_MIN_10MV_LSB         0
+   #define  Si2158_ATV_EXT_AGC_PROP_MIN_10MV_MASK        0xff
+   #define  Si2158_ATV_EXT_AGC_PROP_MIN_10MV_DEFAULT    50
+    #define Si2158_ATV_EXT_AGC_PROP_MIN_10MV_MIN_10MV_MIN  0
+    #define Si2158_ATV_EXT_AGC_PROP_MIN_10MV_MIN_10MV_MAX  255
+
+#endif /* Si2158_ATV_EXT_AGC_PROP */
+
+/* Si2158 ATV_IEN property definition */
+#define   Si2158_ATV_IEN_PROP 0x0601
+
+#ifdef    Si2158_ATV_IEN_PROP
+  #define Si2158_ATV_IEN_PROP_CODE 0x000601
+
+
+    typedef struct { /* Si2158_ATV_IEN_PROP_struct */
+      unsigned char   chlien;
+      unsigned char   pclien;
+   } Si2158_ATV_IEN_PROP_struct;
+
+   /* ATV_IEN property, CHLIEN field definition (NO TITLE)*/
+   #define  Si2158_ATV_IEN_PROP_CHLIEN_LSB         0
+   #define  Si2158_ATV_IEN_PROP_CHLIEN_MASK        0x01
+   #define  Si2158_ATV_IEN_PROP_CHLIEN_DEFAULT    1
+    #define Si2158_ATV_IEN_PROP_CHLIEN_DISABLE  0
+    #define Si2158_ATV_IEN_PROP_CHLIEN_ENABLE   1
+
+   /* ATV_IEN property, PCLIEN field definition (NO TITLE)*/
+   #define  Si2158_ATV_IEN_PROP_PCLIEN_LSB         1
+   #define  Si2158_ATV_IEN_PROP_PCLIEN_MASK        0x01
+   #define  Si2158_ATV_IEN_PROP_PCLIEN_DEFAULT    0
+    #define Si2158_ATV_IEN_PROP_PCLIEN_DISABLE  0
+    #define Si2158_ATV_IEN_PROP_PCLIEN_ENABLE   1
+
+#endif /* Si2158_ATV_IEN_PROP */
+
+/* Si2158 ATV_INT_SENSE property definition */
+#define   Si2158_ATV_INT_SENSE_PROP 0x0613
+
+#ifdef    Si2158_ATV_INT_SENSE_PROP
+  #define Si2158_ATV_INT_SENSE_PROP_CODE 0x000613
+
+
+    typedef struct { /* Si2158_ATV_INT_SENSE_PROP_struct */
+      unsigned char   chlnegen;
+      unsigned char   chlposen;
+      unsigned char   pclnegen;
+      unsigned char   pclposen;
+   } Si2158_ATV_INT_SENSE_PROP_struct;
+
+   /* ATV_INT_SENSE property, CHLNEGEN field definition (NO TITLE)*/
+   #define  Si2158_ATV_INT_SENSE_PROP_CHLNEGEN_LSB         0
+   #define  Si2158_ATV_INT_SENSE_PROP_CHLNEGEN_MASK        0x01
+   #define  Si2158_ATV_INT_SENSE_PROP_CHLNEGEN_DEFAULT    0
+    #define Si2158_ATV_INT_SENSE_PROP_CHLNEGEN_DISABLE  0
+    #define Si2158_ATV_INT_SENSE_PROP_CHLNEGEN_ENABLE   1
+
+   /* ATV_INT_SENSE property, CHLPOSEN field definition (NO TITLE)*/
+   #define  Si2158_ATV_INT_SENSE_PROP_CHLPOSEN_LSB         8
+   #define  Si2158_ATV_INT_SENSE_PROP_CHLPOSEN_MASK        0x01
+   #define  Si2158_ATV_INT_SENSE_PROP_CHLPOSEN_DEFAULT    1
+    #define Si2158_ATV_INT_SENSE_PROP_CHLPOSEN_DISABLE  0
+    #define Si2158_ATV_INT_SENSE_PROP_CHLPOSEN_ENABLE   1
+
+   /* ATV_INT_SENSE property, PCLNEGEN field definition (NO TITLE)*/
+   #define  Si2158_ATV_INT_SENSE_PROP_PCLNEGEN_LSB         1
+   #define  Si2158_ATV_INT_SENSE_PROP_PCLNEGEN_MASK        0x01
+   #define  Si2158_ATV_INT_SENSE_PROP_PCLNEGEN_DEFAULT    0
+    #define Si2158_ATV_INT_SENSE_PROP_PCLNEGEN_DISABLE  0
+    #define Si2158_ATV_INT_SENSE_PROP_PCLNEGEN_ENABLE   1
+
+   /* ATV_INT_SENSE property, PCLPOSEN field definition (NO TITLE)*/
+   #define  Si2158_ATV_INT_SENSE_PROP_PCLPOSEN_LSB         9
+   #define  Si2158_ATV_INT_SENSE_PROP_PCLPOSEN_MASK        0x01
+   #define  Si2158_ATV_INT_SENSE_PROP_PCLPOSEN_DEFAULT    1
+    #define Si2158_ATV_INT_SENSE_PROP_PCLPOSEN_DISABLE  0
+    #define Si2158_ATV_INT_SENSE_PROP_PCLPOSEN_ENABLE   1
+
+#endif /* Si2158_ATV_INT_SENSE_PROP */
+
+/* Si2158 ATV_LIF_FREQ property definition */
+#define   Si2158_ATV_LIF_FREQ_PROP 0x060c
+
+#ifdef    Si2158_ATV_LIF_FREQ_PROP
+  #define Si2158_ATV_LIF_FREQ_PROP_CODE 0x00060c
+
+
+    typedef struct { /* Si2158_ATV_LIF_FREQ_PROP_struct */
+      unsigned int    offset;
+   } Si2158_ATV_LIF_FREQ_PROP_struct;
+
+   /* ATV_LIF_FREQ property, OFFSET field definition (NO TITLE)*/
+   #define  Si2158_ATV_LIF_FREQ_PROP_OFFSET_LSB         0
+   #define  Si2158_ATV_LIF_FREQ_PROP_OFFSET_MASK        0xffff
+   #define  Si2158_ATV_LIF_FREQ_PROP_OFFSET_DEFAULT    5000
+    #define Si2158_ATV_LIF_FREQ_PROP_OFFSET_OFFSET_MIN  0
+    #define Si2158_ATV_LIF_FREQ_PROP_OFFSET_OFFSET_MAX  7000
+
+#endif /* Si2158_ATV_LIF_FREQ_PROP */
+
+/* Si2158 ATV_LIF_OUT property definition */
+#define   Si2158_ATV_LIF_OUT_PROP 0x060d
+
+#ifdef    Si2158_ATV_LIF_OUT_PROP
+  #define Si2158_ATV_LIF_OUT_PROP_CODE 0x00060d
+
+
+    typedef struct { /* Si2158_ATV_LIF_OUT_PROP_struct */
+      unsigned char   amp;
+      unsigned char   offset;
+   } Si2158_ATV_LIF_OUT_PROP_struct;
+
+   /* ATV_LIF_OUT property, AMP field definition (NO TITLE)*/
+   #define  Si2158_ATV_LIF_OUT_PROP_AMP_LSB         8
+   #define  Si2158_ATV_LIF_OUT_PROP_AMP_MASK        0xff
+   #define  Si2158_ATV_LIF_OUT_PROP_AMP_DEFAULT    100
+    #define Si2158_ATV_LIF_OUT_PROP_AMP_AMP_MIN  0
+    #define Si2158_ATV_LIF_OUT_PROP_AMP_AMP_MAX  255
+
+   /* ATV_LIF_OUT property, OFFSET field definition (NO TITLE)*/
+   #define  Si2158_ATV_LIF_OUT_PROP_OFFSET_LSB         0
+   #define  Si2158_ATV_LIF_OUT_PROP_OFFSET_MASK        0xff
+   #define  Si2158_ATV_LIF_OUT_PROP_OFFSET_DEFAULT    148
+    #define Si2158_ATV_LIF_OUT_PROP_OFFSET_OFFSET_MIN  0
+    #define Si2158_ATV_LIF_OUT_PROP_OFFSET_OFFSET_MAX  255
+
+#endif /* Si2158_ATV_LIF_OUT_PROP */
+
+/* Si2158 ATV_PGA_TARGET property definition */
+#define   Si2158_ATV_PGA_TARGET_PROP 0x0617
+
+#ifdef    Si2158_ATV_PGA_TARGET_PROP
+  #define Si2158_ATV_PGA_TARGET_PROP_CODE 0x000617
+
+
+    typedef struct { /* Si2158_ATV_PGA_TARGET_PROP_struct */
+      unsigned char   override_enable;
+               char   pga_target;
+   } Si2158_ATV_PGA_TARGET_PROP_struct;
+
+   /* ATV_PGA_TARGET property, OVERRIDE_ENABLE field definition (NO TITLE)*/
+   #define  Si2158_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_LSB         8
+   #define  Si2158_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_MASK        0x01
+   #define  Si2158_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_DEFAULT    0
+    #define Si2158_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_DISABLE  0
+    #define Si2158_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_ENABLE   1
+
+   /* ATV_PGA_TARGET property, PGA_TARGET field definition (NO TITLE)*/
+   #define  Si2158_ATV_PGA_TARGET_PROP_PGA_TARGET_LSB         0
+   #define  Si2158_ATV_PGA_TARGET_PROP_PGA_TARGET_MASK        0xff
+   #define  Si2158_ATV_PGA_TARGET_PROP_PGA_TARGET_DEFAULT    0
+    #define Si2158_ATV_PGA_TARGET_PROP_PGA_TARGET_PGA_TARGET_MIN  -13
+    #define Si2158_ATV_PGA_TARGET_PROP_PGA_TARGET_PGA_TARGET_MAX  7
+
+#endif /* Si2158_ATV_PGA_TARGET_PROP */
+
+/* Si2158 ATV_RF_TOP property definition */
+#define   Si2158_ATV_RF_TOP_PROP 0x0612
+
+#ifdef    Si2158_ATV_RF_TOP_PROP
+  #define Si2158_ATV_RF_TOP_PROP_CODE 0x000612
+
+
+    typedef struct { /* Si2158_ATV_RF_TOP_PROP_struct */
+      unsigned char   atv_rf_top;
+   } Si2158_ATV_RF_TOP_PROP_struct;
+
+   /* ATV_RF_TOP property, ATV_RF_TOP field definition (NO TITLE)*/
+   #define  Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_LSB         0
+   #define  Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_MASK        0xff
+   #define  Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_DEFAULT    0
+    #define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_AUTO   0
+    #define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_P2DB   4
+    #define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_P1DB   5
+    #define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_0DB    6
+    #define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M1DB   7
+    #define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M2DB   8
+    #define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M3DB   9
+    #define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M4DB   10
+    #define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M5DB   11
+    #define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M6DB   12
+    #define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M7DB   13
+    #define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M8DB   14
+    #define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M9DB   15
+    #define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M10DB  16
+    #define Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_M11DB  17
+
+#endif /* Si2158_ATV_RF_TOP_PROP */
+
+/* Si2158 ATV_RSQ_RSSI_THRESHOLD property definition */
+#define   Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP 0x0605
+
+#ifdef    Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP
+  #define Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_CODE 0x000605
+
+
+    typedef struct { /* Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_struct */
+               char   hi;
+               char   lo;
+   } Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_struct;
+
+   /* ATV_RSQ_RSSI_THRESHOLD property, HI field definition (NO TITLE)*/
+   #define  Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB         8
+   #define  Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK        0xff
+   #define  Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_DEFAULT    0
+    #define Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MIN  -128
+    #define Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MAX  127
+
+   /* ATV_RSQ_RSSI_THRESHOLD property, LO field definition (NO TITLE)*/
+   #define  Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB         0
+   #define  Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK        0xff
+   #define  Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_DEFAULT    -70
+    #define Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MIN  -128
+    #define Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MAX  127
+
+#endif /* Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP */
+
+/* Si2158 ATV_VIDEO_MODE property definition */
+#define   Si2158_ATV_VIDEO_MODE_PROP 0x0604
+
+#ifdef    Si2158_ATV_VIDEO_MODE_PROP
+  #define Si2158_ATV_VIDEO_MODE_PROP_CODE 0x000604
+
+
+    typedef struct { /* Si2158_ATV_VIDEO_MODE_PROP_struct */
+      unsigned char   color;
+      unsigned char   invert_spectrum;
+      unsigned char   video_sys;
+   } Si2158_ATV_VIDEO_MODE_PROP_struct;
+
+   /* ATV_VIDEO_MODE property, COLOR field definition (NO TITLE)*/
+   #define  Si2158_ATV_VIDEO_MODE_PROP_COLOR_LSB         4
+   #define  Si2158_ATV_VIDEO_MODE_PROP_COLOR_MASK        0x01
+   #define  Si2158_ATV_VIDEO_MODE_PROP_COLOR_DEFAULT    0
+    #define Si2158_ATV_VIDEO_MODE_PROP_COLOR_PAL_NTSC  0
+    #define Si2158_ATV_VIDEO_MODE_PROP_COLOR_SECAM     1
+
+   /* ATV_VIDEO_MODE property, INVERT_SPECTRUM field definition (NO TITLE)*/
+   #define  Si2158_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_LSB         9
+   #define  Si2158_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_MASK        0x01
+   #define  Si2158_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_DEFAULT    1
+    #define Si2158_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_NORMAL    0
+    #define Si2158_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_INVERTED  1
+
+   /* ATV_VIDEO_MODE property, VIDEO_SYS field definition (NO TITLE)*/
+   #define  Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LSB         0
+   #define  Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_MASK        0x07
+   #define  Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DEFAULT    0
+    #define Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_B   0
+    #define Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_GH  1
+    #define Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_M   2
+    #define Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_N   3
+    #define Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_I   4
+    #define Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_DK  5
+    #define Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_L   6
+    #define Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LP  7
+
+#endif /* Si2158_ATV_VIDEO_MODE_PROP */
+
+/* Si2158 ATV_VSNR_CAP property definition */
+#define   Si2158_ATV_VSNR_CAP_PROP 0x0616
+
+#ifdef    Si2158_ATV_VSNR_CAP_PROP
+  #define Si2158_ATV_VSNR_CAP_PROP_CODE 0x000616
+
+
+    typedef struct { /* Si2158_ATV_VSNR_CAP_PROP_struct */
+      unsigned char   atv_vsnr_cap;
+   } Si2158_ATV_VSNR_CAP_PROP_struct;
+
+   /* ATV_VSNR_CAP property, ATV_VSNR_CAP field definition (NO TITLE)*/
+   #define  Si2158_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_LSB         0
+   #define  Si2158_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_MASK        0xff
+   #define  Si2158_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_DEFAULT    0
+    #define Si2158_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_ATV_VSNR_CAP_MIN  0
+    #define Si2158_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_ATV_VSNR_CAP_MAX  127
+
+#endif /* Si2158_ATV_VSNR_CAP_PROP */
+
+/* Si2158 CRYSTAL_TRIM property definition */
+#define   Si2158_CRYSTAL_TRIM_PROP 0x0402
+
+#ifdef    Si2158_CRYSTAL_TRIM_PROP
+  #define Si2158_CRYSTAL_TRIM_PROP_CODE 0x000402
+
+
+    typedef struct { /* Si2158_CRYSTAL_TRIM_PROP_struct */
+      unsigned char   xo_cap;
+   } Si2158_CRYSTAL_TRIM_PROP_struct;
+
+   /* CRYSTAL_TRIM property, XO_CAP field definition (NO TITLE)*/
+   #define  Si2158_CRYSTAL_TRIM_PROP_XO_CAP_LSB         0
+   #define  Si2158_CRYSTAL_TRIM_PROP_XO_CAP_MASK        0x0f
+   #define  Si2158_CRYSTAL_TRIM_PROP_XO_CAP_DEFAULT    8
+    #define Si2158_CRYSTAL_TRIM_PROP_XO_CAP_XO_CAP_MIN  0
+    #define Si2158_CRYSTAL_TRIM_PROP_XO_CAP_XO_CAP_MAX  15
+
+#endif /* Si2158_CRYSTAL_TRIM_PROP */
+
+/* Si2158 DTV_AGC_FREEZE_INPUT property definition */
+#define   Si2158_DTV_AGC_FREEZE_INPUT_PROP 0x0711
+
+#ifdef    Si2158_DTV_AGC_FREEZE_INPUT_PROP
+  #define Si2158_DTV_AGC_FREEZE_INPUT_PROP_CODE 0x000711
+
+
+    typedef struct { /* Si2158_DTV_AGC_FREEZE_INPUT_PROP_struct */
+      unsigned char   level;
+      unsigned char   pin;
+   } Si2158_DTV_AGC_FREEZE_INPUT_PROP_struct;
+
+   /* DTV_AGC_FREEZE_INPUT property, LEVEL field definition (NO TITLE)*/
+   #define  Si2158_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_LSB         0
+   #define  Si2158_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_MASK        0x01
+   #define  Si2158_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_DEFAULT    0
+    #define Si2158_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_LOW   0
+    #define Si2158_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_HIGH  1
+
+   /* DTV_AGC_FREEZE_INPUT property, PIN field definition (NO TITLE)*/
+   #define  Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_LSB         1
+   #define  Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_MASK        0x07
+   #define  Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_DEFAULT    0
+    #define Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_NONE      0
+    #define Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_GPIO1     1
+    #define Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_GPIO2     2
+    #define Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_RESERVED  3
+    #define Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_AGC1      4
+    #define Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_AGC2      5
+    #define Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_LIF1A     6
+    #define Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_LIF1B     7
+
+#endif /* Si2158_DTV_AGC_FREEZE_INPUT_PROP */
+
+/* Si2158 DTV_AGC_SPEED property definition */
+#define   Si2158_DTV_AGC_SPEED_PROP 0x0708
+
+#ifdef    Si2158_DTV_AGC_SPEED_PROP
+  #define Si2158_DTV_AGC_SPEED_PROP_CODE 0x000708
+
+
+    typedef struct { /* Si2158_DTV_AGC_SPEED_PROP_struct */
+      unsigned char   agc_decim;
+      unsigned char   if_agc_speed;
+   } Si2158_DTV_AGC_SPEED_PROP_struct;
+
+   /* DTV_AGC_SPEED property, AGC_DECIM field definition (NO TITLE)*/
+   #define  Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_LSB         8
+   #define  Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_MASK        0x03
+   #define  Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_DEFAULT    0
+    #define Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF  0
+    #define Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_2    1
+    #define Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_4    2
+    #define Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_8    3
+
+   /* DTV_AGC_SPEED property, IF_AGC_SPEED field definition (NO TITLE)*/
+   #define  Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB         0
+   #define  Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK        0xff
+   #define  Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_DEFAULT    0
+    #define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO  0
+    #define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_39    39
+    #define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_54    54
+    #define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_63    63
+    #define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_89    89
+    #define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_105   105
+    #define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_121   121
+    #define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_137   137
+    #define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_158   158
+    #define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_172   172
+    #define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_185   185
+    #define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_196   196
+    #define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_206   206
+    #define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_216   216
+    #define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_219   219
+    #define Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_222   222
+
+#endif /* Si2158_DTV_AGC_SPEED_PROP */
+
+/* Si2158 DTV_CONFIG_IF_PORT property definition */
+#define   Si2158_DTV_CONFIG_IF_PORT_PROP 0x0702
+
+#ifdef    Si2158_DTV_CONFIG_IF_PORT_PROP
+  #define Si2158_DTV_CONFIG_IF_PORT_PROP_CODE 0x000702
+
+
+    typedef struct { /* Si2158_DTV_CONFIG_IF_PORT_PROP_struct */
+      unsigned char   dtv_agc_source;
+      unsigned char   dtv_out_type;
+   } Si2158_DTV_CONFIG_IF_PORT_PROP_struct;
+
+   /* DTV_CONFIG_IF_PORT property, DTV_AGC_SOURCE field definition (NO TITLE)*/
+   #define  Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_LSB         8
+   #define  Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_MASK        0x07
+   #define  Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_DEFAULT    0
+    #define Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_INTERNAL   0
+    #define Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_AGC1_3DB   1
+    #define Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_AGC2_3DB   2
+
+   /* DTV_CONFIG_IF_PORT property, DTV_OUT_TYPE field definition (NO TITLE)*/
+   #define  Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LSB         0
+   #define  Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_MASK        0x0f
+   #define  Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_DEFAULT    1
+    #define Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF1      0
+    #define Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF2      1
+    #define Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_SE_IF1A  4
+    #define Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_SE_IF2A  5
+
+#endif /* Si2158_DTV_CONFIG_IF_PORT_PROP */
+
+/* Si2158 DTV_EXT_AGC property definition */
+#define   Si2158_DTV_EXT_AGC_PROP 0x0705
+
+#ifdef    Si2158_DTV_EXT_AGC_PROP
+  #define Si2158_DTV_EXT_AGC_PROP_CODE 0x000705
+
+
+    typedef struct { /* Si2158_DTV_EXT_AGC_PROP_struct */
+      unsigned char   max_10mv;
+      unsigned char   min_10mv;
+   } Si2158_DTV_EXT_AGC_PROP_struct;
+
+   /* DTV_EXT_AGC property, MAX_10MV field definition (NO TITLE)*/
+   #define  Si2158_DTV_EXT_AGC_PROP_MAX_10MV_LSB         8
+   #define  Si2158_DTV_EXT_AGC_PROP_MAX_10MV_MASK        0xff
+   #define  Si2158_DTV_EXT_AGC_PROP_MAX_10MV_DEFAULT    200
+    #define Si2158_DTV_EXT_AGC_PROP_MAX_10MV_MAX_10MV_MIN  0
+    #define Si2158_DTV_EXT_AGC_PROP_MAX_10MV_MAX_10MV_MAX  255
+
+   /* DTV_EXT_AGC property, MIN_10MV field definition (NO TITLE)*/
+   #define  Si2158_DTV_EXT_AGC_PROP_MIN_10MV_LSB         0
+   #define  Si2158_DTV_EXT_AGC_PROP_MIN_10MV_MASK        0xff
+   #define  Si2158_DTV_EXT_AGC_PROP_MIN_10MV_DEFAULT    50
+    #define Si2158_DTV_EXT_AGC_PROP_MIN_10MV_MIN_10MV_MIN  0
+    #define Si2158_DTV_EXT_AGC_PROP_MIN_10MV_MIN_10MV_MAX  255
+
+#endif /* Si2158_DTV_EXT_AGC_PROP */
+
+/* Si2158 DTV_FILTER_SELECT property definition */
+#define   Si2158_DTV_FILTER_SELECT_PROP 0x070c
+
+#ifdef    Si2158_DTV_FILTER_SELECT_PROP
+  #define Si2158_DTV_FILTER_SELECT_PROP_CODE 0x00070c
+
+
+    typedef struct { /* Si2158_DTV_FILTER_SELECT_PROP_struct */
+      unsigned char   filter;
+   } Si2158_DTV_FILTER_SELECT_PROP_struct;
+
+   /* DTV_FILTER_SELECT property, FILTER field definition (NO TITLE)*/
+   #define  Si2158_DTV_FILTER_SELECT_PROP_FILTER_LSB         0
+   #define  Si2158_DTV_FILTER_SELECT_PROP_FILTER_MASK        0x03
+   #define  Si2158_DTV_FILTER_SELECT_PROP_FILTER_DEFAULT    1
+    #define Si2158_DTV_FILTER_SELECT_PROP_FILTER_LEGACY   0
+    #define Si2158_DTV_FILTER_SELECT_PROP_FILTER_CUSTOM1  1
+    #define Si2158_DTV_FILTER_SELECT_PROP_FILTER_CUSTOM2  2
+
+#endif /* Si2158_DTV_FILTER_SELECT_PROP */
+
+/* Si2158 DTV_IEN property definition */
+#define   Si2158_DTV_IEN_PROP 0x0701
+
+#ifdef    Si2158_DTV_IEN_PROP
+  #define Si2158_DTV_IEN_PROP_CODE 0x000701
+
+
+    typedef struct { /* Si2158_DTV_IEN_PROP_struct */
+      unsigned char   chlien;
+   } Si2158_DTV_IEN_PROP_struct;
+
+   /* DTV_IEN property, CHLIEN field definition (NO TITLE)*/
+   #define  Si2158_DTV_IEN_PROP_CHLIEN_LSB         0
+   #define  Si2158_DTV_IEN_PROP_CHLIEN_MASK        0x01
+   #define  Si2158_DTV_IEN_PROP_CHLIEN_DEFAULT    1
+    #define Si2158_DTV_IEN_PROP_CHLIEN_DISABLE  0
+    #define Si2158_DTV_IEN_PROP_CHLIEN_ENABLE   1
+
+#endif /* Si2158_DTV_IEN_PROP */
+
+/* Si2158 DTV_INITIAL_AGC_SPEED property definition */
+#define   Si2158_DTV_INITIAL_AGC_SPEED_PROP 0x070d
+
+#ifdef    Si2158_DTV_INITIAL_AGC_SPEED_PROP
+  #define Si2158_DTV_INITIAL_AGC_SPEED_PROP_CODE 0x00070d
+
+
+    typedef struct { /* Si2158_DTV_INITIAL_AGC_SPEED_PROP_struct */
+      unsigned char   agc_decim;
+      unsigned char   if_agc_speed;
+   } Si2158_DTV_INITIAL_AGC_SPEED_PROP_struct;
+
+   /* DTV_INITIAL_AGC_SPEED property, AGC_DECIM field definition (NO TITLE)*/
+   #define  Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_LSB         8
+   #define  Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_MASK        0x03
+   #define  Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_DEFAULT    0
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_OFF  0
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_2    1
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_4    2
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_8    3
+
+   /* DTV_INITIAL_AGC_SPEED property, IF_AGC_SPEED field definition (NO TITLE)*/
+   #define  Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_LSB         0
+   #define  Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_MASK        0xff
+   #define  Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_DEFAULT    0
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO  0
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_39    39
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_54    54
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_63    63
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_89    89
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_105   105
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_121   121
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_137   137
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_158   158
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_172   172
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_185   185
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_196   196
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_206   206
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_216   216
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_219   219
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_222   222
+
+#endif /* Si2158_DTV_INITIAL_AGC_SPEED_PROP */
+
+/* Si2158 DTV_INITIAL_AGC_SPEED_PERIOD property definition */
+#define   Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP 0x070e
+
+#ifdef    Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP
+  #define Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_CODE 0x00070e
+
+
+    typedef struct { /* Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_struct */
+      unsigned int    period;
+   } Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_struct;
+
+   /* DTV_INITIAL_AGC_SPEED_PERIOD property, PERIOD field definition (NO TITLE)*/
+   #define  Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_LSB         0
+   #define  Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_MASK        0xffff
+   #define  Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_DEFAULT    0
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_PERIOD_MIN  0
+    #define Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_PERIOD_MAX  65535
+
+#endif /* Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP */
+
+/* Si2158 DTV_INTERNAL_ZIF property definition */
+#define   Si2158_DTV_INTERNAL_ZIF_PROP 0x0710
+
+#ifdef    Si2158_DTV_INTERNAL_ZIF_PROP
+  #define Si2158_DTV_INTERNAL_ZIF_PROP_CODE 0x000710
+
+
+    typedef struct { /* Si2158_DTV_INTERNAL_ZIF_PROP_struct */
+      unsigned char   atsc;
+      unsigned char   dtmb;
+      unsigned char   dvbc;
+      unsigned char   dvbt;
+      unsigned char   isdbc;
+      unsigned char   isdbt;
+      unsigned char   qam_us;
+   } Si2158_DTV_INTERNAL_ZIF_PROP_struct;
+
+   /* DTV_INTERNAL_ZIF property, ATSC field definition (NO TITLE)*/
+   #define  Si2158_DTV_INTERNAL_ZIF_PROP_ATSC_LSB         0
+   #define  Si2158_DTV_INTERNAL_ZIF_PROP_ATSC_MASK        0x01
+   #define  Si2158_DTV_INTERNAL_ZIF_PROP_ATSC_DEFAULT    0
+    #define Si2158_DTV_INTERNAL_ZIF_PROP_ATSC_LIF  0
+    #define Si2158_DTV_INTERNAL_ZIF_PROP_ATSC_ZIF  1
+
+   /* DTV_INTERNAL_ZIF property, DTMB field definition (NO TITLE)*/
+   #define  Si2158_DTV_INTERNAL_ZIF_PROP_DTMB_LSB         6
+   #define  Si2158_DTV_INTERNAL_ZIF_PROP_DTMB_MASK        0x01
+   #define  Si2158_DTV_INTERNAL_ZIF_PROP_DTMB_DEFAULT    0
+    #define Si2158_DTV_INTERNAL_ZIF_PROP_DTMB_LIF  0
+    #define Si2158_DTV_INTERNAL_ZIF_PROP_DTMB_ZIF  1
+
+   /* DTV_INTERNAL_ZIF property, DVBC field definition (NO TITLE)*/
+   #define  Si2158_DTV_INTERNAL_ZIF_PROP_DVBC_LSB         3
+   #define  Si2158_DTV_INTERNAL_ZIF_PROP_DVBC_MASK        0x01
+   #define  Si2158_DTV_INTERNAL_ZIF_PROP_DVBC_DEFAULT    0
+    #define Si2158_DTV_INTERNAL_ZIF_PROP_DVBC_LIF  0
+    #define Si2158_DTV_INTERNAL_ZIF_PROP_DVBC_ZIF  1
+
+   /* DTV_INTERNAL_ZIF property, DVBT field definition (NO TITLE)*/
+   #define  Si2158_DTV_INTERNAL_ZIF_PROP_DVBT_LSB         2
+   #define  Si2158_DTV_INTERNAL_ZIF_PROP_DVBT_MASK        0x01
+   #define  Si2158_DTV_INTERNAL_ZIF_PROP_DVBT_DEFAULT    0
+    #define Si2158_DTV_INTERNAL_ZIF_PROP_DVBT_LIF  0
+    #define Si2158_DTV_INTERNAL_ZIF_PROP_DVBT_ZIF  1
+
+   /* DTV_INTERNAL_ZIF property, ISDBC field definition (NO TITLE)*/
+   #define  Si2158_DTV_INTERNAL_ZIF_PROP_ISDBC_LSB         5
+   #define  Si2158_DTV_INTERNAL_ZIF_PROP_ISDBC_MASK        0x01
+   #define  Si2158_DTV_INTERNAL_ZIF_PROP_ISDBC_DEFAULT    0
+    #define Si2158_DTV_INTERNAL_ZIF_PROP_ISDBC_LIF  0
+    #define Si2158_DTV_INTERNAL_ZIF_PROP_ISDBC_ZIF  1
+
+   /* DTV_INTERNAL_ZIF property, ISDBT field definition (NO TITLE)*/
+   #define  Si2158_DTV_INTERNAL_ZIF_PROP_ISDBT_LSB         4
+   #define  Si2158_DTV_INTERNAL_ZIF_PROP_ISDBT_MASK        0x01
+   #define  Si2158_DTV_INTERNAL_ZIF_PROP_ISDBT_DEFAULT    0
+    #define Si2158_DTV_INTERNAL_ZIF_PROP_ISDBT_LIF  0
+    #define Si2158_DTV_INTERNAL_ZIF_PROP_ISDBT_ZIF  1
+
+   /* DTV_INTERNAL_ZIF property, QAM_US field definition (NO TITLE)*/
+   #define  Si2158_DTV_INTERNAL_ZIF_PROP_QAM_US_LSB         1
+   #define  Si2158_DTV_INTERNAL_ZIF_PROP_QAM_US_MASK        0x01
+   #define  Si2158_DTV_INTERNAL_ZIF_PROP_QAM_US_DEFAULT    0
+    #define Si2158_DTV_INTERNAL_ZIF_PROP_QAM_US_LIF  0
+    #define Si2158_DTV_INTERNAL_ZIF_PROP_QAM_US_ZIF  1
+
+#endif /* Si2158_DTV_INTERNAL_ZIF_PROP */
+
+/* Si2158 DTV_INT_SENSE property definition */
+#define   Si2158_DTV_INT_SENSE_PROP 0x070a
+
+#ifdef    Si2158_DTV_INT_SENSE_PROP
+  #define Si2158_DTV_INT_SENSE_PROP_CODE 0x00070a
+
+
+    typedef struct { /* Si2158_DTV_INT_SENSE_PROP_struct */
+      unsigned char   chlnegen;
+      unsigned char   chlposen;
+   } Si2158_DTV_INT_SENSE_PROP_struct;
+
+   /* DTV_INT_SENSE property, CHLNEGEN field definition (NO TITLE)*/
+   #define  Si2158_DTV_INT_SENSE_PROP_CHLNEGEN_LSB         0
+   #define  Si2158_DTV_INT_SENSE_PROP_CHLNEGEN_MASK        0x01
+   #define  Si2158_DTV_INT_SENSE_PROP_CHLNEGEN_DEFAULT    0
+    #define Si2158_DTV_INT_SENSE_PROP_CHLNEGEN_DISABLE  0
+    #define Si2158_DTV_INT_SENSE_PROP_CHLNEGEN_ENABLE   1
+
+   /* DTV_INT_SENSE property, CHLPOSEN field definition (NO TITLE)*/
+   #define  Si2158_DTV_INT_SENSE_PROP_CHLPOSEN_LSB         8
+   #define  Si2158_DTV_INT_SENSE_PROP_CHLPOSEN_MASK        0x01
+   #define  Si2158_DTV_INT_SENSE_PROP_CHLPOSEN_DEFAULT    1
+    #define Si2158_DTV_INT_SENSE_PROP_CHLPOSEN_DISABLE  0
+    #define Si2158_DTV_INT_SENSE_PROP_CHLPOSEN_ENABLE   1
+
+#endif /* Si2158_DTV_INT_SENSE_PROP */
+
+/* Si2158 DTV_LIF_FREQ property definition */
+#define   Si2158_DTV_LIF_FREQ_PROP 0x0706
+
+#ifdef    Si2158_DTV_LIF_FREQ_PROP
+  #define Si2158_DTV_LIF_FREQ_PROP_CODE 0x000706
+
+
+    typedef struct { /* Si2158_DTV_LIF_FREQ_PROP_struct */
+      unsigned int    offset;
+   } Si2158_DTV_LIF_FREQ_PROP_struct;
+
+   /* DTV_LIF_FREQ property, OFFSET field definition (NO TITLE)*/
+   #define  Si2158_DTV_LIF_FREQ_PROP_OFFSET_LSB         0
+   #define  Si2158_DTV_LIF_FREQ_PROP_OFFSET_MASK        0xffff
+   #define  Si2158_DTV_LIF_FREQ_PROP_OFFSET_DEFAULT    5000
+    #define Si2158_DTV_LIF_FREQ_PROP_OFFSET_OFFSET_MIN  0
+    #define Si2158_DTV_LIF_FREQ_PROP_OFFSET_OFFSET_MAX  7000
+
+#endif /* Si2158_DTV_LIF_FREQ_PROP */
+
+/* Si2158 DTV_LIF_OUT property definition */
+#define   Si2158_DTV_LIF_OUT_PROP 0x0707
+
+#ifdef    Si2158_DTV_LIF_OUT_PROP
+  #define Si2158_DTV_LIF_OUT_PROP_CODE 0x000707
+
+
+    typedef struct { /* Si2158_DTV_LIF_OUT_PROP_struct */
+      unsigned char   amp;
+      unsigned char   offset;
+   } Si2158_DTV_LIF_OUT_PROP_struct;
+
+   /* DTV_LIF_OUT property, AMP field definition (NO TITLE)*/
+   #define  Si2158_DTV_LIF_OUT_PROP_AMP_LSB         8
+   #define  Si2158_DTV_LIF_OUT_PROP_AMP_MASK        0xff
+   #define  Si2158_DTV_LIF_OUT_PROP_AMP_DEFAULT    27
+    #define Si2158_DTV_LIF_OUT_PROP_AMP_AMP_MIN  0
+    #define Si2158_DTV_LIF_OUT_PROP_AMP_AMP_MAX  255
+
+   /* DTV_LIF_OUT property, OFFSET field definition (NO TITLE)*/
+   #define  Si2158_DTV_LIF_OUT_PROP_OFFSET_LSB         0
+   #define  Si2158_DTV_LIF_OUT_PROP_OFFSET_MASK        0xff
+   #define  Si2158_DTV_LIF_OUT_PROP_OFFSET_DEFAULT    148
+    #define Si2158_DTV_LIF_OUT_PROP_OFFSET_OFFSET_MIN  0
+    #define Si2158_DTV_LIF_OUT_PROP_OFFSET_OFFSET_MAX  255
+
+#endif /* Si2158_DTV_LIF_OUT_PROP */
+
+/* Si2158 DTV_MODE property definition */
+#define   Si2158_DTV_MODE_PROP 0x0703
+
+#ifdef    Si2158_DTV_MODE_PROP
+  #define Si2158_DTV_MODE_PROP_CODE 0x000703
+
+
+    typedef struct { /* Si2158_DTV_MODE_PROP_struct */
+      unsigned char   bw;
+      unsigned char   invert_spectrum;
+      unsigned char   modulation;
+   } Si2158_DTV_MODE_PROP_struct;
+
+   /* DTV_MODE property, BW field definition (NO TITLE)*/
+   #define  Si2158_DTV_MODE_PROP_BW_LSB         0
+   #define  Si2158_DTV_MODE_PROP_BW_MASK        0x0f
+   #define  Si2158_DTV_MODE_PROP_BW_DEFAULT    8
+    #define Si2158_DTV_MODE_PROP_BW_BW_6MHZ  6
+    #define Si2158_DTV_MODE_PROP_BW_BW_7MHZ  7
+    #define Si2158_DTV_MODE_PROP_BW_BW_8MHZ  8
+
+   /* DTV_MODE property, INVERT_SPECTRUM field definition (NO TITLE)*/
+   #define  Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_LSB         8
+   #define  Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_MASK        0x01
+   #define  Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_DEFAULT    0
+    #define Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_NORMAL    0
+    #define Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_INVERTED  1
+
+   /* DTV_MODE property, MODULATION field definition (NO TITLE)*/
+   #define  Si2158_DTV_MODE_PROP_MODULATION_LSB         4
+   #define  Si2158_DTV_MODE_PROP_MODULATION_MASK        0x0f
+   #define  Si2158_DTV_MODE_PROP_MODULATION_DEFAULT    2
+    #define Si2158_DTV_MODE_PROP_MODULATION_ATSC    0
+    #define Si2158_DTV_MODE_PROP_MODULATION_QAM_US  1
+    #define Si2158_DTV_MODE_PROP_MODULATION_DVBT    2
+    #define Si2158_DTV_MODE_PROP_MODULATION_DVBC    3
+    #define Si2158_DTV_MODE_PROP_MODULATION_ISDBT   4
+    #define Si2158_DTV_MODE_PROP_MODULATION_ISDBC   5
+    #define Si2158_DTV_MODE_PROP_MODULATION_DTMB    6
+
+#endif /* Si2158_DTV_MODE_PROP */
+
+/* Si2158 DTV_PGA_LIMITS property definition */
+#define   Si2158_DTV_PGA_LIMITS_PROP 0x0713
+
+#ifdef    Si2158_DTV_PGA_LIMITS_PROP
+  #define Si2158_DTV_PGA_LIMITS_PROP_CODE 0x000713
+
+
+    typedef struct { /* Si2158_DTV_PGA_LIMITS_PROP_struct */
+               char   max;
+               char   min;
+   } Si2158_DTV_PGA_LIMITS_PROP_struct;
+
+   /* DTV_PGA_LIMITS property, MAX field definition (NO TITLE)*/
+   #define  Si2158_DTV_PGA_LIMITS_PROP_MAX_LSB         8
+   #define  Si2158_DTV_PGA_LIMITS_PROP_MAX_MASK        0xff
+   #define  Si2158_DTV_PGA_LIMITS_PROP_MAX_DEFAULT    -1
+    #define Si2158_DTV_PGA_LIMITS_PROP_MAX_MAX_MIN  -1
+    #define Si2158_DTV_PGA_LIMITS_PROP_MAX_MAX_MAX  56
+
+   /* DTV_PGA_LIMITS property, MIN field definition (NO TITLE)*/
+   #define  Si2158_DTV_PGA_LIMITS_PROP_MIN_LSB         0
+   #define  Si2158_DTV_PGA_LIMITS_PROP_MIN_MASK        0xff
+   #define  Si2158_DTV_PGA_LIMITS_PROP_MIN_DEFAULT    -1
+    #define Si2158_DTV_PGA_LIMITS_PROP_MIN_MIN_MIN  -1
+    #define Si2158_DTV_PGA_LIMITS_PROP_MIN_MIN_MAX  56
+
+#endif /* Si2158_DTV_PGA_LIMITS_PROP */
+
+/* Si2158 DTV_PGA_TARGET property definition */
+#define   Si2158_DTV_PGA_TARGET_PROP 0x070f
+
+#ifdef    Si2158_DTV_PGA_TARGET_PROP
+  #define Si2158_DTV_PGA_TARGET_PROP_CODE 0x00070f
+
+
+    typedef struct { /* Si2158_DTV_PGA_TARGET_PROP_struct */
+      unsigned char   override_enable;
+               char   pga_target;
+   } Si2158_DTV_PGA_TARGET_PROP_struct;
+
+   /* DTV_PGA_TARGET property, OVERRIDE_ENABLE field definition (NO TITLE)*/
+   #define  Si2158_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_LSB         8
+   #define  Si2158_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_MASK        0x01
+   #define  Si2158_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_DEFAULT    0
+    #define Si2158_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_DISABLE  0
+    #define Si2158_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_ENABLE   1
+
+   /* DTV_PGA_TARGET property, PGA_TARGET field definition (NO TITLE)*/
+   #define  Si2158_DTV_PGA_TARGET_PROP_PGA_TARGET_LSB         0
+   #define  Si2158_DTV_PGA_TARGET_PROP_PGA_TARGET_MASK        0xff
+   #define  Si2158_DTV_PGA_TARGET_PROP_PGA_TARGET_DEFAULT    0
+    #define Si2158_DTV_PGA_TARGET_PROP_PGA_TARGET_PGA_TARGET_MIN  -13
+    #define Si2158_DTV_PGA_TARGET_PROP_PGA_TARGET_PGA_TARGET_MAX  7
+
+#endif /* Si2158_DTV_PGA_TARGET_PROP */
+
+/* Si2158 DTV_RF_TOP property definition */
+#define   Si2158_DTV_RF_TOP_PROP 0x0709
+
+#ifdef    Si2158_DTV_RF_TOP_PROP
+  #define Si2158_DTV_RF_TOP_PROP_CODE 0x000709
+
+
+    typedef struct { /* Si2158_DTV_RF_TOP_PROP_struct */
+      unsigned char   dtv_rf_top;
+   } Si2158_DTV_RF_TOP_PROP_struct;
+
+   /* DTV_RF_TOP property, DTV_RF_TOP field definition (NO TITLE)*/
+   #define  Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_LSB         0
+   #define  Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_MASK        0xff
+   #define  Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_DEFAULT    0
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_AUTO     0
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P6DB     9
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P5P5DB   10
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P5DB     11
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P4P5DB   12
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P4DB     13
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P3P5DB   14
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P3DB     15
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P2P5DB   16
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P2DB     17
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P1P5DB   18
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P1DB     19
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_P0P5DB   20
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_0DB      21
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M0P5DB   22
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M1DB     23
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M1P5DB   24
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M2DB     25
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M2P5DB   26
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M3DB     27
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M3P5DB   28
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M4DB     29
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M4P5DB   30
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M5DB     31
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M5P5DB   32
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M6DB     33
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M6P5DB   34
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M7DB     35
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M7P5DB   36
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M8DB     37
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M8P5DB   38
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M9DB     39
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M9P5DB   40
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M10DB    41
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M10P5DB  42
+    #define Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_M11DB    43
+
+#endif /* Si2158_DTV_RF_TOP_PROP */
+
+/* Si2158 DTV_RSQ_RSSI_THRESHOLD property definition */
+#define   Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP 0x0704
+
+#ifdef    Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP
+  #define Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_CODE 0x000704
+
+
+    typedef struct { /* Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_struct */
+               char   hi;
+               char   lo;
+   } Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_struct;
+
+   /* DTV_RSQ_RSSI_THRESHOLD property, HI field definition (NO TITLE)*/
+   #define  Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB         8
+   #define  Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK        0xff
+   #define  Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_DEFAULT    0
+    #define Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MIN  -128
+    #define Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_HI_MAX  127
+
+   /* DTV_RSQ_RSSI_THRESHOLD property, LO field definition (NO TITLE)*/
+   #define  Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB         0
+   #define  Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK        0xff
+   #define  Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_DEFAULT    -80
+    #define Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MIN  -128
+    #define Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LO_MAX  127
+
+#endif /* Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP */
+
+/* Si2158 DTV_ZIF_DC_CANCELLER_BW property definition */
+#define   Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP 0x0712
+
+#ifdef    Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP
+  #define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_CODE 0x000712
+
+
+    typedef struct { /* Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_struct */
+      unsigned char   bandwidth;
+   } Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_struct;
+
+   /* DTV_ZIF_DC_CANCELLER_BW property, BANDWIDTH field definition (NO TITLE)*/
+   #define  Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_LSB         0
+   #define  Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_MASK        0xff
+   #define  Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_DEFAULT    16
+    #define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_4_HZ       0
+    #define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_8_HZ       1
+    #define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_15_HZ      2
+    #define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_30_HZ      3
+    #define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_61_HZ      4
+    #define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_121_HZ     5
+    #define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_243_HZ     6
+    #define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_486_HZ     7
+    #define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_972_HZ     8
+    #define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_1943_HZ    9
+    #define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_3888_HZ    10
+    #define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_7779_HZ    11
+    #define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_15573_HZ   12
+    #define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_31207_HZ   13
+    #define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_62658_HZ   14
+    #define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_126303_HZ  15
+    #define Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_DEFAULT    16
+
+#endif /* Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP */
+
+/* Si2158 MASTER_IEN property definition */
+#define   Si2158_MASTER_IEN_PROP 0x0401
+
+#ifdef    Si2158_MASTER_IEN_PROP
+  #define Si2158_MASTER_IEN_PROP_CODE 0x000401
+
+
+    typedef struct { /* Si2158_MASTER_IEN_PROP_struct */
+      unsigned char   atvien;
+      unsigned char   ctsien;
+      unsigned char   dtvien;
+      unsigned char   errien;
+      unsigned char   tunien;
+   } Si2158_MASTER_IEN_PROP_struct;
+
+   /* MASTER_IEN property, ATVIEN field definition (NO TITLE)*/
+   #define  Si2158_MASTER_IEN_PROP_ATVIEN_LSB         1
+   #define  Si2158_MASTER_IEN_PROP_ATVIEN_MASK        0x01
+   #define  Si2158_MASTER_IEN_PROP_ATVIEN_DEFAULT    0
+    #define Si2158_MASTER_IEN_PROP_ATVIEN_OFF  0
+    #define Si2158_MASTER_IEN_PROP_ATVIEN_ON   1
+
+   /* MASTER_IEN property, CTSIEN field definition (NO TITLE)*/
+   #define  Si2158_MASTER_IEN_PROP_CTSIEN_LSB         7
+   #define  Si2158_MASTER_IEN_PROP_CTSIEN_MASK        0x01
+   #define  Si2158_MASTER_IEN_PROP_CTSIEN_DEFAULT    0
+    #define Si2158_MASTER_IEN_PROP_CTSIEN_OFF  0
+    #define Si2158_MASTER_IEN_PROP_CTSIEN_ON   1
+
+   /* MASTER_IEN property, DTVIEN field definition (NO TITLE)*/
+   #define  Si2158_MASTER_IEN_PROP_DTVIEN_LSB         2
+   #define  Si2158_MASTER_IEN_PROP_DTVIEN_MASK        0x01
+   #define  Si2158_MASTER_IEN_PROP_DTVIEN_DEFAULT    0
+    #define Si2158_MASTER_IEN_PROP_DTVIEN_OFF  0
+    #define Si2158_MASTER_IEN_PROP_DTVIEN_ON   1
+
+   /* MASTER_IEN property, ERRIEN field definition (NO TITLE)*/
+   #define  Si2158_MASTER_IEN_PROP_ERRIEN_LSB         6
+   #define  Si2158_MASTER_IEN_PROP_ERRIEN_MASK        0x01
+   #define  Si2158_MASTER_IEN_PROP_ERRIEN_DEFAULT    0
+    #define Si2158_MASTER_IEN_PROP_ERRIEN_OFF  0
+    #define Si2158_MASTER_IEN_PROP_ERRIEN_ON   1
+
+   /* MASTER_IEN property, TUNIEN field definition (NO TITLE)*/
+   #define  Si2158_MASTER_IEN_PROP_TUNIEN_LSB         0
+   #define  Si2158_MASTER_IEN_PROP_TUNIEN_MASK        0x01
+   #define  Si2158_MASTER_IEN_PROP_TUNIEN_DEFAULT    0
+    #define Si2158_MASTER_IEN_PROP_TUNIEN_OFF  0
+    #define Si2158_MASTER_IEN_PROP_TUNIEN_ON   1
+
+#endif /* Si2158_MASTER_IEN_PROP */
+
+/* Si2158 TUNER_BLOCKED_VCO property definition */
+#define   Si2158_TUNER_BLOCKED_VCO_PROP 0x0504
+
+#ifdef    Si2158_TUNER_BLOCKED_VCO_PROP
+  #define Si2158_TUNER_BLOCKED_VCO_PROP_CODE 0x000504
+
+
+    typedef struct { /* Si2158_TUNER_BLOCKED_VCO_PROP_struct */
+               int    vco_code;
+   } Si2158_TUNER_BLOCKED_VCO_PROP_struct;
+
+   /* TUNER_BLOCKED_VCO property, VCO_CODE field definition (NO TITLE)*/
+   #define  Si2158_TUNER_BLOCKED_VCO_PROP_VCO_CODE_LSB         0
+   #define  Si2158_TUNER_BLOCKED_VCO_PROP_VCO_CODE_MASK        0xffff
+   #define  Si2158_TUNER_BLOCKED_VCO_PROP_VCO_CODE_DEFAULT    0x8000
+    #define Si2158_TUNER_BLOCKED_VCO_PROP_VCO_CODE_VCO_CODE_MIN  -32768
+    #define Si2158_TUNER_BLOCKED_VCO_PROP_VCO_CODE_VCO_CODE_MAX  32767
+
+#endif /* Si2158_TUNER_BLOCKED_VCO_PROP */
+
+/* Si2158 TUNER_IEN property definition */
+#define   Si2158_TUNER_IEN_PROP 0x0501
+
+#ifdef    Si2158_TUNER_IEN_PROP
+  #define Si2158_TUNER_IEN_PROP_CODE 0x000501
+
+
+    typedef struct { /* Si2158_TUNER_IEN_PROP_struct */
+      unsigned char   rssihien;
+      unsigned char   rssilien;
+      unsigned char   tcien;
+   } Si2158_TUNER_IEN_PROP_struct;
+
+   /* TUNER_IEN property, RSSIHIEN field definition (NO TITLE)*/
+   #define  Si2158_TUNER_IEN_PROP_RSSIHIEN_LSB         2
+   #define  Si2158_TUNER_IEN_PROP_RSSIHIEN_MASK        0x01
+   #define  Si2158_TUNER_IEN_PROP_RSSIHIEN_DEFAULT    0
+    #define Si2158_TUNER_IEN_PROP_RSSIHIEN_DISABLE  0
+    #define Si2158_TUNER_IEN_PROP_RSSIHIEN_ENABLE   1
+
+   /* TUNER_IEN property, RSSILIEN field definition (NO TITLE)*/
+   #define  Si2158_TUNER_IEN_PROP_RSSILIEN_LSB         1
+   #define  Si2158_TUNER_IEN_PROP_RSSILIEN_MASK        0x01
+   #define  Si2158_TUNER_IEN_PROP_RSSILIEN_DEFAULT    0
+    #define Si2158_TUNER_IEN_PROP_RSSILIEN_DISABLE  0
+    #define Si2158_TUNER_IEN_PROP_RSSILIEN_ENABLE   1
+
+   /* TUNER_IEN property, TCIEN field definition (NO TITLE)*/
+   #define  Si2158_TUNER_IEN_PROP_TCIEN_LSB         0
+   #define  Si2158_TUNER_IEN_PROP_TCIEN_MASK        0x01
+   #define  Si2158_TUNER_IEN_PROP_TCIEN_DEFAULT    1
+    #define Si2158_TUNER_IEN_PROP_TCIEN_DISABLE  0
+    #define Si2158_TUNER_IEN_PROP_TCIEN_ENABLE   1
+
+#endif /* Si2158_TUNER_IEN_PROP */
+
+/* Si2158 TUNER_INT_SENSE property definition */
+#define   Si2158_TUNER_INT_SENSE_PROP 0x0505
+
+#ifdef    Si2158_TUNER_INT_SENSE_PROP
+  #define Si2158_TUNER_INT_SENSE_PROP_CODE 0x000505
+
+
+    typedef struct { /* Si2158_TUNER_INT_SENSE_PROP_struct */
+      unsigned char   rssihnegen;
+      unsigned char   rssihposen;
+      unsigned char   rssilnegen;
+      unsigned char   rssilposen;
+      unsigned char   tcnegen;
+      unsigned char   tcposen;
+   } Si2158_TUNER_INT_SENSE_PROP_struct;
+
+   /* TUNER_INT_SENSE property, RSSIHNEGEN field definition (NO TITLE)*/
+   #define  Si2158_TUNER_INT_SENSE_PROP_RSSIHNEGEN_LSB         2
+   #define  Si2158_TUNER_INT_SENSE_PROP_RSSIHNEGEN_MASK        0x01
+   #define  Si2158_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DEFAULT    0
+    #define Si2158_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DISABLE  0
+    #define Si2158_TUNER_INT_SENSE_PROP_RSSIHNEGEN_ENABLE   1
+
+   /* TUNER_INT_SENSE property, RSSIHPOSEN field definition (NO TITLE)*/
+   #define  Si2158_TUNER_INT_SENSE_PROP_RSSIHPOSEN_LSB         10
+   #define  Si2158_TUNER_INT_SENSE_PROP_RSSIHPOSEN_MASK        0x01
+   #define  Si2158_TUNER_INT_SENSE_PROP_RSSIHPOSEN_DEFAULT    1
+    #define Si2158_TUNER_INT_SENSE_PROP_RSSIHPOSEN_DISABLE  0
+    #define Si2158_TUNER_INT_SENSE_PROP_RSSIHPOSEN_ENABLE   1
+
+   /* TUNER_INT_SENSE property, RSSILNEGEN field definition (NO TITLE)*/
+   #define  Si2158_TUNER_INT_SENSE_PROP_RSSILNEGEN_LSB         1
+   #define  Si2158_TUNER_INT_SENSE_PROP_RSSILNEGEN_MASK        0x01
+   #define  Si2158_TUNER_INT_SENSE_PROP_RSSILNEGEN_DEFAULT    0
+    #define Si2158_TUNER_INT_SENSE_PROP_RSSILNEGEN_DISABLE  0
+    #define Si2158_TUNER_INT_SENSE_PROP_RSSILNEGEN_ENABLE   1
+
+   /* TUNER_INT_SENSE property, RSSILPOSEN field definition (NO TITLE)*/
+   #define  Si2158_TUNER_INT_SENSE_PROP_RSSILPOSEN_LSB         9
+   #define  Si2158_TUNER_INT_SENSE_PROP_RSSILPOSEN_MASK        0x01
+   #define  Si2158_TUNER_INT_SENSE_PROP_RSSILPOSEN_DEFAULT    1
+    #define Si2158_TUNER_INT_SENSE_PROP_RSSILPOSEN_DISABLE  0
+    #define Si2158_TUNER_INT_SENSE_PROP_RSSILPOSEN_ENABLE   1
+
+   /* TUNER_INT_SENSE property, TCNEGEN field definition (NO TITLE)*/
+   #define  Si2158_TUNER_INT_SENSE_PROP_TCNEGEN_LSB         0
+   #define  Si2158_TUNER_INT_SENSE_PROP_TCNEGEN_MASK        0x01
+   #define  Si2158_TUNER_INT_SENSE_PROP_TCNEGEN_DEFAULT    0
+    #define Si2158_TUNER_INT_SENSE_PROP_TCNEGEN_DISABLE  0
+    #define Si2158_TUNER_INT_SENSE_PROP_TCNEGEN_ENABLE   1
+
+   /* TUNER_INT_SENSE property, TCPOSEN field definition (NO TITLE)*/
+   #define  Si2158_TUNER_INT_SENSE_PROP_TCPOSEN_LSB         8
+   #define  Si2158_TUNER_INT_SENSE_PROP_TCPOSEN_MASK        0x01
+   #define  Si2158_TUNER_INT_SENSE_PROP_TCPOSEN_DEFAULT    1
+    #define Si2158_TUNER_INT_SENSE_PROP_TCPOSEN_DISABLE  0
+    #define Si2158_TUNER_INT_SENSE_PROP_TCPOSEN_ENABLE   1
+
+#endif /* Si2158_TUNER_INT_SENSE_PROP */
+
+/* Si2158 TUNER_LO_INJECTION property definition */
+#define   Si2158_TUNER_LO_INJECTION_PROP 0x0506
+
+#ifdef    Si2158_TUNER_LO_INJECTION_PROP
+  #define Si2158_TUNER_LO_INJECTION_PROP_CODE 0x000506
+
+
+    typedef struct { /* Si2158_TUNER_LO_INJECTION_PROP_struct */
+      unsigned char   band_1;
+      unsigned char   band_2;
+      unsigned char   band_3;
+   } Si2158_TUNER_LO_INJECTION_PROP_struct;
+
+   /* TUNER_LO_INJECTION property, BAND_1 field definition (NO TITLE)*/
+   #define  Si2158_TUNER_LO_INJECTION_PROP_BAND_1_LSB         0
+   #define  Si2158_TUNER_LO_INJECTION_PROP_BAND_1_MASK        0x01
+   #define  Si2158_TUNER_LO_INJECTION_PROP_BAND_1_DEFAULT    1
+    #define Si2158_TUNER_LO_INJECTION_PROP_BAND_1_LOW_SIDE   0
+    #define Si2158_TUNER_LO_INJECTION_PROP_BAND_1_HIGH_SIDE  1
+
+   /* TUNER_LO_INJECTION property, BAND_2 field definition (NO TITLE)*/
+   #define  Si2158_TUNER_LO_INJECTION_PROP_BAND_2_LSB         1
+   #define  Si2158_TUNER_LO_INJECTION_PROP_BAND_2_MASK        0x01
+   #define  Si2158_TUNER_LO_INJECTION_PROP_BAND_2_DEFAULT    0
+    #define Si2158_TUNER_LO_INJECTION_PROP_BAND_2_LOW_SIDE   0
+    #define Si2158_TUNER_LO_INJECTION_PROP_BAND_2_HIGH_SIDE  1
+
+   /* TUNER_LO_INJECTION property, BAND_3 field definition (NO TITLE)*/
+   #define  Si2158_TUNER_LO_INJECTION_PROP_BAND_3_LSB         2
+   #define  Si2158_TUNER_LO_INJECTION_PROP_BAND_3_MASK        0x01
+   #define  Si2158_TUNER_LO_INJECTION_PROP_BAND_3_DEFAULT    0
+    #define Si2158_TUNER_LO_INJECTION_PROP_BAND_3_LOW_SIDE   0
+    #define Si2158_TUNER_LO_INJECTION_PROP_BAND_3_HIGH_SIDE  1
+
+#endif /* Si2158_TUNER_LO_INJECTION_PROP */
+
+/* Si2158 TUNER_RETURN_LOSS property definition */
+#define   Si2158_TUNER_RETURN_LOSS_PROP 0x0507
+
+#ifdef    Si2158_TUNER_RETURN_LOSS_PROP
+  #define Si2158_TUNER_RETURN_LOSS_PROP_CODE 0x000507
+
+
+    typedef struct { /* Si2158_TUNER_RETURN_LOSS_PROP_struct */
+      unsigned char   config;
+      unsigned char   mode;
+   } Si2158_TUNER_RETURN_LOSS_PROP_struct;
+
+   /* TUNER_RETURN_LOSS property, CONFIG field definition (NO TITLE)*/
+   #define  Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_LSB         0
+   #define  Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_MASK        0xff
+   #define  Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_DEFAULT    127
+    #define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_27   27
+    #define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_31   31
+    #define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_35   35
+    #define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_39   39
+    #define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_43   43
+    #define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_47   47
+    #define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_51   51
+    #define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_59   59
+    #define Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_127  127
+
+   /* TUNER_RETURN_LOSS property, MODE field definition (NO TITLE)*/
+   #define  Si2158_TUNER_RETURN_LOSS_PROP_MODE_LSB         8
+   #define  Si2158_TUNER_RETURN_LOSS_PROP_MODE_MASK        0xff
+   #define  Si2158_TUNER_RETURN_LOSS_PROP_MODE_DEFAULT    0
+    #define Si2158_TUNER_RETURN_LOSS_PROP_MODE_TERRESTRIAL  0
+    #define Si2158_TUNER_RETURN_LOSS_PROP_MODE_CABLE        1
+
+#endif /* Si2158_TUNER_RETURN_LOSS_PROP */
+
+/* _properties_defines_insertion_point */
+
+/* _properties_struct_insertion_start */
+
+  /* --------------------------------------------*/
+  /* PROPERTIES STRUCT                           */
+  /* This stores all property fields             */
+  /* --------------------------------------------*/
+  typedef struct {
+    #ifdef    Si2158_ATV_AFC_RANGE_PROP
+              Si2158_ATV_AFC_RANGE_PROP_struct                 atv_afc_range;
+    #endif /* Si2158_ATV_AFC_RANGE_PROP */
+    #ifdef    Si2158_ATV_AGC_SPEED_PROP
+              Si2158_ATV_AGC_SPEED_PROP_struct                 atv_agc_speed;
+    #endif /* Si2158_ATV_AGC_SPEED_PROP */
+    #ifdef    Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP
+              Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_struct        atv_agc_speed_low_rssi;
+    #endif /* Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP */
+    #ifdef    Si2158_ATV_ARTIFICIAL_SNOW_PROP
+              Si2158_ATV_ARTIFICIAL_SNOW_PROP_struct           atv_artificial_snow;
+    #endif /* Si2158_ATV_ARTIFICIAL_SNOW_PROP */
+    #ifdef    Si2158_ATV_CONFIG_IF_PORT_PROP
+              Si2158_ATV_CONFIG_IF_PORT_PROP_struct            atv_config_if_port;
+    #endif /* Si2158_ATV_CONFIG_IF_PORT_PROP */
+    #ifdef    Si2158_ATV_EXT_AGC_PROP
+              Si2158_ATV_EXT_AGC_PROP_struct                   atv_ext_agc;
+    #endif /* Si2158_ATV_EXT_AGC_PROP */
+    #ifdef    Si2158_ATV_IEN_PROP
+              Si2158_ATV_IEN_PROP_struct                       atv_ien;
+    #endif /* Si2158_ATV_IEN_PROP */
+    #ifdef    Si2158_ATV_INT_SENSE_PROP
+              Si2158_ATV_INT_SENSE_PROP_struct                 atv_int_sense;
+    #endif /* Si2158_ATV_INT_SENSE_PROP */
+    #ifdef    Si2158_ATV_LIF_FREQ_PROP
+              Si2158_ATV_LIF_FREQ_PROP_struct                  atv_lif_freq;
+    #endif /* Si2158_ATV_LIF_FREQ_PROP */
+    #ifdef    Si2158_ATV_LIF_OUT_PROP
+              Si2158_ATV_LIF_OUT_PROP_struct                   atv_lif_out;
+    #endif /* Si2158_ATV_LIF_OUT_PROP */
+    #ifdef    Si2158_ATV_PGA_TARGET_PROP
+              Si2158_ATV_PGA_TARGET_PROP_struct                atv_pga_target;
+    #endif /* Si2158_ATV_PGA_TARGET_PROP */
+    #ifdef    Si2158_ATV_RF_TOP_PROP
+              Si2158_ATV_RF_TOP_PROP_struct                    atv_rf_top;
+    #endif /* Si2158_ATV_RF_TOP_PROP */
+    #ifdef    Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP
+              Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_struct        atv_rsq_rssi_threshold;
+    #endif /* Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP */
+    #ifdef    Si2158_ATV_VIDEO_MODE_PROP
+              Si2158_ATV_VIDEO_MODE_PROP_struct                atv_video_mode;
+    #endif /* Si2158_ATV_VIDEO_MODE_PROP */
+    #ifdef    Si2158_ATV_VSNR_CAP_PROP
+              Si2158_ATV_VSNR_CAP_PROP_struct                  atv_vsnr_cap;
+    #endif /* Si2158_ATV_VSNR_CAP_PROP */
+    #ifdef    Si2158_CRYSTAL_TRIM_PROP
+              Si2158_CRYSTAL_TRIM_PROP_struct                  crystal_trim;
+    #endif /* Si2158_CRYSTAL_TRIM_PROP */
+    #ifdef    Si2158_DTV_AGC_FREEZE_INPUT_PROP
+              Si2158_DTV_AGC_FREEZE_INPUT_PROP_struct          dtv_agc_freeze_input;
+    #endif /* Si2158_DTV_AGC_FREEZE_INPUT_PROP */
+    #ifdef    Si2158_DTV_AGC_SPEED_PROP
+              Si2158_DTV_AGC_SPEED_PROP_struct                 dtv_agc_speed;
+    #endif /* Si2158_DTV_AGC_SPEED_PROP */
+    #ifdef    Si2158_DTV_CONFIG_IF_PORT_PROP
+              Si2158_DTV_CONFIG_IF_PORT_PROP_struct            dtv_config_if_port;
+    #endif /* Si2158_DTV_CONFIG_IF_PORT_PROP */
+    #ifdef    Si2158_DTV_EXT_AGC_PROP
+              Si2158_DTV_EXT_AGC_PROP_struct                   dtv_ext_agc;
+    #endif /* Si2158_DTV_EXT_AGC_PROP */
+    #ifdef    Si2158_DTV_FILTER_SELECT_PROP
+              Si2158_DTV_FILTER_SELECT_PROP_struct             dtv_filter_select;
+    #endif /* Si2158_DTV_FILTER_SELECT_PROP */
+    #ifdef    Si2158_DTV_IEN_PROP
+              Si2158_DTV_IEN_PROP_struct                       dtv_ien;
+    #endif /* Si2158_DTV_IEN_PROP */
+    #ifdef    Si2158_DTV_INITIAL_AGC_SPEED_PROP
+              Si2158_DTV_INITIAL_AGC_SPEED_PROP_struct         dtv_initial_agc_speed;
+    #endif /* Si2158_DTV_INITIAL_AGC_SPEED_PROP */
+    #ifdef    Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP
+              Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_struct  dtv_initial_agc_speed_period;
+    #endif /* Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP */
+    #ifdef    Si2158_DTV_INTERNAL_ZIF_PROP
+              Si2158_DTV_INTERNAL_ZIF_PROP_struct              dtv_internal_zif;
+    #endif /* Si2158_DTV_INTERNAL_ZIF_PROP */
+    #ifdef    Si2158_DTV_INT_SENSE_PROP
+              Si2158_DTV_INT_SENSE_PROP_struct                 dtv_int_sense;
+    #endif /* Si2158_DTV_INT_SENSE_PROP */
+    #ifdef    Si2158_DTV_LIF_FREQ_PROP
+              Si2158_DTV_LIF_FREQ_PROP_struct                  dtv_lif_freq;
+    #endif /* Si2158_DTV_LIF_FREQ_PROP */
+    #ifdef    Si2158_DTV_LIF_OUT_PROP
+              Si2158_DTV_LIF_OUT_PROP_struct                   dtv_lif_out;
+    #endif /* Si2158_DTV_LIF_OUT_PROP */
+    #ifdef    Si2158_DTV_MODE_PROP
+              Si2158_DTV_MODE_PROP_struct                      dtv_mode;
+    #endif /* Si2158_DTV_MODE_PROP */
+    #ifdef    Si2158_DTV_PGA_LIMITS_PROP
+              Si2158_DTV_PGA_LIMITS_PROP_struct                dtv_pga_limits;
+    #endif /* Si2158_DTV_PGA_LIMITS_PROP */
+    #ifdef    Si2158_DTV_PGA_TARGET_PROP
+              Si2158_DTV_PGA_TARGET_PROP_struct                dtv_pga_target;
+    #endif /* Si2158_DTV_PGA_TARGET_PROP */
+    #ifdef    Si2158_DTV_RF_TOP_PROP
+              Si2158_DTV_RF_TOP_PROP_struct                    dtv_rf_top;
+    #endif /* Si2158_DTV_RF_TOP_PROP */
+    #ifdef    Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP
+              Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_struct        dtv_rsq_rssi_threshold;
+    #endif /* Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP */
+    #ifdef    Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP
+              Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_struct       dtv_zif_dc_canceller_bw;
+    #endif /* Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP */
+    #ifdef    Si2158_MASTER_IEN_PROP
+              Si2158_MASTER_IEN_PROP_struct                    master_ien;
+    #endif /* Si2158_MASTER_IEN_PROP */
+    #ifdef    Si2158_TUNER_BLOCKED_VCO_PROP
+              Si2158_TUNER_BLOCKED_VCO_PROP_struct             tuner_blocked_vco;
+    #endif /* Si2158_TUNER_BLOCKED_VCO_PROP */
+    #ifdef    Si2158_TUNER_IEN_PROP
+              Si2158_TUNER_IEN_PROP_struct                     tuner_ien;
+    #endif /* Si2158_TUNER_IEN_PROP */
+    #ifdef    Si2158_TUNER_INT_SENSE_PROP
+              Si2158_TUNER_INT_SENSE_PROP_struct               tuner_int_sense;
+    #endif /* Si2158_TUNER_INT_SENSE_PROP */
+    #ifdef    Si2158_TUNER_LO_INJECTION_PROP
+              Si2158_TUNER_LO_INJECTION_PROP_struct            tuner_lo_injection;
+    #endif /* Si2158_TUNER_LO_INJECTION_PROP */
+    #ifdef    Si2158_TUNER_RETURN_LOSS_PROP
+              Si2158_TUNER_RETURN_LOSS_PROP_struct             tuner_return_loss;
+    #endif /* Si2158_TUNER_RETURN_LOSS_PROP */
+  } Si2158_PropObj;
+/* _properties_struct_insertion_point */
+
+/* #define   Si2158_GET_PROPERTY_STRING */
+
+#endif /* _Si2158_PROPERTIES_H_ */
+
+
+
+
+
diff -urN a/drivers/media/dvb-frontends/si2168_20_ROM2_Patch_2_0b5.h b/drivers/media/dvb-frontends/si2168_20_ROM2_Patch_2_0b5.h
--- a/drivers/media/dvb-frontends/si2168_20_ROM2_Patch_2_0b5.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/si2168_20_ROM2_Patch_2_0b5.h	2013-02-14 22:56:24.000000000 +0800
@@ -0,0 +1,818 @@
+#ifndef _Si2168_PATCH_2_0b5_TABLE_H_
+#define _Si2168_PATCH_2_0b5_TABLE_H_
+
+#define Si2168_PATCH_2_0b5_PART    68
+#define Si2168_PATCH_2_0b5_ROM      2
+#define Si2168_PATCH_2_0b5_PMAJOR  '2'
+#define Si2168_PATCH_2_0b5_PMINOR  '0'
+#define Si2168_PATCH_2_0b5_PBUILD   3
+
+unsigned char Si2168_Patch_2_0b5[] = {
+0x04,0x01,0x00,0x00,0x00,0x00,0x6E,0x22,
+0x05,0x8A,0xC7,0x3F,0x6A,0x43,0x27,0x94,
+0x2A,0xA1,0x65,0x0E,0xAD,0x67,0x7B,0x0D,
+0x05,0x68,0x6B,0xE7,0xC3,0xAD,0xF0,0xDC,
+0x22,0xD7,0xDD,0x95,0x46,0x13,0xD0,0xF8,
+0x05,0x02,0x93,0x0D,0x17,0x9C,0x87,0x95,
+0x2A,0xBB,0xAB,0xDD,0x99,0xD4,0x4A,0x43,
+0x05,0x56,0x55,0x15,0x28,0xD5,0x94,0xD3,
+0x22,0x6B,0x94,0x09,0x42,0xE6,0x53,0xDE,
+0x05,0xD2,0xEA,0xAF,0x7F,0xF7,0x2A,0xC0,
+0x22,0xC9,0x77,0xE4,0x73,0x56,0x8C,0xF3,
+0x05,0x69,0xF9,0xE7,0x8B,0x9B,0xFF,0x89,
+0x27,0x96,0x91,0x8E,0x83,0x82,0xD5,0x5F,
+0x27,0x1E,0x9A,0x0A,0x10,0x48,0x01,0x85,
+0x2F,0xB4,0x9F,0xD3,0x54,0xEE,0x7E,0xEB,
+0x2F,0x08,0x68,0xC9,0x51,0xCA,0x35,0x14,
+0x27,0x83,0x90,0xA8,0xC1,0x7C,0xDE,0xD2,
+0x27,0x0D,0x5C,0xBF,0xCD,0xA0,0xCC,0x56,
+0x27,0xF8,0xBF,0x57,0x09,0x9E,0xCC,0x1B,
+0x27,0x67,0x1C,0x92,0x39,0xB0,0xD3,0x77,
+0x2F,0xEB,0x40,0xFF,0xFC,0x5D,0xC9,0x46,
+0x2F,0x81,0x3B,0x65,0x96,0xC1,0xC9,0x72,
+0x27,0x0D,0x5F,0x5B,0xD9,0xC1,0x1C,0xB4,
+0x27,0x6B,0xCA,0xF6,0x84,0xFC,0xEE,0xCE,
+0x2F,0xE8,0x3C,0x26,0xCF,0x1C,0xF6,0xBF,
+0x27,0x9F,0x7C,0x60,0xF8,0xF6,0x1F,0x6F,
+0x27,0xFB,0x6C,0xE2,0xF9,0xC7,0xA5,0x30,
+0x2F,0x31,0x78,0xFB,0xAD,0xFF,0xD1,0x7C,
+0x27,0x2C,0x79,0x51,0x3A,0x9E,0x70,0xB9,
+0x27,0x9C,0x91,0xBD,0xE7,0x23,0x1F,0x5E,
+0x27,0x0F,0x7D,0x82,0x09,0xD1,0xEF,0x48,
+0x2F,0x48,0x0B,0x3E,0x5B,0x58,0x4A,0xA3,
+0x27,0x1E,0xB3,0x41,0x81,0x59,0xDD,0x0F,
+0x2F,0xEC,0xA8,0x54,0x44,0x49,0x9C,0xF9,
+0x27,0xE4,0xAE,0x01,0xD1,0xDD,0x22,0x14,
+0x2F,0x3F,0xA9,0x3A,0x88,0xA8,0x7D,0xC5,
+0x27,0x04,0x3B,0x2A,0xD8,0x30,0x66,0xE9,
+0x27,0x58,0x6F,0x93,0xB2,0x4F,0x59,0x19,
+0x27,0x58,0xCC,0xDF,0x44,0xD0,0x58,0x89,
+0x2F,0x67,0x72,0xC0,0x15,0x4C,0x54,0x16,
+0x2F,0x5A,0xFE,0x0F,0x15,0x6C,0x27,0xC9,
+0x2F,0x23,0xC6,0x71,0xA7,0x70,0x24,0xE2,
+0x2F,0xDD,0xB0,0x33,0x71,0x6E,0x50,0x46,
+0x2F,0x32,0x95,0x38,0xD7,0x1E,0xD8,0x0B,
+0x2F,0x74,0x49,0x1B,0x1A,0x90,0x28,0x29,
+0x2F,0xC2,0x8C,0x74,0xA6,0xDB,0x54,0x33,
+0x2F,0x3A,0xE0,0x31,0x10,0x3F,0xC2,0x67,
+0x2F,0x86,0x34,0x8A,0x11,0x2D,0xD7,0x92,
+0x27,0xA7,0xF7,0x3D,0xE3,0x79,0x39,0x0F,
+0x2F,0xA0,0xAF,0xC6,0xD2,0xC7,0xD2,0x6D,
+0x2F,0xBD,0x30,0x5F,0x7B,0x54,0x94,0xB8,
+0x2F,0x0B,0x37,0x94,0xDB,0x7F,0x43,0x07,
+0x27,0xA5,0x7F,0xC4,0xC8,0x91,0xF3,0xC7,
+0x2F,0x5B,0xE5,0x75,0xA4,0x40,0x53,0x47,
+0x2F,0x5E,0x83,0xD0,0x22,0x99,0xB7,0xA6,
+0x2F,0xA5,0x2B,0x44,0x02,0x40,0x3C,0xF4,
+0x27,0x05,0xE0,0x90,0x42,0x6D,0xB6,0x2E,
+0x27,0xA8,0x6F,0x27,0x1B,0xAF,0xEA,0xB1,
+0x2F,0x56,0x9A,0x85,0xB5,0xFE,0x29,0x57,
+0x27,0x9B,0x53,0x9F,0x41,0x62,0x52,0x25,
+0x2F,0x2E,0xB2,0x16,0x14,0x95,0xE5,0xD9,
+0x27,0xD5,0x6C,0xB7,0xA7,0x21,0xE2,0xBB,
+0x27,0x9B,0x07,0x42,0xB7,0xFC,0xF5,0xC6,
+0x2F,0x77,0x36,0x47,0x57,0xF3,0x71,0x06,
+0x27,0xF4,0x25,0x41,0x87,0x5C,0xB6,0x70,
+0x27,0xC9,0x81,0xD3,0x7E,0xF2,0x6B,0x5E,
+0x2F,0xE8,0xD1,0x50,0x1F,0x94,0x4E,0xD0,
+0x27,0xCB,0x2F,0xE2,0x04,0x89,0x4E,0x4F,
+0x27,0xC5,0x09,0x09,0x0D,0x62,0x40,0x84,
+0x2F,0x24,0x4E,0xDA,0xBF,0x65,0x84,0x45,
+0x27,0x70,0x45,0x3B,0x16,0xA0,0xA4,0x92,
+0x2F,0xC6,0xB6,0x61,0x92,0x27,0x50,0x30,
+0x2F,0x79,0x9C,0x38,0xFE,0x72,0xD9,0x17,
+0x27,0x05,0xB5,0x57,0x86,0x73,0x31,0x8B,
+0x2F,0xA0,0x72,0xD1,0xD1,0x0F,0x71,0xAE,
+0x2F,0x58,0xE1,0x15,0x8C,0x41,0xE4,0x14,
+0x2F,0x79,0xE1,0x2F,0x04,0xD6,0xF7,0xE6,
+0x2F,0xDA,0xF1,0x99,0x1A,0x2A,0xFC,0x74,
+0x2F,0x4F,0x0F,0x4A,0xF8,0xDF,0x7E,0x31,
+0x27,0xB7,0x84,0x0E,0xE9,0x83,0xD3,0x1C,
+0x2F,0xC7,0x8B,0x37,0xCA,0xA4,0x99,0x2B,
+0x27,0x55,0xD9,0x0D,0xFC,0xE8,0xB2,0x45,
+0x2F,0xDC,0x96,0xE2,0x33,0xD7,0xD2,0x5A,
+0x27,0x44,0xEF,0xAF,0x34,0x75,0xF1,0xF0,
+0x2F,0x84,0x84,0x91,0x4B,0x0A,0x7B,0xD0,
+0x2F,0xDC,0x67,0x6F,0x5D,0x59,0xC2,0x9F,
+0x27,0xAC,0xF5,0xDB,0x23,0x46,0xFB,0xAF,
+0x27,0x17,0x3F,0x27,0x0C,0x34,0x6B,0x2F,
+0x27,0xCC,0x2F,0xD1,0xCB,0x8C,0xBE,0xD2,
+0x2F,0x2E,0x79,0x26,0xA5,0xEA,0x05,0x49,
+0x27,0x12,0x88,0x17,0x3A,0xD3,0x41,0x7E,
+0x27,0xCE,0xBC,0xFD,0x24,0x72,0xCE,0x77,
+0x27,0x91,0xF9,0x72,0x68,0x83,0xF7,0x5C,
+0x2F,0xFD,0xAC,0xE3,0x8B,0x59,0x4E,0x5D,
+0x2F,0x13,0xB3,0xA0,0xE9,0xDE,0x58,0xBD,
+0x27,0xF7,0x6A,0x2E,0x84,0xA7,0x14,0x48,
+0x27,0x08,0xE6,0xBC,0x96,0xDF,0xF9,0xE3,
+0x27,0x55,0xFF,0x97,0x69,0x40,0x12,0x9B,
+0x27,0x6E,0x73,0x46,0xA7,0xFD,0x24,0x0B,
+0x2F,0xC0,0x34,0x12,0xB9,0x86,0x80,0x99,
+0x2F,0x35,0x88,0xB7,0xE3,0x37,0xF6,0xB9,
+0x2F,0x0A,0x6E,0x26,0x63,0xA2,0x7F,0x73,
+0x27,0xC0,0x93,0x01,0x5A,0xB3,0x76,0x6F,
+0x2F,0x1A,0x12,0x1E,0xA5,0x2F,0x63,0x79,
+0x2F,0xF4,0x0E,0xCF,0xCC,0x5D,0x32,0x73,
+0x2F,0x74,0x3D,0xBC,0x18,0x30,0x6A,0xB0,
+0x27,0x3C,0xB7,0xAC,0xCC,0xB3,0x20,0x56,
+0x2F,0x76,0xAD,0x00,0x52,0xC9,0xA0,0xE1,
+0x27,0x15,0x3B,0xE4,0x7B,0xF6,0x0F,0xE2,
+0x2F,0x5D,0x70,0x35,0xDE,0x4B,0x3E,0x3B,
+0x2F,0x8D,0xE3,0x7B,0xBA,0xF0,0x7D,0xBF,
+0x27,0x35,0xFD,0xD3,0x2B,0x35,0x3B,0x9C,
+0x2F,0x6A,0x9C,0xD5,0x95,0x2C,0x86,0x1C,
+0x27,0x42,0x0C,0x1F,0xEA,0xCD,0xF5,0x97,
+0x27,0x65,0xB1,0x36,0x1D,0xDC,0x55,0x83,
+0x2F,0x88,0x89,0x23,0x65,0x4C,0x98,0xAA,
+0x2F,0x26,0x4F,0x6F,0x74,0xD3,0x93,0xBA,
+0x2F,0x94,0xA1,0x7D,0x61,0x84,0x1B,0xF9,
+0x27,0x8D,0xD3,0x85,0x70,0xE0,0xFC,0xF7,
+0x27,0x58,0xE6,0xAA,0x6C,0x2C,0x8E,0x13,
+0x2F,0x95,0xC3,0x8D,0xC0,0x8D,0x14,0x5E,
+0x2F,0xE2,0x71,0x93,0x92,0xF0,0xE7,0x4C,
+0x2F,0x2E,0x2D,0x14,0x4B,0x64,0x90,0x66,
+0x2F,0x9A,0x34,0x47,0xFA,0x2F,0x95,0xE9,
+0x2F,0xEE,0x30,0x62,0xE2,0x6C,0xED,0x87,
+0x2F,0xBC,0x86,0xDB,0xD5,0xB6,0x3F,0x24,
+0x27,0xC7,0x6B,0x9A,0xAB,0x63,0x7F,0x17,
+0x2F,0x1E,0xD2,0x78,0x27,0xE1,0x69,0x2A,
+0x27,0x64,0x69,0x37,0x1C,0x8D,0xBD,0x13,
+0x27,0x92,0x1B,0x30,0x48,0x10,0xC7,0x86,
+0x2F,0x29,0x03,0x95,0x97,0x23,0x1E,0x1C,
+0x27,0xD5,0x24,0x62,0x80,0xDC,0xE9,0x40,
+0x27,0xF1,0xAA,0x89,0x7A,0xFF,0xD4,0x85,
+0x2F,0x15,0x9B,0x5D,0x89,0xC8,0x9E,0x7A,
+0x2F,0x7A,0xA5,0xDD,0x4C,0xFC,0x33,0x98,
+0x2F,0x5D,0x3E,0xD4,0x38,0x49,0xB5,0x09,
+0x2F,0x8E,0xD6,0x1C,0x1B,0x9C,0x20,0x75,
+0x27,0x04,0x27,0x8B,0x02,0x5E,0x0F,0x83,
+0x27,0x4A,0xDB,0xDC,0xFF,0x1F,0xA8,0x7C,
+0x2F,0xEC,0x32,0x5B,0x7B,0xEB,0xBB,0xA4,
+0x27,0x04,0x64,0x47,0x68,0x0D,0x07,0xFC,
+0x27,0x62,0x0F,0x73,0xF0,0xF5,0x28,0x6C,
+0x27,0x19,0xCD,0x24,0x9B,0x4F,0x6C,0x38,
+0x27,0x06,0x42,0x9F,0xE3,0x8A,0xE8,0xE9,
+0x27,0xD8,0xC8,0xE4,0x90,0x15,0x8A,0xD6,
+0x27,0x1B,0xB3,0xE4,0x21,0x6F,0x56,0xEE,
+0x27,0xCF,0x92,0x4A,0x30,0x12,0x52,0xFE,
+0x27,0x11,0x3B,0x9B,0x78,0x43,0x76,0xF3,
+0x2F,0x11,0x06,0x5B,0xA4,0xCB,0xCD,0x06,
+0x2F,0x5D,0x07,0x26,0xEF,0xCF,0x8F,0x4E,
+0x2F,0xFA,0x47,0xA6,0x98,0x51,0x49,0x24,
+0x27,0x71,0x79,0x55,0x75,0x86,0x8C,0x08,
+0x27,0xE6,0x3F,0xD5,0x2B,0x73,0xE8,0xB4,
+0x2F,0x35,0xE7,0xE5,0xAB,0x21,0xBD,0x4F,
+0x2F,0xF7,0x12,0x32,0x50,0x55,0x17,0x69,
+0x27,0xF8,0x9F,0xF8,0x6F,0x16,0x66,0x76,
+0x27,0x0A,0x27,0x82,0xA0,0xF9,0x32,0xB7,
+0x2F,0x44,0x4B,0x76,0x26,0xD4,0x37,0x89,
+0x27,0x63,0x30,0xE8,0xBF,0x26,0x4E,0xAF,
+0x27,0x38,0xF9,0xFB,0xB8,0x2E,0x3B,0x23,
+0x27,0x4F,0x21,0x3E,0x7C,0x69,0x4D,0x6D,
+0x27,0x22,0xCB,0x6D,0x2B,0xF6,0xF1,0x0B,
+0x2F,0x75,0xCC,0xDD,0xA7,0x2A,0x3A,0x80,
+0x2F,0x6A,0x39,0x70,0x31,0xCC,0xEA,0x93,
+0x27,0x88,0xF1,0x1E,0x87,0x92,0x4A,0xAC,
+0x2F,0x14,0xAD,0x2F,0x55,0x46,0x60,0xAA,
+0x27,0xB0,0x01,0x00,0x2B,0x1C,0x3A,0x41,
+0x27,0xD5,0x6D,0x7C,0x2B,0xD7,0xDD,0xD8,
+0x27,0xFE,0x23,0x37,0xB3,0x10,0xAE,0x31,
+0x27,0xBC,0xAB,0x1A,0xCC,0x7F,0x14,0xE5,
+0x27,0x91,0x77,0x0C,0xDD,0xAB,0x3A,0x50,
+0x27,0x23,0x07,0x2F,0x00,0xC1,0x25,0x10,
+0x27,0xD7,0xFB,0x2D,0xE7,0xFB,0xFC,0x74,
+0x2F,0x82,0xB5,0x2A,0xEA,0x5D,0xD9,0x1A,
+0x27,0x83,0xEA,0xB7,0x9B,0x9C,0x4C,0xAB,
+0x2F,0x33,0x8D,0xD4,0xCA,0x4E,0xBF,0x9A,
+0x2F,0x3A,0x76,0xD6,0xC3,0xB8,0x99,0xA6,
+0x2F,0x13,0x48,0x1B,0x5F,0x2E,0xAC,0x01,
+0x27,0x1C,0xEE,0x4F,0xC3,0x57,0x13,0xFF,
+0x2F,0x47,0xD9,0xD3,0x05,0x19,0x47,0x81,
+0x27,0x4F,0x0C,0x06,0x4D,0x08,0x70,0x2A,
+0x2F,0xB9,0x54,0x46,0xFE,0x6B,0x72,0x90,
+0x27,0x69,0xDA,0xFC,0x92,0x94,0xA8,0x2F,
+0x27,0xB5,0x8A,0xC0,0x20,0xBD,0x70,0xA7,
+0x2F,0x0D,0x52,0xDC,0xFF,0x5A,0x32,0xCC,
+0x27,0x44,0xB1,0x2C,0x10,0x39,0x49,0x38,
+0x27,0x41,0xE7,0x37,0x7A,0x0C,0x30,0x89,
+0x2F,0x1C,0x7F,0x40,0xEA,0xE3,0xA0,0xDE,
+0x27,0xB6,0x5D,0xA1,0x1B,0x7E,0x1A,0xDD,
+0x2F,0x0B,0xC7,0xAF,0xA5,0xDA,0xFE,0xDA,
+0x27,0x33,0x32,0xFF,0x01,0x7D,0x29,0x22,
+0x2F,0x01,0x34,0xE2,0xD2,0x0A,0xAA,0x3F,
+0x27,0x87,0x24,0x77,0x6C,0xE9,0x1E,0xCB,
+0x27,0x92,0x62,0x8D,0x76,0xC2,0x8D,0x44,
+0x2F,0xFA,0xEE,0x3C,0xA9,0x62,0xCC,0x12,
+0x27,0x50,0xBE,0x4C,0xBC,0x8F,0xD4,0x2D,
+0x27,0xCF,0x8A,0x22,0xDD,0x31,0xC2,0x7C,
+0x2F,0xE4,0x95,0x2D,0xB7,0x97,0xEE,0x6B,
+0x2F,0xC5,0x00,0x8E,0xF8,0x31,0x22,0xC3,
+0x27,0x8F,0xD7,0x29,0x24,0xB3,0x25,0x39,
+0x27,0x45,0xD4,0x58,0x2A,0x98,0xA4,0x43,
+0x27,0xEC,0x9B,0xDF,0xBC,0x4F,0x6E,0xD9,
+0x2F,0xBD,0xCB,0xC2,0xCF,0x41,0x70,0xCF,
+0x27,0x43,0x2B,0x1A,0xDB,0x8D,0x63,0x26,
+0x2F,0xD5,0x9B,0xAB,0xC7,0x77,0x75,0x7E,
+0x27,0x1F,0x63,0xBC,0xF3,0x9B,0x9D,0xBE,
+0x2F,0xF4,0x65,0x69,0xA4,0x72,0x23,0xCA,
+0x21,0xFB,0x21,0x43,0x02,0xCB,0x99,0x36,
+0x05,0x00,0x47,0x01,0xF1,0x03,0x5F,0x8D,
+0x22,0x1E,0xC2,0x9B,0x4A,0x01,0xD1,0xCF,
+0x05,0x90,0x38,0xFC,0x96,0xC0,0x98,0x96,
+0x2C,0x24,0x41,0x26,0x01,0xA4,0x24,0x12,
+0x05,0xE0,0xED,0x23,0xAE,0x82,0xA9,0xE6,
+0x22,0xE5,0xB8,0xB5,0x95,0xAD,0x92,0xC6,
+0x05,0xCD,0xF6,0x39,0xB9,0x0B,0x09,0x76,
+0x22,0x1C,0x35,0x18,0x64,0xBB,0xC6,0x25,
+0x05,0x96,0xE2,0x75,0x4B,0x49,0x53,0x10,
+0x29,0x01,0x91,0x8E,0xCD,0x99,0x6B,0xAA,
+0x05,0x5F,0x76,0x90,0x4A,0x0F,0x04,0xEC,
+0x2B,0xF6,0x1E,0x90,0x2E,0xD8,0xD2,0x31,
+0x05,0xEE,0x77,0xFB,0x8B,0xA0,0x3D,0x9A,
+0x2C,0x85,0x2D,0xEF,0xDF,0x9E,0x35,0x69,
+0x05,0x57,0x62,0x2B,0x64,0x4A,0x23,0xC4,
+0x2F,0xAF,0x1B,0xB9,0x10,0x36,0x14,0xA2,
+0x29,0x38,0xE6,0x6C,0x1D,0x93,0x97,0xE7,
+0x05,0xEA,0xBC,0x84,0x3E,0x33,0x11,0xF3,
+0x2C,0x28,0x56,0x10,0x64,0x06,0x09,0x44,
+0x05,0xC9,0x29,0xB7,0x15,0xB0,0x97,0xD2,
+0x2C,0x8A,0xD4,0xE3,0x63,0x40,0xB3,0xAE,
+0x05,0xE3,0x86,0x83,0xD1,0xCE,0xA1,0xBE,
+0x2C,0x25,0x70,0x82,0x31,0x67,0x72,0x81,
+0x05,0xBC,0x44,0xFD,0xBF,0x1A,0xBC,0x26,
+0x2C,0x68,0x88,0x8F,0xDB,0xAE,0xF3,0xA4,
+0x05,0x31,0x20,0xF3,0x9A,0x08,0x16,0x96,
+0x2C,0xF4,0x7C,0xF2,0xF6,0xB2,0xAB,0xA3,
+0x05,0x1D,0xF8,0x32,0x13,0xF2,0xF2,0xBF,
+0x24,0xEE,0x67,0xEB,0xFF,0x9A,0x2D,0x76,
+0x05,0x20,0xB2,0x8A,0xE8,0x43,0x18,0x95,
+0x2F,0x3B,0x24,0xC3,0x10,0xB4,0x36,0x1C,
+0x25,0xE4,0xC4,0x15,0xFA,0x0F,0x0F,0x78,
+0x05,0x38,0x26,0x57,0x52,0xAF,0xD6,0xEE,
+0x24,0x5B,0x5E,0xC1,0xB3,0x2C,0x2F,0x76,
+0x05,0xEA,0x00,0x49,0xE7,0x46,0x05,0xAC,
+0x2F,0xBD,0x30,0x0D,0xB2,0x01,0x83,0x5E,
+0x21,0x94,0xA4,0xBD,0x13,0x18,0x3F,0xC0,
+0x05,0x1B,0x1A,0xE7,0xAB,0x7F,0xC3,0xFC,
+0x2C,0x88,0x2C,0xDF,0x7F,0xEE,0xCB,0x35,
+0x05,0xE7,0x50,0x23,0x65,0x4C,0x0F,0x54,
+0x27,0x1B,0x2A,0x66,0x07,0x17,0x03,0x3F,
+0x27,0xF6,0x0E,0x86,0x49,0xAB,0x49,0xA3,
+0x2A,0x0A,0x7D,0x1C,0x45,0x6E,0xD4,0xE4,
+0x05,0x1B,0x74,0xC9,0x7E,0x31,0xA7,0x0D,
+0x2C,0x8B,0xCD,0xC2,0x2F,0x3C,0x83,0x07,
+0x05,0x7A,0xB6,0x63,0xDB,0x9C,0xDB,0x43,
+0x2C,0x2C,0xE4,0x9B,0x16,0xF4,0x60,0xCE,
+0x05,0x5D,0x30,0x03,0x36,0x17,0x0E,0x09,
+0x2F,0x65,0x10,0xCD,0x8D,0xD9,0xDD,0x57,
+0x2F,0x0C,0x68,0x12,0x88,0x55,0xF0,0xE3,
+0x27,0xC5,0x28,0xF7,0xD8,0x4A,0x67,0x57,
+0x27,0x90,0x5B,0x0C,0x58,0xBE,0x9A,0x96,
+0x2F,0x3A,0x6C,0x51,0x6B,0x3B,0xC8,0xBA,
+0x2F,0x41,0xAB,0x98,0x0E,0x66,0x9D,0xC8,
+0x27,0x67,0x3B,0x7A,0xFD,0xF6,0xA5,0x02,
+0x2F,0xBF,0xB7,0x7E,0xEE,0xD6,0x18,0x5F,
+0x2F,0x3E,0x2A,0x8C,0xEC,0x38,0x54,0xF6,
+0x27,0x6C,0xAE,0x30,0x7E,0xF7,0x41,0x13,
+0x27,0x73,0x87,0x9B,0xD8,0x9F,0x1C,0xF8,
+0x2F,0xDB,0x2F,0xEE,0xDD,0x80,0x84,0xF7,
+0x2F,0x32,0xC1,0x02,0xCC,0xF4,0x96,0x41,
+0x27,0x26,0x88,0xD2,0xA3,0x41,0x29,0x4A,
+0x2F,0xDA,0x87,0xE5,0x99,0x02,0xE2,0x21,
+0x27,0xED,0xBA,0x64,0x4D,0xEF,0xFD,0xE6,
+0x2F,0xD4,0x60,0x17,0xC8,0x04,0xAF,0xCE,
+0x2F,0xF9,0xDB,0x5A,0xEC,0xFB,0x6D,0x73,
+0x2F,0xE5,0x20,0x60,0x25,0x5D,0x0A,0x90,
+0x2F,0xDF,0x7A,0xD8,0x74,0x51,0x63,0x20,
+0x27,0x9D,0x71,0xF5,0x77,0xA7,0xE2,0x6E,
+0x2F,0x28,0x11,0xD7,0x1C,0x7B,0x7E,0xDF,
+0x27,0xA0,0x54,0x05,0x46,0xB0,0x3D,0x01,
+0x27,0x90,0xD0,0x52,0xB5,0x7D,0xF1,0x11,
+0x27,0x9B,0x7C,0x31,0x2F,0xC7,0x45,0x75,
+0x2F,0xFB,0xCD,0x19,0x27,0x36,0xB0,0xFD,
+0x2F,0x9C,0xB2,0x3D,0x03,0x70,0xC5,0x8C,
+0x2F,0xEB,0x5A,0xB4,0xAA,0x2E,0x35,0xBF,
+0x27,0x0C,0x95,0x4D,0x2D,0xA6,0x1D,0x3C,
+0x27,0xC2,0xD4,0x96,0x87,0x93,0xDC,0x23,
+0x2F,0x4B,0x9F,0xEB,0x76,0xDE,0x30,0x5B,
+0x2F,0x41,0xCF,0x94,0x5E,0x42,0xA4,0x17,
+0x27,0xF8,0xF8,0x9F,0x37,0xA4,0x3E,0x4B,
+0x27,0x70,0xDC,0xB0,0x6F,0x82,0x67,0xFB,
+0x2F,0xA1,0x83,0xDB,0xB5,0x58,0x74,0x59,
+0x2F,0xA8,0x58,0xF7,0x19,0xCA,0x3B,0x48,
+0x2F,0x45,0x4E,0x36,0x74,0x58,0x8A,0x24,
+0x27,0x1F,0x50,0x3B,0xD1,0xBC,0x78,0xA4,
+0x2F,0xDB,0xFC,0x10,0x68,0x60,0x8B,0xA1,
+0x2F,0x63,0xB7,0xE7,0x72,0xED,0x3A,0xE0,
+0x27,0x6A,0x9E,0x2E,0x85,0x82,0x8F,0x31,
+0x27,0x6B,0x68,0x70,0x37,0xEA,0xD6,0xFA,
+0x27,0x2C,0x7F,0x43,0x4C,0x7C,0x8F,0x15,
+0x27,0xB6,0x35,0x88,0xB2,0x37,0xDF,0x38,
+0x27,0x85,0x44,0xA7,0x21,0xBC,0xE6,0x48,
+0x27,0x17,0x1D,0xD8,0xBE,0x7A,0x2D,0xE6,
+0x27,0x29,0x30,0x91,0x52,0x5B,0xBF,0x3D,
+0x2F,0xB0,0x8E,0xC4,0xE5,0xA5,0xA6,0x58,
+0x27,0xB3,0x55,0x7F,0x22,0xE2,0xEB,0xC8,
+0x27,0x7C,0xD6,0x09,0x3D,0x3F,0xED,0x55,
+0x2F,0x06,0xA9,0x47,0x47,0x9B,0xF7,0x86,
+0x2F,0x29,0x14,0xAB,0x3D,0x85,0x44,0x96,
+0x27,0x95,0x45,0x65,0x1B,0xAA,0xA9,0x8B,
+0x2F,0x2C,0x2C,0xF9,0xC6,0xFB,0xDB,0x97,
+0x27,0xB4,0x0E,0x69,0xDB,0xE7,0x43,0x22,
+0x27,0xF7,0x92,0x23,0x72,0x58,0xF1,0x53,
+0x27,0xD3,0x07,0xB0,0x2A,0xCD,0x94,0xA5,
+0x2F,0x05,0xE7,0xFA,0xC3,0xCC,0xC1,0x8B,
+0x2F,0x27,0x4B,0x0B,0xD2,0xAF,0x27,0x78,
+0x27,0x1B,0x7A,0x0C,0xED,0x82,0xB6,0xE0,
+0x2F,0x26,0xC1,0x71,0xA4,0xB4,0xE4,0x15,
+0x27,0x04,0xE1,0x94,0xBF,0xDA,0xB9,0xCF,
+0x27,0xF2,0x34,0x48,0x65,0x1D,0x67,0x5C,
+0x27,0x53,0x51,0xBF,0xFD,0x64,0x91,0xE8,
+0x27,0xB8,0x90,0xB6,0xCC,0xA1,0x50,0x9D,
+0x27,0x1B,0xEE,0xCA,0x15,0x33,0x36,0x6D,
+0x27,0x21,0x42,0xBB,0xAC,0x74,0x2C,0x82,
+0x27,0xAF,0xC2,0xBB,0x5B,0xE3,0x08,0xC4,
+0x27,0x5F,0xC5,0x1D,0x63,0xDC,0xF4,0x71,
+0x2F,0x70,0x43,0x4D,0x1E,0x6F,0xBA,0x87,
+0x2F,0x6E,0x07,0x53,0xAF,0xFF,0x72,0x0F,
+0x27,0x37,0x88,0x55,0x0F,0x90,0xD6,0xCA,
+0x2F,0xFE,0xF6,0xC6,0x5E,0xD5,0x99,0xC2,
+0x2F,0x48,0x03,0x89,0xBF,0xE3,0xE9,0x3D,
+0x2F,0xD0,0x29,0x0E,0x98,0xCB,0x9E,0x6C,
+0x2F,0x8A,0xBE,0x61,0x43,0x90,0x3A,0xB3,
+0x27,0x10,0x72,0xBD,0xA5,0xD9,0x52,0xDD,
+0x2F,0xF5,0x02,0x29,0x1A,0x3E,0x44,0x46,
+0x2F,0x64,0x6B,0xA4,0x87,0xED,0x76,0xBF,
+0x27,0x32,0xB0,0xC0,0xFD,0xE7,0x51,0xD9,
+0x27,0x64,0x46,0x90,0x4C,0xF2,0xAE,0x0A,
+0x27,0xE2,0x12,0x21,0x0D,0x5A,0xDD,0x86,
+0x27,0x9E,0x3B,0x96,0xF9,0xC9,0xCC,0xBC,
+0x27,0xFF,0x93,0x7C,0x2A,0x18,0xAB,0xAE,
+0x27,0xD2,0xA5,0x9E,0x97,0x0B,0xC6,0x8F,
+0x27,0xFB,0x44,0xF1,0x18,0x19,0x6B,0xD9,
+0x2F,0xC9,0xB0,0x3A,0x5E,0xE5,0xAB,0x8B,
+0x27,0x50,0x47,0x73,0xD2,0xE8,0x4E,0xD1,
+0x27,0x59,0xE9,0x8A,0xF0,0xAE,0x40,0xA8,
+0x2F,0xC0,0x6C,0x9A,0x0B,0x0C,0x40,0x68,
+0x27,0xB3,0x32,0x2D,0x0C,0x02,0x62,0x43,
+0x27,0x27,0x22,0x08,0x96,0x8A,0x72,0x19,
+0x27,0x91,0xA9,0x39,0x8E,0x2D,0x4E,0x61,
+0x2F,0xCD,0x85,0x01,0x22,0x5B,0x48,0x00,
+0x27,0xF8,0x4B,0x4F,0x3A,0xD5,0x08,0x09,
+0x27,0x85,0x83,0x53,0x21,0xB5,0x46,0xCF,
+0x2F,0xF7,0x4C,0xC7,0x73,0x41,0xDF,0x33,
+0x27,0x87,0x3B,0x21,0x76,0xA0,0x09,0x85,
+0x27,0x7F,0xD4,0xCB,0xA7,0x34,0xFD,0xF8,
+0x2F,0x0D,0x3A,0x59,0xB1,0xAF,0xA2,0x4E,
+0x27,0xAF,0x8F,0xE1,0xC6,0x64,0xCB,0x55,
+0x27,0x60,0x05,0x04,0xBB,0xAC,0x0D,0xAD,
+0x27,0xEA,0x05,0x76,0xC9,0x3B,0xD8,0x9C,
+0x27,0xF9,0x88,0x23,0x54,0x32,0x54,0x31,
+0x2F,0x94,0xE8,0xA9,0x69,0x06,0x83,0x7C,
+0x2F,0xC7,0x5C,0xAD,0xD8,0x8E,0x36,0xE3,
+0x27,0xF1,0x73,0x1C,0x3F,0x60,0x85,0x39,
+0x2F,0xFB,0x52,0xB5,0xFC,0xBC,0x34,0xA7,
+0x27,0x5F,0xDC,0x64,0x1A,0x8C,0xB8,0x33,
+0x27,0xF2,0x62,0x65,0x41,0xBB,0x1D,0x63,
+0x27,0x92,0x48,0x82,0x63,0xF8,0x54,0xE1,
+0x2F,0x29,0x16,0x18,0xF7,0x3B,0x7D,0x49,
+0x2F,0x68,0xD9,0x9B,0x3D,0x94,0xFC,0xA2,
+0x27,0xD5,0x46,0xDB,0x5B,0xAA,0x0B,0xC1,
+0x2F,0x6A,0x2A,0xF3,0xE9,0x15,0x59,0x4D,
+0x2F,0xC2,0xE7,0x42,0x01,0xE9,0x8E,0x7B,
+0x27,0x1C,0xDA,0x3F,0x17,0x22,0xC5,0x52,
+0x27,0xBF,0x51,0xA8,0xCE,0x7E,0xD7,0xBC,
+0x27,0x4B,0x17,0xFB,0x3E,0x7B,0x39,0x00,
+0x27,0x83,0xED,0xD1,0x40,0x8F,0x70,0xA3,
+0x27,0xEF,0xAF,0xB9,0x7F,0xDB,0x0F,0x7A,
+0x2F,0x25,0x2F,0x05,0x66,0xAE,0x2D,0x06,
+0x27,0x11,0xEE,0xC4,0x3E,0xD4,0x52,0x73,
+0x2F,0xE5,0xC9,0x0E,0xF2,0x72,0xD6,0xFE,
+0x2F,0x47,0x48,0x18,0x15,0x49,0x2D,0xC3,
+0x27,0xD7,0xF5,0x6E,0xA6,0x5F,0x5E,0xD9,
+0x2F,0x29,0x96,0x2A,0x30,0x27,0xE6,0x42,
+0x2F,0x22,0x8E,0xAD,0x79,0x66,0x87,0x96,
+0x2F,0xF2,0x99,0xEA,0x6B,0x01,0x99,0x8E,
+0x2F,0xAB,0xBC,0x18,0xE3,0x20,0xBD,0xC6,
+0x27,0xBB,0x24,0x79,0x72,0x20,0xA1,0xF6,
+0x2F,0xFE,0x07,0xF4,0x26,0x36,0x89,0x5F,
+0x2F,0x81,0x5A,0xB8,0xE8,0x27,0x54,0xDF,
+0x2F,0xDE,0x90,0xAF,0xCC,0xBE,0x3F,0x5B,
+0x2F,0x43,0x7F,0x3B,0x27,0x04,0x5C,0xD1,
+0x2F,0xE2,0x0F,0xA9,0x80,0xB9,0x68,0xC5,
+0x27,0xF4,0x77,0x69,0x74,0x68,0x35,0x36,
+0x2F,0x6B,0x30,0x2E,0xDD,0x1D,0xC7,0x1E,
+0x27,0xD9,0x82,0x48,0x32,0xB7,0xE3,0x5D,
+0x2F,0xD6,0xF8,0xA2,0x8C,0xC5,0x07,0x8F,
+0x2F,0x5B,0xB2,0xB2,0xAC,0x29,0x98,0x21,
+0x2F,0x8F,0x8C,0x75,0xEB,0x4B,0x88,0xE6,
+0x2F,0x28,0x61,0x8F,0x69,0x49,0xB5,0xCA,
+0x2F,0xCF,0xA0,0x81,0xFB,0xBB,0x46,0x7F,
+0x27,0x55,0x09,0x20,0x20,0x95,0x87,0x8B,
+0x27,0xE7,0x4F,0x59,0x55,0x6E,0xD3,0x98,
+0x2F,0x35,0x4B,0x2D,0x77,0xE3,0xFF,0xA0,
+0x27,0x5B,0x3E,0x3D,0xF5,0x24,0x33,0x56,
+0x27,0xF1,0xBF,0xDC,0x50,0x06,0x98,0x8C,
+0x2F,0x02,0x44,0x8A,0x82,0x53,0x09,0x80,
+0x2F,0xA7,0xEA,0x80,0x4D,0x2D,0x8F,0xE5,
+0x2F,0xD0,0x7A,0xCA,0xE6,0xAD,0xF0,0x7A,
+0x2F,0x96,0xBE,0xD8,0xF8,0x6E,0x77,0x59,
+0x2F,0x60,0xFD,0x93,0x86,0x36,0xD0,0x09,
+0x27,0x4C,0xFC,0xF6,0x96,0xC5,0xA4,0x2B,
+0x2F,0xDC,0x16,0xBE,0x99,0x7B,0xB2,0xAA,
+0x2F,0xC4,0x6D,0xD8,0x5F,0xC8,0xC7,0x98,
+0x2F,0x11,0x1F,0x0E,0x83,0x55,0x48,0x7D,
+0x27,0x43,0x9D,0xB6,0x86,0x33,0xBC,0xC9,
+0x2F,0x02,0xFF,0x83,0x0F,0xC3,0xE5,0xD3,
+0x27,0x29,0x2E,0xE3,0xCD,0xB5,0xD5,0xDC,
+0x2F,0xF9,0x02,0xE6,0xE6,0xEF,0x25,0x3E,
+0x27,0x57,0xDF,0xD7,0xE6,0x33,0xC5,0x7A,
+0x2F,0xB3,0x08,0x1C,0x71,0x55,0xA4,0xB7,
+0x2F,0xBB,0xC7,0x62,0x6D,0x6C,0x22,0x43,
+0x27,0xD5,0xD6,0xF5,0x72,0x87,0x59,0x2B,
+0x27,0xB9,0xD9,0x0D,0x75,0x60,0x56,0x65,
+0x27,0x49,0x1B,0x3A,0x5B,0xE3,0x9A,0x2A,
+0x27,0x87,0xDA,0xC8,0xB7,0x09,0x1F,0xCD,
+0x2F,0x18,0x67,0x96,0x32,0xCC,0x50,0x24,
+0x27,0x00,0x6B,0x09,0x31,0x52,0x7F,0xB1,
+0x2F,0x87,0x39,0x40,0xA1,0x5E,0xB7,0xE1,
+0x27,0xD3,0x6C,0x79,0xCC,0x17,0xC5,0x92,
+0x27,0xAE,0xE2,0xC7,0xAA,0xAF,0x45,0x81,
+0x2F,0xEA,0x4E,0xA6,0x4A,0x3B,0xC3,0x30,
+0x2F,0x07,0x44,0x02,0xFB,0xD4,0x84,0xA7,
+0x27,0xA4,0x47,0xC8,0x5C,0x71,0x7E,0x03,
+0x27,0xA6,0x46,0x52,0xA2,0x1C,0xC1,0x6A,
+0x2F,0x76,0xB2,0xC6,0x8E,0xA5,0x5E,0xEE,
+0x2F,0x22,0x87,0x42,0x3D,0x8B,0x75,0x5F,
+0x2F,0x82,0x23,0x4C,0xC2,0x2E,0x4A,0x53,
+0x27,0xB8,0x31,0x37,0x88,0x5D,0xFD,0xFF,
+0x27,0x00,0x19,0x13,0x34,0x78,0xFD,0xD5,
+0x2F,0xCE,0xD5,0xB1,0x21,0x15,0xE0,0xC4,
+0x2F,0xB6,0x80,0x3A,0x99,0x00,0x7E,0x73,
+0x27,0xC1,0x15,0x90,0x40,0xDA,0xB6,0x28,
+0x2F,0x1C,0x1B,0x6A,0x64,0x0B,0x14,0x39,
+0x2F,0xC6,0x86,0x8D,0x1E,0xBA,0x2E,0x1E,
+0x2F,0xFC,0xC2,0x4C,0x8D,0x34,0x18,0x84,
+0x27,0xEF,0xC4,0xF3,0xDE,0x04,0x51,0xD1,
+0x27,0x56,0xAA,0x3A,0xB5,0x13,0x6C,0x0F,
+0x27,0x01,0x04,0xA6,0xF3,0x29,0xF6,0x66,
+0x2F,0x7F,0x20,0xEE,0x87,0xAB,0x72,0x93,
+0x2F,0x3C,0xD1,0x9E,0x36,0x89,0xCC,0xAD,
+0x2F,0x84,0x31,0xEB,0x29,0x48,0x32,0x35,
+0x27,0xC8,0x02,0x2E,0xE6,0x67,0xD2,0x60,
+0x2F,0x0C,0x50,0x05,0x25,0x3F,0x19,0x65,
+0x27,0xF6,0xEE,0x88,0x9F,0xCF,0x32,0x9B,
+0x2F,0xE1,0x80,0x8D,0xB4,0xF3,0x83,0x6C,
+0x27,0x5F,0x7E,0xBF,0x7B,0x15,0x97,0xD8,
+0x27,0xFD,0x24,0xB0,0xC4,0xDE,0x16,0xBF,
+0x2F,0x78,0x2E,0x9C,0x9A,0xC3,0xF5,0x18,
+0x27,0x99,0x52,0x62,0x0C,0x7B,0x8D,0x37,
+0x2F,0x6B,0x7C,0x7F,0x5C,0x95,0x30,0x44,
+0x2F,0xAC,0xF8,0xBE,0xB3,0x6D,0x86,0x49,
+0x27,0x37,0x27,0xED,0xB1,0x90,0xD1,0x99,
+0x2F,0xFD,0xC5,0xB6,0xC7,0x7A,0x7C,0x54,
+0x27,0xD9,0xAB,0x8D,0x01,0xE7,0xD0,0x3F,
+0x27,0x1D,0x86,0x1E,0x11,0x09,0xEF,0x28,
+0x27,0x9F,0x63,0x69,0x6E,0xF0,0x5E,0x2B,
+0x2F,0xE3,0x93,0x6A,0xF3,0x25,0x6B,0xDC,
+0x2F,0x4F,0xE2,0x80,0xE7,0xB6,0x43,0x5D,
+0x27,0x00,0x86,0x12,0x17,0x66,0x5D,0x19,
+0x2F,0xAE,0xD5,0x79,0xC0,0x0A,0xB0,0xC5,
+0x27,0x0F,0x0D,0x3C,0x3D,0x49,0x9D,0xDD,
+0x2F,0x55,0x19,0x8A,0x50,0x9B,0x22,0x1B,
+0x2F,0x26,0xE8,0xFA,0xDE,0x56,0x39,0x98,
+0x27,0x70,0xAB,0x61,0x60,0xA4,0x9C,0x01,
+0x2F,0x2B,0x11,0x62,0x10,0xE9,0xEC,0x37,
+0x2F,0x4E,0x84,0x47,0x7D,0x0D,0x41,0x69,
+0x2F,0xF0,0x89,0x8F,0x01,0x46,0xBD,0x2D,
+0x2F,0x68,0xD0,0xA7,0x11,0x67,0x9B,0xB2,
+0x27,0x43,0xC7,0x2C,0xB2,0x11,0x50,0x6D,
+0x2F,0x3F,0x7B,0x81,0xA1,0xF3,0xEA,0x57,
+0x2F,0xF2,0x18,0xF2,0x0B,0x88,0x8A,0x14,
+0x2F,0x42,0x61,0xC6,0xDC,0x42,0x38,0x1D,
+0x2F,0xA8,0x51,0x25,0x14,0xF3,0x34,0x65,
+0x2F,0x1C,0x0C,0xE4,0x92,0x2F,0x23,0x9A,
+0x27,0x43,0x8E,0xBD,0xDA,0x0A,0xB4,0x06,
+0x2F,0xAF,0xC7,0x39,0x9E,0x41,0xD2,0x38,
+0x2F,0x30,0xA1,0x61,0xA5,0xAC,0xDC,0x0F,
+0x2F,0xCB,0xDB,0x55,0x31,0xAD,0xE0,0xAB,
+0x27,0x82,0x2C,0x7F,0x5E,0x4B,0x2E,0xB5,
+0x2F,0x8E,0xD3,0x65,0x63,0x14,0x8D,0x83,
+0x27,0x1B,0x59,0x08,0x1E,0xBE,0x74,0xA2,
+0x2F,0x16,0x24,0x28,0x4F,0x6B,0x4C,0x68,
+0x27,0x7A,0xFB,0x7E,0xE2,0x66,0x9B,0x26,
+0x27,0x22,0x27,0x25,0xA0,0x06,0x2C,0x0F,
+0x27,0x21,0xFC,0xED,0x20,0xC6,0x95,0xE1,
+0x27,0x5B,0x38,0x17,0x21,0x1F,0x64,0x3F,
+0x2F,0x35,0xE6,0x01,0xA9,0x7C,0x83,0x9E,
+0x2F,0xBF,0xF6,0x62,0xEC,0xB1,0xE1,0x9B,
+0x27,0x56,0x7E,0xF8,0x1C,0xF6,0xCD,0x51,
+0x27,0xDA,0x0C,0xFE,0x6A,0x8E,0xAF,0xB5,
+0x2F,0x76,0xAE,0x67,0x18,0x40,0xAF,0xAA,
+0x27,0xF3,0xAE,0xFF,0x4B,0x9B,0x16,0xDC,
+0x2F,0x6A,0x3D,0x75,0x25,0x12,0x8A,0x08,
+0x2F,0x6D,0x9D,0xCD,0x34,0x85,0x2C,0x6F,
+0x27,0x7C,0x10,0x02,0x63,0xD0,0xF6,0x1A,
+0x27,0xAC,0x42,0xC2,0x44,0x05,0xB1,0xE5,
+0x2F,0xC8,0xFF,0x44,0xE9,0x3F,0xE6,0x29,
+0x27,0x0C,0xE0,0x32,0x28,0xC9,0x54,0x8C,
+0x2F,0xB3,0xF5,0x8C,0x27,0x19,0xAF,0x65,
+0x2F,0x3A,0xD2,0x3E,0x22,0x33,0x1D,0x0B,
+0x27,0xD1,0x64,0x74,0xE1,0xD5,0xF3,0x88,
+0x27,0xBD,0x15,0xDE,0xE9,0xC3,0x14,0xAB,
+0x27,0xAA,0xB5,0xEF,0xE3,0x37,0xFD,0xE5,
+0x2F,0xDB,0x09,0xF8,0x4F,0x2E,0x30,0xB4,
+0x27,0x90,0x8E,0x40,0xC1,0xB5,0x4D,0x65,
+0x2F,0xA9,0x41,0x15,0x18,0xE5,0xD0,0xB7,
+0x27,0x36,0x11,0xD8,0x9C,0x84,0x5B,0x69,
+0x2F,0x3F,0x1E,0x2F,0xB1,0xFC,0x8C,0x07,
+0x2F,0x51,0xA9,0x92,0x9E,0xC9,0xA1,0x61,
+0x2F,0x4C,0xED,0xE0,0x62,0x6A,0x58,0xBA,
+0x2F,0x21,0x2E,0x5C,0xD8,0xAD,0xFC,0x4B,
+0x27,0x26,0x4D,0xB9,0x8A,0xC4,0xFD,0xA7,
+0x27,0x7B,0x51,0x77,0xB7,0x23,0x4E,0xE1,
+0x2F,0xD8,0x7A,0x9A,0x50,0x28,0xCC,0xC6,
+0x27,0x1A,0x0B,0xBC,0x18,0x37,0xC7,0xBE,
+0x27,0xC2,0x83,0xAA,0xDF,0x79,0xA7,0x5E,
+0x27,0xDA,0x6D,0xD4,0x8B,0xAA,0xF7,0xBE,
+0x2F,0xAF,0x27,0xEB,0x2C,0x25,0xE0,0xA6,
+0x27,0x62,0xC1,0x0F,0x6E,0xFF,0xA0,0x7A,
+0x27,0x72,0xCD,0x65,0xF3,0x6D,0x80,0x9C,
+0x27,0x4F,0x77,0xF5,0x4F,0xCF,0xEE,0x12,
+0x27,0x35,0xA0,0xE5,0xF8,0x21,0x15,0x53,
+0x2F,0x12,0x5B,0x45,0x13,0x55,0x2D,0xAB,
+0x2F,0xE0,0xE7,0xB1,0x21,0x85,0x4E,0xAA,
+0x2F,0xEB,0x6A,0x09,0xB5,0xED,0xAE,0xC1,
+0x2F,0x54,0x98,0xEF,0x44,0xED,0x0F,0xA6,
+0x2F,0x4C,0x6D,0x58,0x06,0x3F,0x3D,0xF3,
+0x27,0xF3,0x57,0x67,0x5B,0x89,0x41,0x44,
+0x2F,0xBE,0x84,0x2A,0x5A,0xAB,0x31,0xA2,
+0x2F,0x5E,0xE6,0x0D,0x03,0xDB,0x74,0xFC,
+0x27,0xDA,0x1C,0x4F,0x52,0x84,0x87,0xD6,
+0x2F,0x00,0xB5,0xB9,0x9C,0x44,0xB5,0xB9,
+0x2F,0xCD,0x34,0x41,0x25,0x85,0xA4,0x2F,
+0x27,0x00,0x20,0x72,0xB2,0x94,0xE5,0xB1,
+0x27,0xC3,0x04,0x82,0x9C,0x47,0x0C,0x02,
+0x27,0xCA,0x9E,0xDF,0x9D,0x3B,0x9D,0x97,
+0x2F,0x01,0x60,0xF6,0x11,0x2C,0xE3,0x8E,
+0x2F,0x14,0xE4,0x52,0xA4,0x26,0x81,0xA7,
+0x2F,0x70,0x30,0x9E,0x2F,0xDC,0xAA,0xEC,
+0x27,0x79,0xC0,0x86,0xB0,0x15,0xF3,0x94,
+0x2F,0x14,0xC7,0x59,0x4D,0x2B,0xD7,0xCF,
+0x2F,0x77,0x50,0x71,0x88,0xF6,0x03,0xAD,
+0x27,0x56,0x52,0x66,0x67,0x5C,0x08,0xB2,
+0x27,0x4C,0xB1,0x49,0x3F,0xC1,0xFF,0x9C,
+0x27,0x6E,0xAB,0xF8,0x72,0xD6,0x14,0x08,
+0x2F,0xED,0xD2,0x84,0x84,0x9A,0x73,0x9B,
+0x27,0x98,0x86,0x52,0xF1,0x33,0x2C,0xC8,
+0x2F,0x07,0x14,0xB5,0x17,0x48,0x90,0xB8,
+0x27,0x59,0x98,0x9D,0x8D,0x8A,0x62,0x40,
+0x27,0xDD,0xC1,0x4E,0x41,0x9C,0xE4,0x8B,
+0x2F,0xAC,0x4D,0x24,0x9C,0xCF,0x6A,0xF4,
+0x2F,0x03,0x0D,0x81,0x6E,0x7F,0x4D,0xFF,
+0x27,0xFF,0x40,0x0C,0xF7,0x82,0x33,0xB0,
+0x27,0x1B,0x8D,0xB7,0xCC,0xF7,0x76,0xE6,
+0x27,0xCD,0x54,0xEF,0x7C,0xDF,0x4D,0x3F,
+0x2F,0xE5,0x53,0xA3,0x04,0xF3,0x13,0x86,
+0x2F,0xCC,0xF6,0x8B,0xA3,0x8F,0x7A,0x4D,
+0x27,0x27,0xBA,0xB3,0x7E,0xD9,0x58,0x26,
+0x27,0x22,0x30,0x8A,0x97,0xAC,0x62,0x9C,
+0x27,0x77,0x7F,0xD3,0xDC,0x8C,0xB1,0x8F,
+0x27,0x69,0xE7,0xD8,0xAD,0xE4,0x71,0xB0,
+0x27,0xA6,0x8F,0x68,0xAB,0xBF,0xC8,0xED,
+0x2F,0xC6,0xDC,0x05,0xB1,0xC0,0x56,0x40,
+0x2F,0x32,0x5E,0x76,0x59,0x01,0xDE,0xFA,
+0x2F,0x96,0xD7,0x48,0xA2,0x39,0xB2,0xA2,
+0x2F,0xE1,0xA2,0x27,0x97,0xC3,0xB9,0x4C,
+0x2F,0x36,0x42,0x51,0xA4,0xF3,0xAF,0xC2,
+0x27,0x27,0x5B,0x5C,0xA4,0xAB,0xEE,0x23,
+0x27,0x6F,0xAB,0x76,0xFF,0x32,0x1D,0x1D,
+0x2F,0x61,0xF2,0x31,0xE7,0xAF,0x2D,0x28,
+0x27,0x5E,0xF6,0x2E,0x07,0xDE,0x7D,0xE1,
+0x27,0x63,0xE3,0x5B,0x91,0xF2,0x3A,0x5D,
+0x2F,0x25,0xA5,0xA9,0xAF,0x90,0x4D,0xC9,
+0x2F,0x08,0xD5,0x96,0xB8,0x31,0x87,0x01,
+0x2F,0xDD,0x90,0x5C,0x99,0x75,0x34,0x7A,
+0x2F,0x4D,0x82,0x22,0x1C,0x28,0x7D,0x71,
+0x2F,0xA2,0xF2,0x56,0xD8,0xB7,0xAC,0x93,
+0x2F,0x1E,0xAA,0x27,0xDA,0x47,0x78,0xA7,
+0x2F,0xE0,0x46,0x14,0x79,0xE4,0xE2,0x15,
+0x2F,0xC2,0xD0,0xE1,0xEE,0x1A,0xD7,0x8C,
+0x27,0x6B,0xDC,0x37,0xCA,0xD1,0xFE,0xF5,
+0x27,0x10,0x37,0x8F,0xC4,0x50,0x08,0xF7,
+0x27,0x16,0x52,0x3A,0xD2,0xB7,0x15,0xF0,
+0x27,0x32,0xA1,0xC7,0xB5,0x4B,0xE0,0x59,
+0x2F,0xB3,0xA2,0x98,0xCE,0x32,0x52,0x19,
+0x2F,0x9D,0x32,0x0D,0xFA,0x0D,0xCB,0xA1,
+0x27,0x6D,0xA4,0x96,0xAC,0x7E,0x79,0xF4,
+0x2F,0xCD,0x5D,0x82,0x45,0xD3,0xE2,0xB4,
+0x27,0xA0,0x8D,0x7B,0xA7,0xC8,0x3D,0x8D,
+0x27,0x23,0x32,0x30,0xC5,0x53,0x61,0xE2,
+0x2F,0xD8,0xF5,0xFE,0x22,0xD9,0xBE,0xA6,
+0x27,0xF3,0xD2,0xAA,0x31,0x14,0x0B,0x28,
+0x2F,0xF6,0x6D,0xD5,0xBA,0xE6,0x1A,0x5F,
+0x2F,0x74,0xA5,0x53,0x26,0x4D,0x7B,0xF6,
+0x27,0x39,0xC9,0xBB,0x85,0x98,0x1B,0xEA,
+0x27,0x29,0xA7,0x91,0x62,0xC4,0x02,0x18,
+0x27,0xCD,0x84,0x91,0xC4,0xC0,0x64,0x14,
+0x2F,0xDF,0x11,0x8C,0xCF,0xD3,0x63,0x6C,
+0x27,0x4A,0x86,0xE2,0xB5,0xD0,0x09,0xF1,
+0x27,0x88,0xFC,0x58,0x07,0x00,0x37,0x3D,
+0x2F,0x54,0xAA,0xED,0x73,0x5B,0x0B,0xBA,
+0x2F,0x48,0x97,0x68,0xC2,0x97,0xA4,0x69,
+0x2F,0xA1,0xE1,0xC2,0x0D,0x35,0x80,0xA8,
+0x27,0x89,0xC3,0xBD,0x8D,0x93,0x69,0x05,
+0x2F,0xF1,0x89,0x5E,0x19,0xB0,0xF7,0xFD,
+0x2F,0x9D,0x6D,0xBA,0xB6,0x0B,0x8D,0x59,
+0x27,0x78,0x80,0x55,0x1C,0xA3,0x16,0x2C,
+0x2F,0x7F,0x8B,0x0D,0x0A,0x4D,0x7C,0x86,
+0x27,0x9F,0x67,0x15,0x1C,0xAB,0x5B,0x58,
+0x2F,0x4B,0x26,0x58,0x7C,0xEE,0xF2,0x1C,
+0x27,0x93,0x3E,0xB9,0xFE,0x74,0xE1,0x12,
+0x27,0x21,0x1F,0x62,0x74,0x57,0x25,0x85,
+0x2F,0x77,0x8D,0x47,0x18,0x11,0xB4,0x65,
+0x27,0xDA,0xED,0x99,0x8A,0x5E,0xF3,0x95,
+0x27,0x09,0x03,0xE2,0x9A,0xF3,0x5F,0xE6,
+0x27,0x32,0xA3,0xB2,0xFB,0x5D,0x8F,0xA2,
+0x27,0xB2,0xB1,0x29,0xFE,0x32,0x3D,0x53,
+0x27,0x10,0xA8,0xB2,0x6A,0xED,0xC6,0xB7,
+0x2F,0xBA,0x14,0x8E,0x56,0x46,0xE5,0xA2,
+0x2F,0x91,0x4A,0xD9,0xD8,0xD1,0xEB,0x01,
+0x2F,0x95,0x8D,0x7D,0xDE,0xAC,0xD4,0x34,
+0x2F,0x09,0x3B,0xB1,0x4D,0xF0,0x93,0xA7,
+0x27,0xC4,0x95,0x54,0xF8,0xB6,0x4F,0xAB,
+0x27,0x7C,0xE2,0x27,0x33,0xB2,0x6B,0x7E,
+0x27,0x40,0x96,0x47,0x2C,0xDB,0xB3,0xBB,
+0x27,0x69,0xB0,0x44,0xD1,0x85,0x10,0x05,
+0x27,0x0A,0xF4,0x3E,0x0B,0x45,0xE6,0xBA,
+0x27,0xFD,0xA8,0x9A,0x00,0x02,0xED,0x46,
+0x27,0x4C,0xBB,0x7D,0x08,0x2F,0x28,0x5E,
+0x2F,0x2D,0x39,0xAA,0x6C,0x49,0x76,0x40,
+0x27,0xA4,0x3A,0x2B,0xEC,0x17,0x6E,0x0D,
+0x2F,0xB0,0xE3,0xDF,0x5B,0x49,0xE5,0x0B,
+0x2F,0x0F,0x1F,0x17,0x4E,0x1A,0xC1,0xD5,
+0x2F,0x8E,0x19,0x62,0xAF,0xC7,0xB2,0xB0,
+0x2F,0xA4,0x5E,0x37,0xAC,0x58,0xBD,0xA7,
+0x2F,0xDB,0x67,0x0E,0xAB,0xAB,0x27,0x83,
+0x2F,0x09,0xCE,0xF9,0x58,0x7A,0xCD,0x1C,
+0x27,0xE6,0xFA,0x28,0xE4,0x4D,0x21,0xBA,
+0x27,0xF7,0x6B,0x4A,0x20,0xDF,0xC4,0xA9,
+0x27,0x8A,0xF6,0x00,0x96,0x84,0x66,0x60,
+0x27,0x2B,0x75,0xB7,0x19,0xBA,0x17,0x00,
+0x2F,0xA7,0x02,0x99,0xB7,0xE3,0x57,0xAA,
+0x27,0xED,0x4F,0x43,0xF2,0x0B,0xC4,0xC9,
+0x27,0x49,0xC1,0xE9,0x2E,0x1D,0x07,0x10,
+0x2F,0x8F,0xFA,0x64,0x87,0x02,0xDB,0x74,
+0x2F,0x5D,0x6D,0x92,0x10,0xA6,0x87,0x64,
+0x2F,0xFD,0x36,0x25,0xC4,0xD6,0xE5,0x57,
+0x2F,0x27,0x2C,0x18,0x75,0xAF,0x76,0x2A,
+0x2F,0x9B,0x34,0xB9,0xB2,0x77,0x4D,0xD6,
+0x27,0x4D,0x09,0xC3,0xFD,0x1A,0xEB,0xF0,
+0x27,0xBC,0xF6,0x05,0xC6,0x34,0x37,0x6A,
+0x2F,0x83,0x66,0x8B,0x2B,0x9D,0x57,0x71,
+0x2F,0x2C,0xC0,0x89,0x45,0xB5,0xCD,0x4B,
+0x27,0x46,0xDC,0x28,0x47,0x89,0x2B,0x3E,
+0x27,0xA2,0xBB,0xAF,0xA7,0x1A,0xED,0x4D,
+0x2F,0x3A,0xB2,0xFC,0x1B,0xDC,0x6D,0x17,
+0x27,0x2A,0xAC,0x61,0x03,0x83,0x87,0x84,
+0x27,0x3D,0x12,0xA9,0xDD,0x18,0x6B,0x65,
+0x2F,0x2F,0x61,0x59,0xA1,0x7C,0x1A,0x40,
+0x2F,0xEB,0xEE,0x69,0xB2,0x55,0x77,0x85,
+0x2F,0x6C,0x9C,0x2E,0xBF,0xEA,0xBE,0x58,
+0x27,0x46,0xAC,0x4B,0x77,0xB7,0xDD,0xAA,
+0x2F,0xE9,0x23,0x10,0x76,0xF0,0x33,0x0B,
+0x27,0xCA,0x31,0xDF,0x11,0xCB,0x9A,0xC0,
+0x27,0xCE,0xB1,0xB1,0xEE,0xD3,0xAA,0x1C,
+0x27,0x34,0xC9,0xC7,0xFF,0x79,0x48,0x35,
+0x2F,0x85,0xA7,0x79,0x50,0x83,0x5A,0x40,
+0x27,0x74,0x72,0x9A,0x07,0x3C,0x12,0x80,
+0x27,0xD8,0x02,0x15,0x79,0xFE,0x55,0xCF,
+0x2F,0x97,0x94,0xE7,0x3F,0x0F,0xFA,0xA0,
+0x2F,0x2F,0x44,0xDF,0xC1,0x2C,0x84,0xCB,
+0x27,0x3D,0x54,0x59,0x5D,0x7A,0x05,0x8C,
+0x2F,0x31,0xAA,0xE6,0xE7,0xFB,0xA6,0x93,
+0x27,0xB5,0xAE,0x86,0xB5,0xC0,0xAA,0x10,
+0x27,0x0C,0x61,0xAA,0x25,0x17,0x90,0x3D,
+0x27,0x5F,0x59,0xDD,0x86,0x96,0x82,0x14,
+0x27,0x18,0x71,0xBE,0x78,0x38,0x27,0x6C,
+0x2F,0x64,0x1B,0x50,0x93,0xA9,0x6D,0xE7,
+0x2F,0x53,0xC1,0x70,0xD2,0x25,0xFB,0x8B,
+0x2F,0x1E,0xF5,0x5B,0x4E,0xF7,0x8F,0xC7,
+0x27,0x00,0x83,0x07,0x05,0xCE,0x43,0xFF,
+0x27,0x2F,0x5B,0x19,0xC9,0x44,0xDF,0x5E,
+0x27,0x18,0x84,0x8A,0xED,0xD0,0x7A,0xE3,
+0x2F,0xE7,0x89,0x84,0xA9,0x83,0x39,0x1E,
+0x2F,0xE3,0x29,0xE2,0x11,0xBE,0xBE,0x4C,
+0x2F,0xC4,0x2E,0x81,0xC6,0xAA,0x93,0x37,
+0x2F,0x73,0x3B,0x90,0x82,0xF3,0x7D,0x02,
+0x27,0x9E,0xE0,0x9E,0xB4,0x05,0xC0,0x61,
+0x2F,0x55,0xEE,0xB3,0x9F,0xE3,0x4C,0x60,
+0x27,0x3D,0xC6,0xCF,0x92,0x5B,0xA3,0xD9,
+0x27,0x47,0xA0,0xE9,0xB2,0xFD,0xED,0x5A,
+0x27,0x3D,0xF0,0x14,0x95,0x62,0x13,0x6A,
+0x2F,0x5E,0xDD,0xE7,0xB8,0x25,0xB3,0x78,
+0x27,0x29,0x47,0x48,0x82,0x22,0xE3,0xCD,
+0x2F,0xB8,0x0A,0x08,0x20,0xEF,0xA1,0xDB,
+0x2F,0xE4,0x35,0x52,0xEA,0xD7,0xC7,0x88,
+0x27,0xFC,0xBB,0xE1,0x0F,0x23,0x68,0xAA,
+0x27,0xE6,0xD3,0xF6,0x11,0xBE,0x59,0x90,
+0x2F,0x73,0x06,0xE9,0x2E,0xD4,0x1F,0xA3,
+0x27,0xDF,0x49,0x0B,0x31,0xE7,0x76,0x59,
+0x27,0x8D,0x0A,0xFB,0xB0,0x15,0x84,0x18,
+0x27,0x18,0x5F,0xCD,0x21,0xF4,0xF4,0x58,
+0x27,0x41,0x42,0xD5,0xA3,0x83,0x57,0xB8,
+0x2F,0x91,0xDF,0x32,0x9F,0x8B,0xCC,0xE0,
+0x27,0xE7,0xE6,0x5F,0xA4,0x62,0xB6,0xC4,
+0x27,0xFF,0x40,0x32,0x12,0xFF,0x69,0x5B,
+0x27,0x0B,0x1B,0x0C,0xB4,0x05,0xD5,0x98,
+0x27,0x9B,0xA5,0x7C,0xCC,0x97,0x50,0x17,
+0x2F,0x62,0xA0,0x04,0x7C,0xCF,0x90,0x12,
+0x27,0x26,0x8E,0xC7,0xFF,0x2B,0x4E,0x19,
+0x27,0x76,0x7B,0xCD,0xAE,0x18,0xF6,0xCC,
+0x27,0x2B,0x11,0x32,0xF1,0x9B,0xEA,0xB1,
+0x27,0x1D,0x8A,0x02,0xDE,0x1F,0x79,0x76,
+0x2F,0x65,0x5A,0x94,0xCB,0xED,0x3C,0x0D,
+0x27,0xD6,0xE2,0xFA,0x3D,0x76,0x0F,0xAE,
+0x27,0x6A,0xC5,0x93,0xD2,0x92,0x6A,0xE2,
+0x27,0x93,0x9A,0xF3,0x2B,0xEF,0x50,0xF8,
+0x27,0x02,0xF9,0x9B,0xB6,0xDD,0x21,0xAB,
+0x2F,0xE3,0xCB,0xFA,0x5C,0xC3,0x35,0x28,
+0x27,0x22,0xC1,0x4F,0xDF,0x21,0xF5,0x4E,
+0x27,0xDC,0xD4,0xEC,0xDE,0x37,0xB4,0xDD,
+0x27,0xF2,0x88,0xD5,0x5B,0x7C,0xFA,0x7D,
+0x27,0x2B,0x2C,0x5D,0xFD,0x6C,0x77,0xAD,
+0x2F,0x97,0x4F,0xFA,0xA8,0x6E,0xAD,0x4D,
+0x2F,0x62,0xDF,0x4A,0x76,0xE6,0x96,0x85,
+0x27,0x4B,0xC5,0x0B,0x9E,0x24,0xFA,0x6C,
+0x27,0x06,0xCA,0x8F,0x13,0xD1,0x8F,0x3A,
+0x2F,0x5F,0x8A,0x37,0xD2,0x84,0x32,0x71,
+0x2F,0xB2,0x75,0xF1,0x4B,0x69,0xAC,0x56,
+0x27,0xFB,0xC0,0x16,0x4C,0x7F,0xC4,0x6B,
+0x27,0x53,0x0B,0x18,0x0D,0x5B,0xE9,0x29,
+0x27,0x7A,0xB0,0xE2,0xAB,0xDB,0x37,0x9F,
+0x2F,0xCC,0x15,0x32,0x71,0x4B,0xAB,0x49,
+0x2F,0x03,0xC3,0x76,0xD7,0x70,0xDE,0x5A,
+0x27,0x30,0x11,0x82,0x54,0x80,0x26,0x88,
+0x27,0xCF,0x83,0xA8,0xFC,0x9C,0x20,0x9E,
+0x27,0x54,0xF4,0x3F,0xE9,0x00,0x82,0x2A,
+0x27,0xAA,0xF0,0x36,0xF6,0x46,0xC2,0x94,
+0x2F,0xAF,0xB1,0x02,0x03,0x57,0xF2,0x51,
+0x2F,0xC7,0x75,0x15,0x2E,0x16,0x73,0x3E,
+0x2F,0x02,0x2A,0xFC,0x8F,0x72,0xE4,0x34,
+0x2F,0xA3,0x03,0x27,0xFC,0x8E,0xE4,0xD2,
+0x2F,0xC5,0xBB,0x35,0x3C,0xC3,0xEB,0x48,
+0x2F,0x1B,0x2F,0x2D,0x1A,0x3D,0xF2,0xC9,
+0x2F,0xC7,0xDD,0x2F,0x0D,0x5D,0xEE,0xC2,
+0x2F,0x6E,0xD8,0x17,0x1F,0x51,0x40,0x57,
+0x27,0xFB,0xDE,0x2B,0xBD,0x61,0xCF,0xBB,
+0x2F,0x26,0x39,0x4B,0x18,0xC4,0x8D,0xC7,
+0x27,0x59,0xC1,0x25,0x63,0x99,0xC2,0x24,
+0x27,0x81,0xC5,0x33,0xE0,0x9E,0xD6,0xB0,
+0x27,0x86,0xA8,0xC1,0x73,0x79,0x3C,0x31,
+0x27,0xF1,0x48,0x78,0x4F,0x33,0x4B,0x4B,
+0x2F,0x66,0xF7,0x93,0x2A,0xB0,0xE2,0x72,
+0x27,0x53,0x6C,0xE5,0xEE,0xE0,0x9A,0xB8,
+0x2F,0x47,0x85,0x42,0x90,0x6A,0xDD,0xDE,
+0x2F,0x6B,0xF8,0x12,0x91,0xB9,0x42,0xDA,
+0x27,0x35,0x19,0x36,0x2F,0xB2,0xBB,0x0C,
+0x27,0x85,0x76,0xAE,0xDE,0x87,0xF5,0xC2,
+0x27,0xD0,0xE8,0x04,0x45,0x67,0x58,0xA0,
+0x2F,0x57,0x11,0xEC,0xC5,0x77,0x66,0xDB,
+0x27,0x00,0x13,0xF1,0xE5,0x26,0xCA,0x54,
+0x27,0x47,0x1C,0x62,0x4A,0xE5,0xE0,0xA8,
+0x27,0xD0,0x7B,0x59,0xFE,0x3D,0xEE,0x8D,
+0x2F,0xF9,0xC8,0x6F,0xEB,0x6F,0xB1,0x68,
+0x2F,0x0A,0x6B,0x08,0xBA,0x9C,0x56,0xA5,
+0x2F,0x29,0x51,0xBA,0x7D,0xBC,0xE0,0xEE,
+0x2F,0x65,0x13,0x87,0x5E,0xAE,0xBF,0x7F,
+0x27,0xC0,0x1F,0xAB,0x02,0xD4,0x03,0x0A,
+0x27,0xFF,0x6A,0x33,0xCF,0xA7,0x05,0xF2,
+0x2F,0x56,0x23,0x18,0x43,0xA8,0x22,0xC7,
+0x2F,0x44,0x92,0x17,0xE0,0x72,0x20,0xFB,
+0x2F,0x08,0x59,0x3E,0xB0,0xD7,0x78,0x53,
+0x27,0x2B,0x8D,0x75,0x48,0xD5,0x45,0xC9,
+0x2F,0x0B,0x01,0x27,0xBD,0x0A,0xAA,0x81,
+0x2F,0x56,0x1E,0x5C,0x48,0xE7,0x66,0x1E,
+0x2F,0x3C,0x21,0x90,0xF4,0xFE,0xF7,0x50,
+0x2F,0x2A,0x9A,0x64,0xF5,0x4E,0x56,0x66,
+0x2F,0x05,0x0C,0x39,0xDE,0x13,0x0B,0xC3,
+0x27,0xAF,0xC9,0x39,0x33,0x62,0xAE,0x50,
+0x2F,0xBB,0x6E,0xBF,0x2E,0x44,0x5C,0xAF,
+0x2F,0xB2,0xBA,0x9F,0xCA,0x34,0x3D,0x32,
+0x27,0x0B,0xF7,0xFE,0x54,0xBA,0x20,0x92,
+0x2F,0xAF,0xFD,0x3D,0xD9,0x96,0x64,0x54,
+0x27,0x79,0xA1,0xE0,0x95,0xE4,0x13,0x03,
+0x27,0xE7,0x7C,0x59,0xBB,0x9D,0xBE,0xDB,
+0x27,0x3E,0x68,0xEA,0xA5,0x19,0x13,0xD5,
+0x2F,0xDD,0x0D,0xD7,0xD0,0xDC,0xB2,0x28,
+0x2F,0x22,0x9E,0xA3,0xC1,0x79,0x63,0xBD,
+0x22,0xA5,0xBA,0xE9,0xC2,0x9D,0x5C,0x05,
+0x05,0x75,0xA7,0x65,0xAC,0xFA,0x4B,0xB5,
+0x2F,0xDA,0xC9,0x84,0x35,0xBB,0x41,0xD4,
+0x21,0x25,0xF3,0x5B,0x42,0xE7,0x79,0xCB,
+0x05,0x2B,0xF7,0x69,0x44,0xAD,0xBB,0x66
+};
+
+#define Si2168_Patch_2_0b5_LINES (sizeof(Si2168_Patch_2_0b5)/(8*sizeof(unsigned char)))
+
+#endif /* _Si2168_PATCH_2_0b5_TABLE_H_ */
diff -urN a/drivers/media/dvb-frontends/si2168_commands.h b/drivers/media/dvb-frontends/si2168_commands.h
--- a/drivers/media/dvb-frontends/si2168_commands.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/si2168_commands.h	2013-02-17 18:06:12.000000000 +0800
@@ -0,0 +1,2674 @@
+/**************************************************************************************/
+#ifndef    Si2168_COMMANDS_H
+#define    Si2168_COMMANDS_H
+
+/* _status_defines_insertion_start */
+
+/* STATUS structure definition */
+  typedef struct { /* Si2168_COMMON_REPLY_struct */
+    unsigned char   ddint;
+    unsigned char   scanint;
+    unsigned char   err;
+    unsigned char   cts;
+ }  Si2168_COMMON_REPLY_struct;
+
+/* STATUS fields definition */
+  /* STATUS, DDINT field definition (address 0, size 1, lsb 0, unsigned)*/
+  #define  Si2168_STATUS_DDINT_LSB         0
+  #define  Si2168_STATUS_DDINT_MASK        0x01
+   #define Si2168_STATUS_DDINT_NOT_TRIGGERED  0
+   #define Si2168_STATUS_DDINT_TRIGGERED      1
+  /* STATUS, SCANINT field definition (address 0, size 1, lsb 1, unsigned)*/
+  #define  Si2168_STATUS_SCANINT_LSB         1
+  #define  Si2168_STATUS_SCANINT_MASK        0x01
+   #define Si2168_STATUS_SCANINT_NOT_TRIGGERED  0
+   #define Si2168_STATUS_SCANINT_TRIGGERED      1
+  /* STATUS, ERR field definition (address 0, size 1, lsb 6, unsigned)*/
+  #define  Si2168_STATUS_ERR_LSB         6
+  #define  Si2168_STATUS_ERR_MASK        0x01
+   #define Si2168_STATUS_ERR_ERROR     1
+   #define Si2168_STATUS_ERR_NO_ERROR  0
+  /* STATUS, CTS field definition (address 0, size 1, lsb 7, unsigned)*/
+  #define  Si2168_STATUS_CTS_LSB         7
+  #define  Si2168_STATUS_CTS_MASK        0x01
+   #define Si2168_STATUS_CTS_COMPLETED  1
+   #define Si2168_STATUS_CTS_WAIT       0
+
+/* _status_defines_insertion_point */
+
+/* _commands_defines_insertion_start */
+/* Si2168_CONFIG_CLKIO command definition */
+#define   Si2168_CONFIG_CLKIO_CMD 0x18
+
+#ifdef    Si2168_CONFIG_CLKIO_CMD
+  #define Si2168_CONFIG_CLKIO_CMD_CODE 0x010018
+
+    typedef struct { /* Si2168_CONFIG_CLKIO_CMD_struct */
+     unsigned char   output;
+     unsigned char   pre_driver_str;
+     unsigned char   driver_str;
+   } Si2168_CONFIG_CLKIO_CMD_struct;
+
+
+    typedef struct { /* Si2168_CONFIG_CLKIO_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   mode;
+      unsigned char   pre_driver_str;
+      unsigned char   driver_str;
+   }  Si2168_CONFIG_CLKIO_CMD_REPLY_struct;
+
+   /* CONFIG_CLKIO command, OUTPUT field definition (address 1,size 2, lsb 0, unsigned) */
+   #define  Si2168_CONFIG_CLKIO_CMD_OUTPUT_LSB         0
+   #define  Si2168_CONFIG_CLKIO_CMD_OUTPUT_MASK        0x03
+   #define  Si2168_CONFIG_CLKIO_CMD_OUTPUT_MIN         0
+   #define  Si2168_CONFIG_CLKIO_CMD_OUTPUT_MAX         2
+    #define Si2168_CONFIG_CLKIO_CMD_OUTPUT_NO_CHANGE  0
+    #define Si2168_CONFIG_CLKIO_CMD_OUTPUT_OFF        2
+    #define Si2168_CONFIG_CLKIO_CMD_OUTPUT_ON         1
+   /* CONFIG_CLKIO command, PRE_DRIVER_STR field definition (address 1,size 2, lsb 2, unsigned) */
+   #define  Si2168_CONFIG_CLKIO_CMD_PRE_DRIVER_STR_LSB         2
+   #define  Si2168_CONFIG_CLKIO_CMD_PRE_DRIVER_STR_MASK        0x03
+   #define  Si2168_CONFIG_CLKIO_CMD_PRE_DRIVER_STR_MIN         0
+   #define  Si2168_CONFIG_CLKIO_CMD_PRE_DRIVER_STR_MAX         3
+    #define Si2168_CONFIG_CLKIO_CMD_PRE_DRIVER_STR_PRE_DRIVER_MIN  0
+    #define Si2168_CONFIG_CLKIO_CMD_PRE_DRIVER_STR_PRE_DRIVER_MAX  3
+   /* CONFIG_CLKIO command, DRIVER_STR field definition (address 1,size 4, lsb 4, unsigned) */
+   #define  Si2168_CONFIG_CLKIO_CMD_DRIVER_STR_LSB         4
+   #define  Si2168_CONFIG_CLKIO_CMD_DRIVER_STR_MASK        0x0f
+   #define  Si2168_CONFIG_CLKIO_CMD_DRIVER_STR_MIN         0
+   #define  Si2168_CONFIG_CLKIO_CMD_DRIVER_STR_MAX         15
+    #define Si2168_CONFIG_CLKIO_CMD_DRIVER_STR_DRIVER_MIN  0
+    #define Si2168_CONFIG_CLKIO_CMD_DRIVER_STR_DRIVER_MAX  15
+   /* CONFIG_CLKIO command, MODE field definition (address 1, size 2, lsb 0, unsigned)*/
+   #define  Si2168_CONFIG_CLKIO_RESPONSE_MODE_LSB         0
+   #define  Si2168_CONFIG_CLKIO_RESPONSE_MODE_MASK        0x03
+    #define Si2168_CONFIG_CLKIO_RESPONSE_MODE_CLK_INPUT   2
+    #define Si2168_CONFIG_CLKIO_RESPONSE_MODE_CLK_OUTPUT  1
+    #define Si2168_CONFIG_CLKIO_RESPONSE_MODE_UNUSED      0
+   /* CONFIG_CLKIO command, PRE_DRIVER_STR field definition (address 2, size 8, lsb 0, unsigned)*/
+   #define  Si2168_CONFIG_CLKIO_RESPONSE_PRE_DRIVER_STR_LSB         0
+   #define  Si2168_CONFIG_CLKIO_RESPONSE_PRE_DRIVER_STR_MASK        0xff
+   /* CONFIG_CLKIO command, DRIVER_STR field definition (address 3, size 8, lsb 0, unsigned)*/
+   #define  Si2168_CONFIG_CLKIO_RESPONSE_DRIVER_STR_LSB         0
+   #define  Si2168_CONFIG_CLKIO_RESPONSE_DRIVER_STR_MASK        0xff
+
+#endif /* Si2168_CONFIG_CLKIO_CMD */
+
+/* Si2168_CONFIG_PINS command definition */
+#define   Si2168_CONFIG_PINS_CMD 0x12
+
+#ifdef    Si2168_CONFIG_PINS_CMD
+  #define Si2168_CONFIG_PINS_CMD_CODE 0x010012
+
+    typedef struct { /* Si2168_CONFIG_PINS_CMD_struct */
+     unsigned char   gpio0_mode;
+     unsigned char   gpio0_read;
+     unsigned char   gpio1_mode;
+     unsigned char   gpio1_read;
+   } Si2168_CONFIG_PINS_CMD_struct;
+
+
+    typedef struct { /* Si2168_CONFIG_PINS_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   gpio0_mode;
+      unsigned char   gpio0_state;
+      unsigned char   gpio1_mode;
+      unsigned char   gpio1_state;
+   }  Si2168_CONFIG_PINS_CMD_REPLY_struct;
+
+   /* CONFIG_PINS command, GPIO0_MODE field definition (address 1,size 7, lsb 0, unsigned) */
+   #define  Si2168_CONFIG_PINS_CMD_GPIO0_MODE_LSB         0
+   #define  Si2168_CONFIG_PINS_CMD_GPIO0_MODE_MASK        0x7f
+   #define  Si2168_CONFIG_PINS_CMD_GPIO0_MODE_MIN         0
+   #define  Si2168_CONFIG_PINS_CMD_GPIO0_MODE_MAX         8
+    #define Si2168_CONFIG_PINS_CMD_GPIO0_MODE_DISABLE    1
+    #define Si2168_CONFIG_PINS_CMD_GPIO0_MODE_DRIVE_0    2
+    #define Si2168_CONFIG_PINS_CMD_GPIO0_MODE_DRIVE_1    3
+    #define Si2168_CONFIG_PINS_CMD_GPIO0_MODE_HW_LOCK    8
+    #define Si2168_CONFIG_PINS_CMD_GPIO0_MODE_INT_FLAG   7
+    #define Si2168_CONFIG_PINS_CMD_GPIO0_MODE_NO_CHANGE  0
+    #define Si2168_CONFIG_PINS_CMD_GPIO0_MODE_TS_ERR     4
+   /* CONFIG_PINS command, GPIO0_READ field definition (address 1,size 1, lsb 7, unsigned) */
+   #define  Si2168_CONFIG_PINS_CMD_GPIO0_READ_LSB         7
+   #define  Si2168_CONFIG_PINS_CMD_GPIO0_READ_MASK        0x01
+   #define  Si2168_CONFIG_PINS_CMD_GPIO0_READ_MIN         0
+   #define  Si2168_CONFIG_PINS_CMD_GPIO0_READ_MAX         1
+    #define Si2168_CONFIG_PINS_CMD_GPIO0_READ_DO_NOT_READ  0
+    #define Si2168_CONFIG_PINS_CMD_GPIO0_READ_READ         1
+   /* CONFIG_PINS command, GPIO1_MODE field definition (address 2,size 7, lsb 0, unsigned) */
+   #define  Si2168_CONFIG_PINS_CMD_GPIO1_MODE_LSB         0
+   #define  Si2168_CONFIG_PINS_CMD_GPIO1_MODE_MASK        0x7f
+   #define  Si2168_CONFIG_PINS_CMD_GPIO1_MODE_MIN         0
+   #define  Si2168_CONFIG_PINS_CMD_GPIO1_MODE_MAX         8
+    #define Si2168_CONFIG_PINS_CMD_GPIO1_MODE_DISABLE    1
+    #define Si2168_CONFIG_PINS_CMD_GPIO1_MODE_DRIVE_0    2
+    #define Si2168_CONFIG_PINS_CMD_GPIO1_MODE_DRIVE_1    3
+    #define Si2168_CONFIG_PINS_CMD_GPIO1_MODE_HW_LOCK    8
+    #define Si2168_CONFIG_PINS_CMD_GPIO1_MODE_INT_FLAG   7
+    #define Si2168_CONFIG_PINS_CMD_GPIO1_MODE_NO_CHANGE  0
+    #define Si2168_CONFIG_PINS_CMD_GPIO1_MODE_TS_ERR     4
+   /* CONFIG_PINS command, GPIO1_READ field definition (address 2,size 1, lsb 7, unsigned) */
+   #define  Si2168_CONFIG_PINS_CMD_GPIO1_READ_LSB         7
+   #define  Si2168_CONFIG_PINS_CMD_GPIO1_READ_MASK        0x01
+   #define  Si2168_CONFIG_PINS_CMD_GPIO1_READ_MIN         0
+   #define  Si2168_CONFIG_PINS_CMD_GPIO1_READ_MAX         1
+    #define Si2168_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ  0
+    #define Si2168_CONFIG_PINS_CMD_GPIO1_READ_READ         1
+   /* CONFIG_PINS command, GPIO0_MODE field definition (address 1, size 7, lsb 0, unsigned)*/
+   #define  Si2168_CONFIG_PINS_RESPONSE_GPIO0_MODE_LSB         0
+   #define  Si2168_CONFIG_PINS_RESPONSE_GPIO0_MODE_MASK        0x7f
+    #define Si2168_CONFIG_PINS_RESPONSE_GPIO0_MODE_DISABLE   1
+    #define Si2168_CONFIG_PINS_RESPONSE_GPIO0_MODE_DRIVE_0   2
+    #define Si2168_CONFIG_PINS_RESPONSE_GPIO0_MODE_DRIVE_1   3
+    #define Si2168_CONFIG_PINS_RESPONSE_GPIO0_MODE_HW_LOCK   8
+    #define Si2168_CONFIG_PINS_RESPONSE_GPIO0_MODE_INT_FLAG  7
+    #define Si2168_CONFIG_PINS_RESPONSE_GPIO0_MODE_TS_ERR    4
+   /* CONFIG_PINS command, GPIO0_STATE field definition (address 1, size 1, lsb 7, unsigned)*/
+   #define  Si2168_CONFIG_PINS_RESPONSE_GPIO0_STATE_LSB         7
+   #define  Si2168_CONFIG_PINS_RESPONSE_GPIO0_STATE_MASK        0x01
+    #define Si2168_CONFIG_PINS_RESPONSE_GPIO0_STATE_READ_0  0
+    #define Si2168_CONFIG_PINS_RESPONSE_GPIO0_STATE_READ_1  1
+   /* CONFIG_PINS command, GPIO1_MODE field definition (address 2, size 7, lsb 0, unsigned)*/
+   #define  Si2168_CONFIG_PINS_RESPONSE_GPIO1_MODE_LSB         0
+   #define  Si2168_CONFIG_PINS_RESPONSE_GPIO1_MODE_MASK        0x7f
+    #define Si2168_CONFIG_PINS_RESPONSE_GPIO1_MODE_DISABLE   1
+    #define Si2168_CONFIG_PINS_RESPONSE_GPIO1_MODE_DRIVE_0   2
+    #define Si2168_CONFIG_PINS_RESPONSE_GPIO1_MODE_DRIVE_1   3
+    #define Si2168_CONFIG_PINS_RESPONSE_GPIO1_MODE_HW_LOCK   8
+    #define Si2168_CONFIG_PINS_RESPONSE_GPIO1_MODE_INT_FLAG  7
+    #define Si2168_CONFIG_PINS_RESPONSE_GPIO1_MODE_TS_ERR    4
+   /* CONFIG_PINS command, GPIO1_STATE field definition (address 2, size 1, lsb 7, unsigned)*/
+   #define  Si2168_CONFIG_PINS_RESPONSE_GPIO1_STATE_LSB         7
+   #define  Si2168_CONFIG_PINS_RESPONSE_GPIO1_STATE_MASK        0x01
+    #define Si2168_CONFIG_PINS_RESPONSE_GPIO1_STATE_READ_0  0
+    #define Si2168_CONFIG_PINS_RESPONSE_GPIO1_STATE_READ_1  1
+
+#endif /* Si2168_CONFIG_PINS_CMD */
+
+/* Si2168_DD_BER command definition */
+#define   Si2168_DD_BER_CMD 0x82
+
+#ifdef    Si2168_DD_BER_CMD
+  #define Si2168_DD_BER_CMD_CODE 0x010082
+
+    typedef struct { /* Si2168_DD_BER_CMD_struct */
+     unsigned char   rst;
+   } Si2168_DD_BER_CMD_struct;
+
+
+    typedef struct { /* Si2168_DD_BER_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   exp;
+      unsigned char   mant;
+   }  Si2168_DD_BER_CMD_REPLY_struct;
+
+   /* DD_BER command, RST field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2168_DD_BER_CMD_RST_LSB         0
+   #define  Si2168_DD_BER_CMD_RST_MASK        0x01
+   #define  Si2168_DD_BER_CMD_RST_MIN         0
+   #define  Si2168_DD_BER_CMD_RST_MAX         1
+    #define Si2168_DD_BER_CMD_RST_CLEAR  1
+    #define Si2168_DD_BER_CMD_RST_RUN    0
+   /* DD_BER command, EXP field definition (address 1, size 4, lsb 0, unsigned)*/
+   #define  Si2168_DD_BER_RESPONSE_EXP_LSB         0
+   #define  Si2168_DD_BER_RESPONSE_EXP_MASK        0x0f
+    #define Si2168_DD_BER_RESPONSE_EXP_EXP_MIN  0
+    #define Si2168_DD_BER_RESPONSE_EXP_EXP_MAX  8
+   /* DD_BER command, MANT field definition (address 2, size 8, lsb 0, unsigned)*/
+   #define  Si2168_DD_BER_RESPONSE_MANT_LSB         0
+   #define  Si2168_DD_BER_RESPONSE_MANT_MASK        0xff
+    #define Si2168_DD_BER_RESPONSE_MANT_MANT_MIN  0
+    #define Si2168_DD_BER_RESPONSE_MANT_MANT_MAX  99
+
+#endif /* Si2168_DD_BER_CMD */
+
+/* Si2168_DD_CBER command definition */
+#define   Si2168_DD_CBER_CMD 0x81
+
+#ifdef    Si2168_DD_CBER_CMD
+  #define Si2168_DD_CBER_CMD_CODE 0x010081
+
+    typedef struct { /* Si2168_DD_CBER_CMD_struct */
+     unsigned char   rst;
+   } Si2168_DD_CBER_CMD_struct;
+
+
+    typedef struct { /* Si2168_DD_CBER_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   exp;
+      unsigned char   mant;
+   }  Si2168_DD_CBER_CMD_REPLY_struct;
+
+   /* DD_CBER command, RST field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2168_DD_CBER_CMD_RST_LSB         0
+   #define  Si2168_DD_CBER_CMD_RST_MASK        0x01
+   #define  Si2168_DD_CBER_CMD_RST_MIN         0
+   #define  Si2168_DD_CBER_CMD_RST_MAX         1
+    #define Si2168_DD_CBER_CMD_RST_CLEAR  1
+    #define Si2168_DD_CBER_CMD_RST_RUN    0
+   /* DD_CBER command, EXP field definition (address 1, size 4, lsb 0, unsigned)*/
+   #define  Si2168_DD_CBER_RESPONSE_EXP_LSB         0
+   #define  Si2168_DD_CBER_RESPONSE_EXP_MASK        0x0f
+    #define Si2168_DD_CBER_RESPONSE_EXP_EXP_MIN  0
+    #define Si2168_DD_CBER_RESPONSE_EXP_EXP_MAX  8
+   /* DD_CBER command, MANT field definition (address 2, size 8, lsb 0, unsigned)*/
+   #define  Si2168_DD_CBER_RESPONSE_MANT_LSB         0
+   #define  Si2168_DD_CBER_RESPONSE_MANT_MASK        0xff
+    #define Si2168_DD_CBER_RESPONSE_MANT_MANT_MIN  0
+    #define Si2168_DD_CBER_RESPONSE_MANT_MANT_MAX  99
+
+#endif /* Si2168_DD_CBER_CMD */
+
+
+/* Si2168_DD_EXT_AGC_TER command definition */
+#define   Si2168_DD_EXT_AGC_TER_CMD 0x89
+
+#ifdef    Si2168_DD_EXT_AGC_TER_CMD
+  #define Si2168_DD_EXT_AGC_TER_CMD_CODE 0x010089
+
+    typedef struct { /* Si2168_DD_EXT_AGC_TER_CMD_struct */
+     unsigned char   agc_1_mode;
+     unsigned char   agc_1_inv;
+     unsigned char   agc_2_mode;
+     unsigned char   agc_2_inv;
+     unsigned char   agc_1_kloop;
+     unsigned char   agc_2_kloop;
+     unsigned char   agc_1_min;
+     unsigned char   agc_2_min;
+   } Si2168_DD_EXT_AGC_TER_CMD_struct;
+
+
+    typedef struct { /* Si2168_DD_EXT_AGC_TER_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   agc_1_level;
+      unsigned char   agc_2_level;
+   }  Si2168_DD_EXT_AGC_TER_CMD_REPLY_struct;
+
+   /* DD_EXT_AGC_TER command, AGC_1_MODE field definition (address 1,size 3, lsb 0, unsigned) */
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_LSB         0
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MASK        0x07
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MIN         0
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MAX         5
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MP_A       2
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MP_B       3
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MP_C       4
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MP_D       5
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_NOT_USED   1
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_NO_CHANGE  0
+   /* DD_EXT_AGC_TER command, AGC_1_INV field definition (address 1,size 1, lsb 3, unsigned) */
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_INV_LSB         3
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_INV_MASK        0x01
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_INV_MIN         0
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_INV_MAX         1
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_INV_INVERTED      1
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_INV_NOT_INVERTED  0
+   /* DD_EXT_AGC_TER command, AGC_2_MODE field definition (address 1,size 3, lsb 4, unsigned) */
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_LSB         4
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MASK        0x07
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MIN         0
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MAX         5
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MP_A       2
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MP_B       3
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MP_C       4
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MP_D       5
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_NOT_USED   1
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_NO_CHANGE  0
+   /* DD_EXT_AGC_TER command, AGC_2_INV field definition (address 1,size 1, lsb 7, unsigned) */
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_INV_LSB         7
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_INV_MASK        0x01
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_INV_MIN         0
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_INV_MAX         1
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_INV_INVERTED      1
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_INV_NOT_INVERTED  0
+   /* DD_EXT_AGC_TER command, AGC_1_KLOOP field definition (address 2,size 5, lsb 0, unsigned) */
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_LSB         0
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_MASK        0x1f
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_MIN         6
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_MAX         20
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_AGC_1_KLOOP_MIN  6
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_AGC_1_KLOOP_MAX  20
+   /* DD_EXT_AGC_TER command, AGC_2_KLOOP field definition (address 3,size 5, lsb 0, unsigned) */
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_LSB         0
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_MASK        0x1f
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_MIN         6
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_MAX         20
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_AGC_2_KLOOP_MIN  6
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_AGC_2_KLOOP_MAX  20
+   /* DD_EXT_AGC_TER command, AGC_1_MIN field definition (address 4,size 8, lsb 0, unsigned) */
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MIN_LSB         0
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MIN_MASK        0xff
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MIN_MIN         0
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MIN_MAX         255
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MIN_AGC_1_MIN_MIN  0
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MIN_AGC_1_MIN_MAX  255
+   /* DD_EXT_AGC_TER command, AGC_2_MIN field definition (address 5,size 8, lsb 0, unsigned) */
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MIN_LSB         0
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MIN_MASK        0xff
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MIN_MIN         0
+   #define  Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MIN_MAX         255
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MIN_AGC_2_MIN_MIN  0
+    #define Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MIN_AGC_2_MIN_MAX  255
+   /* DD_EXT_AGC_TER command, AGC_1_LEVEL field definition (address 1, size 8, lsb 0, unsigned)*/
+   #define  Si2168_DD_EXT_AGC_TER_RESPONSE_AGC_1_LEVEL_LSB         0
+   #define  Si2168_DD_EXT_AGC_TER_RESPONSE_AGC_1_LEVEL_MASK        0xff
+   /* DD_EXT_AGC_TER command, AGC_2_LEVEL field definition (address 2, size 8, lsb 0, unsigned)*/
+   #define  Si2168_DD_EXT_AGC_TER_RESPONSE_AGC_2_LEVEL_LSB         0
+   #define  Si2168_DD_EXT_AGC_TER_RESPONSE_AGC_2_LEVEL_MASK        0xff
+
+#endif /* Si2168_DD_EXT_AGC_TER_CMD */
+
+
+/* Si2168_DD_FER command definition */
+#define   Si2168_DD_FER_CMD 0x86
+
+#ifdef    Si2168_DD_FER_CMD
+  #define Si2168_DD_FER_CMD_CODE 0x010086
+
+    typedef struct { /* Si2168_DD_FER_CMD_struct */
+     unsigned char   rst;
+   } Si2168_DD_FER_CMD_struct;
+
+
+    typedef struct { /* Si2168_DD_FER_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   exp;
+      unsigned char   mant;
+   }  Si2168_DD_FER_CMD_REPLY_struct;
+
+   /* DD_FER command, RST field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2168_DD_FER_CMD_RST_LSB         0
+   #define  Si2168_DD_FER_CMD_RST_MASK        0x01
+   #define  Si2168_DD_FER_CMD_RST_MIN         0
+   #define  Si2168_DD_FER_CMD_RST_MAX         1
+    #define Si2168_DD_FER_CMD_RST_CLEAR  1
+    #define Si2168_DD_FER_CMD_RST_RUN    0
+   /* DD_FER command, EXP field definition (address 1, size 4, lsb 0, unsigned)*/
+   #define  Si2168_DD_FER_RESPONSE_EXP_LSB         0
+   #define  Si2168_DD_FER_RESPONSE_EXP_MASK        0x0f
+    #define Si2168_DD_FER_RESPONSE_EXP_EXP_MIN  0
+    #define Si2168_DD_FER_RESPONSE_EXP_EXP_MAX  8
+   /* DD_FER command, MANT field definition (address 2, size 8, lsb 0, unsigned)*/
+   #define  Si2168_DD_FER_RESPONSE_MANT_LSB         0
+   #define  Si2168_DD_FER_RESPONSE_MANT_MASK        0xff
+    #define Si2168_DD_FER_RESPONSE_MANT_MANT_MIN  0
+    #define Si2168_DD_FER_RESPONSE_MANT_MANT_MAX  99
+
+#endif /* Si2168_DD_FER_CMD */
+
+/* Si2168_DD_GET_REG command definition */
+#define   Si2168_DD_GET_REG_CMD 0x8f
+
+#ifdef    Si2168_DD_GET_REG_CMD
+  #define Si2168_DD_GET_REG_CMD_CODE 0x01008f
+
+    typedef struct { /* Si2168_DD_GET_REG_CMD_struct */
+     unsigned char   reg_code_lsb;
+     unsigned char   reg_code_mid;
+     unsigned char   reg_code_msb;
+   } Si2168_DD_GET_REG_CMD_struct;
+
+
+    typedef struct { /* Si2168_DD_GET_REG_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   data1;
+      unsigned char   data2;
+      unsigned char   data3;
+      unsigned char   data4;
+   }  Si2168_DD_GET_REG_CMD_REPLY_struct;
+
+   /* DD_GET_REG command, REG_CODE_LSB field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  Si2168_DD_GET_REG_CMD_REG_CODE_LSB_LSB         0
+   #define  Si2168_DD_GET_REG_CMD_REG_CODE_LSB_MASK        0xff
+   #define  Si2168_DD_GET_REG_CMD_REG_CODE_LSB_MIN         0
+   #define  Si2168_DD_GET_REG_CMD_REG_CODE_LSB_MAX         255
+    #define Si2168_DD_GET_REG_CMD_REG_CODE_LSB_REG_CODE_LSB_MIN  0
+    #define Si2168_DD_GET_REG_CMD_REG_CODE_LSB_REG_CODE_LSB_MAX  255
+   /* DD_GET_REG command, REG_CODE_MID field definition (address 2,size 8, lsb 0, unsigned) */
+   #define  Si2168_DD_GET_REG_CMD_REG_CODE_MID_LSB         0
+   #define  Si2168_DD_GET_REG_CMD_REG_CODE_MID_MASK        0xff
+   #define  Si2168_DD_GET_REG_CMD_REG_CODE_MID_MIN         0
+   #define  Si2168_DD_GET_REG_CMD_REG_CODE_MID_MAX         255
+    #define Si2168_DD_GET_REG_CMD_REG_CODE_MID_REG_CODE_MID_MIN  0
+    #define Si2168_DD_GET_REG_CMD_REG_CODE_MID_REG_CODE_MID_MAX  255
+   /* DD_GET_REG command, REG_CODE_MSB field definition (address 3,size 8, lsb 0, unsigned) */
+   #define  Si2168_DD_GET_REG_CMD_REG_CODE_MSB_LSB         0
+   #define  Si2168_DD_GET_REG_CMD_REG_CODE_MSB_MASK        0xff
+   #define  Si2168_DD_GET_REG_CMD_REG_CODE_MSB_MIN         0
+   #define  Si2168_DD_GET_REG_CMD_REG_CODE_MSB_MAX         255
+    #define Si2168_DD_GET_REG_CMD_REG_CODE_MSB_REG_CODE_MSB_MIN  0
+    #define Si2168_DD_GET_REG_CMD_REG_CODE_MSB_REG_CODE_MSB_MAX  255
+   /* DD_GET_REG command, DATA1 field definition (address 1, size 8, lsb 0, unsigned)*/
+   #define  Si2168_DD_GET_REG_RESPONSE_DATA1_LSB         0
+   #define  Si2168_DD_GET_REG_RESPONSE_DATA1_MASK        0xff
+    #define Si2168_DD_GET_REG_RESPONSE_DATA1_DATA1_MIN  0
+    #define Si2168_DD_GET_REG_RESPONSE_DATA1_DATA1_MAX  255
+   /* DD_GET_REG command, DATA2 field definition (address 2, size 8, lsb 0, unsigned)*/
+   #define  Si2168_DD_GET_REG_RESPONSE_DATA2_LSB         0
+   #define  Si2168_DD_GET_REG_RESPONSE_DATA2_MASK        0xff
+    #define Si2168_DD_GET_REG_RESPONSE_DATA2_DATA2_MIN  0
+    #define Si2168_DD_GET_REG_RESPONSE_DATA2_DATA2_MAX  255
+   /* DD_GET_REG command, DATA3 field definition (address 3, size 8, lsb 0, unsigned)*/
+   #define  Si2168_DD_GET_REG_RESPONSE_DATA3_LSB         0
+   #define  Si2168_DD_GET_REG_RESPONSE_DATA3_MASK        0xff
+    #define Si2168_DD_GET_REG_RESPONSE_DATA3_DATA3_MIN  0
+    #define Si2168_DD_GET_REG_RESPONSE_DATA3_DATA3_MAX  255
+   /* DD_GET_REG command, DATA4 field definition (address 4, size 8, lsb 0, unsigned)*/
+   #define  Si2168_DD_GET_REG_RESPONSE_DATA4_LSB         0
+   #define  Si2168_DD_GET_REG_RESPONSE_DATA4_MASK        0xff
+    #define Si2168_DD_GET_REG_RESPONSE_DATA4_DATA4_MIN  0
+    #define Si2168_DD_GET_REG_RESPONSE_DATA4_DATA4_MAX  255
+
+#endif /* Si2168_DD_GET_REG_CMD */
+
+/* Si2168_DD_MP_DEFAULTS command definition */
+#define   Si2168_DD_MP_DEFAULTS_CMD 0x88
+
+#ifdef    Si2168_DD_MP_DEFAULTS_CMD
+  #define Si2168_DD_MP_DEFAULTS_CMD_CODE 0x010088
+
+    typedef struct { /* Si2168_DD_MP_DEFAULTS_CMD_struct */
+     unsigned char   mp_a_mode;
+     unsigned char   mp_b_mode;
+     unsigned char   mp_c_mode;
+     unsigned char   mp_d_mode;
+   } Si2168_DD_MP_DEFAULTS_CMD_struct;
+
+
+    typedef struct { /* Si2168_DD_MP_DEFAULTS_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   mp_a_mode;
+      unsigned char   mp_b_mode;
+      unsigned char   mp_c_mode;
+      unsigned char   mp_d_mode;
+   }  Si2168_DD_MP_DEFAULTS_CMD_REPLY_struct;
+
+   /* DD_MP_DEFAULTS command, MP_A_MODE field definition (address 1,size 7, lsb 0, unsigned) */
+   #define  Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_LSB         0
+   #define  Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_MASK        0x7f
+   #define  Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_MIN         0
+   #define  Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_MAX         3
+    #define Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_DISABLE    1
+    #define Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_DRIVE_0    2
+    #define Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_DRIVE_1    3
+    #define Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_NO_CHANGE  0
+   /* DD_MP_DEFAULTS command, MP_B_MODE field definition (address 2,size 7, lsb 0, unsigned) */
+   #define  Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_LSB         0
+   #define  Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_MASK        0x7f
+   #define  Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_MIN         0
+   #define  Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_MAX         3
+    #define Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_DISABLE    1
+    #define Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_DRIVE_0    2
+    #define Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_DRIVE_1    3
+    #define Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_NO_CHANGE  0
+   /* DD_MP_DEFAULTS command, MP_C_MODE field definition (address 3,size 7, lsb 0, unsigned) */
+   #define  Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_LSB         0
+   #define  Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_MASK        0x7f
+   #define  Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_MIN         0
+   #define  Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_MAX         3
+    #define Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_DISABLE    1
+    #define Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_DRIVE_0    2
+    #define Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_DRIVE_1    3
+    #define Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_NO_CHANGE  0
+   /* DD_MP_DEFAULTS command, MP_D_MODE field definition (address 4,size 7, lsb 0, unsigned) */
+   #define  Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_LSB         0
+   #define  Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_MASK        0x7f
+   #define  Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_MIN         0
+   #define  Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_MAX         3
+    #define Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_DISABLE    1
+    #define Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_DRIVE_0    2
+    #define Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_DRIVE_1    3
+    #define Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_NO_CHANGE  0
+   /* DD_MP_DEFAULTS command, MP_A_MODE field definition (address 1, size 7, lsb 0, unsigned)*/
+   #define  Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_LSB         0
+   #define  Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_MASK        0x7f
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_AGC_1           3
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_AGC_1_INVERTED  4
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_AGC_2           5
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_AGC_2_INVERTED  6
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_DISABLE         0
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_DRIVE_0         1
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_DRIVE_1         2
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_FEF             7
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_FEF_INVERTED    8
+   /* DD_MP_DEFAULTS command, MP_B_MODE field definition (address 2, size 7, lsb 0, unsigned)*/
+   #define  Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_LSB         0
+   #define  Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_MASK        0x7f
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_AGC_1           3
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_AGC_1_INVERTED  4
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_AGC_2           5
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_AGC_2_INVERTED  6
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_DISABLE         0
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_DRIVE_0         1
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_DRIVE_1         2
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_FEF             7
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_FEF_INVERTED    8
+   /* DD_MP_DEFAULTS command, MP_C_MODE field definition (address 3, size 7, lsb 0, unsigned)*/
+   #define  Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_LSB         0
+   #define  Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_MASK        0x7f
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_AGC_1           3
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_AGC_1_INVERTED  4
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_AGC_2           5
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_AGC_2_INVERTED  6
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_DISABLE         0
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_DRIVE_0         1
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_DRIVE_1         2
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_FEF             7
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_FEF_INVERTED    8
+   /* DD_MP_DEFAULTS command, MP_D_MODE field definition (address 4, size 7, lsb 0, unsigned)*/
+   #define  Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_LSB         0
+   #define  Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_MASK        0x7f
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_AGC_1           3
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_AGC_1_INVERTED  4
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_AGC_2           5
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_AGC_2_INVERTED  6
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_DISABLE         0
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_DRIVE_0         1
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_DRIVE_1         2
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_FEF             7
+    #define Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_FEF_INVERTED    8
+
+#endif /* Si2168_DD_MP_DEFAULTS_CMD */
+
+/* Si2168_DD_PER command definition */
+#define   Si2168_DD_PER_CMD 0x83
+
+#ifdef    Si2168_DD_PER_CMD
+  #define Si2168_DD_PER_CMD_CODE 0x010083
+
+    typedef struct { /* Si2168_DD_PER_CMD_struct */
+     unsigned char   rst;
+   } Si2168_DD_PER_CMD_struct;
+
+
+    typedef struct { /* Si2168_DD_PER_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   exp;
+      unsigned char   mant;
+   }  Si2168_DD_PER_CMD_REPLY_struct;
+
+   /* DD_PER command, RST field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2168_DD_PER_CMD_RST_LSB         0
+   #define  Si2168_DD_PER_CMD_RST_MASK        0x01
+   #define  Si2168_DD_PER_CMD_RST_MIN         0
+   #define  Si2168_DD_PER_CMD_RST_MAX         1
+    #define Si2168_DD_PER_CMD_RST_CLEAR  1
+    #define Si2168_DD_PER_CMD_RST_RUN    0
+   /* DD_PER command, EXP field definition (address 1, size 4, lsb 0, unsigned)*/
+   #define  Si2168_DD_PER_RESPONSE_EXP_LSB         0
+   #define  Si2168_DD_PER_RESPONSE_EXP_MASK        0x0f
+    #define Si2168_DD_PER_RESPONSE_EXP_EXP_MIN  0
+    #define Si2168_DD_PER_RESPONSE_EXP_EXP_MAX  8
+   /* DD_PER command, MANT field definition (address 2, size 8, lsb 0, unsigned)*/
+   #define  Si2168_DD_PER_RESPONSE_MANT_LSB         0
+   #define  Si2168_DD_PER_RESPONSE_MANT_MASK        0xff
+    #define Si2168_DD_PER_RESPONSE_MANT_MANT_MIN  0
+    #define Si2168_DD_PER_RESPONSE_MANT_MANT_MAX  99
+
+#endif /* Si2168_DD_PER_CMD */
+
+/* Si2168_DD_RESTART command definition */
+#define   Si2168_DD_RESTART_CMD 0x85
+
+#ifdef    Si2168_DD_RESTART_CMD
+  #define Si2168_DD_RESTART_CMD_CODE 0x010085
+
+    typedef struct { /* Si2168_DD_RESTART_CMD_struct */
+         unsigned char   nothing;   } Si2168_DD_RESTART_CMD_struct;
+
+
+    typedef struct { /* Si2168_DD_RESTART_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+   }  Si2168_DD_RESTART_CMD_REPLY_struct;
+
+#endif /* Si2168_DD_RESTART_CMD */
+
+/* Si2168_DD_SET_REG command definition */
+#define   Si2168_DD_SET_REG_CMD 0x8e
+
+#ifdef    Si2168_DD_SET_REG_CMD
+  #define Si2168_DD_SET_REG_CMD_CODE 0x01008e
+
+    typedef struct { /* Si2168_DD_SET_REG_CMD_struct */
+     unsigned char   reg_code_lsb;
+     unsigned char   reg_code_mid;
+     unsigned char   reg_code_msb;
+     unsigned long   value;
+   } Si2168_DD_SET_REG_CMD_struct;
+
+
+    typedef struct { /* Si2168_DD_SET_REG_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+   }  Si2168_DD_SET_REG_CMD_REPLY_struct;
+
+   /* DD_SET_REG command, REG_CODE_LSB field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_LSB_LSB         0
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_LSB_MASK        0xff
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_LSB_MIN         0
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_LSB_MAX         255
+    #define Si2168_DD_SET_REG_CMD_REG_CODE_LSB_REG_CODE_LSB_MIN  0
+    #define Si2168_DD_SET_REG_CMD_REG_CODE_LSB_REG_CODE_LSB_MAX  255
+   /* DD_SET_REG command, REG_CODE_MID field definition (address 2,size 8, lsb 0, unsigned) */
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_MID_LSB         0
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_MID_MASK        0xff
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_MID_MIN         0
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_MID_MAX         255
+    #define Si2168_DD_SET_REG_CMD_REG_CODE_MID_REG_CODE_MID_MIN  0
+    #define Si2168_DD_SET_REG_CMD_REG_CODE_MID_REG_CODE_MID_MAX  255
+   /* DD_SET_REG command, REG_CODE_MSB field definition (address 3,size 8, lsb 0, unsigned) */
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_MSB_LSB         0
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_MSB_MASK        0xff
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_MSB_MIN         0
+   #define  Si2168_DD_SET_REG_CMD_REG_CODE_MSB_MAX         255
+    #define Si2168_DD_SET_REG_CMD_REG_CODE_MSB_REG_CODE_MSB_MIN  0
+    #define Si2168_DD_SET_REG_CMD_REG_CODE_MSB_REG_CODE_MSB_MAX  255
+   /* DD_SET_REG command, VALUE field definition (address 4,size 32, lsb 0, unsigned) */
+   #define  Si2168_DD_SET_REG_CMD_VALUE_LSB         0
+   #define  Si2168_DD_SET_REG_CMD_VALUE_MASK        0xffffffff
+   #define  Si2168_DD_SET_REG_CMD_VALUE_MIN         0
+   #define  Si2168_DD_SET_REG_CMD_VALUE_MAX         4294967295
+    #define Si2168_DD_SET_REG_CMD_VALUE_VALUE_MIN  0
+    #define Si2168_DD_SET_REG_CMD_VALUE_VALUE_MAX  4294967295
+#endif /* Si2168_DD_SET_REG_CMD */
+
+/* Si2168_DD_SSI_SQI command definition */
+#define   Si2168_DD_SSI_SQI_CMD 0x8b
+
+#ifdef    Si2168_DD_SSI_SQI_CMD
+  #define Si2168_DD_SSI_SQI_CMD_CODE 0x01008b
+
+    typedef struct { /* Si2168_DD_SSI_SQI_CMD_struct */
+              char   tuner_rssi;
+   } Si2168_DD_SSI_SQI_CMD_struct;
+
+
+    typedef struct { /* Si2168_DD_SSI_SQI_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+               char   ssi;
+               char   sqi;
+   }  Si2168_DD_SSI_SQI_CMD_REPLY_struct;
+
+   /* DD_SSI_SQI command, TUNER_RSSI field definition (address 1,size 8, lsb 0, signed) */
+   #define  Si2168_DD_SSI_SQI_CMD_TUNER_RSSI_LSB         0
+   #define  Si2168_DD_SSI_SQI_CMD_TUNER_RSSI_MASK        0xff
+   #define  Si2168_DD_SSI_SQI_CMD_TUNER_RSSI_SHIFT       24
+   #define  Si2168_DD_SSI_SQI_CMD_TUNER_RSSI_MIN         -128.0
+   #define  Si2168_DD_SSI_SQI_CMD_TUNER_RSSI_MAX         127.0
+   /* DD_SSI_SQI command, SSI field definition (address 1, size 8, lsb 0, signed)*/
+   #define  Si2168_DD_SSI_SQI_RESPONSE_SSI_LSB         0
+   #define  Si2168_DD_SSI_SQI_RESPONSE_SSI_MASK        0xff
+   #define  Si2168_DD_SSI_SQI_RESPONSE_SSI_SHIFT       24
+    #define Si2168_DD_SSI_SQI_RESPONSE_SSI_SSI_MIN  -1
+    #define Si2168_DD_SSI_SQI_RESPONSE_SSI_SSI_MAX  100
+   /* DD_SSI_SQI command, SQI field definition (address 2, size 8, lsb 0, signed)*/
+   #define  Si2168_DD_SSI_SQI_RESPONSE_SQI_LSB         0
+   #define  Si2168_DD_SSI_SQI_RESPONSE_SQI_MASK        0xff
+   #define  Si2168_DD_SSI_SQI_RESPONSE_SQI_SHIFT       24
+    #define Si2168_DD_SSI_SQI_RESPONSE_SQI_SQI_MIN  -1
+    #define Si2168_DD_SSI_SQI_RESPONSE_SQI_SQI_MAX  100
+
+#endif /* Si2168_DD_SSI_SQI_CMD */
+
+/* Si2168_DD_STATUS command definition */
+#define   Si2168_DD_STATUS_CMD 0x87
+
+#ifdef    Si2168_DD_STATUS_CMD
+  #define Si2168_DD_STATUS_CMD_CODE 0x010087
+
+    typedef struct { /* Si2168_DD_STATUS_CMD_struct */
+     unsigned char   intack;
+   } Si2168_DD_STATUS_CMD_struct;
+
+
+    typedef struct { /* Si2168_DD_STATUS_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   pclint;
+      unsigned char   dlint;
+      unsigned char   berint;
+      unsigned char   uncorint;
+      unsigned char   rsqint_bit5;
+      unsigned char   rsqint_bit6;
+      unsigned char   rsqint_bit7;
+      unsigned char   pcl;
+      unsigned char   dl;
+      unsigned char   ber;
+      unsigned char   uncor;
+      unsigned char   rsqstat_bit5;
+      unsigned char   rsqstat_bit6;
+      unsigned char   rsqstat_bit7;
+      unsigned char   modulation;
+      unsigned int    ts_bit_rate;
+      unsigned int    ts_clk_freq;
+   }  Si2168_DD_STATUS_CMD_REPLY_struct;
+
+   /* DD_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2168_DD_STATUS_CMD_INTACK_LSB         0
+   #define  Si2168_DD_STATUS_CMD_INTACK_MASK        0x01
+   #define  Si2168_DD_STATUS_CMD_INTACK_MIN         0
+   #define  Si2168_DD_STATUS_CMD_INTACK_MAX         1
+    #define Si2168_DD_STATUS_CMD_INTACK_CLEAR  1
+    #define Si2168_DD_STATUS_CMD_INTACK_OK     0
+   /* DD_STATUS command, PCLINT field definition (address 1, size 1, lsb 1, unsigned)*/
+   #define  Si2168_DD_STATUS_RESPONSE_PCLINT_LSB         1
+   #define  Si2168_DD_STATUS_RESPONSE_PCLINT_MASK        0x01
+    #define Si2168_DD_STATUS_RESPONSE_PCLINT_CHANGED    1
+    #define Si2168_DD_STATUS_RESPONSE_PCLINT_NO_CHANGE  0
+   /* DD_STATUS command, DLINT field definition (address 1, size 1, lsb 2, unsigned)*/
+   #define  Si2168_DD_STATUS_RESPONSE_DLINT_LSB         2
+   #define  Si2168_DD_STATUS_RESPONSE_DLINT_MASK        0x01
+    #define Si2168_DD_STATUS_RESPONSE_DLINT_CHANGED    1
+    #define Si2168_DD_STATUS_RESPONSE_DLINT_NO_CHANGE  0
+   /* DD_STATUS command, BERINT field definition (address 1, size 1, lsb 3, unsigned)*/
+   #define  Si2168_DD_STATUS_RESPONSE_BERINT_LSB         3
+   #define  Si2168_DD_STATUS_RESPONSE_BERINT_MASK        0x01
+    #define Si2168_DD_STATUS_RESPONSE_BERINT_CHANGED    1
+    #define Si2168_DD_STATUS_RESPONSE_BERINT_NO_CHANGE  0
+   /* DD_STATUS command, UNCORINT field definition (address 1, size 1, lsb 4, unsigned)*/
+   #define  Si2168_DD_STATUS_RESPONSE_UNCORINT_LSB         4
+   #define  Si2168_DD_STATUS_RESPONSE_UNCORINT_MASK        0x01
+    #define Si2168_DD_STATUS_RESPONSE_UNCORINT_CHANGED    1
+    #define Si2168_DD_STATUS_RESPONSE_UNCORINT_NO_CHANGE  0
+   /* DD_STATUS command, RSQINT_BIT5 field definition (address 1, size 1, lsb 5, unsigned)*/
+   #define  Si2168_DD_STATUS_RESPONSE_RSQINT_BIT5_LSB         5
+   #define  Si2168_DD_STATUS_RESPONSE_RSQINT_BIT5_MASK        0x01
+    #define Si2168_DD_STATUS_RESPONSE_RSQINT_BIT5_CHANGED    1
+    #define Si2168_DD_STATUS_RESPONSE_RSQINT_BIT5_NO_CHANGE  0
+   /* DD_STATUS command, RSQINT_BIT6 field definition (address 1, size 1, lsb 6, unsigned)*/
+   #define  Si2168_DD_STATUS_RESPONSE_RSQINT_BIT6_LSB         6
+   #define  Si2168_DD_STATUS_RESPONSE_RSQINT_BIT6_MASK        0x01
+    #define Si2168_DD_STATUS_RESPONSE_RSQINT_BIT6_CHANGED    1
+    #define Si2168_DD_STATUS_RESPONSE_RSQINT_BIT6_NO_CHANGE  0
+   /* DD_STATUS command, RSQINT_BIT7 field definition (address 1, size 1, lsb 7, unsigned)*/
+   #define  Si2168_DD_STATUS_RESPONSE_RSQINT_BIT7_LSB         7
+   #define  Si2168_DD_STATUS_RESPONSE_RSQINT_BIT7_MASK        0x01
+    #define Si2168_DD_STATUS_RESPONSE_RSQINT_BIT7_CHANGED    1
+    #define Si2168_DD_STATUS_RESPONSE_RSQINT_BIT7_NO_CHANGE  0
+   /* DD_STATUS command, PCL field definition (address 2, size 1, lsb 1, unsigned)*/
+   #define  Si2168_DD_STATUS_RESPONSE_PCL_LSB         1
+   #define  Si2168_DD_STATUS_RESPONSE_PCL_MASK        0x01
+    #define Si2168_DD_STATUS_RESPONSE_PCL_LOCKED   1
+    #define Si2168_DD_STATUS_RESPONSE_PCL_NO_LOCK  0
+   /* DD_STATUS command, DL field definition (address 2, size 1, lsb 2, unsigned)*/
+   #define  Si2168_DD_STATUS_RESPONSE_DL_LSB         2
+   #define  Si2168_DD_STATUS_RESPONSE_DL_MASK        0x01
+    #define Si2168_DD_STATUS_RESPONSE_DL_LOCKED   1
+    #define Si2168_DD_STATUS_RESPONSE_DL_NO_LOCK  0
+   /* DD_STATUS command, BER field definition (address 2, size 1, lsb 3, unsigned)*/
+   #define  Si2168_DD_STATUS_RESPONSE_BER_LSB         3
+   #define  Si2168_DD_STATUS_RESPONSE_BER_MASK        0x01
+    #define Si2168_DD_STATUS_RESPONSE_BER_BER_ABOVE  1
+    #define Si2168_DD_STATUS_RESPONSE_BER_BER_BELOW  0
+   /* DD_STATUS command, UNCOR field definition (address 2, size 1, lsb 4, unsigned)*/
+   #define  Si2168_DD_STATUS_RESPONSE_UNCOR_LSB         4
+   #define  Si2168_DD_STATUS_RESPONSE_UNCOR_MASK        0x01
+    #define Si2168_DD_STATUS_RESPONSE_UNCOR_NO_UNCOR_FOUND  0
+    #define Si2168_DD_STATUS_RESPONSE_UNCOR_UNCOR_FOUND     1
+   /* DD_STATUS command, RSQSTAT_BIT5 field definition (address 2, size 1, lsb 5, unsigned)*/
+   #define  Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT5_LSB         5
+   #define  Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT5_MASK        0x01
+    #define  Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT5_NO_CHANGE 0
+    #define  Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT5_CHANGE    1
+   /* DD_STATUS command, RSQSTAT_BIT6 field definition (address 2, size 1, lsb 6, unsigned)*/
+   #define  Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT6_LSB         6
+   #define  Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT6_MASK        0x01
+   /* DD_STATUS command, RSQSTAT_BIT7 field definition (address 2, size 1, lsb 7, unsigned)*/
+   #define  Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT7_LSB         7
+   #define  Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT7_MASK        0x01
+   /* DD_STATUS command, MODULATION field definition (address 3, size 4, lsb 0, unsigned)*/
+   #define  Si2168_DD_STATUS_RESPONSE_MODULATION_LSB         0
+   #define  Si2168_DD_STATUS_RESPONSE_MODULATION_MASK        0x0f
+    #define Si2168_DD_STATUS_RESPONSE_MODULATION_DSS     10
+    #define Si2168_DD_STATUS_RESPONSE_MODULATION_DVBC    3
+    #define Si2168_DD_STATUS_RESPONSE_MODULATION_DVBS    8
+    #define Si2168_DD_STATUS_RESPONSE_MODULATION_DVBS2   9
+    #define Si2168_DD_STATUS_RESPONSE_MODULATION_DVBT    2
+    #define Si2168_DD_STATUS_RESPONSE_MODULATION_DVBT2   7
+   /* DD_STATUS command, TS_BIT_RATE field definition (address 4, size 16, lsb 0, unsigned)*/
+   #define  Si2168_DD_STATUS_RESPONSE_TS_BIT_RATE_LSB         0
+   #define  Si2168_DD_STATUS_RESPONSE_TS_BIT_RATE_MASK        0xffff
+   /* DD_STATUS command, TS_CLK_FREQ field definition (address 6, size 16, lsb 0, unsigned)*/
+   #define  Si2168_DD_STATUS_RESPONSE_TS_CLK_FREQ_LSB         0
+   #define  Si2168_DD_STATUS_RESPONSE_TS_CLK_FREQ_MASK        0xffff
+
+#endif /* Si2168_DD_STATUS_CMD */
+
+/* Si2168_DD_UNCOR command definition */
+#define   Si2168_DD_UNCOR_CMD 0x84
+
+#ifdef    Si2168_DD_UNCOR_CMD
+  #define Si2168_DD_UNCOR_CMD_CODE 0x010084
+
+    typedef struct { /* Si2168_DD_UNCOR_CMD_struct */
+     unsigned char   rst;
+   } Si2168_DD_UNCOR_CMD_struct;
+
+
+    typedef struct { /* Si2168_DD_UNCOR_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   uncor_lsb;
+      unsigned char   uncor_msb;
+   }  Si2168_DD_UNCOR_CMD_REPLY_struct;
+
+   /* DD_UNCOR command, RST field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2168_DD_UNCOR_CMD_RST_LSB         0
+   #define  Si2168_DD_UNCOR_CMD_RST_MASK        0x01
+   #define  Si2168_DD_UNCOR_CMD_RST_MIN         0
+   #define  Si2168_DD_UNCOR_CMD_RST_MAX         1
+    #define Si2168_DD_UNCOR_CMD_RST_CLEAR  1
+    #define Si2168_DD_UNCOR_CMD_RST_RUN    0
+   /* DD_UNCOR command, UNCOR_LSB field definition (address 1, size 8, lsb 0, unsigned)*/
+   #define  Si2168_DD_UNCOR_RESPONSE_UNCOR_LSB_LSB         0
+   #define  Si2168_DD_UNCOR_RESPONSE_UNCOR_LSB_MASK        0xff
+   /* DD_UNCOR command, UNCOR_MSB field definition (address 2, size 8, lsb 0, unsigned)*/
+   #define  Si2168_DD_UNCOR_RESPONSE_UNCOR_MSB_LSB         0
+   #define  Si2168_DD_UNCOR_RESPONSE_UNCOR_MSB_MASK        0xff
+
+#endif /* Si2168_DD_UNCOR_CMD */
+
+/* Si2168_DOWNLOAD_DATASET_CONTINUE command definition */
+#define   Si2168_DOWNLOAD_DATASET_CONTINUE_CMD 0xb9
+
+#ifdef    Si2168_DOWNLOAD_DATASET_CONTINUE_CMD
+  #define Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_CODE 0x0100b9
+
+    typedef struct { /* Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_struct */
+     unsigned char   data0;
+     unsigned char   data1;
+     unsigned char   data2;
+     unsigned char   data3;
+     unsigned char   data4;
+     unsigned char   data5;
+     unsigned char   data6;
+   } Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_struct;
+
+
+    typedef struct { /* Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+   }  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_REPLY_struct;
+
+   /* DOWNLOAD_DATASET_CONTINUE command, DATA0 field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_LSB         0
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_MASK        0xff
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_MIN         0
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_MAX         255
+    #define Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_DATA0_MIN  0
+    #define Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_DATA0_MAX  255
+   /* DOWNLOAD_DATASET_CONTINUE command, DATA1 field definition (address 2,size 8, lsb 0, unsigned) */
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_LSB         0
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_MASK        0xff
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_MIN         0
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_MAX         255
+    #define Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_DATA1_MIN  0
+    #define Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_DATA1_MAX  255
+   /* DOWNLOAD_DATASET_CONTINUE command, DATA2 field definition (address 3,size 8, lsb 0, unsigned) */
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_LSB         0
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_MASK        0xff
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_MIN         0
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_MAX         255
+    #define Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_DATA2_MIN  0
+    #define Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_DATA2_MAX  255
+   /* DOWNLOAD_DATASET_CONTINUE command, DATA3 field definition (address 4,size 8, lsb 0, unsigned) */
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_LSB         0
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_MASK        0xff
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_MIN         0
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_MAX         255
+    #define Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_DATA3_MIN  0
+    #define Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_DATA3_MAX  255
+   /* DOWNLOAD_DATASET_CONTINUE command, DATA4 field definition (address 5,size 8, lsb 0, unsigned) */
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_LSB         0
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_MASK        0xff
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_MIN         0
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_MAX         255
+    #define Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_DATA4_MIN  0
+    #define Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_DATA4_MAX  255
+   /* DOWNLOAD_DATASET_CONTINUE command, DATA5 field definition (address 6,size 8, lsb 0, unsigned) */
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_LSB         0
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_MASK        0xff
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_MIN         0
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_MAX         255
+    #define Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_DATA5_MIN  0
+    #define Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_DATA5_MAX  255
+   /* DOWNLOAD_DATASET_CONTINUE command, DATA6 field definition (address 7,size 8, lsb 0, unsigned) */
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_LSB         0
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_MASK        0xff
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_MIN         0
+   #define  Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_MAX         255
+    #define Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_DATA6_MIN  0
+    #define Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_DATA6_MAX  255
+#endif /* Si2168_DOWNLOAD_DATASET_CONTINUE_CMD */
+
+/* Si2168_DOWNLOAD_DATASET_START command definition */
+#define   Si2168_DOWNLOAD_DATASET_START_CMD 0xb8
+
+#ifdef    Si2168_DOWNLOAD_DATASET_START_CMD
+  #define Si2168_DOWNLOAD_DATASET_START_CMD_CODE 0x0100b8
+
+    typedef struct { /* Si2168_DOWNLOAD_DATASET_START_CMD_struct */
+     unsigned char   dataset_id;
+     unsigned char   dataset_checksum;
+     unsigned char   data0;
+     unsigned char   data1;
+     unsigned char   data2;
+     unsigned char   data3;
+     unsigned char   data4;
+   } Si2168_DOWNLOAD_DATASET_START_CMD_struct;
+
+
+    typedef struct { /* Si2168_DOWNLOAD_DATASET_START_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+   }  Si2168_DOWNLOAD_DATASET_START_CMD_REPLY_struct;
+
+   /* DOWNLOAD_DATASET_START command, DATASET_ID field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATASET_ID_LSB         0
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATASET_ID_MASK        0xff
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATASET_ID_MIN         0
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATASET_ID_MAX         0
+    #define Si2168_DOWNLOAD_DATASET_START_CMD_DATASET_ID_RFU  0
+   /* DOWNLOAD_DATASET_START command, DATASET_CHECKSUM field definition (address 2,size 8, lsb 0, unsigned) */
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_LSB         0
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_MASK        0xff
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_MIN         0
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_MAX         255
+    #define Si2168_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_DATASET_CHECKSUM_MIN  0
+    #define Si2168_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_DATASET_CHECKSUM_MAX  255
+   /* DOWNLOAD_DATASET_START command, DATA0 field definition (address 3,size 8, lsb 0, unsigned) */
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATA0_LSB         0
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATA0_MASK        0xff
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATA0_MIN         0
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATA0_MAX         255
+    #define Si2168_DOWNLOAD_DATASET_START_CMD_DATA0_DATA0_MIN  0
+    #define Si2168_DOWNLOAD_DATASET_START_CMD_DATA0_DATA0_MAX  255
+   /* DOWNLOAD_DATASET_START command, DATA1 field definition (address 4,size 8, lsb 0, unsigned) */
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATA1_LSB         0
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATA1_MASK        0xff
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATA1_MIN         0
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATA1_MAX         255
+    #define Si2168_DOWNLOAD_DATASET_START_CMD_DATA1_DATA1_MIN  0
+    #define Si2168_DOWNLOAD_DATASET_START_CMD_DATA1_DATA1_MAX  255
+   /* DOWNLOAD_DATASET_START command, DATA2 field definition (address 5,size 8, lsb 0, unsigned) */
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATA2_LSB         0
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATA2_MASK        0xff
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATA2_MIN         0
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATA2_MAX         255
+    #define Si2168_DOWNLOAD_DATASET_START_CMD_DATA2_DATA2_MIN  0
+    #define Si2168_DOWNLOAD_DATASET_START_CMD_DATA2_DATA2_MAX  255
+   /* DOWNLOAD_DATASET_START command, DATA3 field definition (address 6,size 8, lsb 0, unsigned) */
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATA3_LSB         0
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATA3_MASK        0xff
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATA3_MIN         0
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATA3_MAX         255
+    #define Si2168_DOWNLOAD_DATASET_START_CMD_DATA3_DATA3_MIN  0
+    #define Si2168_DOWNLOAD_DATASET_START_CMD_DATA3_DATA3_MAX  255
+   /* DOWNLOAD_DATASET_START command, DATA4 field definition (address 7,size 8, lsb 0, unsigned) */
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATA4_LSB         0
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATA4_MASK        0xff
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATA4_MIN         0
+   #define  Si2168_DOWNLOAD_DATASET_START_CMD_DATA4_MAX         255
+    #define Si2168_DOWNLOAD_DATASET_START_CMD_DATA4_DATA4_MIN  0
+    #define Si2168_DOWNLOAD_DATASET_START_CMD_DATA4_DATA4_MAX  255
+#endif /* Si2168_DOWNLOAD_DATASET_START_CMD */
+
+/* Si2168_DVBC_STATUS command definition */
+#define   Si2168_DVBC_STATUS_CMD 0x90
+
+#ifdef    Si2168_DVBC_STATUS_CMD
+  #define Si2168_DVBC_STATUS_CMD_CODE 0x010090
+
+    typedef struct { /* Si2168_DVBC_STATUS_CMD_struct */
+     unsigned char   intack;
+   } Si2168_DVBC_STATUS_CMD_struct;
+
+
+    typedef struct { /* Si2168_DVBC_STATUS_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   pclint;
+      unsigned char   dlint;
+      unsigned char   berint;
+      unsigned char   uncorint;
+      unsigned char   pcl;
+      unsigned char   dl;
+      unsigned char   ber;
+      unsigned char   uncor;
+      unsigned char   cnr;
+               int    afc_freq;
+               int    timing_offset;
+      unsigned char   constellation;
+      unsigned char   sp_inv;
+   }  Si2168_DVBC_STATUS_CMD_REPLY_struct;
+
+   /* DVBC_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2168_DVBC_STATUS_CMD_INTACK_LSB         0
+   #define  Si2168_DVBC_STATUS_CMD_INTACK_MASK        0x01
+   #define  Si2168_DVBC_STATUS_CMD_INTACK_MIN         0
+   #define  Si2168_DVBC_STATUS_CMD_INTACK_MAX         1
+    #define Si2168_DVBC_STATUS_CMD_INTACK_CLEAR  1
+    #define Si2168_DVBC_STATUS_CMD_INTACK_OK     0
+   /* DVBC_STATUS command, PCLINT field definition (address 1, size 1, lsb 1, unsigned)*/
+   #define  Si2168_DVBC_STATUS_RESPONSE_PCLINT_LSB         1
+   #define  Si2168_DVBC_STATUS_RESPONSE_PCLINT_MASK        0x01
+    #define Si2168_DVBC_STATUS_RESPONSE_PCLINT_CHANGED    1
+    #define Si2168_DVBC_STATUS_RESPONSE_PCLINT_NO_CHANGE  0
+   /* DVBC_STATUS command, DLINT field definition (address 1, size 1, lsb 2, unsigned)*/
+   #define  Si2168_DVBC_STATUS_RESPONSE_DLINT_LSB         2
+   #define  Si2168_DVBC_STATUS_RESPONSE_DLINT_MASK        0x01
+    #define Si2168_DVBC_STATUS_RESPONSE_DLINT_CHANGED    1
+    #define Si2168_DVBC_STATUS_RESPONSE_DLINT_NO_CHANGE  0
+   /* DVBC_STATUS command, BERINT field definition (address 1, size 1, lsb 3, unsigned)*/
+   #define  Si2168_DVBC_STATUS_RESPONSE_BERINT_LSB         3
+   #define  Si2168_DVBC_STATUS_RESPONSE_BERINT_MASK        0x01
+    #define Si2168_DVBC_STATUS_RESPONSE_BERINT_CHANGED    1
+    #define Si2168_DVBC_STATUS_RESPONSE_BERINT_NO_CHANGE  0
+   /* DVBC_STATUS command, UNCORINT field definition (address 1, size 1, lsb 4, unsigned)*/
+   #define  Si2168_DVBC_STATUS_RESPONSE_UNCORINT_LSB         4
+   #define  Si2168_DVBC_STATUS_RESPONSE_UNCORINT_MASK        0x01
+    #define Si2168_DVBC_STATUS_RESPONSE_UNCORINT_CHANGED    1
+    #define Si2168_DVBC_STATUS_RESPONSE_UNCORINT_NO_CHANGE  0
+   /* DVBC_STATUS command, PCL field definition (address 2, size 1, lsb 1, unsigned)*/
+   #define  Si2168_DVBC_STATUS_RESPONSE_PCL_LSB         1
+   #define  Si2168_DVBC_STATUS_RESPONSE_PCL_MASK        0x01
+    #define Si2168_DVBC_STATUS_RESPONSE_PCL_LOCKED   1
+    #define Si2168_DVBC_STATUS_RESPONSE_PCL_NO_LOCK  0
+   /* DVBC_STATUS command, DL field definition (address 2, size 1, lsb 2, unsigned)*/
+   #define  Si2168_DVBC_STATUS_RESPONSE_DL_LSB         2
+   #define  Si2168_DVBC_STATUS_RESPONSE_DL_MASK        0x01
+    #define Si2168_DVBC_STATUS_RESPONSE_DL_LOCKED   1
+    #define Si2168_DVBC_STATUS_RESPONSE_DL_NO_LOCK  0
+   /* DVBC_STATUS command, BER field definition (address 2, size 1, lsb 3, unsigned)*/
+   #define  Si2168_DVBC_STATUS_RESPONSE_BER_LSB         3
+   #define  Si2168_DVBC_STATUS_RESPONSE_BER_MASK        0x01
+    #define Si2168_DVBC_STATUS_RESPONSE_BER_BER_ABOVE  1
+    #define Si2168_DVBC_STATUS_RESPONSE_BER_BER_BELOW  0
+   /* DVBC_STATUS command, UNCOR field definition (address 2, size 1, lsb 4, unsigned)*/
+   #define  Si2168_DVBC_STATUS_RESPONSE_UNCOR_LSB         4
+   #define  Si2168_DVBC_STATUS_RESPONSE_UNCOR_MASK        0x01
+    #define Si2168_DVBC_STATUS_RESPONSE_UNCOR_NO_UNCOR_FOUND  0
+    #define Si2168_DVBC_STATUS_RESPONSE_UNCOR_UNCOR_FOUND     1
+   /* DVBC_STATUS command, CNR field definition (address 3, size 8, lsb 0, unsigned)*/
+   #define  Si2168_DVBC_STATUS_RESPONSE_CNR_LSB         0
+   #define  Si2168_DVBC_STATUS_RESPONSE_CNR_MASK        0xff
+   /* DVBC_STATUS command, AFC_FREQ field definition (address 4, size 16, lsb 0, signed)*/
+   #define  Si2168_DVBC_STATUS_RESPONSE_AFC_FREQ_LSB         0
+   #define  Si2168_DVBC_STATUS_RESPONSE_AFC_FREQ_MASK        0xffff
+   #define  Si2168_DVBC_STATUS_RESPONSE_AFC_FREQ_SHIFT       16
+   /* DVBC_STATUS command, TIMING_OFFSET field definition (address 6, size 16, lsb 0, signed)*/
+   #define  Si2168_DVBC_STATUS_RESPONSE_TIMING_OFFSET_LSB         0
+   #define  Si2168_DVBC_STATUS_RESPONSE_TIMING_OFFSET_MASK        0xffff
+   #define  Si2168_DVBC_STATUS_RESPONSE_TIMING_OFFSET_SHIFT       16
+   /* DVBC_STATUS command, CONSTELLATION field definition (address 8, size 6, lsb 0, unsigned)*/
+   #define  Si2168_DVBC_STATUS_RESPONSE_CONSTELLATION_LSB         0
+   #define  Si2168_DVBC_STATUS_RESPONSE_CONSTELLATION_MASK        0x3f
+    #define Si2168_DVBC_STATUS_RESPONSE_CONSTELLATION_QAM128  10
+    #define Si2168_DVBC_STATUS_RESPONSE_CONSTELLATION_QAM16   7
+    #define Si2168_DVBC_STATUS_RESPONSE_CONSTELLATION_QAM256  11
+    #define Si2168_DVBC_STATUS_RESPONSE_CONSTELLATION_QAM32   8
+    #define Si2168_DVBC_STATUS_RESPONSE_CONSTELLATION_QAM64   9
+   /* DVBC_STATUS command, SP_INV field definition (address 8, size 1, lsb 6, unsigned)*/
+   #define  Si2168_DVBC_STATUS_RESPONSE_SP_INV_LSB         6
+   #define  Si2168_DVBC_STATUS_RESPONSE_SP_INV_MASK        0x01
+    #define Si2168_DVBC_STATUS_RESPONSE_SP_INV_INVERTED  1
+    #define Si2168_DVBC_STATUS_RESPONSE_SP_INV_NORMAL    0
+
+#endif /* Si2168_DVBC_STATUS_CMD */
+
+
+
+/* Si2168_DVBT2_FEF command definition */
+#define   Si2168_DVBT2_FEF_CMD 0x51
+
+#ifdef    Si2168_DVBT2_FEF_CMD
+  #define Si2168_DVBT2_FEF_CMD_CODE 0x010051
+
+    typedef struct { /* Si2168_DVBT2_FEF_CMD_struct */
+     unsigned char   fef_tuner_flag;
+     unsigned char   fef_tuner_flag_inv;
+   } Si2168_DVBT2_FEF_CMD_struct;
+
+
+    typedef struct { /* Si2168_DVBT2_FEF_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   fef_type;
+      unsigned long   fef_length;
+      unsigned long   fef_repetition;
+   }  Si2168_DVBT2_FEF_CMD_REPLY_struct;
+
+   /* DVBT2_FEF command, FEF_TUNER_FLAG field definition (address 1,size 3, lsb 0, unsigned) */
+   #define  Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_LSB         0
+   #define  Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MASK        0x07
+   #define  Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MIN         0
+   #define  Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MAX         5
+    #define Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_A       2
+    #define Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_B       3
+    #define Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_C       4
+    #define Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_D       5
+    #define Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_NOT_USED   1
+    #define Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_NO_CHANGE  0
+   /* DVBT2_FEF command, FEF_TUNER_FLAG_INV field definition (address 1,size 1, lsb 3, unsigned) */
+   #define  Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_LSB         3
+   #define  Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_MASK        0x01
+   #define  Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_MIN         0
+   #define  Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_MAX         1
+    #define Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_FEF_HIGH  0
+    #define Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_FEF_LOW   1
+   /* DVBT2_FEF command, FEF_TYPE field definition (address 1, size 4, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_FEF_RESPONSE_FEF_TYPE_LSB         0
+   #define  Si2168_DVBT2_FEF_RESPONSE_FEF_TYPE_MASK        0x0f
+   /* DVBT2_FEF command, FEF_LENGTH field definition (address 4, size 32, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_FEF_RESPONSE_FEF_LENGTH_LSB         0
+   #define  Si2168_DVBT2_FEF_RESPONSE_FEF_LENGTH_MASK        0xffffffff
+   /* DVBT2_FEF command, FEF_REPETITION field definition (address 8, size 32, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_FEF_RESPONSE_FEF_REPETITION_LSB         0
+   #define  Si2168_DVBT2_FEF_RESPONSE_FEF_REPETITION_MASK        0xffffffff
+
+#endif /* Si2168_DVBT2_FEF_CMD */
+
+/* Si2168_DVBT2_PLP_INFO command definition */
+#define   Si2168_DVBT2_PLP_INFO_CMD 0x53
+
+#ifdef    Si2168_DVBT2_PLP_INFO_CMD
+  #define Si2168_DVBT2_PLP_INFO_CMD_CODE 0x010053
+
+    typedef struct { /* Si2168_DVBT2_PLP_INFO_CMD_struct */
+     unsigned char   plp_index;
+   } Si2168_DVBT2_PLP_INFO_CMD_struct;
+
+
+    typedef struct { /* Si2168_DVBT2_PLP_INFO_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   plp_id;
+      unsigned char   reserved_1_1;
+      unsigned char   in_band_b_flag;
+      unsigned char   in_band_a_flag;
+      unsigned char   static_flag;
+      unsigned char   plp_mode;
+      unsigned char   reserved_1_2;
+      unsigned char   static_padding_flag;
+      unsigned char   plp_payload_type;
+      unsigned char   plp_type;
+      unsigned char   first_frame_idx_msb;
+      unsigned char   first_rf_idx;
+      unsigned char   ff_flag;
+      unsigned char   plp_group_id_msb;
+      unsigned char   first_frame_idx_lsb;
+      unsigned char   plp_mod_msb;
+      unsigned char   plp_cod;
+      unsigned char   plp_group_id_lsb;
+      unsigned char   plp_num_blocks_max_msb;
+      unsigned char   plp_fec_type;
+      unsigned char   plp_rot;
+      unsigned char   plp_mod_lsb;
+      unsigned char   frame_interval_msb;
+      unsigned char   plp_num_blocks_max_lsb;
+      unsigned char   time_il_length_msb;
+      unsigned char   frame_interval_lsb;
+      unsigned char   time_il_type;
+      unsigned char   time_il_length_lsb;
+   }  Si2168_DVBT2_PLP_INFO_CMD_REPLY_struct;
+
+   /* DVBT2_PLP_INFO command, PLP_INDEX field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  Si2168_DVBT2_PLP_INFO_CMD_PLP_INDEX_LSB         0
+   #define  Si2168_DVBT2_PLP_INFO_CMD_PLP_INDEX_MASK        0xff
+   #define  Si2168_DVBT2_PLP_INFO_CMD_PLP_INDEX_MIN         0
+   #define  Si2168_DVBT2_PLP_INFO_CMD_PLP_INDEX_MAX         255.0
+   /* DVBT2_PLP_INFO command, PLP_ID field definition (address 1, size 8, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_ID_LSB         0
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_ID_MASK        0xff
+   /* DVBT2_PLP_INFO command, RESERVED_1_1 field definition (address 10, size 6, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_RESERVED_1_1_LSB         0
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_RESERVED_1_1_MASK        0x3f
+   /* DVBT2_PLP_INFO command, IN_BAND_B_FLAG field definition (address 10, size 1, lsb 6, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_IN_BAND_B_FLAG_LSB         6
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_IN_BAND_B_FLAG_MASK        0x01
+   /* DVBT2_PLP_INFO command, IN_BAND_A_FLAG field definition (address 10, size 1, lsb 7, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_IN_BAND_A_FLAG_LSB         7
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_IN_BAND_A_FLAG_MASK        0x01
+   /* DVBT2_PLP_INFO command, STATIC_FLAG field definition (address 11, size 1, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_STATIC_FLAG_LSB         0
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_STATIC_FLAG_MASK        0x01
+   /* DVBT2_PLP_INFO command, PLP_MODE field definition (address 11, size 2, lsb 1, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_MODE_LSB         1
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_MODE_MASK        0x03
+    #define Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_MODE_HIGH_EFFICIENCY_MODE  2
+    #define Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_MODE_NORMAL_MODE           1
+    #define Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_MODE_NOT_SPECIFIED         0
+    #define Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_MODE_RESERVED              3
+   /* DVBT2_PLP_INFO command, RESERVED_1_2 field definition (address 11, size 5, lsb 3, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_RESERVED_1_2_LSB         3
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_RESERVED_1_2_MASK        0x1f
+   /* DVBT2_PLP_INFO command, STATIC_PADDING_FLAG field definition (address 12, size 1, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_STATIC_PADDING_FLAG_LSB         0
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_STATIC_PADDING_FLAG_MASK        0x01
+   /* DVBT2_PLP_INFO command, PLP_PAYLOAD_TYPE field definition (address 2, size 5, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_PAYLOAD_TYPE_LSB         0
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_PAYLOAD_TYPE_MASK        0x1f
+    #define Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_PAYLOAD_TYPE_GCS   1
+    #define Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_PAYLOAD_TYPE_GFPS  0
+    #define Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_PAYLOAD_TYPE_GSE   2
+    #define Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_PAYLOAD_TYPE_TS    3
+   /* DVBT2_PLP_INFO command, PLP_TYPE field definition (address 2, size 3, lsb 5, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_TYPE_LSB         5
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_TYPE_MASK        0x07
+    #define Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_TYPE_COMMON      0
+    #define Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_TYPE_DATA_TYPE1  1
+    #define Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_TYPE_DATA_TYPE2  2
+   /* DVBT2_PLP_INFO command, FIRST_FRAME_IDX_MSB field definition (address 3, size 4, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_FIRST_FRAME_IDX_MSB_LSB         0
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_FIRST_FRAME_IDX_MSB_MASK        0x0f
+   /* DVBT2_PLP_INFO command, FIRST_RF_IDX field definition (address 3, size 3, lsb 4, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_FIRST_RF_IDX_LSB         4
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_FIRST_RF_IDX_MASK        0x07
+   /* DVBT2_PLP_INFO command, FF_FLAG field definition (address 3, size 1, lsb 7, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_FF_FLAG_LSB         7
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_FF_FLAG_MASK        0x01
+   /* DVBT2_PLP_INFO command, PLP_GROUP_ID_MSB field definition (address 4, size 4, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_GROUP_ID_MSB_LSB         0
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_GROUP_ID_MSB_MASK        0x0f
+   /* DVBT2_PLP_INFO command, FIRST_FRAME_IDX_LSB field definition (address 4, size 4, lsb 4, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_FIRST_FRAME_IDX_LSB_LSB         4
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_FIRST_FRAME_IDX_LSB_MASK        0x0f
+   /* DVBT2_PLP_INFO command, PLP_MOD_MSB field definition (address 5, size 1, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_MOD_MSB_LSB         0
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_MOD_MSB_MASK        0x01
+   /* DVBT2_PLP_INFO command, PLP_COD field definition (address 5, size 3, lsb 1, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_COD_LSB         1
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_COD_MASK        0x07
+    #define Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_COD_1_2  0
+    #define Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_COD_2_3  2
+    #define Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_COD_3_4  3
+    #define Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_COD_3_5  1
+    #define Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_COD_4_5  4
+    #define Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_COD_5_6  5
+   /* DVBT2_PLP_INFO command, PLP_GROUP_ID_LSB field definition (address 5, size 4, lsb 4, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_GROUP_ID_LSB_LSB         4
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_GROUP_ID_LSB_MASK        0x0f
+   /* DVBT2_PLP_INFO command, PLP_NUM_BLOCKS_MAX_MSB field definition (address 6, size 3, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_NUM_BLOCKS_MAX_MSB_LSB         0
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_NUM_BLOCKS_MAX_MSB_MASK        0x07
+   /* DVBT2_PLP_INFO command, PLP_FEC_TYPE field definition (address 6, size 2, lsb 3, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_FEC_TYPE_LSB         3
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_FEC_TYPE_MASK        0x03
+    #define Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_FEC_TYPE_16K_LDPC  0
+    #define Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_FEC_TYPE_64K_LDPC  1
+   /* DVBT2_PLP_INFO command, PLP_ROT field definition (address 6, size 1, lsb 5, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_ROT_LSB         5
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_ROT_MASK        0x01
+    #define Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_ROT_NOT_ROTATED  0
+    #define Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_ROT_ROTATED      1
+   /* DVBT2_PLP_INFO command, PLP_MOD_LSB field definition (address 6, size 2, lsb 6, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_MOD_LSB_LSB         6
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_MOD_LSB_MASK        0x03
+   /* DVBT2_PLP_INFO command, FRAME_INTERVAL_MSB field definition (address 7, size 1, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_FRAME_INTERVAL_MSB_LSB         0
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_FRAME_INTERVAL_MSB_MASK        0x01
+   /* DVBT2_PLP_INFO command, PLP_NUM_BLOCKS_MAX_LSB field definition (address 7, size 7, lsb 1, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_NUM_BLOCKS_MAX_LSB_LSB         1
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_NUM_BLOCKS_MAX_LSB_MASK        0x7f
+   /* DVBT2_PLP_INFO command, TIME_IL_LENGTH_MSB field definition (address 8, size 1, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_TIME_IL_LENGTH_MSB_LSB         0
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_TIME_IL_LENGTH_MSB_MASK        0x01
+   /* DVBT2_PLP_INFO command, FRAME_INTERVAL_LSB field definition (address 8, size 7, lsb 1, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_FRAME_INTERVAL_LSB_LSB         1
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_FRAME_INTERVAL_LSB_MASK        0x7f
+   /* DVBT2_PLP_INFO command, TIME_IL_TYPE field definition (address 9, size 1, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_TIME_IL_TYPE_LSB         0
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_TIME_IL_TYPE_MASK        0x01
+   /* DVBT2_PLP_INFO command, TIME_IL_LENGTH_LSB field definition (address 9, size 7, lsb 1, unsigned)*/
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_TIME_IL_LENGTH_LSB_LSB         1
+   #define  Si2168_DVBT2_PLP_INFO_RESPONSE_TIME_IL_LENGTH_LSB_MASK        0x7f
+
+#endif /* Si2168_DVBT2_PLP_INFO_CMD */
+
+/* Si2168_DVBT2_PLP_SELECT command definition */
+#define   Si2168_DVBT2_PLP_SELECT_CMD 0x52
+
+#ifdef    Si2168_DVBT2_PLP_SELECT_CMD
+  #define Si2168_DVBT2_PLP_SELECT_CMD_CODE 0x010052
+
+    typedef struct { /* Si2168_DVBT2_PLP_SELECT_CMD_struct */
+     unsigned char   plp_id;
+     unsigned char   plp_id_sel_mode;
+   } Si2168_DVBT2_PLP_SELECT_CMD_struct;
+
+
+    typedef struct { /* Si2168_DVBT2_PLP_SELECT_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+   }  Si2168_DVBT2_PLP_SELECT_CMD_REPLY_struct;
+
+   /* DVBT2_PLP_SELECT command, PLP_ID field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_LSB         0
+   #define  Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_MASK        0xff
+   #define  Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_MIN         0
+   #define  Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_MAX         255.0
+   /* DVBT2_PLP_SELECT command, PLP_ID_SEL_MODE field definition (address 2,size 1, lsb 0, unsigned) */
+   #define  Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_LSB         0
+   #define  Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_MASK        0x01
+   #define  Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_MIN         0
+   #define  Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_MAX         1
+    #define Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_AUTO    0
+    #define Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_MANUAL  1
+#endif /* Si2168_DVBT2_PLP_SELECT_CMD */
+
+/* Si2168_DVBT2_STATUS command definition */
+#define   Si2168_DVBT2_STATUS_CMD 0x50
+
+#ifdef    Si2168_DVBT2_STATUS_CMD
+  #define Si2168_DVBT2_STATUS_CMD_CODE 0x010050
+
+    typedef struct { /* Si2168_DVBT2_STATUS_CMD_struct */
+     unsigned char   intack;
+   } Si2168_DVBT2_STATUS_CMD_struct;
+
+
+    typedef struct { /* Si2168_DVBT2_STATUS_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   pclint;
+      unsigned char   dlint;
+      unsigned char   berint;
+      unsigned char   uncorint;
+      unsigned char   notdvbt2int;
+      unsigned char   num_plp;
+      unsigned char   pilot_pattern;
+      unsigned char   tx_mode;
+      unsigned char   rotated;
+      unsigned char   short_frame;
+      unsigned char   code_rate;
+      unsigned char   plp_id;
+      unsigned char   pcl;
+      unsigned char   dl;
+      unsigned char   ber;
+      unsigned char   uncor;
+      unsigned char   notdvbt2;
+      unsigned char   cnr;
+               int    afc_freq;
+               int    timing_offset;
+      unsigned char   constellation;
+      unsigned char   sp_inv;
+      unsigned char   fef;
+      unsigned char   fft_mode;
+      unsigned char   guard_int;
+      unsigned char   bw_ext;
+   }  Si2168_DVBT2_STATUS_CMD_REPLY_struct;
+
+   /* DVBT2_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2168_DVBT2_STATUS_CMD_INTACK_LSB         0
+   #define  Si2168_DVBT2_STATUS_CMD_INTACK_MASK        0x01
+   #define  Si2168_DVBT2_STATUS_CMD_INTACK_MIN         0
+   #define  Si2168_DVBT2_STATUS_CMD_INTACK_MAX         1
+    #define Si2168_DVBT2_STATUS_CMD_INTACK_CLEAR  1
+    #define Si2168_DVBT2_STATUS_CMD_INTACK_OK     0
+   /* DVBT2_STATUS command, PCLINT field definition (address 1, size 1, lsb 1, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_PCLINT_LSB         1
+   #define  Si2168_DVBT2_STATUS_RESPONSE_PCLINT_MASK        0x01
+    #define Si2168_DVBT2_STATUS_RESPONSE_PCLINT_CHANGED    1
+    #define Si2168_DVBT2_STATUS_RESPONSE_PCLINT_NO_CHANGE  0
+   /* DVBT2_STATUS command, DLINT field definition (address 1, size 1, lsb 2, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_DLINT_LSB         2
+   #define  Si2168_DVBT2_STATUS_RESPONSE_DLINT_MASK        0x01
+    #define Si2168_DVBT2_STATUS_RESPONSE_DLINT_CHANGED    1
+    #define Si2168_DVBT2_STATUS_RESPONSE_DLINT_NO_CHANGE  0
+   /* DVBT2_STATUS command, BERINT field definition (address 1, size 1, lsb 3, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_BERINT_LSB         3
+   #define  Si2168_DVBT2_STATUS_RESPONSE_BERINT_MASK        0x01
+    #define Si2168_DVBT2_STATUS_RESPONSE_BERINT_CHANGED    1
+    #define Si2168_DVBT2_STATUS_RESPONSE_BERINT_NO_CHANGE  0
+   /* DVBT2_STATUS command, UNCORINT field definition (address 1, size 1, lsb 4, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_UNCORINT_LSB         4
+   #define  Si2168_DVBT2_STATUS_RESPONSE_UNCORINT_MASK        0x01
+    #define Si2168_DVBT2_STATUS_RESPONSE_UNCORINT_CHANGED    1
+    #define Si2168_DVBT2_STATUS_RESPONSE_UNCORINT_NO_CHANGE  0
+   /* DVBT2_STATUS command, NOTDVBT2INT field definition (address 1, size 1, lsb 5, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2INT_LSB         5
+   #define  Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2INT_MASK        0x01
+    #define Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2INT_CHANGED    1
+    #define Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2INT_NO_CHANGE  0
+   /* DVBT2_STATUS command, NUM_PLP field definition (address 10, size 8, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_NUM_PLP_LSB         0
+   #define  Si2168_DVBT2_STATUS_RESPONSE_NUM_PLP_MASK        0xff
+   /* DVBT2_STATUS command, PILOT_PATTERN field definition (address 11, size 4, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_LSB         0
+   #define  Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_MASK        0x0f
+    #define Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP1  0
+    #define Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP2  1
+    #define Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP3  2
+    #define Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP4  3
+    #define Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP5  4
+    #define Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP6  5
+    #define Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP7  6
+    #define Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP8  7
+   /* DVBT2_STATUS command, TX_MODE field definition (address 11, size 1, lsb 4, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_TX_MODE_LSB         4
+   #define  Si2168_DVBT2_STATUS_RESPONSE_TX_MODE_MASK        0x01
+    #define Si2168_DVBT2_STATUS_RESPONSE_TX_MODE_MISO  1
+    #define Si2168_DVBT2_STATUS_RESPONSE_TX_MODE_SISO  0
+   /* DVBT2_STATUS command, ROTATED field definition (address 11, size 1, lsb 5, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_ROTATED_LSB         5
+   #define  Si2168_DVBT2_STATUS_RESPONSE_ROTATED_MASK        0x01
+    #define Si2168_DVBT2_STATUS_RESPONSE_ROTATED_NORMAL   0
+    #define Si2168_DVBT2_STATUS_RESPONSE_ROTATED_ROTATED  1
+   /* DVBT2_STATUS command, SHORT_FRAME field definition (address 11, size 1, lsb 6, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_SHORT_FRAME_LSB         6
+   #define  Si2168_DVBT2_STATUS_RESPONSE_SHORT_FRAME_MASK        0x01
+    #define Si2168_DVBT2_STATUS_RESPONSE_SHORT_FRAME_16K_LDPC  0
+    #define Si2168_DVBT2_STATUS_RESPONSE_SHORT_FRAME_64K_LDPC  1
+   /* DVBT2_STATUS command, CODE_RATE field definition (address 12, size 4, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_LSB         0
+   #define  Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_MASK        0x0f
+    #define Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_1_2  1
+    #define Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_2_3  2
+    #define Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_3_4  3
+    #define Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_3_5  13
+    #define Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_4_5  4
+    #define Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_5_6  5
+   /* DVBT2_STATUS command, PLP_ID field definition (address 13, size 8, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_PLP_ID_LSB         0
+   #define  Si2168_DVBT2_STATUS_RESPONSE_PLP_ID_MASK        0xff
+   /* DVBT2_STATUS command, PCL field definition (address 2, size 1, lsb 1, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_PCL_LSB         1
+   #define  Si2168_DVBT2_STATUS_RESPONSE_PCL_MASK        0x01
+    #define Si2168_DVBT2_STATUS_RESPONSE_PCL_LOCKED   1
+    #define Si2168_DVBT2_STATUS_RESPONSE_PCL_NO_LOCK  0
+   /* DVBT2_STATUS command, DL field definition (address 2, size 1, lsb 2, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_DL_LSB         2
+   #define  Si2168_DVBT2_STATUS_RESPONSE_DL_MASK        0x01
+    #define Si2168_DVBT2_STATUS_RESPONSE_DL_LOCKED   1
+    #define Si2168_DVBT2_STATUS_RESPONSE_DL_NO_LOCK  0
+   /* DVBT2_STATUS command, BER field definition (address 2, size 1, lsb 3, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_BER_LSB         3
+   #define  Si2168_DVBT2_STATUS_RESPONSE_BER_MASK        0x01
+    #define Si2168_DVBT2_STATUS_RESPONSE_BER_BER_ABOVE  1
+    #define Si2168_DVBT2_STATUS_RESPONSE_BER_BER_BELOW  0
+   /* DVBT2_STATUS command, UNCOR field definition (address 2, size 1, lsb 4, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_UNCOR_LSB         4
+   #define  Si2168_DVBT2_STATUS_RESPONSE_UNCOR_MASK        0x01
+    #define Si2168_DVBT2_STATUS_RESPONSE_UNCOR_NO_UNCOR_FOUND  0
+    #define Si2168_DVBT2_STATUS_RESPONSE_UNCOR_UNCOR_FOUND     1
+   /* DVBT2_STATUS command, NOTDVBT2 field definition (address 2, size 1, lsb 5, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2_LSB         5
+   #define  Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2_MASK        0x01
+    #define Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2_DVBT2      0
+    #define Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2_NOT_DVBT2  1
+   /* DVBT2_STATUS command, CNR field definition (address 3, size 8, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_CNR_LSB         0
+   #define  Si2168_DVBT2_STATUS_RESPONSE_CNR_MASK        0xff
+   /* DVBT2_STATUS command, AFC_FREQ field definition (address 4, size 16, lsb 0, signed)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_AFC_FREQ_LSB         0
+   #define  Si2168_DVBT2_STATUS_RESPONSE_AFC_FREQ_MASK        0xffff
+   #define  Si2168_DVBT2_STATUS_RESPONSE_AFC_FREQ_SHIFT       16
+   /* DVBT2_STATUS command, TIMING_OFFSET field definition (address 6, size 16, lsb 0, signed)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_TIMING_OFFSET_LSB         0
+   #define  Si2168_DVBT2_STATUS_RESPONSE_TIMING_OFFSET_MASK        0xffff
+   #define  Si2168_DVBT2_STATUS_RESPONSE_TIMING_OFFSET_SHIFT       16
+   /* DVBT2_STATUS command, CONSTELLATION field definition (address 8, size 6, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_CONSTELLATION_LSB         0
+   #define  Si2168_DVBT2_STATUS_RESPONSE_CONSTELLATION_MASK        0x3f
+    #define Si2168_DVBT2_STATUS_RESPONSE_CONSTELLATION_QAM128  10
+    #define Si2168_DVBT2_STATUS_RESPONSE_CONSTELLATION_QAM16   7
+    #define Si2168_DVBT2_STATUS_RESPONSE_CONSTELLATION_QAM256  11
+    #define Si2168_DVBT2_STATUS_RESPONSE_CONSTELLATION_QAM32   8
+    #define Si2168_DVBT2_STATUS_RESPONSE_CONSTELLATION_QAM64   9
+    #define Si2168_DVBT2_STATUS_RESPONSE_CONSTELLATION_QPSK    3
+   /* DVBT2_STATUS command, SP_INV field definition (address 8, size 1, lsb 6, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_SP_INV_LSB         6
+   #define  Si2168_DVBT2_STATUS_RESPONSE_SP_INV_MASK        0x01
+    #define Si2168_DVBT2_STATUS_RESPONSE_SP_INV_INVERTED  1
+    #define Si2168_DVBT2_STATUS_RESPONSE_SP_INV_NORMAL    0
+   /* DVBT2_STATUS command, FEF field definition (address 8, size 1, lsb 7, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_FEF_LSB         7
+   #define  Si2168_DVBT2_STATUS_RESPONSE_FEF_MASK        0x01
+    #define Si2168_DVBT2_STATUS_RESPONSE_FEF_FEF     1
+    #define Si2168_DVBT2_STATUS_RESPONSE_FEF_NO_FEF  0
+   /* DVBT2_STATUS command, FFT_MODE field definition (address 9, size 4, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_LSB         0
+   #define  Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_MASK        0x0f
+    #define Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_16K  14
+    #define Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_1K   10
+    #define Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_2K   11
+    #define Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_32K  15
+    #define Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_4K   12
+    #define Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_8K   13
+   /* DVBT2_STATUS command, GUARD_INT field definition (address 9, size 3, lsb 4, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_LSB         4
+   #define  Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_MASK        0x07
+    #define Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_19_128  6
+    #define Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_19_256  7
+    #define Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_1_128   5
+    #define Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_1_16    2
+    #define Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_1_32    1
+    #define Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_1_4     4
+    #define Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_1_8     3
+   /* DVBT2_STATUS command, BW_EXT field definition (address 9, size 1, lsb 7, unsigned)*/
+   #define  Si2168_DVBT2_STATUS_RESPONSE_BW_EXT_LSB         7
+   #define  Si2168_DVBT2_STATUS_RESPONSE_BW_EXT_MASK        0x01
+    #define Si2168_DVBT2_STATUS_RESPONSE_BW_EXT_EXTENDED  1
+    #define Si2168_DVBT2_STATUS_RESPONSE_BW_EXT_NORMAL    0
+
+#endif /* Si2168_DVBT2_STATUS_CMD */
+
+/* Si2168_DVBT2_TX_ID command definition */
+#define   Si2168_DVBT2_TX_ID_CMD 0x54
+
+#ifdef    Si2168_DVBT2_TX_ID_CMD
+  #define Si2168_DVBT2_TX_ID_CMD_CODE 0x010054
+
+    typedef struct { /* Si2168_DVBT2_TX_ID_CMD_struct */
+         unsigned char   nothing;   } Si2168_DVBT2_TX_ID_CMD_struct;
+
+
+    typedef struct { /* Si2168_DVBT2_TX_ID_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   tx_id_availability;
+      unsigned int    cell_id;
+      unsigned int    network_id;
+      unsigned int    t2_system_id;
+   }  Si2168_DVBT2_TX_ID_CMD_REPLY_struct;
+
+   /* DVBT2_TX_ID command, TX_ID_AVAILABILITY field definition (address 1, size 8, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_TX_ID_RESPONSE_TX_ID_AVAILABILITY_LSB         0
+   #define  Si2168_DVBT2_TX_ID_RESPONSE_TX_ID_AVAILABILITY_MASK        0xff
+   /* DVBT2_TX_ID command, CELL_ID field definition (address 2, size 16, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_TX_ID_RESPONSE_CELL_ID_LSB         0
+   #define  Si2168_DVBT2_TX_ID_RESPONSE_CELL_ID_MASK        0xffff
+   /* DVBT2_TX_ID command, NETWORK_ID field definition (address 4, size 16, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_TX_ID_RESPONSE_NETWORK_ID_LSB         0
+   #define  Si2168_DVBT2_TX_ID_RESPONSE_NETWORK_ID_MASK        0xffff
+   /* DVBT2_TX_ID command, T2_SYSTEM_ID field definition (address 6, size 16, lsb 0, unsigned)*/
+   #define  Si2168_DVBT2_TX_ID_RESPONSE_T2_SYSTEM_ID_LSB         0
+   #define  Si2168_DVBT2_TX_ID_RESPONSE_T2_SYSTEM_ID_MASK        0xffff
+
+#endif /* Si2168_DVBT2_TX_ID_CMD */
+
+
+/* Si2168_DVBT_STATUS command definition */
+#define   Si2168_DVBT_STATUS_CMD 0xa0
+
+#ifdef    Si2168_DVBT_STATUS_CMD
+  #define Si2168_DVBT_STATUS_CMD_CODE 0x0100a0
+
+    typedef struct { /* Si2168_DVBT_STATUS_CMD_struct */
+     unsigned char   intack;
+   } Si2168_DVBT_STATUS_CMD_struct;
+
+
+    typedef struct { /* Si2168_DVBT_STATUS_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   pclint;
+      unsigned char   dlint;
+      unsigned char   berint;
+      unsigned char   uncorint;
+      unsigned char   notdvbtint;
+      unsigned char   fft_mode;
+      unsigned char   guard_int;
+      unsigned char   hierarchy;
+               char   tps_length;
+      unsigned char   pcl;
+      unsigned char   dl;
+      unsigned char   ber;
+      unsigned char   uncor;
+      unsigned char   notdvbt;
+      unsigned char   cnr;
+               int    afc_freq;
+               int    timing_offset;
+      unsigned char   constellation;
+      unsigned char   sp_inv;
+      unsigned char   rate_hp;
+      unsigned char   rate_lp;
+   }  Si2168_DVBT_STATUS_CMD_REPLY_struct;
+
+   /* DVBT_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2168_DVBT_STATUS_CMD_INTACK_LSB         0
+   #define  Si2168_DVBT_STATUS_CMD_INTACK_MASK        0x01
+   #define  Si2168_DVBT_STATUS_CMD_INTACK_MIN         0
+   #define  Si2168_DVBT_STATUS_CMD_INTACK_MAX         1
+    #define Si2168_DVBT_STATUS_CMD_INTACK_CLEAR  1
+    #define Si2168_DVBT_STATUS_CMD_INTACK_OK     0
+   /* DVBT_STATUS command, PCLINT field definition (address 1, size 1, lsb 1, unsigned)*/
+   #define  Si2168_DVBT_STATUS_RESPONSE_PCLINT_LSB         1
+   #define  Si2168_DVBT_STATUS_RESPONSE_PCLINT_MASK        0x01
+    #define Si2168_DVBT_STATUS_RESPONSE_PCLINT_CHANGED    1
+    #define Si2168_DVBT_STATUS_RESPONSE_PCLINT_NO_CHANGE  0
+   /* DVBT_STATUS command, DLINT field definition (address 1, size 1, lsb 2, unsigned)*/
+   #define  Si2168_DVBT_STATUS_RESPONSE_DLINT_LSB         2
+   #define  Si2168_DVBT_STATUS_RESPONSE_DLINT_MASK        0x01
+    #define Si2168_DVBT_STATUS_RESPONSE_DLINT_CHANGED    1
+    #define Si2168_DVBT_STATUS_RESPONSE_DLINT_NO_CHANGE  0
+   /* DVBT_STATUS command, BERINT field definition (address 1, size 1, lsb 3, unsigned)*/
+   #define  Si2168_DVBT_STATUS_RESPONSE_BERINT_LSB         3
+   #define  Si2168_DVBT_STATUS_RESPONSE_BERINT_MASK        0x01
+    #define Si2168_DVBT_STATUS_RESPONSE_BERINT_CHANGED    1
+    #define Si2168_DVBT_STATUS_RESPONSE_BERINT_NO_CHANGE  0
+   /* DVBT_STATUS command, UNCORINT field definition (address 1, size 1, lsb 4, unsigned)*/
+   #define  Si2168_DVBT_STATUS_RESPONSE_UNCORINT_LSB         4
+   #define  Si2168_DVBT_STATUS_RESPONSE_UNCORINT_MASK        0x01
+    #define Si2168_DVBT_STATUS_RESPONSE_UNCORINT_CHANGED    1
+    #define Si2168_DVBT_STATUS_RESPONSE_UNCORINT_NO_CHANGE  0
+   /* DVBT_STATUS command, NOTDVBTINT field definition (address 1, size 1, lsb 5, unsigned)*/
+   #define  Si2168_DVBT_STATUS_RESPONSE_NOTDVBTINT_LSB         5
+   #define  Si2168_DVBT_STATUS_RESPONSE_NOTDVBTINT_MASK        0x01
+    #define Si2168_DVBT_STATUS_RESPONSE_NOTDVBTINT_CHANGED    1
+    #define Si2168_DVBT_STATUS_RESPONSE_NOTDVBTINT_NO_CHANGE  0
+   /* DVBT_STATUS command, FFT_MODE field definition (address 10, size 4, lsb 0, unsigned)*/
+   #define  Si2168_DVBT_STATUS_RESPONSE_FFT_MODE_LSB         0
+   #define  Si2168_DVBT_STATUS_RESPONSE_FFT_MODE_MASK        0x0f
+    #define Si2168_DVBT_STATUS_RESPONSE_FFT_MODE_2K  11
+    #define Si2168_DVBT_STATUS_RESPONSE_FFT_MODE_4K  12
+    #define Si2168_DVBT_STATUS_RESPONSE_FFT_MODE_8K  13
+   /* DVBT_STATUS command, GUARD_INT field definition (address 10, size 3, lsb 4, unsigned)*/
+   #define  Si2168_DVBT_STATUS_RESPONSE_GUARD_INT_LSB         4
+   #define  Si2168_DVBT_STATUS_RESPONSE_GUARD_INT_MASK        0x07
+    #define Si2168_DVBT_STATUS_RESPONSE_GUARD_INT_1_16  2
+    #define Si2168_DVBT_STATUS_RESPONSE_GUARD_INT_1_32  1
+    #define Si2168_DVBT_STATUS_RESPONSE_GUARD_INT_1_4   4
+    #define Si2168_DVBT_STATUS_RESPONSE_GUARD_INT_1_8   3
+   /* DVBT_STATUS command, HIERARCHY field definition (address 11, size 3, lsb 0, unsigned)*/
+   #define  Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_LSB         0
+   #define  Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_MASK        0x07
+    #define Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_ALFA1  2
+    #define Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_ALFA2  3
+    #define Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_ALFA4  5
+    #define Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_NONE   1
+   /* DVBT_STATUS command, TPS_LENGTH field definition (address 12, size 7, lsb 0, signed)*/
+   #define  Si2168_DVBT_STATUS_RESPONSE_TPS_LENGTH_LSB         0
+   #define  Si2168_DVBT_STATUS_RESPONSE_TPS_LENGTH_MASK        0x7f
+   #define  Si2168_DVBT_STATUS_RESPONSE_TPS_LENGTH_SHIFT       25
+   /* DVBT_STATUS command, PCL field definition (address 2, size 1, lsb 1, unsigned)*/
+   #define  Si2168_DVBT_STATUS_RESPONSE_PCL_LSB         1
+   #define  Si2168_DVBT_STATUS_RESPONSE_PCL_MASK        0x01
+    #define Si2168_DVBT_STATUS_RESPONSE_PCL_LOCKED   1
+    #define Si2168_DVBT_STATUS_RESPONSE_PCL_NO_LOCK  0
+   /* DVBT_STATUS command, DL field definition (address 2, size 1, lsb 2, unsigned)*/
+   #define  Si2168_DVBT_STATUS_RESPONSE_DL_LSB         2
+   #define  Si2168_DVBT_STATUS_RESPONSE_DL_MASK        0x01
+    #define Si2168_DVBT_STATUS_RESPONSE_DL_LOCKED   1
+    #define Si2168_DVBT_STATUS_RESPONSE_DL_NO_LOCK  0
+   /* DVBT_STATUS command, BER field definition (address 2, size 1, lsb 3, unsigned)*/
+   #define  Si2168_DVBT_STATUS_RESPONSE_BER_LSB         3
+   #define  Si2168_DVBT_STATUS_RESPONSE_BER_MASK        0x01
+    #define Si2168_DVBT_STATUS_RESPONSE_BER_BER_ABOVE  1
+    #define Si2168_DVBT_STATUS_RESPONSE_BER_BER_BELOW  0
+   /* DVBT_STATUS command, UNCOR field definition (address 2, size 1, lsb 4, unsigned)*/
+   #define  Si2168_DVBT_STATUS_RESPONSE_UNCOR_LSB         4
+   #define  Si2168_DVBT_STATUS_RESPONSE_UNCOR_MASK        0x01
+    #define Si2168_DVBT_STATUS_RESPONSE_UNCOR_NO_UNCOR_FOUND  0
+    #define Si2168_DVBT_STATUS_RESPONSE_UNCOR_UNCOR_FOUND     1
+   /* DVBT_STATUS command, NOTDVBT field definition (address 2, size 1, lsb 5, unsigned)*/
+   #define  Si2168_DVBT_STATUS_RESPONSE_NOTDVBT_LSB         5
+   #define  Si2168_DVBT_STATUS_RESPONSE_NOTDVBT_MASK        0x01
+    #define Si2168_DVBT_STATUS_RESPONSE_NOTDVBT_DVBT      0
+    #define Si2168_DVBT_STATUS_RESPONSE_NOTDVBT_NOT_DVBT  1
+   /* DVBT_STATUS command, CNR field definition (address 3, size 8, lsb 0, unsigned)*/
+   #define  Si2168_DVBT_STATUS_RESPONSE_CNR_LSB         0
+   #define  Si2168_DVBT_STATUS_RESPONSE_CNR_MASK        0xff
+   /* DVBT_STATUS command, AFC_FREQ field definition (address 4, size 16, lsb 0, signed)*/
+   #define  Si2168_DVBT_STATUS_RESPONSE_AFC_FREQ_LSB         0
+   #define  Si2168_DVBT_STATUS_RESPONSE_AFC_FREQ_MASK        0xffff
+   #define  Si2168_DVBT_STATUS_RESPONSE_AFC_FREQ_SHIFT       16
+   /* DVBT_STATUS command, TIMING_OFFSET field definition (address 6, size 16, lsb 0, signed)*/
+   #define  Si2168_DVBT_STATUS_RESPONSE_TIMING_OFFSET_LSB         0
+   #define  Si2168_DVBT_STATUS_RESPONSE_TIMING_OFFSET_MASK        0xffff
+   #define  Si2168_DVBT_STATUS_RESPONSE_TIMING_OFFSET_SHIFT       16
+   /* DVBT_STATUS command, CONSTELLATION field definition (address 8, size 6, lsb 0, unsigned)*/
+   #define  Si2168_DVBT_STATUS_RESPONSE_CONSTELLATION_LSB         0
+   #define  Si2168_DVBT_STATUS_RESPONSE_CONSTELLATION_MASK        0x3f
+    #define Si2168_DVBT_STATUS_RESPONSE_CONSTELLATION_QAM16  7
+    #define Si2168_DVBT_STATUS_RESPONSE_CONSTELLATION_QAM64  9
+    #define Si2168_DVBT_STATUS_RESPONSE_CONSTELLATION_QPSK   3
+   /* DVBT_STATUS command, SP_INV field definition (address 8, size 1, lsb 6, unsigned)*/
+   #define  Si2168_DVBT_STATUS_RESPONSE_SP_INV_LSB         6
+   #define  Si2168_DVBT_STATUS_RESPONSE_SP_INV_MASK        0x01
+    #define Si2168_DVBT_STATUS_RESPONSE_SP_INV_INVERTED  1
+    #define Si2168_DVBT_STATUS_RESPONSE_SP_INV_NORMAL    0
+   /* DVBT_STATUS command, RATE_HP field definition (address 9, size 4, lsb 0, unsigned)*/
+   #define  Si2168_DVBT_STATUS_RESPONSE_RATE_HP_LSB         0
+   #define  Si2168_DVBT_STATUS_RESPONSE_RATE_HP_MASK        0x0f
+    #define Si2168_DVBT_STATUS_RESPONSE_RATE_HP_1_2  1
+    #define Si2168_DVBT_STATUS_RESPONSE_RATE_HP_2_3  2
+    #define Si2168_DVBT_STATUS_RESPONSE_RATE_HP_3_4  3
+    #define Si2168_DVBT_STATUS_RESPONSE_RATE_HP_5_6  5
+    #define Si2168_DVBT_STATUS_RESPONSE_RATE_HP_7_8  7
+   /* DVBT_STATUS command, RATE_LP field definition (address 9, size 4, lsb 4, unsigned)*/
+   #define  Si2168_DVBT_STATUS_RESPONSE_RATE_LP_LSB         4
+   #define  Si2168_DVBT_STATUS_RESPONSE_RATE_LP_MASK        0x0f
+    #define Si2168_DVBT_STATUS_RESPONSE_RATE_LP_1_2  1
+    #define Si2168_DVBT_STATUS_RESPONSE_RATE_LP_2_3  2
+    #define Si2168_DVBT_STATUS_RESPONSE_RATE_LP_3_4  3
+    #define Si2168_DVBT_STATUS_RESPONSE_RATE_LP_5_6  5
+    #define Si2168_DVBT_STATUS_RESPONSE_RATE_LP_7_8  7
+
+#endif /* Si2168_DVBT_STATUS_CMD */
+
+/* Si2168_DVBT_TPS_EXTRA command definition */
+#define   Si2168_DVBT_TPS_EXTRA_CMD 0xa1
+
+#ifdef    Si2168_DVBT_TPS_EXTRA_CMD
+  #define Si2168_DVBT_TPS_EXTRA_CMD_CODE 0x0100a1
+
+    typedef struct { /* Si2168_DVBT_TPS_EXTRA_CMD_struct */
+         unsigned char   nothing;   } Si2168_DVBT_TPS_EXTRA_CMD_struct;
+
+
+    typedef struct { /* Si2168_DVBT_TPS_EXTRA_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   lptimeslice;
+      unsigned char   hptimeslice;
+      unsigned char   lpmpefec;
+      unsigned char   hpmpefec;
+      unsigned char   dvbhinter;
+               int    cell_id;
+      unsigned char   tps_res1;
+      unsigned char   tps_res2;
+      unsigned char   tps_res3;
+      unsigned char   tps_res4;
+   }  Si2168_DVBT_TPS_EXTRA_CMD_REPLY_struct;
+
+   /* DVBT_TPS_EXTRA command, LPTIMESLICE field definition (address 1, size 1, lsb 0, unsigned)*/
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_LPTIMESLICE_LSB         0
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_LPTIMESLICE_MASK        0x01
+    #define Si2168_DVBT_TPS_EXTRA_RESPONSE_LPTIMESLICE_OFF  0
+    #define Si2168_DVBT_TPS_EXTRA_RESPONSE_LPTIMESLICE_ON   1
+   /* DVBT_TPS_EXTRA command, HPTIMESLICE field definition (address 1, size 1, lsb 1, unsigned)*/
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_HPTIMESLICE_LSB         1
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_HPTIMESLICE_MASK        0x01
+    #define Si2168_DVBT_TPS_EXTRA_RESPONSE_HPTIMESLICE_OFF  0
+    #define Si2168_DVBT_TPS_EXTRA_RESPONSE_HPTIMESLICE_ON   1
+   /* DVBT_TPS_EXTRA command, LPMPEFEC field definition (address 1, size 1, lsb 2, unsigned)*/
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_LPMPEFEC_LSB         2
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_LPMPEFEC_MASK        0x01
+    #define Si2168_DVBT_TPS_EXTRA_RESPONSE_LPMPEFEC_OFF  0
+    #define Si2168_DVBT_TPS_EXTRA_RESPONSE_LPMPEFEC_ON   1
+   /* DVBT_TPS_EXTRA command, HPMPEFEC field definition (address 1, size 1, lsb 3, unsigned)*/
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_HPMPEFEC_LSB         3
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_HPMPEFEC_MASK        0x01
+    #define Si2168_DVBT_TPS_EXTRA_RESPONSE_HPMPEFEC_OFF  0
+    #define Si2168_DVBT_TPS_EXTRA_RESPONSE_HPMPEFEC_ON   1
+   /* DVBT_TPS_EXTRA command, DVBHINTER field definition (address 1, size 1, lsb 4, unsigned)*/
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_DVBHINTER_LSB         4
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_DVBHINTER_MASK        0x01
+    #define Si2168_DVBT_TPS_EXTRA_RESPONSE_DVBHINTER_IN_DEPTH  1
+    #define Si2168_DVBT_TPS_EXTRA_RESPONSE_DVBHINTER_NATIVE    0
+   /* DVBT_TPS_EXTRA command, CELL_ID field definition (address 2, size 16, lsb 0, signed)*/
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_CELL_ID_LSB         0
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_CELL_ID_MASK        0xffff
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_CELL_ID_SHIFT       16
+   /* DVBT_TPS_EXTRA command, TPS_RES1 field definition (address 4, size 4, lsb 0, unsigned)*/
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES1_LSB         0
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES1_MASK        0x0f
+   /* DVBT_TPS_EXTRA command, TPS_RES2 field definition (address 4, size 4, lsb 4, unsigned)*/
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES2_LSB         4
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES2_MASK        0x0f
+   /* DVBT_TPS_EXTRA command, TPS_RES3 field definition (address 5, size 4, lsb 0, unsigned)*/
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES3_LSB         0
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES3_MASK        0x0f
+   /* DVBT_TPS_EXTRA command, TPS_RES4 field definition (address 5, size 4, lsb 4, unsigned)*/
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES4_LSB         4
+   #define  Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES4_MASK        0x0f
+
+#endif /* Si2168_DVBT_TPS_EXTRA_CMD */
+
+
+/* Si2168_EXIT_BOOTLOADER command definition */
+#define   Si2168_EXIT_BOOTLOADER_CMD 0x01
+
+#ifdef    Si2168_EXIT_BOOTLOADER_CMD
+  #define Si2168_EXIT_BOOTLOADER_CMD_CODE 0x010001
+
+    typedef struct { /* Si2168_EXIT_BOOTLOADER_CMD_struct */
+     unsigned char   func;
+     unsigned char   ctsien;
+   } Si2168_EXIT_BOOTLOADER_CMD_struct;
+
+
+    typedef struct { /* Si2168_EXIT_BOOTLOADER_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+   }  Si2168_EXIT_BOOTLOADER_CMD_REPLY_struct;
+
+   /* EXIT_BOOTLOADER command, FUNC field definition (address 1,size 4, lsb 0, unsigned) */
+   #define  Si2168_EXIT_BOOTLOADER_CMD_FUNC_LSB         0
+   #define  Si2168_EXIT_BOOTLOADER_CMD_FUNC_MASK        0x0f
+   #define  Si2168_EXIT_BOOTLOADER_CMD_FUNC_MIN         0
+   #define  Si2168_EXIT_BOOTLOADER_CMD_FUNC_MAX         1
+    #define Si2168_EXIT_BOOTLOADER_CMD_FUNC_BOOTLOADER  0
+    #define Si2168_EXIT_BOOTLOADER_CMD_FUNC_NORMAL      1
+   /* EXIT_BOOTLOADER command, CTSIEN field definition (address 1,size 1, lsb 7, unsigned) */
+   #define  Si2168_EXIT_BOOTLOADER_CMD_CTSIEN_LSB         7
+   #define  Si2168_EXIT_BOOTLOADER_CMD_CTSIEN_MASK        0x01
+   #define  Si2168_EXIT_BOOTLOADER_CMD_CTSIEN_MIN         0
+   #define  Si2168_EXIT_BOOTLOADER_CMD_CTSIEN_MAX         1
+    #define Si2168_EXIT_BOOTLOADER_CMD_CTSIEN_OFF  0
+    #define Si2168_EXIT_BOOTLOADER_CMD_CTSIEN_ON   1
+#endif /* Si2168_EXIT_BOOTLOADER_CMD */
+
+/* Si2168_GET_PROPERTY command definition */
+#define   Si2168_GET_PROPERTY_CMD 0x15
+
+#ifdef    Si2168_GET_PROPERTY_CMD
+  #define Si2168_GET_PROPERTY_CMD_CODE 0x010015
+
+    typedef struct { /* Si2168_GET_PROPERTY_CMD_struct */
+     unsigned char   reserved;
+     unsigned int    prop;
+   } Si2168_GET_PROPERTY_CMD_struct;
+
+
+    typedef struct { /* Si2168_GET_PROPERTY_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   reserved;
+      unsigned int    data;
+   }  Si2168_GET_PROPERTY_CMD_REPLY_struct;
+
+   /* GET_PROPERTY command, RESERVED field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  Si2168_GET_PROPERTY_CMD_RESERVED_LSB         0
+   #define  Si2168_GET_PROPERTY_CMD_RESERVED_MASK        0xff
+   #define  Si2168_GET_PROPERTY_CMD_RESERVED_MIN         0
+   #define  Si2168_GET_PROPERTY_CMD_RESERVED_MAX         0
+    #define Si2168_GET_PROPERTY_CMD_RESERVED_RESERVED_MIN  0
+    #define Si2168_GET_PROPERTY_CMD_RESERVED_RESERVED_MAX  0
+   /* GET_PROPERTY command, PROP field definition (address 2,size 16, lsb 0, unsigned) */
+   #define  Si2168_GET_PROPERTY_CMD_PROP_LSB         0
+   #define  Si2168_GET_PROPERTY_CMD_PROP_MASK        0xffff
+   #define  Si2168_GET_PROPERTY_CMD_PROP_MIN         0
+   #define  Si2168_GET_PROPERTY_CMD_PROP_MAX         65535
+    #define Si2168_GET_PROPERTY_CMD_PROP_PROP_MIN  0
+    #define Si2168_GET_PROPERTY_CMD_PROP_PROP_MAX  65535
+   /* GET_PROPERTY command, RESERVED field definition (address 1, size 8, lsb 0, unsigned)*/
+   #define  Si2168_GET_PROPERTY_RESPONSE_RESERVED_LSB         0
+   #define  Si2168_GET_PROPERTY_RESPONSE_RESERVED_MASK        0xff
+   /* GET_PROPERTY command, DATA field definition (address 2, size 16, lsb 0, unsigned)*/
+   #define  Si2168_GET_PROPERTY_RESPONSE_DATA_LSB         0
+   #define  Si2168_GET_PROPERTY_RESPONSE_DATA_MASK        0xffff
+
+#endif /* Si2168_GET_PROPERTY_CMD */
+
+/* Si2168_GET_REV command definition */
+#define   Si2168_GET_REV_CMD 0x11
+
+#ifdef    Si2168_GET_REV_CMD
+  #define Si2168_GET_REV_CMD_CODE 0x010011
+
+    typedef struct { /* Si2168_GET_REV_CMD_struct */
+         unsigned char   nothing;   } Si2168_GET_REV_CMD_struct;
+
+
+    typedef struct { /* Si2168_GET_REV_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   pn;
+      unsigned char   fwmajor;
+      unsigned char   fwminor;
+      unsigned int    patch;
+      unsigned char   cmpmajor;
+      unsigned char   cmpminor;
+      unsigned char   cmpbuild;
+      unsigned char   chiprev;
+   }  Si2168_GET_REV_CMD_REPLY_struct;
+
+   /* GET_REV command, PN field definition (address 1, size 8, lsb 0, unsigned)*/
+   #define  Si2168_GET_REV_RESPONSE_PN_LSB         0
+   #define  Si2168_GET_REV_RESPONSE_PN_MASK        0xff
+   /* GET_REV command, FWMAJOR field definition (address 2, size 8, lsb 0, unsigned)*/
+   #define  Si2168_GET_REV_RESPONSE_FWMAJOR_LSB         0
+   #define  Si2168_GET_REV_RESPONSE_FWMAJOR_MASK        0xff
+   /* GET_REV command, FWMINOR field definition (address 3, size 8, lsb 0, unsigned)*/
+   #define  Si2168_GET_REV_RESPONSE_FWMINOR_LSB         0
+   #define  Si2168_GET_REV_RESPONSE_FWMINOR_MASK        0xff
+   /* GET_REV command, PATCH field definition (address 4, size 16, lsb 0, unsigned)*/
+   #define  Si2168_GET_REV_RESPONSE_PATCH_LSB         0
+   #define  Si2168_GET_REV_RESPONSE_PATCH_MASK        0xffff
+   /* GET_REV command, CMPMAJOR field definition (address 6, size 8, lsb 0, unsigned)*/
+   #define  Si2168_GET_REV_RESPONSE_CMPMAJOR_LSB         0
+   #define  Si2168_GET_REV_RESPONSE_CMPMAJOR_MASK        0xff
+   /* GET_REV command, CMPMINOR field definition (address 7, size 8, lsb 0, unsigned)*/
+   #define  Si2168_GET_REV_RESPONSE_CMPMINOR_LSB         0
+   #define  Si2168_GET_REV_RESPONSE_CMPMINOR_MASK        0xff
+   /* GET_REV command, CMPBUILD field definition (address 8, size 8, lsb 0, unsigned)*/
+   #define  Si2168_GET_REV_RESPONSE_CMPBUILD_LSB         0
+   #define  Si2168_GET_REV_RESPONSE_CMPBUILD_MASK        0xff
+    #define Si2168_GET_REV_RESPONSE_CMPBUILD_CMPBUILD_MIN  0
+    #define Si2168_GET_REV_RESPONSE_CMPBUILD_CMPBUILD_MAX  255
+   /* GET_REV command, CHIPREV field definition (address 9, size 4, lsb 0, unsigned)*/
+   #define  Si2168_GET_REV_RESPONSE_CHIPREV_LSB         0
+   #define  Si2168_GET_REV_RESPONSE_CHIPREV_MASK        0x0f
+    #define Si2168_GET_REV_RESPONSE_CHIPREV_A  1
+    #define Si2168_GET_REV_RESPONSE_CHIPREV_B  2
+
+#endif /* Si2168_GET_REV_CMD */
+
+/* Si2168_I2C_PASSTHROUGH command definition */
+#define   Si2168_I2C_PASSTHROUGH_CMD 0xc0
+
+#ifdef    Si2168_I2C_PASSTHROUGH_CMD
+  #define Si2168_I2C_PASSTHROUGH_CMD_CODE 0x0100c0
+
+    typedef struct { /* Si2168_I2C_PASSTHROUGH_CMD_struct */
+     unsigned char   subcode;
+     unsigned char   i2c_passthru;
+     unsigned char   reserved;
+   } Si2168_I2C_PASSTHROUGH_CMD_struct;
+
+
+    typedef struct { /* Si2168_I2C_PASSTHROUGH_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+   }  Si2168_I2C_PASSTHROUGH_CMD_REPLY_struct;
+
+   /* I2C_PASSTHROUGH command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  Si2168_I2C_PASSTHROUGH_CMD_SUBCODE_LSB         0
+   #define  Si2168_I2C_PASSTHROUGH_CMD_SUBCODE_MASK        0xff
+   #define  Si2168_I2C_PASSTHROUGH_CMD_SUBCODE_MIN         13
+   #define  Si2168_I2C_PASSTHROUGH_CMD_SUBCODE_MAX         13
+    #define Si2168_I2C_PASSTHROUGH_CMD_SUBCODE_CODE  13
+   /* I2C_PASSTHROUGH command, I2C_PASSTHRU field definition (address 2,size 1, lsb 0, unsigned) */
+   #define  Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_LSB         0
+   #define  Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_MASK        0x01
+   #define  Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_MIN         0
+   #define  Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_MAX         1
+    #define Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_CLOSE  1
+    #define Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_OPEN   0
+   /* I2C_PASSTHROUGH command, RESERVED field definition (address 2,size 7, lsb 1, unsigned) */
+   #define  Si2168_I2C_PASSTHROUGH_CMD_RESERVED_LSB         1
+   #define  Si2168_I2C_PASSTHROUGH_CMD_RESERVED_MASK        0x7f
+   #define  Si2168_I2C_PASSTHROUGH_CMD_RESERVED_MIN         0
+   #define  Si2168_I2C_PASSTHROUGH_CMD_RESERVED_MAX         0
+    #define Si2168_I2C_PASSTHROUGH_CMD_RESERVED_RESERVED  0
+#endif /* Si2168_I2C_PASSTHROUGH_CMD */
+
+/* Si2168_PART_INFO command definition */
+#define   Si2168_PART_INFO_CMD 0x02
+
+#ifdef    Si2168_PART_INFO_CMD
+  #define Si2168_PART_INFO_CMD_CODE 0x010002
+
+    typedef struct { /* Si2168_PART_INFO_CMD_struct */
+         unsigned char   nothing;   } Si2168_PART_INFO_CMD_struct;
+
+
+    typedef struct { /* Si2168_PART_INFO_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   chiprev;
+      unsigned char   romid;
+      unsigned char   part;
+      unsigned char   pmajor;
+      unsigned char   pminor;
+      unsigned char   pbuild;
+      unsigned int    reserved;
+      unsigned long   serial;
+   }  Si2168_PART_INFO_CMD_REPLY_struct;
+
+   /* PART_INFO command, CHIPREV field definition (address 1, size 4, lsb 0, unsigned)*/
+   #define  Si2168_PART_INFO_RESPONSE_CHIPREV_LSB         0
+   #define  Si2168_PART_INFO_RESPONSE_CHIPREV_MASK        0x0f
+    #define Si2168_PART_INFO_RESPONSE_CHIPREV_A  1
+    #define Si2168_PART_INFO_RESPONSE_CHIPREV_B  2
+   /* PART_INFO command, ROMID field definition (address 12, size 8, lsb 0, unsigned)*/
+   #define  Si2168_PART_INFO_RESPONSE_ROMID_LSB         0
+   #define  Si2168_PART_INFO_RESPONSE_ROMID_MASK        0xff
+   /* PART_INFO command, PART field definition (address 2, size 8, lsb 0, unsigned)*/
+   #define  Si2168_PART_INFO_RESPONSE_PART_LSB         0
+   #define  Si2168_PART_INFO_RESPONSE_PART_MASK        0xff
+   /* PART_INFO command, PMAJOR field definition (address 3, size 8, lsb 0, unsigned)*/
+   #define  Si2168_PART_INFO_RESPONSE_PMAJOR_LSB         0
+   #define  Si2168_PART_INFO_RESPONSE_PMAJOR_MASK        0xff
+   /* PART_INFO command, PMINOR field definition (address 4, size 8, lsb 0, unsigned)*/
+   #define  Si2168_PART_INFO_RESPONSE_PMINOR_LSB         0
+   #define  Si2168_PART_INFO_RESPONSE_PMINOR_MASK        0xff
+   /* PART_INFO command, PBUILD field definition (address 5, size 8, lsb 0, unsigned)*/
+   #define  Si2168_PART_INFO_RESPONSE_PBUILD_LSB         0
+   #define  Si2168_PART_INFO_RESPONSE_PBUILD_MASK        0xff
+   /* PART_INFO command, RESERVED field definition (address 6, size 16, lsb 0, unsigned)*/
+   #define  Si2168_PART_INFO_RESPONSE_RESERVED_LSB         0
+   #define  Si2168_PART_INFO_RESPONSE_RESERVED_MASK        0xffff
+   /* PART_INFO command, SERIAL field definition (address 8, size 32, lsb 0, unsigned)*/
+   #define  Si2168_PART_INFO_RESPONSE_SERIAL_LSB         0
+   #define  Si2168_PART_INFO_RESPONSE_SERIAL_MASK        0xffffffff
+
+#endif /* Si2168_PART_INFO_CMD */
+
+/* Si2168_POWER_DOWN command definition */
+#define   Si2168_POWER_DOWN_CMD 0x13
+
+#ifdef    Si2168_POWER_DOWN_CMD
+  #define Si2168_POWER_DOWN_CMD_CODE 0x010013
+
+    typedef struct { /* Si2168_POWER_DOWN_CMD_struct */
+         unsigned char   nothing;   } Si2168_POWER_DOWN_CMD_struct;
+
+
+    typedef struct { /* Si2168_POWER_DOWN_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+   }  Si2168_POWER_DOWN_CMD_REPLY_struct;
+
+#endif /* Si2168_POWER_DOWN_CMD */
+
+/* Si2168_POWER_UP command definition */
+#define   Si2168_POWER_UP_CMD 0xc0
+
+#ifdef    Si2168_POWER_UP_CMD
+  #define Si2168_POWER_UP_CMD_CODE 0x0200c0
+
+    typedef struct { /* Si2168_POWER_UP_CMD_struct */
+     unsigned char   subcode;
+     unsigned char   reset;
+     unsigned char   reserved2;
+     unsigned char   reserved4;
+     unsigned char   reserved1;
+     unsigned char   addr_mode;
+     unsigned char   reserved5;
+     unsigned char   func;
+     unsigned char   clock_freq;
+     unsigned char   ctsien;
+     unsigned char   wake_up;
+   } Si2168_POWER_UP_CMD_struct;
+
+
+    typedef struct { /* Si2168_POWER_UP_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+   }  Si2168_POWER_UP_CMD_REPLY_struct;
+
+   /* POWER_UP command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  Si2168_POWER_UP_CMD_SUBCODE_LSB         0
+   #define  Si2168_POWER_UP_CMD_SUBCODE_MASK        0xff
+   #define  Si2168_POWER_UP_CMD_SUBCODE_MIN         6
+   #define  Si2168_POWER_UP_CMD_SUBCODE_MAX         6
+    #define Si2168_POWER_UP_CMD_SUBCODE_CODE  6
+   /* POWER_UP command, RESET field definition (address 2,size 8, lsb 0, unsigned) */
+   #define  Si2168_POWER_UP_CMD_RESET_LSB         0
+   #define  Si2168_POWER_UP_CMD_RESET_MASK        0xff
+   #define  Si2168_POWER_UP_CMD_RESET_MIN         1
+   #define  Si2168_POWER_UP_CMD_RESET_MAX         8
+    #define Si2168_POWER_UP_CMD_RESET_RESET   1
+    #define Si2168_POWER_UP_CMD_RESET_RESUME  8
+   /* POWER_UP command, RESERVED2 field definition (address 3,size 8, lsb 0, unsigned) */
+   #define  Si2168_POWER_UP_CMD_RESERVED2_LSB         0
+   #define  Si2168_POWER_UP_CMD_RESERVED2_MASK        0xff
+   #define  Si2168_POWER_UP_CMD_RESERVED2_MIN         15
+   #define  Si2168_POWER_UP_CMD_RESERVED2_MAX         15
+    #define Si2168_POWER_UP_CMD_RESERVED2_RESERVED  15
+   /* POWER_UP command, RESERVED4 field definition (address 4,size 8, lsb 0, unsigned) */
+   #define  Si2168_POWER_UP_CMD_RESERVED4_LSB         0
+   #define  Si2168_POWER_UP_CMD_RESERVED4_MASK        0xff
+   #define  Si2168_POWER_UP_CMD_RESERVED4_MIN         0
+   #define  Si2168_POWER_UP_CMD_RESERVED4_MAX         0
+    #define Si2168_POWER_UP_CMD_RESERVED4_RESERVED  0
+   /* POWER_UP command, RESERVED1 field definition (address 5,size 4, lsb 0, unsigned) */
+   #define  Si2168_POWER_UP_CMD_RESERVED1_LSB         0
+   #define  Si2168_POWER_UP_CMD_RESERVED1_MASK        0x0f
+   #define  Si2168_POWER_UP_CMD_RESERVED1_MIN         0
+   #define  Si2168_POWER_UP_CMD_RESERVED1_MAX         0
+    #define Si2168_POWER_UP_CMD_RESERVED1_RESERVED  0
+   /* POWER_UP command, ADDR_MODE field definition (address 5,size 1, lsb 4, unsigned) */
+   #define  Si2168_POWER_UP_CMD_ADDR_MODE_LSB         4
+   #define  Si2168_POWER_UP_CMD_ADDR_MODE_MASK        0x01
+   #define  Si2168_POWER_UP_CMD_ADDR_MODE_MIN         0
+   #define  Si2168_POWER_UP_CMD_ADDR_MODE_MAX         1
+    #define Si2168_POWER_UP_CMD_ADDR_MODE_CAPTURE  1
+    #define Si2168_POWER_UP_CMD_ADDR_MODE_CURRENT  0
+   /* POWER_UP command, RESERVED5 field definition (address 5,size 1, lsb 5, unsigned) */
+   #define  Si2168_POWER_UP_CMD_RESERVED5_LSB         5
+   #define  Si2168_POWER_UP_CMD_RESERVED5_MASK        0x01
+   #define  Si2168_POWER_UP_CMD_RESERVED5_MIN         1
+   #define  Si2168_POWER_UP_CMD_RESERVED5_MAX         1
+    #define Si2168_POWER_UP_CMD_RESERVED5_RESERVED  1
+   /* POWER_UP command, FUNC field definition (address 6,size 4, lsb 0, unsigned) */
+   #define  Si2168_POWER_UP_CMD_FUNC_LSB         0
+   #define  Si2168_POWER_UP_CMD_FUNC_MASK        0x0f
+   #define  Si2168_POWER_UP_CMD_FUNC_MIN         0
+   #define  Si2168_POWER_UP_CMD_FUNC_MAX         1
+    #define Si2168_POWER_UP_CMD_FUNC_BOOTLOADER  0
+    #define Si2168_POWER_UP_CMD_FUNC_NORMAL      1
+   /* POWER_UP command, CLOCK_FREQ field definition (address 6,size 3, lsb 4, unsigned) */
+   #define  Si2168_POWER_UP_CMD_CLOCK_FREQ_LSB         4
+   #define  Si2168_POWER_UP_CMD_CLOCK_FREQ_MASK        0x07
+   #define  Si2168_POWER_UP_CMD_CLOCK_FREQ_MIN         0
+   #define  Si2168_POWER_UP_CMD_CLOCK_FREQ_MAX         4
+    #define Si2168_POWER_UP_CMD_CLOCK_FREQ_CLK_16MHZ  0
+    #define Si2168_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ  2
+    #define Si2168_POWER_UP_CMD_CLOCK_FREQ_CLK_27MHZ  3
+   /* POWER_UP command, CTSIEN field definition (address 6,size 1, lsb 7, unsigned) */
+   #define  Si2168_POWER_UP_CMD_CTSIEN_LSB         7
+   #define  Si2168_POWER_UP_CMD_CTSIEN_MASK        0x01
+   #define  Si2168_POWER_UP_CMD_CTSIEN_MIN         0
+   #define  Si2168_POWER_UP_CMD_CTSIEN_MAX         1
+    #define Si2168_POWER_UP_CMD_CTSIEN_DISABLE  0
+    #define Si2168_POWER_UP_CMD_CTSIEN_ENABLE   1
+   /* POWER_UP command, WAKE_UP field definition (address 7,size 1, lsb 0, unsigned) */
+   #define  Si2168_POWER_UP_CMD_WAKE_UP_LSB         0
+   #define  Si2168_POWER_UP_CMD_WAKE_UP_MASK        0x01
+   #define  Si2168_POWER_UP_CMD_WAKE_UP_MIN         1
+   #define  Si2168_POWER_UP_CMD_WAKE_UP_MAX         1
+    #define Si2168_POWER_UP_CMD_WAKE_UP_WAKE_UP  1
+#endif /* Si2168_POWER_UP_CMD */
+
+/* Si2168_RSSI_ADC command definition */
+#define   Si2168_RSSI_ADC_CMD 0x17
+
+#ifdef    Si2168_RSSI_ADC_CMD
+  #define Si2168_RSSI_ADC_CMD_CODE 0x010017
+
+    typedef struct { /* Si2168_RSSI_ADC_CMD_struct */
+     unsigned char   on_off;
+   } Si2168_RSSI_ADC_CMD_struct;
+
+
+    typedef struct { /* Si2168_RSSI_ADC_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   level;
+   }  Si2168_RSSI_ADC_CMD_REPLY_struct;
+
+   /* RSSI_ADC command, ON_OFF field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2168_RSSI_ADC_CMD_ON_OFF_LSB         0
+   #define  Si2168_RSSI_ADC_CMD_ON_OFF_MASK        0x01
+   #define  Si2168_RSSI_ADC_CMD_ON_OFF_MIN         0
+   #define  Si2168_RSSI_ADC_CMD_ON_OFF_MAX         1
+    #define Si2168_RSSI_ADC_CMD_ON_OFF_OFF  0
+    #define Si2168_RSSI_ADC_CMD_ON_OFF_ON   1
+   /* RSSI_ADC command, LEVEL field definition (address 1, size 8, lsb 0, unsigned)*/
+   #define  Si2168_RSSI_ADC_RESPONSE_LEVEL_LSB         0
+   #define  Si2168_RSSI_ADC_RESPONSE_LEVEL_MASK        0xff
+
+#endif /* Si2168_RSSI_ADC_CMD */
+
+/* Si2168_SCAN_CTRL command definition */
+#define   Si2168_SCAN_CTRL_CMD 0x31
+
+#ifdef    Si2168_SCAN_CTRL_CMD
+  #define Si2168_SCAN_CTRL_CMD_CODE 0x010031
+
+    typedef struct { /* Si2168_SCAN_CTRL_CMD_struct */
+     unsigned char   action;
+     unsigned long   tuned_rf_freq;
+   } Si2168_SCAN_CTRL_CMD_struct;
+
+
+    typedef struct { /* Si2168_SCAN_CTRL_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+   }  Si2168_SCAN_CTRL_CMD_REPLY_struct;
+
+   /* SCAN_CTRL command, ACTION field definition (address 1,size 4, lsb 0, unsigned) */
+   #define  Si2168_SCAN_CTRL_CMD_ACTION_LSB         0
+   #define  Si2168_SCAN_CTRL_CMD_ACTION_MASK        0x0f
+   #define  Si2168_SCAN_CTRL_CMD_ACTION_MIN         1
+   #define  Si2168_SCAN_CTRL_CMD_ACTION_MAX         3
+    #define Si2168_SCAN_CTRL_CMD_ACTION_ABORT   3
+    #define Si2168_SCAN_CTRL_CMD_ACTION_RESUME  2
+    #define Si2168_SCAN_CTRL_CMD_ACTION_START   1
+   /* SCAN_CTRL command, TUNED_RF_FREQ field definition (address 4,size 32, lsb 0, unsigned) */
+   #define  Si2168_SCAN_CTRL_CMD_TUNED_RF_FREQ_LSB         0
+   #define  Si2168_SCAN_CTRL_CMD_TUNED_RF_FREQ_MASK        0xffffffff
+   #define  Si2168_SCAN_CTRL_CMD_TUNED_RF_FREQ_MIN         0
+   #define  Si2168_SCAN_CTRL_CMD_TUNED_RF_FREQ_MAX         4294967
+    #define Si2168_SCAN_CTRL_CMD_TUNED_RF_FREQ_TUNED_RF_FREQ_MIN  0
+    #define Si2168_SCAN_CTRL_CMD_TUNED_RF_FREQ_TUNED_RF_FREQ_MAX  4294967
+#endif /* Si2168_SCAN_CTRL_CMD */
+
+/* Si2168_SCAN_STATUS command definition */
+#define   Si2168_SCAN_STATUS_CMD 0x30
+
+#ifdef    Si2168_SCAN_STATUS_CMD
+  #define Si2168_SCAN_STATUS_CMD_CODE 0x010030
+
+    typedef struct { /* Si2168_SCAN_STATUS_CMD_struct */
+     unsigned char   intack;
+   } Si2168_SCAN_STATUS_CMD_struct;
+
+
+    typedef struct { /* Si2168_SCAN_STATUS_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   buzint;
+      unsigned char   reqint;
+      unsigned char   modulation;
+      unsigned char   buz;
+      unsigned char   req;
+      unsigned char   scan_status;
+      unsigned long   rf_freq;
+      unsigned int    symb_rate;
+   }  Si2168_SCAN_STATUS_CMD_REPLY_struct;
+
+   /* SCAN_STATUS command, INTACK field definition (address 1,size 1, lsb 0, unsigned) */
+   #define  Si2168_SCAN_STATUS_CMD_INTACK_LSB         0
+   #define  Si2168_SCAN_STATUS_CMD_INTACK_MASK        0x01
+   #define  Si2168_SCAN_STATUS_CMD_INTACK_MIN         0
+   #define  Si2168_SCAN_STATUS_CMD_INTACK_MAX         1
+    #define Si2168_SCAN_STATUS_CMD_INTACK_CLEAR  1
+    #define Si2168_SCAN_STATUS_CMD_INTACK_OK     0
+   /* SCAN_STATUS command, BUZINT field definition (address 1, size 1, lsb 0, unsigned)*/
+   #define  Si2168_SCAN_STATUS_RESPONSE_BUZINT_LSB         0
+   #define  Si2168_SCAN_STATUS_RESPONSE_BUZINT_MASK        0x01
+    #define Si2168_SCAN_STATUS_RESPONSE_BUZINT_CHANGED    1
+    #define Si2168_SCAN_STATUS_RESPONSE_BUZINT_NO_CHANGE  0
+   /* SCAN_STATUS command, REQINT field definition (address 1, size 1, lsb 1, unsigned)*/
+   #define  Si2168_SCAN_STATUS_RESPONSE_REQINT_LSB         1
+   #define  Si2168_SCAN_STATUS_RESPONSE_REQINT_MASK        0x01
+    #define Si2168_SCAN_STATUS_RESPONSE_REQINT_CHANGED    1
+    #define Si2168_SCAN_STATUS_RESPONSE_REQINT_NO_CHANGE  0
+   /* SCAN_STATUS command, MODULATION field definition (address 10, size 4, lsb 0, unsigned)*/
+   #define  Si2168_SCAN_STATUS_RESPONSE_MODULATION_LSB         0
+   #define  Si2168_SCAN_STATUS_RESPONSE_MODULATION_MASK        0x0f
+    #define Si2168_SCAN_STATUS_RESPONSE_MODULATION_DSS     10
+    #define Si2168_SCAN_STATUS_RESPONSE_MODULATION_DVBC    3
+    #define Si2168_SCAN_STATUS_RESPONSE_MODULATION_DVBS    8
+    #define Si2168_SCAN_STATUS_RESPONSE_MODULATION_DVBS2   9
+    #define Si2168_SCAN_STATUS_RESPONSE_MODULATION_DVBT    2
+    #define Si2168_SCAN_STATUS_RESPONSE_MODULATION_DVBT2   7
+   /* SCAN_STATUS command, BUZ field definition (address 2, size 1, lsb 0, unsigned)*/
+   #define  Si2168_SCAN_STATUS_RESPONSE_BUZ_LSB         0
+   #define  Si2168_SCAN_STATUS_RESPONSE_BUZ_MASK        0x01
+    #define Si2168_SCAN_STATUS_RESPONSE_BUZ_BUSY  1
+    #define Si2168_SCAN_STATUS_RESPONSE_BUZ_CTS   0
+   /* SCAN_STATUS command, REQ field definition (address 2, size 1, lsb 1, unsigned)*/
+   #define  Si2168_SCAN_STATUS_RESPONSE_REQ_LSB         1
+   #define  Si2168_SCAN_STATUS_RESPONSE_REQ_MASK        0x01
+    #define Si2168_SCAN_STATUS_RESPONSE_REQ_NO_REQUEST  0
+    #define Si2168_SCAN_STATUS_RESPONSE_REQ_REQUEST     1
+   /* SCAN_STATUS command, SCAN_STATUS field definition (address 3, size 6, lsb 0, unsigned)*/
+   #define  Si2168_SCAN_STATUS_RESPONSE_SCAN_STATUS_LSB         0
+   #define  Si2168_SCAN_STATUS_RESPONSE_SCAN_STATUS_MASK        0x3f
+    #define Si2168_SCAN_STATUS_RESPONSE_SCAN_STATUS_ANALOG_CHANNEL_FOUND   6
+    #define Si2168_SCAN_STATUS_RESPONSE_SCAN_STATUS_DEBUG                  63
+    #define Si2168_SCAN_STATUS_RESPONSE_SCAN_STATUS_DIGITAL_CHANNEL_FOUND  5
+    #define Si2168_SCAN_STATUS_RESPONSE_SCAN_STATUS_ENDED                  2
+    #define Si2168_SCAN_STATUS_RESPONSE_SCAN_STATUS_ERROR                  3
+    #define Si2168_SCAN_STATUS_RESPONSE_SCAN_STATUS_IDLE                   0
+    #define Si2168_SCAN_STATUS_RESPONSE_SCAN_STATUS_SEARCHING              1
+    #define Si2168_SCAN_STATUS_RESPONSE_SCAN_STATUS_TUNE_REQUEST           4
+   /* SCAN_STATUS command, RF_FREQ field definition (address 4, size 32, lsb 0, unsigned)*/
+   #define  Si2168_SCAN_STATUS_RESPONSE_RF_FREQ_LSB         0
+   #define  Si2168_SCAN_STATUS_RESPONSE_RF_FREQ_MASK        0xffffffff
+   /* SCAN_STATUS command, SYMB_RATE field definition (address 8, size 16, lsb 0, unsigned)*/
+   #define  Si2168_SCAN_STATUS_RESPONSE_SYMB_RATE_LSB         0
+   #define  Si2168_SCAN_STATUS_RESPONSE_SYMB_RATE_MASK        0xffff
+
+#endif /* Si2168_SCAN_STATUS_CMD */
+
+/* Si2168_SET_PROPERTY command definition */
+#define   Si2168_SET_PROPERTY_CMD 0x14
+
+#ifdef    Si2168_SET_PROPERTY_CMD
+  #define Si2168_SET_PROPERTY_CMD_CODE 0x010014
+
+    typedef struct { /* Si2168_SET_PROPERTY_CMD_struct */
+     unsigned char   reserved;
+     unsigned int    prop;
+     unsigned int    data;
+   } Si2168_SET_PROPERTY_CMD_struct;
+
+
+    typedef struct { /* Si2168_SET_PROPERTY_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+      unsigned char   reserved;
+      unsigned int    data;
+   }  Si2168_SET_PROPERTY_CMD_REPLY_struct;
+
+   /* SET_PROPERTY command, RESERVED field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  Si2168_SET_PROPERTY_CMD_RESERVED_LSB         0
+   #define  Si2168_SET_PROPERTY_CMD_RESERVED_MASK        0xff
+   #define  Si2168_SET_PROPERTY_CMD_RESERVED_MIN         0
+   #define  Si2168_SET_PROPERTY_CMD_RESERVED_MAX         255.0
+   /* SET_PROPERTY command, PROP field definition (address 2,size 16, lsb 0, unsigned) */
+   #define  Si2168_SET_PROPERTY_CMD_PROP_LSB         0
+   #define  Si2168_SET_PROPERTY_CMD_PROP_MASK        0xffff
+   #define  Si2168_SET_PROPERTY_CMD_PROP_MIN         0
+   #define  Si2168_SET_PROPERTY_CMD_PROP_MAX         65535
+    #define Si2168_SET_PROPERTY_CMD_PROP_PROP_MIN  0
+    #define Si2168_SET_PROPERTY_CMD_PROP_PROP_MAX  65535
+   /* SET_PROPERTY command, DATA field definition (address 4,size 16, lsb 0, unsigned) */
+   #define  Si2168_SET_PROPERTY_CMD_DATA_LSB         0
+   #define  Si2168_SET_PROPERTY_CMD_DATA_MASK        0xffff
+   #define  Si2168_SET_PROPERTY_CMD_DATA_MIN         0
+   #define  Si2168_SET_PROPERTY_CMD_DATA_MAX         65535
+    #define Si2168_SET_PROPERTY_CMD_DATA_DATA_MIN  0
+    #define Si2168_SET_PROPERTY_CMD_DATA_DATA_MAX  65535
+   /* SET_PROPERTY command, RESERVED field definition (address 1, size 8, lsb 0, unsigned)*/
+   #define  Si2168_SET_PROPERTY_RESPONSE_RESERVED_LSB         0
+   #define  Si2168_SET_PROPERTY_RESPONSE_RESERVED_MASK        0xff
+    #define Si2168_SET_PROPERTY_RESPONSE_RESERVED_RESERVED_MIN  0
+    #define Si2168_SET_PROPERTY_RESPONSE_RESERVED_RESERVED_MAX  0
+   /* SET_PROPERTY command, DATA field definition (address 2, size 16, lsb 0, unsigned)*/
+   #define  Si2168_SET_PROPERTY_RESPONSE_DATA_LSB         0
+   #define  Si2168_SET_PROPERTY_RESPONSE_DATA_MASK        0xffff
+
+#endif /* Si2168_SET_PROPERTY_CMD */
+
+/* Si2168_START_CLK command definition */
+#define   Si2168_START_CLK_CMD 0xc0
+
+#ifdef    Si2168_START_CLK_CMD
+  #define Si2168_START_CLK_CMD_CODE 0x0300c0
+
+    typedef struct { /* Si2168_START_CLK_CMD_struct */
+     unsigned char   subcode;
+     unsigned char   reserved1;
+     unsigned char   tune_cap;
+     unsigned char   reserved2;
+     unsigned int    clk_mode;
+     unsigned char   reserved3;
+     unsigned char   reserved4;
+     unsigned char   start_clk;
+   } Si2168_START_CLK_CMD_struct;
+
+
+    typedef struct { /* Si2168_START_CLK_CMD_REPLY_struct */
+       Si2168_COMMON_REPLY_struct * STATUS;
+   }  Si2168_START_CLK_CMD_REPLY_struct;
+
+   /* START_CLK command, SUBCODE field definition (address 1,size 8, lsb 0, unsigned) */
+   #define  Si2168_START_CLK_CMD_SUBCODE_LSB         0
+   #define  Si2168_START_CLK_CMD_SUBCODE_MASK        0xff
+   #define  Si2168_START_CLK_CMD_SUBCODE_MIN         18
+   #define  Si2168_START_CLK_CMD_SUBCODE_MAX         18
+    #define Si2168_START_CLK_CMD_SUBCODE_CODE  18
+   /* START_CLK command, RESERVED1 field definition (address 2,size 8, lsb 0, unsigned) */
+   #define  Si2168_START_CLK_CMD_RESERVED1_LSB         0
+   #define  Si2168_START_CLK_CMD_RESERVED1_MASK        0xff
+   #define  Si2168_START_CLK_CMD_RESERVED1_MIN         0
+   #define  Si2168_START_CLK_CMD_RESERVED1_MAX         0
+    #define Si2168_START_CLK_CMD_RESERVED1_RESERVED  0
+   /* START_CLK command, TUNE_CAP field definition (address 3,size 4, lsb 0, unsigned) */
+   #define  Si2168_START_CLK_CMD_TUNE_CAP_LSB         0
+   #define  Si2168_START_CLK_CMD_TUNE_CAP_MASK        0x0f
+   #define  Si2168_START_CLK_CMD_TUNE_CAP_MIN         0
+   #define  Si2168_START_CLK_CMD_TUNE_CAP_MAX         15
+    #define Si2168_START_CLK_CMD_TUNE_CAP_10P4     8
+    #define Si2168_START_CLK_CMD_TUNE_CAP_11P7     9
+    #define Si2168_START_CLK_CMD_TUNE_CAP_13P0     10
+    #define Si2168_START_CLK_CMD_TUNE_CAP_14P3     11
+    #define Si2168_START_CLK_CMD_TUNE_CAP_15P6     12
+    #define Si2168_START_CLK_CMD_TUNE_CAP_16P9     13
+    #define Si2168_START_CLK_CMD_TUNE_CAP_18P2     14
+    #define Si2168_START_CLK_CMD_TUNE_CAP_19P5     15
+    #define Si2168_START_CLK_CMD_TUNE_CAP_1P3      1
+    #define Si2168_START_CLK_CMD_TUNE_CAP_2P6      2
+    #define Si2168_START_CLK_CMD_TUNE_CAP_3P9      3
+    #define Si2168_START_CLK_CMD_TUNE_CAP_5P2      4
+    #define Si2168_START_CLK_CMD_TUNE_CAP_6P5      5
+    #define Si2168_START_CLK_CMD_TUNE_CAP_7P8      6
+    #define Si2168_START_CLK_CMD_TUNE_CAP_9P1      7
+    #define Si2168_START_CLK_CMD_TUNE_CAP_EXT_CLK  0
+   /* START_CLK command, RESERVED2 field definition (address 3,size 4, lsb 4, unsigned) */
+   #define  Si2168_START_CLK_CMD_RESERVED2_LSB         4
+   #define  Si2168_START_CLK_CMD_RESERVED2_MASK        0x0f
+   #define  Si2168_START_CLK_CMD_RESERVED2_MIN         0
+   #define  Si2168_START_CLK_CMD_RESERVED2_MAX         0
+    #define Si2168_START_CLK_CMD_RESERVED2_RESERVED  0
+   /* START_CLK command, CLK_MODE field definition (address 4,size 12, lsb 0, unsigned) */
+   #define  Si2168_START_CLK_CMD_CLK_MODE_LSB         0
+   #define  Si2168_START_CLK_CMD_CLK_MODE_MASK        0xfff
+   #define  Si2168_START_CLK_CMD_CLK_MODE_MIN         575
+   #define  Si2168_START_CLK_CMD_CLK_MODE_MAX         3328
+    #define Si2168_START_CLK_CMD_CLK_MODE_CLK_CLKIO    3328
+    #define Si2168_START_CLK_CMD_CLK_MODE_CLK_XTAL_IN  1536
+    #define Si2168_START_CLK_CMD_CLK_MODE_XTAL         575
+   /* START_CLK command, RESERVED3 field definition (address 6,size 8, lsb 0, unsigned) */
+   #define  Si2168_START_CLK_CMD_RESERVED3_LSB         0
+   #define  Si2168_START_CLK_CMD_RESERVED3_MASK        0xff
+   #define  Si2168_START_CLK_CMD_RESERVED3_MIN         22
+   #define  Si2168_START_CLK_CMD_RESERVED3_MAX         22
+    #define Si2168_START_CLK_CMD_RESERVED3_RESERVED  22
+   /* START_CLK command, RESERVED4 field definition (address 7,size 1, lsb 0, unsigned) */
+   #define  Si2168_START_CLK_CMD_RESERVED4_LSB         0
+   #define  Si2168_START_CLK_CMD_RESERVED4_MASK        0x01
+   #define  Si2168_START_CLK_CMD_RESERVED4_MIN         0
+   #define  Si2168_START_CLK_CMD_RESERVED4_MAX         0
+    #define Si2168_START_CLK_CMD_RESERVED4_RESERVED  0
+   /* START_CLK command, START_CLK field definition (address 12,size 1, lsb 0, unsigned) */
+   #define  Si2168_START_CLK_CMD_START_CLK_LSB         0
+   #define  Si2168_START_CLK_CMD_START_CLK_MASK        0x01
+   #define  Si2168_START_CLK_CMD_START_CLK_MIN         0
+   #define  Si2168_START_CLK_CMD_START_CLK_MAX         0
+    #define Si2168_START_CLK_CMD_START_CLK_START_CLK  0
+#endif /* Si2168_START_CLK_CMD */
+
+/* _commands_defines_insertion_point */
+
+/* _commands_struct_insertion_start */
+
+  /* --------------------------------------------*/
+  /* COMMANDS STRUCT                             */
+  /* This is used to store all command fields    */
+  /* --------------------------------------------*/
+  typedef struct { /* Si2168_CmdObj struct */
+    #ifdef    Si2168_CONFIG_CLKIO_CMD
+              Si2168_CONFIG_CLKIO_CMD_struct               config_clkio;
+    #endif /* Si2168_CONFIG_CLKIO_CMD */
+    #ifdef    Si2168_CONFIG_PINS_CMD
+              Si2168_CONFIG_PINS_CMD_struct                config_pins;
+    #endif /* Si2168_CONFIG_PINS_CMD */
+    #ifdef    Si2168_DD_BER_CMD
+              Si2168_DD_BER_CMD_struct                     dd_ber;
+    #endif /* Si2168_DD_BER_CMD */
+    #ifdef    Si2168_DD_CBER_CMD
+              Si2168_DD_CBER_CMD_struct                    dd_cber;
+    #endif /* Si2168_DD_CBER_CMD */
+
+    #ifdef    Si2168_DD_EXT_AGC_TER_CMD
+              Si2168_DD_EXT_AGC_TER_CMD_struct             dd_ext_agc_ter;
+    #endif /* Si2168_DD_EXT_AGC_TER_CMD */
+
+    #ifdef    Si2168_DD_FER_CMD
+              Si2168_DD_FER_CMD_struct                     dd_fer;
+    #endif /* Si2168_DD_FER_CMD */
+    #ifdef    Si2168_DD_GET_REG_CMD
+              Si2168_DD_GET_REG_CMD_struct                 dd_get_reg;
+    #endif /* Si2168_DD_GET_REG_CMD */
+    #ifdef    Si2168_DD_MP_DEFAULTS_CMD
+              Si2168_DD_MP_DEFAULTS_CMD_struct             dd_mp_defaults;
+    #endif /* Si2168_DD_MP_DEFAULTS_CMD */
+    #ifdef    Si2168_DD_PER_CMD
+              Si2168_DD_PER_CMD_struct                     dd_per;
+    #endif /* Si2168_DD_PER_CMD */
+    #ifdef    Si2168_DD_RESTART_CMD
+              Si2168_DD_RESTART_CMD_struct                 dd_restart;
+    #endif /* Si2168_DD_RESTART_CMD */
+    #ifdef    Si2168_DD_SET_REG_CMD
+              Si2168_DD_SET_REG_CMD_struct                 dd_set_reg;
+    #endif /* Si2168_DD_SET_REG_CMD */
+    #ifdef    Si2168_DD_SSI_SQI_CMD
+              Si2168_DD_SSI_SQI_CMD_struct                 dd_ssi_sqi;
+    #endif /* Si2168_DD_SSI_SQI_CMD */
+    #ifdef    Si2168_DD_STATUS_CMD
+              Si2168_DD_STATUS_CMD_struct                  dd_status;
+    #endif /* Si2168_DD_STATUS_CMD */
+    #ifdef    Si2168_DD_UNCOR_CMD
+              Si2168_DD_UNCOR_CMD_struct                   dd_uncor;
+    #endif /* Si2168_DD_UNCOR_CMD */
+    #ifdef    Si2168_DOWNLOAD_DATASET_CONTINUE_CMD
+              Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_struct  download_dataset_continue;
+    #endif /* Si2168_DOWNLOAD_DATASET_CONTINUE_CMD */
+    #ifdef    Si2168_DOWNLOAD_DATASET_START_CMD
+              Si2168_DOWNLOAD_DATASET_START_CMD_struct     download_dataset_start;
+    #endif /* Si2168_DOWNLOAD_DATASET_START_CMD */
+    #ifdef    Si2168_DVBC_STATUS_CMD
+              Si2168_DVBC_STATUS_CMD_struct                dvbc_status;
+    #endif /* Si2168_DVBC_STATUS_CMD */
+
+
+    #ifdef    Si2168_DVBT2_FEF_CMD
+              Si2168_DVBT2_FEF_CMD_struct                  dvbt2_fef;
+    #endif /* Si2168_DVBT2_FEF_CMD */
+    #ifdef    Si2168_DVBT2_PLP_INFO_CMD
+              Si2168_DVBT2_PLP_INFO_CMD_struct             dvbt2_plp_info;
+    #endif /* Si2168_DVBT2_PLP_INFO_CMD */
+    #ifdef    Si2168_DVBT2_PLP_SELECT_CMD
+              Si2168_DVBT2_PLP_SELECT_CMD_struct           dvbt2_plp_select;
+    #endif /* Si2168_DVBT2_PLP_SELECT_CMD */
+    #ifdef    Si2168_DVBT2_STATUS_CMD
+              Si2168_DVBT2_STATUS_CMD_struct               dvbt2_status;
+    #endif /* Si2168_DVBT2_STATUS_CMD */
+    #ifdef    Si2168_DVBT2_TX_ID_CMD
+              Si2168_DVBT2_TX_ID_CMD_struct                dvbt2_tx_id;
+    #endif /* Si2168_DVBT2_TX_ID_CMD */
+
+    #ifdef    Si2168_DVBT_STATUS_CMD
+              Si2168_DVBT_STATUS_CMD_struct                dvbt_status;
+    #endif /* Si2168_DVBT_STATUS_CMD */
+    #ifdef    Si2168_DVBT_TPS_EXTRA_CMD
+              Si2168_DVBT_TPS_EXTRA_CMD_struct             dvbt_tps_extra;
+    #endif /* Si2168_DVBT_TPS_EXTRA_CMD */
+
+    #ifdef    Si2168_EXIT_BOOTLOADER_CMD
+              Si2168_EXIT_BOOTLOADER_CMD_struct            exit_bootloader;
+    #endif /* Si2168_EXIT_BOOTLOADER_CMD */
+    #ifdef    Si2168_GET_PROPERTY_CMD
+              Si2168_GET_PROPERTY_CMD_struct               get_property;
+    #endif /* Si2168_GET_PROPERTY_CMD */
+    #ifdef    Si2168_GET_REV_CMD
+              Si2168_GET_REV_CMD_struct                    get_rev;
+    #endif /* Si2168_GET_REV_CMD */
+    #ifdef    Si2168_I2C_PASSTHROUGH_CMD
+              Si2168_I2C_PASSTHROUGH_CMD_struct            i2c_passthrough;
+    #endif /* Si2168_I2C_PASSTHROUGH_CMD */
+    #ifdef    Si2168_PART_INFO_CMD
+              Si2168_PART_INFO_CMD_struct                  part_info;
+    #endif /* Si2168_PART_INFO_CMD */
+    #ifdef    Si2168_POWER_DOWN_CMD
+              Si2168_POWER_DOWN_CMD_struct                 power_down;
+    #endif /* Si2168_POWER_DOWN_CMD */
+    #ifdef    Si2168_POWER_UP_CMD
+              Si2168_POWER_UP_CMD_struct                   power_up;
+    #endif /* Si2168_POWER_UP_CMD */
+    #ifdef    Si2168_RSSI_ADC_CMD
+              Si2168_RSSI_ADC_CMD_struct                   rssi_adc;
+    #endif /* Si2168_RSSI_ADC_CMD */
+    #ifdef    Si2168_SCAN_CTRL_CMD
+              Si2168_SCAN_CTRL_CMD_struct                  scan_ctrl;
+    #endif /* Si2168_SCAN_CTRL_CMD */
+    #ifdef    Si2168_SCAN_STATUS_CMD
+              Si2168_SCAN_STATUS_CMD_struct                scan_status;
+    #endif /* Si2168_SCAN_STATUS_CMD */
+    #ifdef    Si2168_SET_PROPERTY_CMD
+              Si2168_SET_PROPERTY_CMD_struct               set_property;
+    #endif /* Si2168_SET_PROPERTY_CMD */
+    #ifdef    Si2168_START_CLK_CMD
+              Si2168_START_CLK_CMD_struct                  start_clk;
+    #endif /* Si2168_START_CLK_CMD */
+  } Si2168_CmdObj;
+/* _commands_struct_insertion_point */
+
+/* _commands_reply_struct_insertion_start */
+
+  /* --------------------------------------------*/
+  /* COMMANDS REPLY STRUCT                       */
+  /* This stores all command reply fields        */
+  /* --------------------------------------------*/
+  typedef struct { /* Si2168_CmdReplyObj struct */
+    #ifdef    Si2168_CONFIG_CLKIO_CMD
+              Si2168_CONFIG_CLKIO_CMD_REPLY_struct               config_clkio;
+    #endif /* Si2168_CONFIG_CLKIO_CMD */
+    #ifdef    Si2168_CONFIG_PINS_CMD
+              Si2168_CONFIG_PINS_CMD_REPLY_struct                config_pins;
+    #endif /* Si2168_CONFIG_PINS_CMD */
+    #ifdef    Si2168_DD_BER_CMD
+              Si2168_DD_BER_CMD_REPLY_struct                     dd_ber;
+    #endif /* Si2168_DD_BER_CMD */
+    #ifdef    Si2168_DD_CBER_CMD
+              Si2168_DD_CBER_CMD_REPLY_struct                    dd_cber;
+    #endif /* Si2168_DD_CBER_CMD */
+
+    #ifdef    Si2168_DD_EXT_AGC_TER_CMD
+              Si2168_DD_EXT_AGC_TER_CMD_REPLY_struct             dd_ext_agc_ter;
+    #endif /* Si2168_DD_EXT_AGC_TER_CMD */
+
+    #ifdef    Si2168_DD_FER_CMD
+              Si2168_DD_FER_CMD_REPLY_struct                     dd_fer;
+    #endif /* Si2168_DD_FER_CMD */
+    #ifdef    Si2168_DD_GET_REG_CMD
+              Si2168_DD_GET_REG_CMD_REPLY_struct                 dd_get_reg;
+    #endif /* Si2168_DD_GET_REG_CMD */
+    #ifdef    Si2168_DD_MP_DEFAULTS_CMD
+              Si2168_DD_MP_DEFAULTS_CMD_REPLY_struct             dd_mp_defaults;
+    #endif /* Si2168_DD_MP_DEFAULTS_CMD */
+    #ifdef    Si2168_DD_PER_CMD
+              Si2168_DD_PER_CMD_REPLY_struct                     dd_per;
+    #endif /* Si2168_DD_PER_CMD */
+    #ifdef    Si2168_DD_RESTART_CMD
+              Si2168_DD_RESTART_CMD_REPLY_struct                 dd_restart;
+    #endif /* Si2168_DD_RESTART_CMD */
+    #ifdef    Si2168_DD_SET_REG_CMD
+              Si2168_DD_SET_REG_CMD_REPLY_struct                 dd_set_reg;
+    #endif /* Si2168_DD_SET_REG_CMD */
+    #ifdef    Si2168_DD_SSI_SQI_CMD
+              Si2168_DD_SSI_SQI_CMD_REPLY_struct                 dd_ssi_sqi;
+    #endif /* Si2168_DD_SSI_SQI_CMD */
+    #ifdef    Si2168_DD_STATUS_CMD
+              Si2168_DD_STATUS_CMD_REPLY_struct                  dd_status;
+    #endif /* Si2168_DD_STATUS_CMD */
+    #ifdef    Si2168_DD_UNCOR_CMD
+              Si2168_DD_UNCOR_CMD_REPLY_struct                   dd_uncor;
+    #endif /* Si2168_DD_UNCOR_CMD */
+    #ifdef    Si2168_DOWNLOAD_DATASET_CONTINUE_CMD
+              Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_REPLY_struct  download_dataset_continue;
+    #endif /* Si2168_DOWNLOAD_DATASET_CONTINUE_CMD */
+    #ifdef    Si2168_DOWNLOAD_DATASET_START_CMD
+              Si2168_DOWNLOAD_DATASET_START_CMD_REPLY_struct     download_dataset_start;
+    #endif /* Si2168_DOWNLOAD_DATASET_START_CMD */
+    #ifdef    Si2168_DVBC_STATUS_CMD
+              Si2168_DVBC_STATUS_CMD_REPLY_struct                dvbc_status;
+    #endif /* Si2168_DVBC_STATUS_CMD */
+
+
+    #ifdef    Si2168_DVBT2_FEF_CMD
+              Si2168_DVBT2_FEF_CMD_REPLY_struct                  dvbt2_fef;
+    #endif /* Si2168_DVBT2_FEF_CMD */
+    #ifdef    Si2168_DVBT2_PLP_INFO_CMD
+              Si2168_DVBT2_PLP_INFO_CMD_REPLY_struct             dvbt2_plp_info;
+    #endif /* Si2168_DVBT2_PLP_INFO_CMD */
+    #ifdef    Si2168_DVBT2_PLP_SELECT_CMD
+              Si2168_DVBT2_PLP_SELECT_CMD_REPLY_struct           dvbt2_plp_select;
+    #endif /* Si2168_DVBT2_PLP_SELECT_CMD */
+    #ifdef    Si2168_DVBT2_STATUS_CMD
+              Si2168_DVBT2_STATUS_CMD_REPLY_struct               dvbt2_status;
+    #endif /* Si2168_DVBT2_STATUS_CMD */
+    #ifdef    Si2168_DVBT2_TX_ID_CMD
+              Si2168_DVBT2_TX_ID_CMD_REPLY_struct                dvbt2_tx_id;
+    #endif /* Si2168_DVBT2_TX_ID_CMD */
+
+    #ifdef    Si2168_DVBT_STATUS_CMD
+              Si2168_DVBT_STATUS_CMD_REPLY_struct                dvbt_status;
+    #endif /* Si2168_DVBT_STATUS_CMD */
+    #ifdef    Si2168_DVBT_TPS_EXTRA_CMD
+              Si2168_DVBT_TPS_EXTRA_CMD_REPLY_struct             dvbt_tps_extra;
+    #endif /* Si2168_DVBT_TPS_EXTRA_CMD */
+
+    #ifdef    Si2168_EXIT_BOOTLOADER_CMD
+              Si2168_EXIT_BOOTLOADER_CMD_REPLY_struct            exit_bootloader;
+    #endif /* Si2168_EXIT_BOOTLOADER_CMD */
+    #ifdef    Si2168_GET_PROPERTY_CMD
+              Si2168_GET_PROPERTY_CMD_REPLY_struct               get_property;
+    #endif /* Si2168_GET_PROPERTY_CMD */
+    #ifdef    Si2168_GET_REV_CMD
+              Si2168_GET_REV_CMD_REPLY_struct                    get_rev;
+    #endif /* Si2168_GET_REV_CMD */
+    #ifdef    Si2168_I2C_PASSTHROUGH_CMD
+              Si2168_I2C_PASSTHROUGH_CMD_REPLY_struct            i2c_passthrough;
+    #endif /* Si2168_I2C_PASSTHROUGH_CMD */
+    #ifdef    Si2168_PART_INFO_CMD
+              Si2168_PART_INFO_CMD_REPLY_struct                  part_info;
+    #endif /* Si2168_PART_INFO_CMD */
+    #ifdef    Si2168_POWER_DOWN_CMD
+              Si2168_POWER_DOWN_CMD_REPLY_struct                 power_down;
+    #endif /* Si2168_POWER_DOWN_CMD */
+    #ifdef    Si2168_POWER_UP_CMD
+              Si2168_POWER_UP_CMD_REPLY_struct                   power_up;
+    #endif /* Si2168_POWER_UP_CMD */
+    #ifdef    Si2168_RSSI_ADC_CMD
+              Si2168_RSSI_ADC_CMD_REPLY_struct                   rssi_adc;
+    #endif /* Si2168_RSSI_ADC_CMD */
+    #ifdef    Si2168_SCAN_CTRL_CMD
+              Si2168_SCAN_CTRL_CMD_REPLY_struct                  scan_ctrl;
+    #endif /* Si2168_SCAN_CTRL_CMD */
+    #ifdef    Si2168_SCAN_STATUS_CMD
+              Si2168_SCAN_STATUS_CMD_REPLY_struct                scan_status;
+    #endif /* Si2168_SCAN_STATUS_CMD */
+    #ifdef    Si2168_SET_PROPERTY_CMD
+              Si2168_SET_PROPERTY_CMD_REPLY_struct               set_property;
+    #endif /* Si2168_SET_PROPERTY_CMD */
+    #ifdef    Si2168_START_CLK_CMD
+              Si2168_START_CLK_CMD_REPLY_struct                  start_clk;
+    #endif /* Si2168_START_CLK_CMD */
+  } Si2168_CmdReplyObj;
+/* _commands_reply_struct_insertion_point */
+
+#ifdef    Si2168_COMMAND_PROTOTYPES
+#define   Si2168_GET_COMMAND_STRINGS
+#endif /* Si2168_COMMAND_PROTOTYPES */
+
+#endif /* Si2168_COMMANDS_H */
+
+
+
+
+
diff -urN a/drivers/media/dvb-frontends/si2168_demod.c b/drivers/media/dvb-frontends/si2168_demod.c
--- a/drivers/media/dvb-frontends/si2168_demod.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/si2168_demod.c	2013-02-17 17:57:28.000000000 +0800
@@ -0,0 +1,5100 @@
+/****************************************************************/
+#include "si2168_20_ROM2_Patch_2_0b5.h"
+#include "si2168_priv.h"
+
+/***********************************************************************************************************************
+  Si2168_CurrentResponseStatus function
+  Use:        status checking function
+              Used to fill the Si2168_COMMON_REPLY_struct members with the ptDataBuffer byte's bits
+  Comments:   The status byte definition being identical for all commands,
+              using this function to fill the status structure helps reducing the code size
+  Parameter: ptDataBuffer  a single byte received when reading a command's response (the first byte)
+  Returns:   0 if the err bit (bit 6) is unset, 1 otherwise
+ ***********************************************************************************************************************/
+unsigned char Si2168_CurrentResponseStatus (L1_Si2168_Context *api, unsigned char ptDataBuffer)
+{
+/* _status_code_insertion_start */
+    api->status->ddint   = ((ptDataBuffer >> 0 ) & 0x01);
+    api->status->scanint = ((ptDataBuffer >> 1 ) & 0x01);
+    api->status->err     = ((ptDataBuffer >> 6 ) & 0x01);
+    api->status->cts     = ((ptDataBuffer >> 7 ) & 0x01);
+/* _status_code_insertion_point */
+  return (api->status->err ? ERROR_Si2168_ERR : NO_Si2168_ERROR);
+}
+
+  /* --------------------------------------------*/
+  /* SEND_COMMAND2 FUNCTION                      */
+  /* --------------------------------------------*/
+unsigned char   Si2168_L1_SendCommand2(L1_Si2168_Context *api, unsigned int cmd_code) {
+    switch (cmd_code) {
+    #ifdef        Si2168_CONFIG_CLKIO_CMD
+     case         Si2168_CONFIG_CLKIO_CMD_CODE:
+       return Si2168_L1_CONFIG_CLKIO (api, api->cmd->config_clkio.output, api->cmd->config_clkio.pre_driver_str, api->cmd->config_clkio.driver_str );
+     break;
+    #endif /*     Si2168_CONFIG_CLKIO_CMD */
+    #ifdef        Si2168_CONFIG_PINS_CMD
+     case         Si2168_CONFIG_PINS_CMD_CODE:
+       return Si2168_L1_CONFIG_PINS (api, api->cmd->config_pins.gpio0_mode, api->cmd->config_pins.gpio0_read, api->cmd->config_pins.gpio1_mode, api->cmd->config_pins.gpio1_read );
+     break;
+    #endif /*     Si2168_CONFIG_PINS_CMD */
+    #ifdef        Si2168_DD_BER_CMD
+     case         Si2168_DD_BER_CMD_CODE:
+       return Si2168_L1_DD_BER (api, api->cmd->dd_ber.rst );
+     break;
+    #endif /*     Si2168_DD_BER_CMD */
+    #ifdef        Si2168_DD_CBER_CMD
+     case         Si2168_DD_CBER_CMD_CODE:
+       return Si2168_L1_DD_CBER (api, api->cmd->dd_cber.rst );
+     break;
+    #endif /*     Si2168_DD_CBER_CMD */
+
+    #ifdef        Si2168_DD_EXT_AGC_TER_CMD
+     case         Si2168_DD_EXT_AGC_TER_CMD_CODE:
+       return Si2168_L1_DD_EXT_AGC_TER (api, api->cmd->dd_ext_agc_ter.agc_1_mode, api->cmd->dd_ext_agc_ter.agc_1_inv, api->cmd->dd_ext_agc_ter.agc_2_mode, api->cmd->dd_ext_agc_ter.agc_2_inv, api->cmd->dd_ext_agc_ter.agc_1_kloop, api->cmd->dd_ext_agc_ter.agc_2_kloop, api->cmd->dd_ext_agc_ter.agc_1_min, api->cmd->dd_ext_agc_ter.agc_2_min );
+     break;
+    #endif /*     Si2168_DD_EXT_AGC_TER_CMD */
+
+    #ifdef        Si2168_DD_FER_CMD
+     case         Si2168_DD_FER_CMD_CODE:
+       return Si2168_L1_DD_FER (api, api->cmd->dd_fer.rst );
+     break;
+    #endif /*     Si2168_DD_FER_CMD */
+    #ifdef        Si2168_DD_GET_REG_CMD
+     case         Si2168_DD_GET_REG_CMD_CODE:
+       return Si2168_L1_DD_GET_REG (api, api->cmd->dd_get_reg.reg_code_lsb, api->cmd->dd_get_reg.reg_code_mid, api->cmd->dd_get_reg.reg_code_msb );
+     break;
+    #endif /*     Si2168_DD_GET_REG_CMD */
+    #ifdef        Si2168_DD_MP_DEFAULTS_CMD
+     case         Si2168_DD_MP_DEFAULTS_CMD_CODE:
+       return Si2168_L1_DD_MP_DEFAULTS (api, api->cmd->dd_mp_defaults.mp_a_mode, api->cmd->dd_mp_defaults.mp_b_mode, api->cmd->dd_mp_defaults.mp_c_mode, api->cmd->dd_mp_defaults.mp_d_mode );
+     break;
+    #endif /*     Si2168_DD_MP_DEFAULTS_CMD */
+    #ifdef        Si2168_DD_PER_CMD
+     case         Si2168_DD_PER_CMD_CODE:
+       return Si2168_L1_DD_PER (api, api->cmd->dd_per.rst );
+     break;
+    #endif /*     Si2168_DD_PER_CMD */
+    #ifdef        Si2168_DD_RESTART_CMD
+     case         Si2168_DD_RESTART_CMD_CODE:
+       return Si2168_L1_DD_RESTART (api );
+     break;
+    #endif /*     Si2168_DD_RESTART_CMD */
+    #ifdef        Si2168_DD_SET_REG_CMD
+     case         Si2168_DD_SET_REG_CMD_CODE:
+       return Si2168_L1_DD_SET_REG (api, api->cmd->dd_set_reg.reg_code_lsb, api->cmd->dd_set_reg.reg_code_mid, api->cmd->dd_set_reg.reg_code_msb, api->cmd->dd_set_reg.value );
+     break;
+    #endif /*     Si2168_DD_SET_REG_CMD */
+    #ifdef        Si2168_DD_SSI_SQI_CMD
+     case         Si2168_DD_SSI_SQI_CMD_CODE:
+       return Si2168_L1_DD_SSI_SQI (api, api->cmd->dd_ssi_sqi.tuner_rssi );
+     break;
+    #endif /*     Si2168_DD_SSI_SQI_CMD */
+    #ifdef        Si2168_DD_STATUS_CMD
+     case         Si2168_DD_STATUS_CMD_CODE:
+       return Si2168_L1_DD_STATUS (api, api->cmd->dd_status.intack );
+     break;
+    #endif /*     Si2168_DD_STATUS_CMD */
+    #ifdef        Si2168_DD_UNCOR_CMD
+     case         Si2168_DD_UNCOR_CMD_CODE:
+       return Si2168_L1_DD_UNCOR (api, api->cmd->dd_uncor.rst );
+     break;
+    #endif /*     Si2168_DD_UNCOR_CMD */
+    #ifdef        Si2168_DOWNLOAD_DATASET_CONTINUE_CMD
+     case         Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_CODE:
+       return Si2168_L1_DOWNLOAD_DATASET_CONTINUE (api, api->cmd->download_dataset_continue.data0, api->cmd->download_dataset_continue.data1, api->cmd->download_dataset_continue.data2, api->cmd->download_dataset_continue.data3, api->cmd->download_dataset_continue.data4, api->cmd->download_dataset_continue.data5, api->cmd->download_dataset_continue.data6 );
+     break;
+    #endif /*     Si2168_DOWNLOAD_DATASET_CONTINUE_CMD */
+    #ifdef        Si2168_DOWNLOAD_DATASET_START_CMD
+     case         Si2168_DOWNLOAD_DATASET_START_CMD_CODE:
+       return Si2168_L1_DOWNLOAD_DATASET_START (api, api->cmd->download_dataset_start.dataset_id, api->cmd->download_dataset_start.dataset_checksum, api->cmd->download_dataset_start.data0, api->cmd->download_dataset_start.data1, api->cmd->download_dataset_start.data2, api->cmd->download_dataset_start.data3, api->cmd->download_dataset_start.data4 );
+     break;
+    #endif /*     Si2168_DOWNLOAD_DATASET_START_CMD */
+    #ifdef        Si2168_DVBC_STATUS_CMD
+     case         Si2168_DVBC_STATUS_CMD_CODE:
+       return Si2168_L1_DVBC_STATUS (api, api->cmd->dvbc_status.intack );
+     break;
+    #endif /*     Si2168_DVBC_STATUS_CMD */
+
+
+    #ifdef        Si2168_DVBT2_FEF_CMD
+     case         Si2168_DVBT2_FEF_CMD_CODE:
+       return Si2168_L1_DVBT2_FEF (api, api->cmd->dvbt2_fef.fef_tuner_flag, api->cmd->dvbt2_fef.fef_tuner_flag_inv );
+     break;
+    #endif /*     Si2168_DVBT2_FEF_CMD */
+    #ifdef        Si2168_DVBT2_PLP_INFO_CMD
+     case         Si2168_DVBT2_PLP_INFO_CMD_CODE:
+       return Si2168_L1_DVBT2_PLP_INFO (api, api->cmd->dvbt2_plp_info.plp_index );
+     break;
+    #endif /*     Si2168_DVBT2_PLP_INFO_CMD */
+    #ifdef        Si2168_DVBT2_PLP_SELECT_CMD
+     case         Si2168_DVBT2_PLP_SELECT_CMD_CODE:
+       return Si2168_L1_DVBT2_PLP_SELECT (api, api->cmd->dvbt2_plp_select.plp_id, api->cmd->dvbt2_plp_select.plp_id_sel_mode );
+     break;
+    #endif /*     Si2168_DVBT2_PLP_SELECT_CMD */
+    #ifdef        Si2168_DVBT2_STATUS_CMD
+     case         Si2168_DVBT2_STATUS_CMD_CODE:
+       return Si2168_L1_DVBT2_STATUS (api, api->cmd->dvbt2_status.intack );
+     break;
+    #endif /*     Si2168_DVBT2_STATUS_CMD */
+    #ifdef        Si2168_DVBT2_TX_ID_CMD
+     case         Si2168_DVBT2_TX_ID_CMD_CODE:
+       return Si2168_L1_DVBT2_TX_ID (api );
+     break;
+    #endif /*     Si2168_DVBT2_TX_ID_CMD */
+
+    #ifdef        Si2168_DVBT_STATUS_CMD
+     case         Si2168_DVBT_STATUS_CMD_CODE:
+       return Si2168_L1_DVBT_STATUS (api, api->cmd->dvbt_status.intack );
+     break;
+    #endif /*     Si2168_DVBT_STATUS_CMD */
+    #ifdef        Si2168_DVBT_TPS_EXTRA_CMD
+     case         Si2168_DVBT_TPS_EXTRA_CMD_CODE:
+       return Si2168_L1_DVBT_TPS_EXTRA (api );
+     break;
+    #endif /*     Si2168_DVBT_TPS_EXTRA_CMD */
+
+    #ifdef        Si2168_EXIT_BOOTLOADER_CMD
+     case         Si2168_EXIT_BOOTLOADER_CMD_CODE:
+       return Si2168_L1_EXIT_BOOTLOADER (api, api->cmd->exit_bootloader.func, api->cmd->exit_bootloader.ctsien );
+     break;
+    #endif /*     Si2168_EXIT_BOOTLOADER_CMD */
+    #ifdef        Si2168_GET_PROPERTY_CMD
+     case         Si2168_GET_PROPERTY_CMD_CODE:
+       return Si2168_L1_GET_PROPERTY (api, api->cmd->get_property.reserved, api->cmd->get_property.prop );
+     break;
+    #endif /*     Si2168_GET_PROPERTY_CMD */
+    #ifdef        Si2168_GET_REV_CMD
+     case         Si2168_GET_REV_CMD_CODE:
+       return Si2168_L1_GET_REV (api );
+     break;
+    #endif /*     Si2168_GET_REV_CMD */
+    #ifdef        Si2168_I2C_PASSTHROUGH_CMD
+     case         Si2168_I2C_PASSTHROUGH_CMD_CODE:
+       return Si2168_L1_I2C_PASSTHROUGH (api, api->cmd->i2c_passthrough.subcode, api->cmd->i2c_passthrough.i2c_passthru, api->cmd->i2c_passthrough.reserved );
+     break;
+    #endif /*     Si2168_I2C_PASSTHROUGH_CMD */
+    #ifdef        Si2168_PART_INFO_CMD
+     case         Si2168_PART_INFO_CMD_CODE:
+       return Si2168_L1_PART_INFO (api );
+     break;
+    #endif /*     Si2168_PART_INFO_CMD */
+    #ifdef        Si2168_POWER_DOWN_CMD
+     case         Si2168_POWER_DOWN_CMD_CODE:
+       return Si2168_L1_POWER_DOWN (api );
+     break;
+    #endif /*     Si2168_POWER_DOWN_CMD */
+    #ifdef        Si2168_POWER_UP_CMD
+     case         Si2168_POWER_UP_CMD_CODE:
+       return Si2168_L1_POWER_UP (api, api->cmd->power_up.subcode, api->cmd->power_up.reset, api->cmd->power_up.reserved2, api->cmd->power_up.reserved4, api->cmd->power_up.reserved1, api->cmd->power_up.addr_mode, api->cmd->power_up.reserved5, api->cmd->power_up.func, api->cmd->power_up.clock_freq, api->cmd->power_up.ctsien, api->cmd->power_up.wake_up );
+     break;
+    #endif /*     Si2168_POWER_UP_CMD */
+    #ifdef        Si2168_RSSI_ADC_CMD
+     case         Si2168_RSSI_ADC_CMD_CODE:
+       return Si2168_L1_RSSI_ADC (api, api->cmd->rssi_adc.on_off );
+     break;
+    #endif /*     Si2168_RSSI_ADC_CMD */
+    #ifdef        Si2168_SCAN_CTRL_CMD
+     case         Si2168_SCAN_CTRL_CMD_CODE:
+       return Si2168_L1_SCAN_CTRL (api, api->cmd->scan_ctrl.action, api->cmd->scan_ctrl.tuned_rf_freq );
+     break;
+    #endif /*     Si2168_SCAN_CTRL_CMD */
+    #ifdef        Si2168_SCAN_STATUS_CMD
+     case         Si2168_SCAN_STATUS_CMD_CODE:
+       return Si2168_L1_SCAN_STATUS (api, api->cmd->scan_status.intack );
+     break;
+    #endif /*     Si2168_SCAN_STATUS_CMD */
+    #ifdef        Si2168_SET_PROPERTY_CMD
+     case         Si2168_SET_PROPERTY_CMD_CODE:
+       return Si2168_L1_SET_PROPERTY (api, api->cmd->set_property.reserved, api->cmd->set_property.prop, api->cmd->set_property.data );
+     break;
+    #endif /*     Si2168_SET_PROPERTY_CMD */
+    #ifdef        Si2168_START_CLK_CMD
+     case         Si2168_START_CLK_CMD_CODE:
+       return Si2168_L1_START_CLK (api, api->cmd->start_clk.subcode, api->cmd->start_clk.reserved1, api->cmd->start_clk.tune_cap, api->cmd->start_clk.reserved2, api->cmd->start_clk.clk_mode, api->cmd->start_clk.reserved3, api->cmd->start_clk.reserved4, api->cmd->start_clk.start_clk );
+     break;
+    #endif /*     Si2168_START_CLK_CMD */
+   default : break;
+    }
+     return 0;
+  }
+
+#ifdef    Si2168_DD_STATUS_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DD_STATUS COMMAND                        */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DD_STATUS                 (L1_Si2168_Context *api,
+                                                   unsigned char   intack)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[8];
+    api->rsp->dd_status.STATUS = api->status;
+
+    SiTRACE("Si2168 DD_STATUS ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((intack > Si2168_DD_STATUS_CMD_INTACK_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("INTACK %d ", intack );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DD_STATUS_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( intack & Si2168_DD_STATUS_CMD_INTACK_MASK ) << Si2168_DD_STATUS_CMD_INTACK_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing DD_STATUS bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 8, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DD_STATUS response\n");
+      return error_code;
+    }
+
+    api->rsp->dd_status.pclint       =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_STATUS_RESPONSE_PCLINT_LSB       ) & Si2168_DD_STATUS_RESPONSE_PCLINT_MASK       );
+    api->rsp->dd_status.dlint        =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_STATUS_RESPONSE_DLINT_LSB        ) & Si2168_DD_STATUS_RESPONSE_DLINT_MASK        );
+    api->rsp->dd_status.berint       =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_STATUS_RESPONSE_BERINT_LSB       ) & Si2168_DD_STATUS_RESPONSE_BERINT_MASK       );
+    api->rsp->dd_status.uncorint     =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_STATUS_RESPONSE_UNCORINT_LSB     ) & Si2168_DD_STATUS_RESPONSE_UNCORINT_MASK     );
+    api->rsp->dd_status.rsqint_bit5  =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_STATUS_RESPONSE_RSQINT_BIT5_LSB  ) & Si2168_DD_STATUS_RESPONSE_RSQINT_BIT5_MASK  );
+    api->rsp->dd_status.rsqint_bit6  =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_STATUS_RESPONSE_RSQINT_BIT6_LSB  ) & Si2168_DD_STATUS_RESPONSE_RSQINT_BIT6_MASK  );
+    api->rsp->dd_status.rsqint_bit7  =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_STATUS_RESPONSE_RSQINT_BIT7_LSB  ) & Si2168_DD_STATUS_RESPONSE_RSQINT_BIT7_MASK  );
+    api->rsp->dd_status.pcl          =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_STATUS_RESPONSE_PCL_LSB          ) & Si2168_DD_STATUS_RESPONSE_PCL_MASK          );
+    api->rsp->dd_status.dl           =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_STATUS_RESPONSE_DL_LSB           ) & Si2168_DD_STATUS_RESPONSE_DL_MASK           );
+    api->rsp->dd_status.ber          =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_STATUS_RESPONSE_BER_LSB          ) & Si2168_DD_STATUS_RESPONSE_BER_MASK          );
+    api->rsp->dd_status.uncor        =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_STATUS_RESPONSE_UNCOR_LSB        ) & Si2168_DD_STATUS_RESPONSE_UNCOR_MASK        );
+    api->rsp->dd_status.rsqstat_bit5 =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT5_LSB ) & Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT5_MASK );
+    api->rsp->dd_status.rsqstat_bit6 =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT6_LSB ) & Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT6_MASK );
+    api->rsp->dd_status.rsqstat_bit7 =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT7_LSB ) & Si2168_DD_STATUS_RESPONSE_RSQSTAT_BIT7_MASK );
+    api->rsp->dd_status.modulation   =   (( ( (rspByteBuffer[3]  )) >> Si2168_DD_STATUS_RESPONSE_MODULATION_LSB   ) & Si2168_DD_STATUS_RESPONSE_MODULATION_MASK   );
+    api->rsp->dd_status.ts_bit_rate  =   (( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 )) >> Si2168_DD_STATUS_RESPONSE_TS_BIT_RATE_LSB  ) & Si2168_DD_STATUS_RESPONSE_TS_BIT_RATE_MASK  );
+    api->rsp->dd_status.ts_clk_freq  =   (( ( (rspByteBuffer[6]  ) | (rspByteBuffer[7]  << 8 )) >> Si2168_DD_STATUS_RESPONSE_TS_CLK_FREQ_LSB  ) & Si2168_DD_STATUS_RESPONSE_TS_CLK_FREQ_MASK  );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DD_STATUS_CMD */
+
+#ifdef    Si2168_I2C_PASSTHROUGH_CMD
+ /*---------------------------------------------------*/
+/* Si2168_I2C_PASSTHROUGH COMMAND                  */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_I2C_PASSTHROUGH           (L1_Si2168_Context *api,
+                                                   unsigned char   subcode,
+                                                   unsigned char   i2c_passthru,
+                                                   unsigned char   reserved)
+{
+    /*unsigned char error_code = 0;*/
+    unsigned char cmdByteBuffer[3];
+    api->rsp->i2c_passthrough.STATUS = api->status;
+
+    SiTRACE("Si2168 I2C_PASSTHROUGH ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((subcode      > Si2168_I2C_PASSTHROUGH_CMD_SUBCODE_MAX     )  || (subcode      < Si2168_I2C_PASSTHROUGH_CMD_SUBCODE_MIN     ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("SUBCODE %d "     , subcode      );
+    if ((i2c_passthru > Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("I2C_PASSTHRU %d ", i2c_passthru );
+    if ((reserved     > Si2168_I2C_PASSTHROUGH_CMD_RESERVED_MAX    ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED %d "    , reserved     );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_I2C_PASSTHROUGH_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( subcode      & Si2168_I2C_PASSTHROUGH_CMD_SUBCODE_MASK      ) << Si2168_I2C_PASSTHROUGH_CMD_SUBCODE_LSB     );
+    cmdByteBuffer[2] = (unsigned char) ( ( i2c_passthru & Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_MASK ) << Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_LSB|
+                                         ( reserved     & Si2168_I2C_PASSTHROUGH_CMD_RESERVED_MASK     ) << Si2168_I2C_PASSTHROUGH_CMD_RESERVED_LSB    );
+
+    if (L0_WriteCommandBytes(api->i2c, 3, cmdByteBuffer) != 3) {
+      SiTRACE("Error writing I2C_PASSTHROUGH bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_I2C_PASSTHROUGH_CMD */
+
+#ifdef    Si2168_CONFIG_CLKIO_CMD
+ /*---------------------------------------------------*/
+/* Si2168_CONFIG_CLKIO COMMAND                     */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_CONFIG_CLKIO              (L1_Si2168_Context *api,
+                                                   unsigned char   output,
+                                                   unsigned char   pre_driver_str,
+                                                   unsigned char   driver_str)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[4];
+    api->rsp->config_clkio.STATUS = api->status;
+
+    SiTRACE("Si2168 CONFIG_CLKIO ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((output         > Si2168_CONFIG_CLKIO_CMD_OUTPUT_MAX        ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("OUTPUT %d "        , output         );
+    if ((pre_driver_str > Si2168_CONFIG_CLKIO_CMD_PRE_DRIVER_STR_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("PRE_DRIVER_STR %d ", pre_driver_str );
+    if ((driver_str     > Si2168_CONFIG_CLKIO_CMD_DRIVER_STR_MAX    ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("DRIVER_STR %d "    , driver_str     );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_CONFIG_CLKIO_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( output         & Si2168_CONFIG_CLKIO_CMD_OUTPUT_MASK         ) << Si2168_CONFIG_CLKIO_CMD_OUTPUT_LSB        |
+                                         ( pre_driver_str & Si2168_CONFIG_CLKIO_CMD_PRE_DRIVER_STR_MASK ) << Si2168_CONFIG_CLKIO_CMD_PRE_DRIVER_STR_LSB|
+                                         ( driver_str     & Si2168_CONFIG_CLKIO_CMD_DRIVER_STR_MASK     ) << Si2168_CONFIG_CLKIO_CMD_DRIVER_STR_LSB    );
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing CONFIG_CLKIO bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 4, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling CONFIG_CLKIO response\n");
+      return error_code;
+    }
+
+    api->rsp->config_clkio.mode           =   (( ( (rspByteBuffer[1]  )) >> Si2168_CONFIG_CLKIO_RESPONSE_MODE_LSB           ) & Si2168_CONFIG_CLKIO_RESPONSE_MODE_MASK           );
+    api->rsp->config_clkio.pre_driver_str =   (( ( (rspByteBuffer[2]  )) >> Si2168_CONFIG_CLKIO_RESPONSE_PRE_DRIVER_STR_LSB ) & Si2168_CONFIG_CLKIO_RESPONSE_PRE_DRIVER_STR_MASK );
+    api->rsp->config_clkio.driver_str     =   (( ( (rspByteBuffer[3]  )) >> Si2168_CONFIG_CLKIO_RESPONSE_DRIVER_STR_LSB     ) & Si2168_CONFIG_CLKIO_RESPONSE_DRIVER_STR_MASK     );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_CONFIG_CLKIO_CMD */
+#ifdef    Si2168_CONFIG_PINS_CMD
+ /*---------------------------------------------------*/
+/* Si2168_CONFIG_PINS COMMAND                      */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_CONFIG_PINS               (L1_Si2168_Context *api,
+                                                   unsigned char   gpio0_mode,
+                                                   unsigned char   gpio0_read,
+                                                   unsigned char   gpio1_mode,
+                                                   unsigned char   gpio1_read)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[3];
+    unsigned char rspByteBuffer[3];
+    api->rsp->config_pins.STATUS = api->status;
+
+    SiTRACE("Si2168 CONFIG_PINS ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((gpio0_mode > Si2168_CONFIG_PINS_CMD_GPIO0_MODE_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("GPIO0_MODE %d ", gpio0_mode );
+    if ((gpio0_read > Si2168_CONFIG_PINS_CMD_GPIO0_READ_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("GPIO0_READ %d ", gpio0_read );
+    if ((gpio1_mode > Si2168_CONFIG_PINS_CMD_GPIO1_MODE_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("GPIO1_MODE %d ", gpio1_mode );
+    if ((gpio1_read > Si2168_CONFIG_PINS_CMD_GPIO1_READ_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("GPIO1_READ %d ", gpio1_read );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_CONFIG_PINS_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( gpio0_mode & Si2168_CONFIG_PINS_CMD_GPIO0_MODE_MASK ) << Si2168_CONFIG_PINS_CMD_GPIO0_MODE_LSB|
+                                         ( gpio0_read & Si2168_CONFIG_PINS_CMD_GPIO0_READ_MASK ) << Si2168_CONFIG_PINS_CMD_GPIO0_READ_LSB);
+    cmdByteBuffer[2] = (unsigned char) ( ( gpio1_mode & Si2168_CONFIG_PINS_CMD_GPIO1_MODE_MASK ) << Si2168_CONFIG_PINS_CMD_GPIO1_MODE_LSB|
+                                         ( gpio1_read & Si2168_CONFIG_PINS_CMD_GPIO1_READ_MASK ) << Si2168_CONFIG_PINS_CMD_GPIO1_READ_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 3, cmdByteBuffer) != 3) {
+      SiTRACE("Error writing CONFIG_PINS bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 3, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling CONFIG_PINS response\n");
+      return error_code;
+    }
+
+    api->rsp->config_pins.gpio0_mode  =   (( ( (rspByteBuffer[1]  )) >> Si2168_CONFIG_PINS_RESPONSE_GPIO0_MODE_LSB  ) & Si2168_CONFIG_PINS_RESPONSE_GPIO0_MODE_MASK  );
+    api->rsp->config_pins.gpio0_state =   (( ( (rspByteBuffer[1]  )) >> Si2168_CONFIG_PINS_RESPONSE_GPIO0_STATE_LSB ) & Si2168_CONFIG_PINS_RESPONSE_GPIO0_STATE_MASK );
+    api->rsp->config_pins.gpio1_mode  =   (( ( (rspByteBuffer[2]  )) >> Si2168_CONFIG_PINS_RESPONSE_GPIO1_MODE_LSB  ) & Si2168_CONFIG_PINS_RESPONSE_GPIO1_MODE_MASK  );
+    api->rsp->config_pins.gpio1_state =   (( ( (rspByteBuffer[2]  )) >> Si2168_CONFIG_PINS_RESPONSE_GPIO1_STATE_LSB ) & Si2168_CONFIG_PINS_RESPONSE_GPIO1_STATE_MASK );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_CONFIG_PINS_CMD */
+
+#ifdef    Si2168_DD_BER_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DD_BER COMMAND                           */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DD_BER                    (L1_Si2168_Context *api,
+                                                   unsigned char   rst)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[3];
+    api->rsp->dd_ber.STATUS = api->status;
+
+    SiTRACE("Si2168 DD_BER ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((rst > Si2168_DD_BER_CMD_RST_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RST %d ", rst );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DD_BER_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( rst & Si2168_DD_BER_CMD_RST_MASK ) << Si2168_DD_BER_CMD_RST_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing DD_BER bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 3, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DD_BER response\n");
+      return error_code;
+    }
+
+    api->rsp->dd_ber.exp  =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_BER_RESPONSE_EXP_LSB  ) & Si2168_DD_BER_RESPONSE_EXP_MASK  );
+    api->rsp->dd_ber.mant =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_BER_RESPONSE_MANT_LSB ) & Si2168_DD_BER_RESPONSE_MANT_MASK );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DD_BER_CMD */
+
+#ifdef    Si2168_DD_CBER_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DD_CBER COMMAND                          */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DD_CBER                   (L1_Si2168_Context *api,
+                                                   unsigned char   rst)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[3];
+    api->rsp->dd_cber.STATUS = api->status;
+
+    SiTRACE("Si2168 DD_CBER ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((rst > Si2168_DD_CBER_CMD_RST_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RST %d ", rst );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DD_CBER_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( rst & Si2168_DD_CBER_CMD_RST_MASK ) << Si2168_DD_CBER_CMD_RST_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing DD_CBER bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 3, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DD_CBER response\n");
+      return error_code;
+    }
+
+    api->rsp->dd_cber.exp  =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_CBER_RESPONSE_EXP_LSB  ) & Si2168_DD_CBER_RESPONSE_EXP_MASK  );
+    api->rsp->dd_cber.mant =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_CBER_RESPONSE_MANT_LSB ) & Si2168_DD_CBER_RESPONSE_MANT_MASK );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DD_CBER_CMD */
+
+#ifdef    Si2168_DD_EXT_AGC_TER_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DD_EXT_AGC_TER COMMAND                   */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DD_EXT_AGC_TER            (L1_Si2168_Context *api,
+                                                   unsigned char   agc_1_mode,
+                                                   unsigned char   agc_1_inv,
+                                                   unsigned char   agc_2_mode,
+                                                   unsigned char   agc_2_inv,
+                                                   unsigned char   agc_1_kloop,
+                                                   unsigned char   agc_2_kloop,
+                                                   unsigned char   agc_1_min,
+                                                   unsigned char   agc_2_min)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[6];
+    unsigned char rspByteBuffer[3];
+    api->rsp->dd_ext_agc_ter.STATUS = api->status;
+
+    SiTRACE("Si2168 DD_EXT_AGC_TER ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((agc_1_mode  > Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MAX ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("AGC_1_MODE %d " , agc_1_mode  );
+    if ((agc_1_inv   > Si2168_DD_EXT_AGC_TER_CMD_AGC_1_INV_MAX  ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("AGC_1_INV %d "  , agc_1_inv   );
+    if ((agc_2_mode  > Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MAX ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("AGC_2_MODE %d " , agc_2_mode  );
+    if ((agc_2_inv   > Si2168_DD_EXT_AGC_TER_CMD_AGC_2_INV_MAX  ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("AGC_2_INV %d "  , agc_2_inv   );
+    if ((agc_1_kloop > Si2168_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_MAX)  || (agc_1_kloop < Si2168_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_MIN) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("AGC_1_KLOOP %d ", agc_1_kloop );
+    if ((agc_2_kloop > Si2168_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_MAX)  || (agc_2_kloop < Si2168_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_MIN) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("AGC_2_KLOOP %d ", agc_2_kloop );
+    SiTRACE("AGC_1_MIN %d "  , agc_1_min   );
+    SiTRACE("AGC_2_MIN %d "  , agc_2_min   );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DD_EXT_AGC_TER_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( agc_1_mode  & Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_MASK  ) << Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_LSB |
+                                         ( agc_1_inv   & Si2168_DD_EXT_AGC_TER_CMD_AGC_1_INV_MASK   ) << Si2168_DD_EXT_AGC_TER_CMD_AGC_1_INV_LSB  |
+                                         ( agc_2_mode  & Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MASK  ) << Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_LSB |
+                                         ( agc_2_inv   & Si2168_DD_EXT_AGC_TER_CMD_AGC_2_INV_MASK   ) << Si2168_DD_EXT_AGC_TER_CMD_AGC_2_INV_LSB  );
+    cmdByteBuffer[2] = (unsigned char) ( ( agc_1_kloop & Si2168_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_MASK ) << Si2168_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_LSB);
+    cmdByteBuffer[3] = (unsigned char) ( ( agc_2_kloop & Si2168_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_MASK ) << Si2168_DD_EXT_AGC_TER_CMD_AGC_2_KLOOP_LSB);
+    cmdByteBuffer[4] = (unsigned char) ( ( agc_1_min   & Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MIN_MASK   ) << Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MIN_LSB  );
+    cmdByteBuffer[5] = (unsigned char) ( ( agc_2_min   & Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MIN_MASK   ) << Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MIN_LSB  );
+
+    if (L0_WriteCommandBytes(api->i2c, 6, cmdByteBuffer) != 6) {
+      SiTRACE("Error writing DD_EXT_AGC_TER bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 3, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DD_EXT_AGC_TER response\n");
+      return error_code;
+    }
+
+    api->rsp->dd_ext_agc_ter.agc_1_level =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_EXT_AGC_TER_RESPONSE_AGC_1_LEVEL_LSB ) & Si2168_DD_EXT_AGC_TER_RESPONSE_AGC_1_LEVEL_MASK );
+    api->rsp->dd_ext_agc_ter.agc_2_level =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_EXT_AGC_TER_RESPONSE_AGC_2_LEVEL_LSB ) & Si2168_DD_EXT_AGC_TER_RESPONSE_AGC_2_LEVEL_MASK );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DD_EXT_AGC_TER_CMD */
+
+#ifdef    Si2168_DD_FER_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DD_FER COMMAND                           */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DD_FER                    (L1_Si2168_Context *api,
+                                                   unsigned char   rst)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[3];
+    api->rsp->dd_fer.STATUS = api->status;
+
+    SiTRACE("Si2168 DD_FER ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((rst > Si2168_DD_FER_CMD_RST_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RST %d ", rst );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DD_FER_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( rst & Si2168_DD_FER_CMD_RST_MASK ) << Si2168_DD_FER_CMD_RST_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing DD_FER bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 3, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DD_FER response\n");
+      return error_code;
+    }
+
+    api->rsp->dd_fer.exp  =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_FER_RESPONSE_EXP_LSB  ) & Si2168_DD_FER_RESPONSE_EXP_MASK  );
+    api->rsp->dd_fer.mant =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_FER_RESPONSE_MANT_LSB ) & Si2168_DD_FER_RESPONSE_MANT_MASK );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DD_FER_CMD */
+
+#ifdef    Si2168_DD_GET_REG_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DD_GET_REG COMMAND                       */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DD_GET_REG                (L1_Si2168_Context *api,
+                                                   unsigned char   reg_code_lsb,
+                                                   unsigned char   reg_code_mid,
+                                                   unsigned char   reg_code_msb)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[4];
+    unsigned char rspByteBuffer[5];
+    api->rsp->dd_get_reg.STATUS = api->status;
+
+    SiTRACE("Si2168 DD_GET_REG ");
+  #ifdef   DEBUG_RANGE_CHECK
+    SiTRACE("REG_CODE_LSB %d ", reg_code_lsb );
+    SiTRACE("REG_CODE_MID %d ", reg_code_mid );
+    SiTRACE("REG_CODE_MSB %d ", reg_code_msb );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DD_GET_REG_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( reg_code_lsb & Si2168_DD_GET_REG_CMD_REG_CODE_LSB_MASK ) << Si2168_DD_GET_REG_CMD_REG_CODE_LSB_LSB);
+    cmdByteBuffer[2] = (unsigned char) ( ( reg_code_mid & Si2168_DD_GET_REG_CMD_REG_CODE_MID_MASK ) << Si2168_DD_GET_REG_CMD_REG_CODE_MID_LSB);
+    cmdByteBuffer[3] = (unsigned char) ( ( reg_code_msb & Si2168_DD_GET_REG_CMD_REG_CODE_MSB_MASK ) << Si2168_DD_GET_REG_CMD_REG_CODE_MSB_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 4, cmdByteBuffer) != 4) {
+      SiTRACE("Error writing DD_GET_REG bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 5, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DD_GET_REG response\n");
+      return error_code;
+    }
+
+    api->rsp->dd_get_reg.data1 =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_GET_REG_RESPONSE_DATA1_LSB ) & Si2168_DD_GET_REG_RESPONSE_DATA1_MASK );
+    api->rsp->dd_get_reg.data2 =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_GET_REG_RESPONSE_DATA2_LSB ) & Si2168_DD_GET_REG_RESPONSE_DATA2_MASK );
+    api->rsp->dd_get_reg.data3 =   (( ( (rspByteBuffer[3]  )) >> Si2168_DD_GET_REG_RESPONSE_DATA3_LSB ) & Si2168_DD_GET_REG_RESPONSE_DATA3_MASK );
+    api->rsp->dd_get_reg.data4 =   (( ( (rspByteBuffer[4]  )) >> Si2168_DD_GET_REG_RESPONSE_DATA4_LSB ) & Si2168_DD_GET_REG_RESPONSE_DATA4_MASK );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DD_GET_REG_CMD */
+
+#ifdef    Si2168_DD_MP_DEFAULTS_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DD_MP_DEFAULTS COMMAND                   */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DD_MP_DEFAULTS            (L1_Si2168_Context *api,
+                                                   unsigned char   mp_a_mode,
+                                                   unsigned char   mp_b_mode,
+                                                   unsigned char   mp_c_mode,
+                                                   unsigned char   mp_d_mode)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[5];
+    unsigned char rspByteBuffer[5];
+    api->rsp->dd_mp_defaults.STATUS = api->status;
+
+    SiTRACE("Si2168 DD_MP_DEFAULTS ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((mp_a_mode > Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("MP_A_MODE %d ", mp_a_mode );
+    if ((mp_b_mode > Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("MP_B_MODE %d ", mp_b_mode );
+    if ((mp_c_mode > Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("MP_C_MODE %d ", mp_c_mode );
+    if ((mp_d_mode > Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("MP_D_MODE %d ", mp_d_mode );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DD_MP_DEFAULTS_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( mp_a_mode & Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_MASK ) << Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_LSB);
+    cmdByteBuffer[2] = (unsigned char) ( ( mp_b_mode & Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_MASK ) << Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_LSB);
+    cmdByteBuffer[3] = (unsigned char) ( ( mp_c_mode & Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_MASK ) << Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_LSB);
+    cmdByteBuffer[4] = (unsigned char) ( ( mp_d_mode & Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_MASK ) << Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 5, cmdByteBuffer) != 5) {
+      SiTRACE("Error writing DD_MP_DEFAULTS bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 5, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DD_MP_DEFAULTS response\n");
+      return error_code;
+    }
+
+    api->rsp->dd_mp_defaults.mp_a_mode =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_LSB ) & Si2168_DD_MP_DEFAULTS_RESPONSE_MP_A_MODE_MASK );
+    api->rsp->dd_mp_defaults.mp_b_mode =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_LSB ) & Si2168_DD_MP_DEFAULTS_RESPONSE_MP_B_MODE_MASK );
+    api->rsp->dd_mp_defaults.mp_c_mode =   (( ( (rspByteBuffer[3]  )) >> Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_LSB ) & Si2168_DD_MP_DEFAULTS_RESPONSE_MP_C_MODE_MASK );
+    api->rsp->dd_mp_defaults.mp_d_mode =   (( ( (rspByteBuffer[4]  )) >> Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_LSB ) & Si2168_DD_MP_DEFAULTS_RESPONSE_MP_D_MODE_MASK );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DD_MP_DEFAULTS_CMD */
+
+#ifdef    Si2168_DD_PER_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DD_PER COMMAND                           */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DD_PER                    (L1_Si2168_Context *api,
+                                                   unsigned char   rst)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[3];
+    api->rsp->dd_per.STATUS = api->status;
+
+    SiTRACE("Si2168 DD_PER ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((rst > Si2168_DD_PER_CMD_RST_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RST %d ", rst );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DD_PER_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( rst & Si2168_DD_PER_CMD_RST_MASK ) << Si2168_DD_PER_CMD_RST_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing DD_PER bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 3, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DD_PER response\n");
+      return error_code;
+    }
+
+    api->rsp->dd_per.exp  =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_PER_RESPONSE_EXP_LSB  ) & Si2168_DD_PER_RESPONSE_EXP_MASK  );
+    api->rsp->dd_per.mant =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_PER_RESPONSE_MANT_LSB ) & Si2168_DD_PER_RESPONSE_MANT_MASK );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DD_PER_CMD */
+#ifdef    Si2168_DD_RESTART_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DD_RESTART COMMAND                       */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DD_RESTART                (L1_Si2168_Context *api)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[1];
+    unsigned char rspByteBuffer[1];
+    api->rsp->dd_restart.STATUS = api->status;
+
+    SiTRACE("Si2168 DD_RESTART ");
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DD_RESTART_CMD;
+
+    if (L0_WriteCommandBytes(api->i2c, 1, cmdByteBuffer) != 1) {
+      SiTRACE("Error writing DD_RESTART bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 1, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DD_RESTART response\n");
+      return error_code;
+    }
+
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DD_RESTART_CMD */
+
+#ifdef    Si2168_DD_SET_REG_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DD_SET_REG COMMAND                       */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DD_SET_REG                (L1_Si2168_Context *api,
+                                                   unsigned char   reg_code_lsb,
+                                                   unsigned char   reg_code_mid,
+                                                   unsigned char   reg_code_msb,
+                                                   unsigned long   value)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[8];
+    unsigned char rspByteBuffer[1];
+    api->rsp->dd_set_reg.STATUS = api->status;
+
+    SiTRACE("Si2168 DD_SET_REG ");
+  #ifdef   DEBUG_RANGE_CHECK
+    SiTRACE("REG_CODE_LSB %d ", reg_code_lsb );
+    SiTRACE("REG_CODE_MID %d ", reg_code_mid );
+    SiTRACE("REG_CODE_MSB %d ", reg_code_msb );
+    SiTRACE("VALUE %d "       , value        );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DD_SET_REG_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( reg_code_lsb & Si2168_DD_SET_REG_CMD_REG_CODE_LSB_MASK ) << Si2168_DD_SET_REG_CMD_REG_CODE_LSB_LSB);
+    cmdByteBuffer[2] = (unsigned char) ( ( reg_code_mid & Si2168_DD_SET_REG_CMD_REG_CODE_MID_MASK ) << Si2168_DD_SET_REG_CMD_REG_CODE_MID_LSB);
+    cmdByteBuffer[3] = (unsigned char) ( ( reg_code_msb & Si2168_DD_SET_REG_CMD_REG_CODE_MSB_MASK ) << Si2168_DD_SET_REG_CMD_REG_CODE_MSB_LSB);
+    cmdByteBuffer[4] = (unsigned char) ( ( value        & Si2168_DD_SET_REG_CMD_VALUE_MASK        ) << Si2168_DD_SET_REG_CMD_VALUE_LSB       );
+    cmdByteBuffer[5] = (unsigned char) ((( value        & Si2168_DD_SET_REG_CMD_VALUE_MASK        ) << Si2168_DD_SET_REG_CMD_VALUE_LSB       )>>8);
+    cmdByteBuffer[6] = (unsigned char) ((( value        & Si2168_DD_SET_REG_CMD_VALUE_MASK        ) << Si2168_DD_SET_REG_CMD_VALUE_LSB       )>>16);
+    cmdByteBuffer[7] = (unsigned char) ((( value        & Si2168_DD_SET_REG_CMD_VALUE_MASK        ) << Si2168_DD_SET_REG_CMD_VALUE_LSB       )>>24);
+
+    if (L0_WriteCommandBytes(api->i2c, 8, cmdByteBuffer) != 8) {
+      SiTRACE("Error writing DD_SET_REG bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 1, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DD_SET_REG response\n");
+      return error_code;
+    }
+
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DD_SET_REG_CMD */
+#ifdef    Si2168_DD_SSI_SQI_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DD_SSI_SQI COMMAND                       */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DD_SSI_SQI                (L1_Si2168_Context *api,
+                                                             char  tuner_rssi)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[3];
+    api->rsp->dd_ssi_sqi.STATUS = api->status;
+
+    SiTRACE("Si2168 DD_SSI_SQI ");
+  #ifdef   DEBUG_RANGE_CHECK
+    SiTRACE("TUNER_RSSI %d ", tuner_rssi );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DD_SSI_SQI_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( tuner_rssi & Si2168_DD_SSI_SQI_CMD_TUNER_RSSI_MASK ) << Si2168_DD_SSI_SQI_CMD_TUNER_RSSI_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing DD_SSI_SQI bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 3, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DD_SSI_SQI response\n");
+      return error_code;
+    }
+
+    api->rsp->dd_ssi_sqi.ssi = (((( ( (rspByteBuffer[1]  )) >> Si2168_DD_SSI_SQI_RESPONSE_SSI_LSB ) & Si2168_DD_SSI_SQI_RESPONSE_SSI_MASK) <<Si2168_DD_SSI_SQI_RESPONSE_SSI_SHIFT ) >>Si2168_DD_SSI_SQI_RESPONSE_SSI_SHIFT );
+    api->rsp->dd_ssi_sqi.sqi = (((( ( (rspByteBuffer[2]  )) >> Si2168_DD_SSI_SQI_RESPONSE_SQI_LSB ) & Si2168_DD_SSI_SQI_RESPONSE_SQI_MASK) <<Si2168_DD_SSI_SQI_RESPONSE_SQI_SHIFT ) >>Si2168_DD_SSI_SQI_RESPONSE_SQI_SHIFT );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DD_SSI_SQI_CMD */
+
+#ifdef    Si2168_DD_UNCOR_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DD_UNCOR COMMAND                         */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DD_UNCOR                  (L1_Si2168_Context *api,
+                                                   unsigned char   rst)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[3];
+    api->rsp->dd_uncor.STATUS = api->status;
+
+    SiTRACE("Si2168 DD_UNCOR ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((rst > Si2168_DD_UNCOR_CMD_RST_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RST %d ", rst );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DD_UNCOR_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( rst & Si2168_DD_UNCOR_CMD_RST_MASK ) << Si2168_DD_UNCOR_CMD_RST_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing DD_UNCOR bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 3, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DD_UNCOR response\n");
+      return error_code;
+    }
+
+    api->rsp->dd_uncor.uncor_lsb =   (( ( (rspByteBuffer[1]  )) >> Si2168_DD_UNCOR_RESPONSE_UNCOR_LSB_LSB ) & Si2168_DD_UNCOR_RESPONSE_UNCOR_LSB_MASK );
+    api->rsp->dd_uncor.uncor_msb =   (( ( (rspByteBuffer[2]  )) >> Si2168_DD_UNCOR_RESPONSE_UNCOR_MSB_LSB ) & Si2168_DD_UNCOR_RESPONSE_UNCOR_MSB_MASK );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DD_UNCOR_CMD */
+#ifdef    Si2168_DOWNLOAD_DATASET_CONTINUE_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DOWNLOAD_DATASET_CONTINUE COMMAND        */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DOWNLOAD_DATASET_CONTINUE (L1_Si2168_Context *api,
+                                                   unsigned char   data0,
+                                                   unsigned char   data1,
+                                                   unsigned char   data2,
+                                                   unsigned char   data3,
+                                                   unsigned char   data4,
+                                                   unsigned char   data5,
+                                                   unsigned char   data6)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[8];
+    unsigned char rspByteBuffer[1];
+    api->rsp->download_dataset_continue.STATUS = api->status;
+
+    SiTRACE("Si2168 DOWNLOAD_DATASET_CONTINUE ");
+  #ifdef   DEBUG_RANGE_CHECK
+    SiTRACE("DATA0 %d ", data0 );
+    SiTRACE("DATA1 %d ", data1 );
+    SiTRACE("DATA2 %d ", data2 );
+    SiTRACE("DATA3 %d ", data3 );
+    SiTRACE("DATA4 %d ", data4 );
+    SiTRACE("DATA5 %d ", data5 );
+    SiTRACE("DATA6 %d ", data6 );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DOWNLOAD_DATASET_CONTINUE_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( data0 & Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_MASK ) << Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA0_LSB);
+    cmdByteBuffer[2] = (unsigned char) ( ( data1 & Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_MASK ) << Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA1_LSB);
+    cmdByteBuffer[3] = (unsigned char) ( ( data2 & Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_MASK ) << Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA2_LSB);
+    cmdByteBuffer[4] = (unsigned char) ( ( data3 & Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_MASK ) << Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA3_LSB);
+    cmdByteBuffer[5] = (unsigned char) ( ( data4 & Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_MASK ) << Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA4_LSB);
+    cmdByteBuffer[6] = (unsigned char) ( ( data5 & Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_MASK ) << Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA5_LSB);
+    cmdByteBuffer[7] = (unsigned char) ( ( data6 & Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_MASK ) << Si2168_DOWNLOAD_DATASET_CONTINUE_CMD_DATA6_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 8, cmdByteBuffer) != 8) {
+      SiTRACE("Error writing DOWNLOAD_DATASET_CONTINUE bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 1, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DOWNLOAD_DATASET_CONTINUE response\n");
+      return error_code;
+    }
+
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DOWNLOAD_DATASET_CONTINUE_CMD */
+#ifdef    Si2168_DOWNLOAD_DATASET_START_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DOWNLOAD_DATASET_START COMMAND           */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DOWNLOAD_DATASET_START    (L1_Si2168_Context *api,
+                                                   unsigned char   dataset_id,
+                                                   unsigned char   dataset_checksum,
+                                                   unsigned char   data0,
+                                                   unsigned char   data1,
+                                                   unsigned char   data2,
+                                                   unsigned char   data3,
+                                                   unsigned char   data4)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[8];
+    unsigned char rspByteBuffer[1];
+    api->rsp->download_dataset_start.STATUS = api->status;
+
+    SiTRACE("Si2168 DOWNLOAD_DATASET_START ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((dataset_id       > Si2168_DOWNLOAD_DATASET_START_CMD_DATASET_ID_MAX      ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("DATASET_ID %d "      , dataset_id       );
+    SiTRACE("DATASET_CHECKSUM %d ", dataset_checksum );
+    SiTRACE("DATA0 %d "           , data0            );
+    SiTRACE("DATA1 %d "           , data1            );
+    SiTRACE("DATA2 %d "           , data2            );
+    SiTRACE("DATA3 %d "           , data3            );
+    SiTRACE("DATA4 %d "           , data4            );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DOWNLOAD_DATASET_START_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( dataset_id       & Si2168_DOWNLOAD_DATASET_START_CMD_DATASET_ID_MASK       ) << Si2168_DOWNLOAD_DATASET_START_CMD_DATASET_ID_LSB      );
+    cmdByteBuffer[2] = (unsigned char) ( ( dataset_checksum & Si2168_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_MASK ) << Si2168_DOWNLOAD_DATASET_START_CMD_DATASET_CHECKSUM_LSB);
+    cmdByteBuffer[3] = (unsigned char) ( ( data0            & Si2168_DOWNLOAD_DATASET_START_CMD_DATA0_MASK            ) << Si2168_DOWNLOAD_DATASET_START_CMD_DATA0_LSB           );
+    cmdByteBuffer[4] = (unsigned char) ( ( data1            & Si2168_DOWNLOAD_DATASET_START_CMD_DATA1_MASK            ) << Si2168_DOWNLOAD_DATASET_START_CMD_DATA1_LSB           );
+    cmdByteBuffer[5] = (unsigned char) ( ( data2            & Si2168_DOWNLOAD_DATASET_START_CMD_DATA2_MASK            ) << Si2168_DOWNLOAD_DATASET_START_CMD_DATA2_LSB           );
+    cmdByteBuffer[6] = (unsigned char) ( ( data3            & Si2168_DOWNLOAD_DATASET_START_CMD_DATA3_MASK            ) << Si2168_DOWNLOAD_DATASET_START_CMD_DATA3_LSB           );
+    cmdByteBuffer[7] = (unsigned char) ( ( data4            & Si2168_DOWNLOAD_DATASET_START_CMD_DATA4_MASK            ) << Si2168_DOWNLOAD_DATASET_START_CMD_DATA4_LSB           );
+
+    if (L0_WriteCommandBytes(api->i2c, 8, cmdByteBuffer) != 8) {
+      SiTRACE("Error writing DOWNLOAD_DATASET_START bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 1, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DOWNLOAD_DATASET_START response\n");
+      return error_code;
+    }
+
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DOWNLOAD_DATASET_START_CMD */
+#ifdef    Si2168_DVBC_STATUS_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DVBC_STATUS COMMAND                      */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DVBC_STATUS               (L1_Si2168_Context *api,
+                                                   unsigned char   intack)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[9];
+    api->rsp->dvbc_status.STATUS = api->status;
+
+    SiTRACE("Si2168 DVBC_STATUS ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((intack > Si2168_DVBC_STATUS_CMD_INTACK_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("INTACK %d ", intack );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DVBC_STATUS_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( intack & Si2168_DVBC_STATUS_CMD_INTACK_MASK ) << Si2168_DVBC_STATUS_CMD_INTACK_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing DVBC_STATUS bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 9, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DVBC_STATUS response\n");
+      return error_code;
+    }
+
+    api->rsp->dvbc_status.pclint        =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBC_STATUS_RESPONSE_PCLINT_LSB        ) & Si2168_DVBC_STATUS_RESPONSE_PCLINT_MASK        );
+    api->rsp->dvbc_status.dlint         =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBC_STATUS_RESPONSE_DLINT_LSB         ) & Si2168_DVBC_STATUS_RESPONSE_DLINT_MASK         );
+    api->rsp->dvbc_status.berint        =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBC_STATUS_RESPONSE_BERINT_LSB        ) & Si2168_DVBC_STATUS_RESPONSE_BERINT_MASK        );
+    api->rsp->dvbc_status.uncorint      =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBC_STATUS_RESPONSE_UNCORINT_LSB      ) & Si2168_DVBC_STATUS_RESPONSE_UNCORINT_MASK      );
+    api->rsp->dvbc_status.pcl           =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBC_STATUS_RESPONSE_PCL_LSB           ) & Si2168_DVBC_STATUS_RESPONSE_PCL_MASK           );
+    api->rsp->dvbc_status.dl            =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBC_STATUS_RESPONSE_DL_LSB            ) & Si2168_DVBC_STATUS_RESPONSE_DL_MASK            );
+    api->rsp->dvbc_status.ber           =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBC_STATUS_RESPONSE_BER_LSB           ) & Si2168_DVBC_STATUS_RESPONSE_BER_MASK           );
+    api->rsp->dvbc_status.uncor         =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBC_STATUS_RESPONSE_UNCOR_LSB         ) & Si2168_DVBC_STATUS_RESPONSE_UNCOR_MASK         );
+    api->rsp->dvbc_status.cnr           =   (( ( (rspByteBuffer[3]  )) >> Si2168_DVBC_STATUS_RESPONSE_CNR_LSB           ) & Si2168_DVBC_STATUS_RESPONSE_CNR_MASK           );
+    api->rsp->dvbc_status.afc_freq      = (((( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 )) >> Si2168_DVBC_STATUS_RESPONSE_AFC_FREQ_LSB      ) & Si2168_DVBC_STATUS_RESPONSE_AFC_FREQ_MASK) <<Si2168_DVBC_STATUS_RESPONSE_AFC_FREQ_SHIFT ) >>Si2168_DVBC_STATUS_RESPONSE_AFC_FREQ_SHIFT      );
+    api->rsp->dvbc_status.timing_offset = (((( ( (rspByteBuffer[6]  ) | (rspByteBuffer[7]  << 8 )) >> Si2168_DVBC_STATUS_RESPONSE_TIMING_OFFSET_LSB ) & Si2168_DVBC_STATUS_RESPONSE_TIMING_OFFSET_MASK) <<Si2168_DVBC_STATUS_RESPONSE_TIMING_OFFSET_SHIFT ) >>Si2168_DVBC_STATUS_RESPONSE_TIMING_OFFSET_SHIFT );
+    api->rsp->dvbc_status.constellation =   (( ( (rspByteBuffer[8]  )) >> Si2168_DVBC_STATUS_RESPONSE_CONSTELLATION_LSB ) & Si2168_DVBC_STATUS_RESPONSE_CONSTELLATION_MASK );
+    api->rsp->dvbc_status.sp_inv        =   (( ( (rspByteBuffer[8]  )) >> Si2168_DVBC_STATUS_RESPONSE_SP_INV_LSB        ) & Si2168_DVBC_STATUS_RESPONSE_SP_INV_MASK        );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DVBC_STATUS_CMD */
+#ifdef    Si2168_DVBT2_FEF_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DVBT2_FEF COMMAND                        */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DVBT2_FEF                 (L1_Si2168_Context *api,
+                                                   unsigned char   fef_tuner_flag,
+                                                   unsigned char   fef_tuner_flag_inv)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[12];
+    api->rsp->dvbt2_fef.STATUS = api->status;
+
+    SiTRACE("Si2168 DVBT2_FEF ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((fef_tuner_flag     > Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MAX    ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("FEF_TUNER_FLAG %d "    , fef_tuner_flag     );
+    if ((fef_tuner_flag_inv > Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("FEF_TUNER_FLAG_INV %d ", fef_tuner_flag_inv );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DVBT2_FEF_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( fef_tuner_flag     & Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MASK     ) << Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_LSB    |
+                                         ( fef_tuner_flag_inv & Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_MASK ) << Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing DVBT2_FEF bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 12, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DVBT2_FEF response\n");
+      return error_code;
+    }
+
+    api->rsp->dvbt2_fef.fef_type       =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT2_FEF_RESPONSE_FEF_TYPE_LSB       ) & Si2168_DVBT2_FEF_RESPONSE_FEF_TYPE_MASK       );
+    api->rsp->dvbt2_fef.fef_length     =   (( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 ) | (rspByteBuffer[6]  << 16 ) | (rspByteBuffer[7]  << 24 )) >> Si2168_DVBT2_FEF_RESPONSE_FEF_LENGTH_LSB     ) & Si2168_DVBT2_FEF_RESPONSE_FEF_LENGTH_MASK     );
+    api->rsp->dvbt2_fef.fef_repetition =   (( ( (rspByteBuffer[8]  ) | (rspByteBuffer[9]  << 8 ) | (rspByteBuffer[10] << 16 ) | (rspByteBuffer[11] << 24 )) >> Si2168_DVBT2_FEF_RESPONSE_FEF_REPETITION_LSB ) & Si2168_DVBT2_FEF_RESPONSE_FEF_REPETITION_MASK );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DVBT2_FEF_CMD */
+#ifdef    Si2168_DVBT2_PLP_INFO_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DVBT2_PLP_INFO COMMAND                   */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DVBT2_PLP_INFO            (L1_Si2168_Context *api,
+                                                   unsigned char   plp_index)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[13];
+    api->rsp->dvbt2_plp_info.STATUS = api->status;
+
+    SiTRACE("Si2168 DVBT2_PLP_INFO ");
+  #ifdef   DEBUG_RANGE_CHECK
+    SiTRACE("PLP_INDEX %d ", plp_index );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DVBT2_PLP_INFO_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( plp_index & Si2168_DVBT2_PLP_INFO_CMD_PLP_INDEX_MASK ) << Si2168_DVBT2_PLP_INFO_CMD_PLP_INDEX_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing DVBT2_PLP_INFO bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 13, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DVBT2_PLP_INFO response\n");
+      return error_code;
+    }
+
+    api->rsp->dvbt2_plp_info.plp_id                 =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_ID_LSB                 ) & Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_ID_MASK                 );
+    api->rsp->dvbt2_plp_info.plp_payload_type       =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_PAYLOAD_TYPE_LSB       ) & Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_PAYLOAD_TYPE_MASK       );
+    api->rsp->dvbt2_plp_info.plp_type               =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_TYPE_LSB               ) & Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_TYPE_MASK               );
+    api->rsp->dvbt2_plp_info.first_frame_idx_msb    =   (( ( (rspByteBuffer[3]  )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_FIRST_FRAME_IDX_MSB_LSB    ) & Si2168_DVBT2_PLP_INFO_RESPONSE_FIRST_FRAME_IDX_MSB_MASK    );
+    api->rsp->dvbt2_plp_info.first_rf_idx           =   (( ( (rspByteBuffer[3]  )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_FIRST_RF_IDX_LSB           ) & Si2168_DVBT2_PLP_INFO_RESPONSE_FIRST_RF_IDX_MASK           );
+    api->rsp->dvbt2_plp_info.ff_flag                =   (( ( (rspByteBuffer[3]  )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_FF_FLAG_LSB                ) & Si2168_DVBT2_PLP_INFO_RESPONSE_FF_FLAG_MASK                );
+    api->rsp->dvbt2_plp_info.plp_group_id_msb       =   (( ( (rspByteBuffer[4]  )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_GROUP_ID_MSB_LSB       ) & Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_GROUP_ID_MSB_MASK       );
+    api->rsp->dvbt2_plp_info.first_frame_idx_lsb    =   (( ( (rspByteBuffer[4]  )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_FIRST_FRAME_IDX_LSB_LSB    ) & Si2168_DVBT2_PLP_INFO_RESPONSE_FIRST_FRAME_IDX_LSB_MASK    );
+    api->rsp->dvbt2_plp_info.plp_mod_msb            =   (( ( (rspByteBuffer[5]  )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_MOD_MSB_LSB            ) & Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_MOD_MSB_MASK            );
+    api->rsp->dvbt2_plp_info.plp_cod                =   (( ( (rspByteBuffer[5]  )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_COD_LSB                ) & Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_COD_MASK                );
+    api->rsp->dvbt2_plp_info.plp_group_id_lsb       =   (( ( (rspByteBuffer[5]  )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_GROUP_ID_LSB_LSB       ) & Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_GROUP_ID_LSB_MASK       );
+    api->rsp->dvbt2_plp_info.plp_num_blocks_max_msb =   (( ( (rspByteBuffer[6]  )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_NUM_BLOCKS_MAX_MSB_LSB ) & Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_NUM_BLOCKS_MAX_MSB_MASK );
+    api->rsp->dvbt2_plp_info.plp_fec_type           =   (( ( (rspByteBuffer[6]  )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_FEC_TYPE_LSB           ) & Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_FEC_TYPE_MASK           );
+    api->rsp->dvbt2_plp_info.plp_rot                =   (( ( (rspByteBuffer[6]  )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_ROT_LSB                ) & Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_ROT_MASK                );
+    api->rsp->dvbt2_plp_info.plp_mod_lsb            =   (( ( (rspByteBuffer[6]  )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_MOD_LSB_LSB            ) & Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_MOD_LSB_MASK            );
+    api->rsp->dvbt2_plp_info.frame_interval_msb     =   (( ( (rspByteBuffer[7]  )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_FRAME_INTERVAL_MSB_LSB     ) & Si2168_DVBT2_PLP_INFO_RESPONSE_FRAME_INTERVAL_MSB_MASK     );
+    api->rsp->dvbt2_plp_info.plp_num_blocks_max_lsb =   (( ( (rspByteBuffer[7]  )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_NUM_BLOCKS_MAX_LSB_LSB ) & Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_NUM_BLOCKS_MAX_LSB_MASK );
+    api->rsp->dvbt2_plp_info.time_il_length_msb     =   (( ( (rspByteBuffer[8]  )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_TIME_IL_LENGTH_MSB_LSB     ) & Si2168_DVBT2_PLP_INFO_RESPONSE_TIME_IL_LENGTH_MSB_MASK     );
+    api->rsp->dvbt2_plp_info.frame_interval_lsb     =   (( ( (rspByteBuffer[8]  )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_FRAME_INTERVAL_LSB_LSB     ) & Si2168_DVBT2_PLP_INFO_RESPONSE_FRAME_INTERVAL_LSB_MASK     );
+    api->rsp->dvbt2_plp_info.time_il_type           =   (( ( (rspByteBuffer[9]  )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_TIME_IL_TYPE_LSB           ) & Si2168_DVBT2_PLP_INFO_RESPONSE_TIME_IL_TYPE_MASK           );
+    api->rsp->dvbt2_plp_info.time_il_length_lsb     =   (( ( (rspByteBuffer[9]  )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_TIME_IL_LENGTH_LSB_LSB     ) & Si2168_DVBT2_PLP_INFO_RESPONSE_TIME_IL_LENGTH_LSB_MASK     );
+    api->rsp->dvbt2_plp_info.reserved_1_1           =   (( ( (rspByteBuffer[10] )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_RESERVED_1_1_LSB           ) & Si2168_DVBT2_PLP_INFO_RESPONSE_RESERVED_1_1_MASK           );
+    api->rsp->dvbt2_plp_info.in_band_b_flag         =   (( ( (rspByteBuffer[10] )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_IN_BAND_B_FLAG_LSB         ) & Si2168_DVBT2_PLP_INFO_RESPONSE_IN_BAND_B_FLAG_MASK         );
+    api->rsp->dvbt2_plp_info.in_band_a_flag         =   (( ( (rspByteBuffer[10] )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_IN_BAND_A_FLAG_LSB         ) & Si2168_DVBT2_PLP_INFO_RESPONSE_IN_BAND_A_FLAG_MASK         );
+    api->rsp->dvbt2_plp_info.static_flag            =   (( ( (rspByteBuffer[11] )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_STATIC_FLAG_LSB            ) & Si2168_DVBT2_PLP_INFO_RESPONSE_STATIC_FLAG_MASK            );
+    api->rsp->dvbt2_plp_info.plp_mode               =   (( ( (rspByteBuffer[11] )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_MODE_LSB               ) & Si2168_DVBT2_PLP_INFO_RESPONSE_PLP_MODE_MASK               );
+    api->rsp->dvbt2_plp_info.reserved_1_2           =   (( ( (rspByteBuffer[11] )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_RESERVED_1_2_LSB           ) & Si2168_DVBT2_PLP_INFO_RESPONSE_RESERVED_1_2_MASK           );
+    api->rsp->dvbt2_plp_info.static_padding_flag    =   (( ( (rspByteBuffer[12] )) >> Si2168_DVBT2_PLP_INFO_RESPONSE_STATIC_PADDING_FLAG_LSB    ) & Si2168_DVBT2_PLP_INFO_RESPONSE_STATIC_PADDING_FLAG_MASK    );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DVBT2_PLP_INFO_CMD */
+#ifdef    Si2168_DVBT2_PLP_SELECT_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DVBT2_PLP_SELECT COMMAND                 */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DVBT2_PLP_SELECT          (L1_Si2168_Context *api,
+                                                   unsigned char   plp_id,
+                                                   unsigned char   plp_id_sel_mode)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[3];
+    unsigned char rspByteBuffer[1];
+    api->rsp->dvbt2_plp_select.STATUS = api->status;
+
+    SiTRACE("Si2168 DVBT2_PLP_SELECT ");
+  #ifdef   DEBUG_RANGE_CHECK
+    SiTRACE("PLP_ID %d "         , plp_id          );
+    if ((plp_id_sel_mode > Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("PLP_ID_SEL_MODE %d ", plp_id_sel_mode );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DVBT2_PLP_SELECT_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( plp_id          & Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_MASK          ) << Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_LSB         );
+    cmdByteBuffer[2] = (unsigned char) ( ( plp_id_sel_mode & Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_MASK ) << Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 3, cmdByteBuffer) != 3) {
+      SiTRACE("Error writing DVBT2_PLP_SELECT bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 1, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DVBT2_PLP_SELECT response\n");
+      return error_code;
+    }
+
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DVBT2_PLP_SELECT_CMD */
+#ifdef    Si2168_DVBT2_STATUS_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DVBT2_STATUS COMMAND                     */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DVBT2_STATUS              (L1_Si2168_Context *api,
+                                                   unsigned char   intack)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[14];
+    api->rsp->dvbt2_status.STATUS = api->status;
+
+    SiTRACE("Si2168 DVBT2_STATUS ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((intack > Si2168_DVBT2_STATUS_CMD_INTACK_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("INTACK %d ", intack );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DVBT2_STATUS_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( intack & Si2168_DVBT2_STATUS_CMD_INTACK_MASK ) << Si2168_DVBT2_STATUS_CMD_INTACK_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing DVBT2_STATUS bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 14, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DVBT2_STATUS response\n");
+      return error_code;
+    }
+
+    api->rsp->dvbt2_status.pclint        =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT2_STATUS_RESPONSE_PCLINT_LSB        ) & Si2168_DVBT2_STATUS_RESPONSE_PCLINT_MASK        );
+    api->rsp->dvbt2_status.dlint         =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT2_STATUS_RESPONSE_DLINT_LSB         ) & Si2168_DVBT2_STATUS_RESPONSE_DLINT_MASK         );
+    api->rsp->dvbt2_status.berint        =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT2_STATUS_RESPONSE_BERINT_LSB        ) & Si2168_DVBT2_STATUS_RESPONSE_BERINT_MASK        );
+    api->rsp->dvbt2_status.uncorint      =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT2_STATUS_RESPONSE_UNCORINT_LSB      ) & Si2168_DVBT2_STATUS_RESPONSE_UNCORINT_MASK      );
+    api->rsp->dvbt2_status.notdvbt2int   =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2INT_LSB   ) & Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2INT_MASK   );
+    api->rsp->dvbt2_status.pcl           =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT2_STATUS_RESPONSE_PCL_LSB           ) & Si2168_DVBT2_STATUS_RESPONSE_PCL_MASK           );
+    api->rsp->dvbt2_status.dl            =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT2_STATUS_RESPONSE_DL_LSB            ) & Si2168_DVBT2_STATUS_RESPONSE_DL_MASK            );
+    api->rsp->dvbt2_status.ber           =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT2_STATUS_RESPONSE_BER_LSB           ) & Si2168_DVBT2_STATUS_RESPONSE_BER_MASK           );
+    api->rsp->dvbt2_status.uncor         =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT2_STATUS_RESPONSE_UNCOR_LSB         ) & Si2168_DVBT2_STATUS_RESPONSE_UNCOR_MASK         );
+    api->rsp->dvbt2_status.notdvbt2      =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2_LSB      ) & Si2168_DVBT2_STATUS_RESPONSE_NOTDVBT2_MASK      );
+    api->rsp->dvbt2_status.cnr           =   (( ( (rspByteBuffer[3]  )) >> Si2168_DVBT2_STATUS_RESPONSE_CNR_LSB           ) & Si2168_DVBT2_STATUS_RESPONSE_CNR_MASK           );
+    api->rsp->dvbt2_status.afc_freq      = (((( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 )) >> Si2168_DVBT2_STATUS_RESPONSE_AFC_FREQ_LSB      ) & Si2168_DVBT2_STATUS_RESPONSE_AFC_FREQ_MASK) <<Si2168_DVBT2_STATUS_RESPONSE_AFC_FREQ_SHIFT ) >>Si2168_DVBT2_STATUS_RESPONSE_AFC_FREQ_SHIFT      );
+    api->rsp->dvbt2_status.timing_offset = (((( ( (rspByteBuffer[6]  ) | (rspByteBuffer[7]  << 8 )) >> Si2168_DVBT2_STATUS_RESPONSE_TIMING_OFFSET_LSB ) & Si2168_DVBT2_STATUS_RESPONSE_TIMING_OFFSET_MASK) <<Si2168_DVBT2_STATUS_RESPONSE_TIMING_OFFSET_SHIFT ) >>Si2168_DVBT2_STATUS_RESPONSE_TIMING_OFFSET_SHIFT );
+    api->rsp->dvbt2_status.constellation =   (( ( (rspByteBuffer[8]  )) >> Si2168_DVBT2_STATUS_RESPONSE_CONSTELLATION_LSB ) & Si2168_DVBT2_STATUS_RESPONSE_CONSTELLATION_MASK );
+    api->rsp->dvbt2_status.sp_inv        =   (( ( (rspByteBuffer[8]  )) >> Si2168_DVBT2_STATUS_RESPONSE_SP_INV_LSB        ) & Si2168_DVBT2_STATUS_RESPONSE_SP_INV_MASK        );
+    api->rsp->dvbt2_status.fef           =   (( ( (rspByteBuffer[8]  )) >> Si2168_DVBT2_STATUS_RESPONSE_FEF_LSB           ) & Si2168_DVBT2_STATUS_RESPONSE_FEF_MASK           );
+    api->rsp->dvbt2_status.fft_mode      =   (( ( (rspByteBuffer[9]  )) >> Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_LSB      ) & Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_MASK      );
+    api->rsp->dvbt2_status.guard_int     =   (( ( (rspByteBuffer[9]  )) >> Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_LSB     ) & Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_MASK     );
+    api->rsp->dvbt2_status.bw_ext        =   (( ( (rspByteBuffer[9]  )) >> Si2168_DVBT2_STATUS_RESPONSE_BW_EXT_LSB        ) & Si2168_DVBT2_STATUS_RESPONSE_BW_EXT_MASK        );
+    api->rsp->dvbt2_status.num_plp       =   (( ( (rspByteBuffer[10] )) >> Si2168_DVBT2_STATUS_RESPONSE_NUM_PLP_LSB       ) & Si2168_DVBT2_STATUS_RESPONSE_NUM_PLP_MASK       );
+    api->rsp->dvbt2_status.pilot_pattern =   (( ( (rspByteBuffer[11] )) >> Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_LSB ) & Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_MASK );
+    api->rsp->dvbt2_status.tx_mode       =   (( ( (rspByteBuffer[11] )) >> Si2168_DVBT2_STATUS_RESPONSE_TX_MODE_LSB       ) & Si2168_DVBT2_STATUS_RESPONSE_TX_MODE_MASK       );
+    api->rsp->dvbt2_status.rotated       =   (( ( (rspByteBuffer[11] )) >> Si2168_DVBT2_STATUS_RESPONSE_ROTATED_LSB       ) & Si2168_DVBT2_STATUS_RESPONSE_ROTATED_MASK       );
+    api->rsp->dvbt2_status.short_frame   =   (( ( (rspByteBuffer[11] )) >> Si2168_DVBT2_STATUS_RESPONSE_SHORT_FRAME_LSB   ) & Si2168_DVBT2_STATUS_RESPONSE_SHORT_FRAME_MASK   );
+    api->rsp->dvbt2_status.code_rate     =   (( ( (rspByteBuffer[12] )) >> Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_LSB     ) & Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_MASK     );
+    api->rsp->dvbt2_status.plp_id        =   (( ( (rspByteBuffer[13] )) >> Si2168_DVBT2_STATUS_RESPONSE_PLP_ID_LSB        ) & Si2168_DVBT2_STATUS_RESPONSE_PLP_ID_MASK        );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DVBT2_STATUS_CMD */
+#ifdef    Si2168_DVBT2_TX_ID_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DVBT2_TX_ID COMMAND                      */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DVBT2_TX_ID               (L1_Si2168_Context *api)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[1];
+    unsigned char rspByteBuffer[8];
+    api->rsp->dvbt2_tx_id.STATUS = api->status;
+
+    SiTRACE("Si2168 DVBT2_TX_ID ");
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DVBT2_TX_ID_CMD;
+
+    if (L0_WriteCommandBytes(api->i2c, 1, cmdByteBuffer) != 1) {
+      SiTRACE("Error writing DVBT2_TX_ID bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 8, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DVBT2_TX_ID response\n");
+      return error_code;
+    }
+
+    api->rsp->dvbt2_tx_id.tx_id_availability =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT2_TX_ID_RESPONSE_TX_ID_AVAILABILITY_LSB ) & Si2168_DVBT2_TX_ID_RESPONSE_TX_ID_AVAILABILITY_MASK );
+    api->rsp->dvbt2_tx_id.cell_id            =   (( ( (rspByteBuffer[2]  ) | (rspByteBuffer[3]  << 8 )) >> Si2168_DVBT2_TX_ID_RESPONSE_CELL_ID_LSB            ) & Si2168_DVBT2_TX_ID_RESPONSE_CELL_ID_MASK            );
+    api->rsp->dvbt2_tx_id.network_id         =   (( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 )) >> Si2168_DVBT2_TX_ID_RESPONSE_NETWORK_ID_LSB         ) & Si2168_DVBT2_TX_ID_RESPONSE_NETWORK_ID_MASK         );
+    api->rsp->dvbt2_tx_id.t2_system_id       =   (( ( (rspByteBuffer[6]  ) | (rspByteBuffer[7]  << 8 )) >> Si2168_DVBT2_TX_ID_RESPONSE_T2_SYSTEM_ID_LSB       ) & Si2168_DVBT2_TX_ID_RESPONSE_T2_SYSTEM_ID_MASK       );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DVBT2_TX_ID_CMD */
+#ifdef    Si2168_DVBT_STATUS_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DVBT_STATUS COMMAND                      */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DVBT_STATUS               (L1_Si2168_Context *api,
+                                                   unsigned char   intack)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[13];
+    api->rsp->dvbt_status.STATUS = api->status;
+
+    SiTRACE("Si2168 DVBT_STATUS ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((intack > Si2168_DVBT_STATUS_CMD_INTACK_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("INTACK %d ", intack );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DVBT_STATUS_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( intack & Si2168_DVBT_STATUS_CMD_INTACK_MASK ) << Si2168_DVBT_STATUS_CMD_INTACK_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing DVBT_STATUS bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 13, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DVBT_STATUS response\n");
+      return error_code;
+    }
+
+    api->rsp->dvbt_status.pclint        =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT_STATUS_RESPONSE_PCLINT_LSB        ) & Si2168_DVBT_STATUS_RESPONSE_PCLINT_MASK        );
+    api->rsp->dvbt_status.dlint         =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT_STATUS_RESPONSE_DLINT_LSB         ) & Si2168_DVBT_STATUS_RESPONSE_DLINT_MASK         );
+    api->rsp->dvbt_status.berint        =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT_STATUS_RESPONSE_BERINT_LSB        ) & Si2168_DVBT_STATUS_RESPONSE_BERINT_MASK        );
+    api->rsp->dvbt_status.uncorint      =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT_STATUS_RESPONSE_UNCORINT_LSB      ) & Si2168_DVBT_STATUS_RESPONSE_UNCORINT_MASK      );
+    api->rsp->dvbt_status.notdvbtint    =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT_STATUS_RESPONSE_NOTDVBTINT_LSB    ) & Si2168_DVBT_STATUS_RESPONSE_NOTDVBTINT_MASK    );
+    api->rsp->dvbt_status.pcl           =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT_STATUS_RESPONSE_PCL_LSB           ) & Si2168_DVBT_STATUS_RESPONSE_PCL_MASK           );
+    api->rsp->dvbt_status.dl            =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT_STATUS_RESPONSE_DL_LSB            ) & Si2168_DVBT_STATUS_RESPONSE_DL_MASK            );
+    api->rsp->dvbt_status.ber           =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT_STATUS_RESPONSE_BER_LSB           ) & Si2168_DVBT_STATUS_RESPONSE_BER_MASK           );
+    api->rsp->dvbt_status.uncor         =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT_STATUS_RESPONSE_UNCOR_LSB         ) & Si2168_DVBT_STATUS_RESPONSE_UNCOR_MASK         );
+    api->rsp->dvbt_status.notdvbt       =   (( ( (rspByteBuffer[2]  )) >> Si2168_DVBT_STATUS_RESPONSE_NOTDVBT_LSB       ) & Si2168_DVBT_STATUS_RESPONSE_NOTDVBT_MASK       );
+    api->rsp->dvbt_status.cnr           =   (( ( (rspByteBuffer[3]  )) >> Si2168_DVBT_STATUS_RESPONSE_CNR_LSB           ) & Si2168_DVBT_STATUS_RESPONSE_CNR_MASK           );
+    api->rsp->dvbt_status.afc_freq      = (((( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 )) >> Si2168_DVBT_STATUS_RESPONSE_AFC_FREQ_LSB      ) & Si2168_DVBT_STATUS_RESPONSE_AFC_FREQ_MASK) <<Si2168_DVBT_STATUS_RESPONSE_AFC_FREQ_SHIFT ) >>Si2168_DVBT_STATUS_RESPONSE_AFC_FREQ_SHIFT      );
+    api->rsp->dvbt_status.timing_offset = (((( ( (rspByteBuffer[6]  ) | (rspByteBuffer[7]  << 8 )) >> Si2168_DVBT_STATUS_RESPONSE_TIMING_OFFSET_LSB ) & Si2168_DVBT_STATUS_RESPONSE_TIMING_OFFSET_MASK) <<Si2168_DVBT_STATUS_RESPONSE_TIMING_OFFSET_SHIFT ) >>Si2168_DVBT_STATUS_RESPONSE_TIMING_OFFSET_SHIFT );
+    api->rsp->dvbt_status.constellation =   (( ( (rspByteBuffer[8]  )) >> Si2168_DVBT_STATUS_RESPONSE_CONSTELLATION_LSB ) & Si2168_DVBT_STATUS_RESPONSE_CONSTELLATION_MASK );
+    api->rsp->dvbt_status.sp_inv        =   (( ( (rspByteBuffer[8]  )) >> Si2168_DVBT_STATUS_RESPONSE_SP_INV_LSB        ) & Si2168_DVBT_STATUS_RESPONSE_SP_INV_MASK        );
+    api->rsp->dvbt_status.rate_hp       =   (( ( (rspByteBuffer[9]  )) >> Si2168_DVBT_STATUS_RESPONSE_RATE_HP_LSB       ) & Si2168_DVBT_STATUS_RESPONSE_RATE_HP_MASK       );
+    api->rsp->dvbt_status.rate_lp       =   (( ( (rspByteBuffer[9]  )) >> Si2168_DVBT_STATUS_RESPONSE_RATE_LP_LSB       ) & Si2168_DVBT_STATUS_RESPONSE_RATE_LP_MASK       );
+    api->rsp->dvbt_status.fft_mode      =   (( ( (rspByteBuffer[10] )) >> Si2168_DVBT_STATUS_RESPONSE_FFT_MODE_LSB      ) & Si2168_DVBT_STATUS_RESPONSE_FFT_MODE_MASK      );
+    api->rsp->dvbt_status.guard_int     =   (( ( (rspByteBuffer[10] )) >> Si2168_DVBT_STATUS_RESPONSE_GUARD_INT_LSB     ) & Si2168_DVBT_STATUS_RESPONSE_GUARD_INT_MASK     );
+    api->rsp->dvbt_status.hierarchy     =   (( ( (rspByteBuffer[11] )) >> Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_LSB     ) & Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_MASK     );
+    api->rsp->dvbt_status.tps_length    = (((( ( (rspByteBuffer[12] )) >> Si2168_DVBT_STATUS_RESPONSE_TPS_LENGTH_LSB    ) & Si2168_DVBT_STATUS_RESPONSE_TPS_LENGTH_MASK) <<Si2168_DVBT_STATUS_RESPONSE_TPS_LENGTH_SHIFT ) >>Si2168_DVBT_STATUS_RESPONSE_TPS_LENGTH_SHIFT    );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DVBT_STATUS_CMD */
+#ifdef    Si2168_DVBT_TPS_EXTRA_CMD
+ /*---------------------------------------------------*/
+/* Si2168_DVBT_TPS_EXTRA COMMAND                   */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_DVBT_TPS_EXTRA            (L1_Si2168_Context *api)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[1];
+    unsigned char rspByteBuffer[6];
+    api->rsp->dvbt_tps_extra.STATUS = api->status;
+
+    SiTRACE("Si2168 DVBT_TPS_EXTRA ");
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_DVBT_TPS_EXTRA_CMD;
+
+    if (L0_WriteCommandBytes(api->i2c, 1, cmdByteBuffer) != 1) {
+      SiTRACE("Error writing DVBT_TPS_EXTRA bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 6, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DVBT_TPS_EXTRA response\n");
+      return error_code;
+    }
+
+    api->rsp->dvbt_tps_extra.lptimeslice =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT_TPS_EXTRA_RESPONSE_LPTIMESLICE_LSB ) & Si2168_DVBT_TPS_EXTRA_RESPONSE_LPTIMESLICE_MASK );
+    api->rsp->dvbt_tps_extra.hptimeslice =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT_TPS_EXTRA_RESPONSE_HPTIMESLICE_LSB ) & Si2168_DVBT_TPS_EXTRA_RESPONSE_HPTIMESLICE_MASK );
+    api->rsp->dvbt_tps_extra.lpmpefec    =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT_TPS_EXTRA_RESPONSE_LPMPEFEC_LSB    ) & Si2168_DVBT_TPS_EXTRA_RESPONSE_LPMPEFEC_MASK    );
+    api->rsp->dvbt_tps_extra.hpmpefec    =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT_TPS_EXTRA_RESPONSE_HPMPEFEC_LSB    ) & Si2168_DVBT_TPS_EXTRA_RESPONSE_HPMPEFEC_MASK    );
+    api->rsp->dvbt_tps_extra.dvbhinter   =   (( ( (rspByteBuffer[1]  )) >> Si2168_DVBT_TPS_EXTRA_RESPONSE_DVBHINTER_LSB   ) & Si2168_DVBT_TPS_EXTRA_RESPONSE_DVBHINTER_MASK   );
+    api->rsp->dvbt_tps_extra.cell_id     = (((( ( (rspByteBuffer[2]  ) | (rspByteBuffer[3]  << 8 )) >> Si2168_DVBT_TPS_EXTRA_RESPONSE_CELL_ID_LSB     ) & Si2168_DVBT_TPS_EXTRA_RESPONSE_CELL_ID_MASK) <<Si2168_DVBT_TPS_EXTRA_RESPONSE_CELL_ID_SHIFT ) >>Si2168_DVBT_TPS_EXTRA_RESPONSE_CELL_ID_SHIFT     );
+    api->rsp->dvbt_tps_extra.tps_res1    =   (( ( (rspByteBuffer[4]  )) >> Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES1_LSB    ) & Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES1_MASK    );
+    api->rsp->dvbt_tps_extra.tps_res2    =   (( ( (rspByteBuffer[4]  )) >> Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES2_LSB    ) & Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES2_MASK    );
+    api->rsp->dvbt_tps_extra.tps_res3    =   (( ( (rspByteBuffer[5]  )) >> Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES3_LSB    ) & Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES3_MASK    );
+    api->rsp->dvbt_tps_extra.tps_res4    =   (( ( (rspByteBuffer[5]  )) >> Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES4_LSB    ) & Si2168_DVBT_TPS_EXTRA_RESPONSE_TPS_RES4_MASK    );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_DVBT_TPS_EXTRA_CMD */
+#ifdef    Si2168_EXIT_BOOTLOADER_CMD
+ /*---------------------------------------------------*/
+/* Si2168_EXIT_BOOTLOADER COMMAND                  */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_EXIT_BOOTLOADER           (L1_Si2168_Context *api,
+                                                   unsigned char   func,
+                                                   unsigned char   ctsien)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[1];
+    api->rsp->exit_bootloader.STATUS = api->status;
+
+    SiTRACE("Si2168 EXIT_BOOTLOADER ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((func   > Si2168_EXIT_BOOTLOADER_CMD_FUNC_MAX  ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("FUNC %d "  , func   );
+    if ((ctsien > Si2168_EXIT_BOOTLOADER_CMD_CTSIEN_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("CTSIEN %d ", ctsien );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_EXIT_BOOTLOADER_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( func   & Si2168_EXIT_BOOTLOADER_CMD_FUNC_MASK   ) << Si2168_EXIT_BOOTLOADER_CMD_FUNC_LSB  |
+                                         ( ctsien & Si2168_EXIT_BOOTLOADER_CMD_CTSIEN_MASK ) << Si2168_EXIT_BOOTLOADER_CMD_CTSIEN_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing EXIT_BOOTLOADER bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 1, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling EXIT_BOOTLOADER response\n");
+      return error_code;
+    }
+
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_EXIT_BOOTLOADER_CMD */
+#ifdef    Si2168_GET_PROPERTY_CMD
+ /*---------------------------------------------------*/
+/* Si2168_GET_PROPERTY COMMAND                     */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_GET_PROPERTY              (L1_Si2168_Context *api,
+                                                   unsigned char   reserved,
+                                                   unsigned int    prop)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[4];
+    unsigned char rspByteBuffer[4];
+    api->rsp->get_property.STATUS = api->status;
+
+    SiTRACE("Si2168 GET_PROPERTY ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((reserved > Si2168_GET_PROPERTY_CMD_RESERVED_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED %d ", reserved );
+    SiTRACE("PROP %d "    , prop     );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_GET_PROPERTY_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( reserved & Si2168_GET_PROPERTY_CMD_RESERVED_MASK ) << Si2168_GET_PROPERTY_CMD_RESERVED_LSB);
+    cmdByteBuffer[2] = (unsigned char) ( ( prop     & Si2168_GET_PROPERTY_CMD_PROP_MASK     ) << Si2168_GET_PROPERTY_CMD_PROP_LSB    );
+    cmdByteBuffer[3] = (unsigned char) ((( prop     & Si2168_GET_PROPERTY_CMD_PROP_MASK     ) << Si2168_GET_PROPERTY_CMD_PROP_LSB    )>>8);
+
+    if (L0_WriteCommandBytes(api->i2c, 4, cmdByteBuffer) != 4) {
+      SiTRACE("Error writing GET_PROPERTY bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 4, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling GET_PROPERTY response\n");
+      return error_code;
+    }
+
+    api->rsp->get_property.reserved =   (( ( (rspByteBuffer[1]  )) >> Si2168_GET_PROPERTY_RESPONSE_RESERVED_LSB ) & Si2168_GET_PROPERTY_RESPONSE_RESERVED_MASK );
+    api->rsp->get_property.data     =   (( ( (rspByteBuffer[2]  ) | (rspByteBuffer[3]  << 8 )) >> Si2168_GET_PROPERTY_RESPONSE_DATA_LSB     ) & Si2168_GET_PROPERTY_RESPONSE_DATA_MASK     );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_GET_PROPERTY_CMD */
+#ifdef    Si2168_GET_REV_CMD
+ /*---------------------------------------------------*/
+/* Si2168_GET_REV COMMAND                          */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_GET_REV                   (L1_Si2168_Context *api)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[1];
+    unsigned char rspByteBuffer[10];
+    api->rsp->get_rev.STATUS = api->status;
+
+    SiTRACE("Si2168 GET_REV ");
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_GET_REV_CMD;
+
+    if (L0_WriteCommandBytes(api->i2c, 1, cmdByteBuffer) != 1) {
+      SiTRACE("Error writing GET_REV bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 10, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling GET_REV response\n");
+      return error_code;
+    }
+
+    api->rsp->get_rev.pn       =   (( ( (rspByteBuffer[1]  )) >> Si2168_GET_REV_RESPONSE_PN_LSB       ) & Si2168_GET_REV_RESPONSE_PN_MASK       );
+    api->rsp->get_rev.fwmajor  =   (( ( (rspByteBuffer[2]  )) >> Si2168_GET_REV_RESPONSE_FWMAJOR_LSB  ) & Si2168_GET_REV_RESPONSE_FWMAJOR_MASK  );
+    api->rsp->get_rev.fwminor  =   (( ( (rspByteBuffer[3]  )) >> Si2168_GET_REV_RESPONSE_FWMINOR_LSB  ) & Si2168_GET_REV_RESPONSE_FWMINOR_MASK  );
+    api->rsp->get_rev.patch    =   (( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 )) >> Si2168_GET_REV_RESPONSE_PATCH_LSB    ) & Si2168_GET_REV_RESPONSE_PATCH_MASK    );
+    api->rsp->get_rev.cmpmajor =   (( ( (rspByteBuffer[6]  )) >> Si2168_GET_REV_RESPONSE_CMPMAJOR_LSB ) & Si2168_GET_REV_RESPONSE_CMPMAJOR_MASK );
+    api->rsp->get_rev.cmpminor =   (( ( (rspByteBuffer[7]  )) >> Si2168_GET_REV_RESPONSE_CMPMINOR_LSB ) & Si2168_GET_REV_RESPONSE_CMPMINOR_MASK );
+    api->rsp->get_rev.cmpbuild =   (( ( (rspByteBuffer[8]  )) >> Si2168_GET_REV_RESPONSE_CMPBUILD_LSB ) & Si2168_GET_REV_RESPONSE_CMPBUILD_MASK );
+    api->rsp->get_rev.chiprev  =   (( ( (rspByteBuffer[9]  )) >> Si2168_GET_REV_RESPONSE_CHIPREV_LSB  ) & Si2168_GET_REV_RESPONSE_CHIPREV_MASK  );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_GET_REV_CMD */
+#ifdef    Si2168_PART_INFO_CMD
+ /*---------------------------------------------------*/
+/* Si2168_PART_INFO COMMAND                        */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_PART_INFO                 (L1_Si2168_Context *api)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[1];
+    unsigned char rspByteBuffer[13];
+    api->rsp->part_info.STATUS = api->status;
+
+    SiTRACE("Si2168 PART_INFO ");
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_PART_INFO_CMD;
+
+    if (L0_WriteCommandBytes(api->i2c, 1, cmdByteBuffer) != 1) {
+      SiTRACE("Error writing PART_INFO bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 13, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling PART_INFO response\n");
+      return error_code;
+    }
+
+    api->rsp->part_info.chiprev  =   (( ( (rspByteBuffer[1]  )) >> Si2168_PART_INFO_RESPONSE_CHIPREV_LSB  ) & Si2168_PART_INFO_RESPONSE_CHIPREV_MASK  );
+    api->rsp->part_info.part     =   (( ( (rspByteBuffer[2]  )) >> Si2168_PART_INFO_RESPONSE_PART_LSB     ) & Si2168_PART_INFO_RESPONSE_PART_MASK     );
+    api->rsp->part_info.pmajor   =   (( ( (rspByteBuffer[3]  )) >> Si2168_PART_INFO_RESPONSE_PMAJOR_LSB   ) & Si2168_PART_INFO_RESPONSE_PMAJOR_MASK   );
+    api->rsp->part_info.pminor   =   (( ( (rspByteBuffer[4]  )) >> Si2168_PART_INFO_RESPONSE_PMINOR_LSB   ) & Si2168_PART_INFO_RESPONSE_PMINOR_MASK   );
+    api->rsp->part_info.pbuild   =   (( ( (rspByteBuffer[5]  )) >> Si2168_PART_INFO_RESPONSE_PBUILD_LSB   ) & Si2168_PART_INFO_RESPONSE_PBUILD_MASK   );
+    api->rsp->part_info.reserved =   (( ( (rspByteBuffer[6]  ) | (rspByteBuffer[7]  << 8 )) >> Si2168_PART_INFO_RESPONSE_RESERVED_LSB ) & Si2168_PART_INFO_RESPONSE_RESERVED_MASK );
+    api->rsp->part_info.serial   =   (( ( (rspByteBuffer[8]  ) | (rspByteBuffer[9]  << 8 ) | (rspByteBuffer[10] << 16 ) | (rspByteBuffer[11] << 24 )) >> Si2168_PART_INFO_RESPONSE_SERIAL_LSB   ) & Si2168_PART_INFO_RESPONSE_SERIAL_MASK   );
+    api->rsp->part_info.romid    =   (( ( (rspByteBuffer[12] )) >> Si2168_PART_INFO_RESPONSE_ROMID_LSB    ) & Si2168_PART_INFO_RESPONSE_ROMID_MASK    );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_PART_INFO_CMD */
+#ifdef    Si2168_POWER_DOWN_CMD
+ /*---------------------------------------------------*/
+/* Si2168_POWER_DOWN COMMAND                       */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_POWER_DOWN                (L1_Si2168_Context *api)
+{
+    unsigned char cmdByteBuffer[1];
+    api->rsp->power_down.STATUS = api->status;
+
+    SiTRACE("Si2168 POWER_DOWN ");
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_POWER_DOWN_CMD;
+
+    if (L0_WriteCommandBytes(api->i2c, 1, cmdByteBuffer) != 1) {
+      SiTRACE("Error writing POWER_DOWN bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_POWER_DOWN_CMD */
+#ifdef    Si2168_POWER_UP_CMD
+ /*---------------------------------------------------*/
+/* Si2168_POWER_UP COMMAND                         */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_POWER_UP                  (L1_Si2168_Context *api,
+                                                   unsigned char   subcode,
+                                                   unsigned char   reset,
+                                                   unsigned char   reserved2,
+                                                   unsigned char   reserved4,
+                                                   unsigned char   reserved1,
+                                                   unsigned char   addr_mode,
+                                                   unsigned char   reserved5,
+                                                   unsigned char   func,
+                                                   unsigned char   clock_freq,
+                                                   unsigned char   ctsien,
+                                                   unsigned char   wake_up)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[8];
+    unsigned char rspByteBuffer[1];
+    api->rsp->power_up.STATUS = api->status;
+
+    SiTRACE("Si2168 POWER_UP ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((subcode    > Si2168_POWER_UP_CMD_SUBCODE_MAX   )  || (subcode    < Si2168_POWER_UP_CMD_SUBCODE_MIN   ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("SUBCODE %d "   , subcode    );
+    if ((reset      > Si2168_POWER_UP_CMD_RESET_MAX     )  || (reset      < Si2168_POWER_UP_CMD_RESET_MIN     ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESET %d "     , reset      );
+    if ((reserved2  > Si2168_POWER_UP_CMD_RESERVED2_MAX )  || (reserved2  < Si2168_POWER_UP_CMD_RESERVED2_MIN ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED2 %d " , reserved2  );
+    if ((reserved4  > Si2168_POWER_UP_CMD_RESERVED4_MAX ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED4 %d " , reserved4  );
+    if ((reserved1  > Si2168_POWER_UP_CMD_RESERVED1_MAX ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED1 %d " , reserved1  );
+    if ((addr_mode  > Si2168_POWER_UP_CMD_ADDR_MODE_MAX ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("ADDR_MODE %d " , addr_mode  );
+    if ((reserved5  > Si2168_POWER_UP_CMD_RESERVED5_MAX )  || (reserved5  < Si2168_POWER_UP_CMD_RESERVED5_MIN ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED5 %d " , reserved5  );
+    if ((func       > Si2168_POWER_UP_CMD_FUNC_MAX      ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("FUNC %d "      , func       );
+    if ((clock_freq > Si2168_POWER_UP_CMD_CLOCK_FREQ_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("CLOCK_FREQ %d ", clock_freq );
+    if ((ctsien     > Si2168_POWER_UP_CMD_CTSIEN_MAX    ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("CTSIEN %d "    , ctsien     );
+    if ((wake_up    > Si2168_POWER_UP_CMD_WAKE_UP_MAX   )  || (wake_up    < Si2168_POWER_UP_CMD_WAKE_UP_MIN   ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("WAKE_UP %d "   , wake_up    );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_POWER_UP_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( subcode    & Si2168_POWER_UP_CMD_SUBCODE_MASK    ) << Si2168_POWER_UP_CMD_SUBCODE_LSB   );
+    cmdByteBuffer[2] = (unsigned char) ( ( reset      & Si2168_POWER_UP_CMD_RESET_MASK      ) << Si2168_POWER_UP_CMD_RESET_LSB     );
+    cmdByteBuffer[3] = (unsigned char) ( ( reserved2  & Si2168_POWER_UP_CMD_RESERVED2_MASK  ) << Si2168_POWER_UP_CMD_RESERVED2_LSB );
+    cmdByteBuffer[4] = (unsigned char) ( ( reserved4  & Si2168_POWER_UP_CMD_RESERVED4_MASK  ) << Si2168_POWER_UP_CMD_RESERVED4_LSB );
+    cmdByteBuffer[5] = (unsigned char) ( ( reserved1  & Si2168_POWER_UP_CMD_RESERVED1_MASK  ) << Si2168_POWER_UP_CMD_RESERVED1_LSB |
+                                         ( addr_mode  & Si2168_POWER_UP_CMD_ADDR_MODE_MASK  ) << Si2168_POWER_UP_CMD_ADDR_MODE_LSB |
+                                         ( reserved5  & Si2168_POWER_UP_CMD_RESERVED5_MASK  ) << Si2168_POWER_UP_CMD_RESERVED5_LSB );
+    cmdByteBuffer[6] = (unsigned char) ( ( func       & Si2168_POWER_UP_CMD_FUNC_MASK       ) << Si2168_POWER_UP_CMD_FUNC_LSB      |
+                                         ( clock_freq & Si2168_POWER_UP_CMD_CLOCK_FREQ_MASK ) << Si2168_POWER_UP_CMD_CLOCK_FREQ_LSB|
+                                         ( ctsien     & Si2168_POWER_UP_CMD_CTSIEN_MASK     ) << Si2168_POWER_UP_CMD_CTSIEN_LSB    );
+    cmdByteBuffer[7] = (unsigned char) ( ( wake_up    & Si2168_POWER_UP_CMD_WAKE_UP_MASK    ) << Si2168_POWER_UP_CMD_WAKE_UP_LSB   );
+
+    if (L0_WriteCommandBytes(api->i2c, 8, cmdByteBuffer) != 8) {
+      SiTRACE("Error writing POWER_UP bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 1, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling POWER_UP response\n");
+      return error_code;
+    }
+
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_POWER_UP_CMD */
+#ifdef    Si2168_RSSI_ADC_CMD
+ /*---------------------------------------------------*/
+/* Si2168_RSSI_ADC COMMAND                         */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_RSSI_ADC                  (L1_Si2168_Context *api,
+                                                   unsigned char   on_off)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[2];
+    api->rsp->rssi_adc.STATUS = api->status;
+
+    SiTRACE("Si2168 RSSI_ADC ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((on_off > Si2168_RSSI_ADC_CMD_ON_OFF_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("ON_OFF %d ", on_off );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_RSSI_ADC_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( on_off & Si2168_RSSI_ADC_CMD_ON_OFF_MASK ) << Si2168_RSSI_ADC_CMD_ON_OFF_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing RSSI_ADC bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 2, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling RSSI_ADC response\n");
+      return error_code;
+    }
+
+    api->rsp->rssi_adc.level =   (( ( (rspByteBuffer[1]  )) >> Si2168_RSSI_ADC_RESPONSE_LEVEL_LSB ) & Si2168_RSSI_ADC_RESPONSE_LEVEL_MASK );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_RSSI_ADC_CMD */
+#ifdef    Si2168_SCAN_CTRL_CMD
+ /*---------------------------------------------------*/
+/* Si2168_SCAN_CTRL COMMAND                        */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_SCAN_CTRL                 (L1_Si2168_Context *api,
+                                                   unsigned char   action,
+                                                   unsigned long   tuned_rf_freq)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[8];
+    unsigned char rspByteBuffer[1];
+    api->rsp->scan_ctrl.STATUS = api->status;
+
+    SiTRACE("Si2168 SCAN_CTRL ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((action        > Si2168_SCAN_CTRL_CMD_ACTION_MAX       )  || (action        < Si2168_SCAN_CTRL_CMD_ACTION_MIN       ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("ACTION %d "       , action        );
+    SiTRACE("TUNED_RF_FREQ %d ", tuned_rf_freq );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_SCAN_CTRL_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( action        & Si2168_SCAN_CTRL_CMD_ACTION_MASK        ) << Si2168_SCAN_CTRL_CMD_ACTION_LSB       );
+    cmdByteBuffer[2] = (unsigned char)0x00;
+    cmdByteBuffer[3] = (unsigned char)0x00;
+    cmdByteBuffer[4] = (unsigned char) ( ( tuned_rf_freq & Si2168_SCAN_CTRL_CMD_TUNED_RF_FREQ_MASK ) << Si2168_SCAN_CTRL_CMD_TUNED_RF_FREQ_LSB);
+    cmdByteBuffer[5] = (unsigned char) ((( tuned_rf_freq & Si2168_SCAN_CTRL_CMD_TUNED_RF_FREQ_MASK ) << Si2168_SCAN_CTRL_CMD_TUNED_RF_FREQ_LSB)>>8);
+    cmdByteBuffer[6] = (unsigned char) ((( tuned_rf_freq & Si2168_SCAN_CTRL_CMD_TUNED_RF_FREQ_MASK ) << Si2168_SCAN_CTRL_CMD_TUNED_RF_FREQ_LSB)>>16);
+    cmdByteBuffer[7] = (unsigned char) ((( tuned_rf_freq & Si2168_SCAN_CTRL_CMD_TUNED_RF_FREQ_MASK ) << Si2168_SCAN_CTRL_CMD_TUNED_RF_FREQ_LSB)>>24);
+
+    if (L0_WriteCommandBytes(api->i2c, 8, cmdByteBuffer) != 8) {
+      SiTRACE("Error writing SCAN_CTRL bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 1, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling SCAN_CTRL response\n");
+      return error_code;
+    }
+
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_SCAN_CTRL_CMD */
+#ifdef    Si2168_SCAN_STATUS_CMD
+ /*---------------------------------------------------*/
+/* Si2168_SCAN_STATUS COMMAND                      */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_SCAN_STATUS               (L1_Si2168_Context *api,
+                                                   unsigned char   intack)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[11];
+    api->rsp->scan_status.STATUS = api->status;
+
+    SiTRACE("Si2168 SCAN_STATUS ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((intack > Si2168_SCAN_STATUS_CMD_INTACK_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("INTACK %d ", intack );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_SCAN_STATUS_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( intack & Si2168_SCAN_STATUS_CMD_INTACK_MASK ) << Si2168_SCAN_STATUS_CMD_INTACK_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing SCAN_STATUS bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 11, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling SCAN_STATUS response\n");
+      return error_code;
+    }
+
+    api->rsp->scan_status.buzint      =   (( ( (rspByteBuffer[1]  )) >> Si2168_SCAN_STATUS_RESPONSE_BUZINT_LSB      ) & Si2168_SCAN_STATUS_RESPONSE_BUZINT_MASK      );
+    api->rsp->scan_status.reqint      =   (( ( (rspByteBuffer[1]  )) >> Si2168_SCAN_STATUS_RESPONSE_REQINT_LSB      ) & Si2168_SCAN_STATUS_RESPONSE_REQINT_MASK      );
+    api->rsp->scan_status.buz         =   (( ( (rspByteBuffer[2]  )) >> Si2168_SCAN_STATUS_RESPONSE_BUZ_LSB         ) & Si2168_SCAN_STATUS_RESPONSE_BUZ_MASK         );
+    api->rsp->scan_status.req         =   (( ( (rspByteBuffer[2]  )) >> Si2168_SCAN_STATUS_RESPONSE_REQ_LSB         ) & Si2168_SCAN_STATUS_RESPONSE_REQ_MASK         );
+    api->rsp->scan_status.scan_status =   (( ( (rspByteBuffer[3]  )) >> Si2168_SCAN_STATUS_RESPONSE_SCAN_STATUS_LSB ) & Si2168_SCAN_STATUS_RESPONSE_SCAN_STATUS_MASK );
+    api->rsp->scan_status.rf_freq     =   (( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 ) | (rspByteBuffer[6]  << 16 ) | (rspByteBuffer[7]  << 24 )) >> Si2168_SCAN_STATUS_RESPONSE_RF_FREQ_LSB     ) & Si2168_SCAN_STATUS_RESPONSE_RF_FREQ_MASK     );
+    api->rsp->scan_status.symb_rate   =   (( ( (rspByteBuffer[8]  ) | (rspByteBuffer[9]  << 8 )) >> Si2168_SCAN_STATUS_RESPONSE_SYMB_RATE_LSB   ) & Si2168_SCAN_STATUS_RESPONSE_SYMB_RATE_MASK   );
+    api->rsp->scan_status.modulation  =   (( ( (rspByteBuffer[10] )) >> Si2168_SCAN_STATUS_RESPONSE_MODULATION_LSB  ) & Si2168_SCAN_STATUS_RESPONSE_MODULATION_MASK  );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_SCAN_STATUS_CMD */
+#ifdef    Si2168_SET_PROPERTY_CMD
+ /*---------------------------------------------------*/
+/* Si2168_SET_PROPERTY COMMAND                     */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_SET_PROPERTY              (L1_Si2168_Context *api,
+                                                   unsigned char   reserved,
+                                                   unsigned int    prop,
+                                                   unsigned int    data)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[6];
+    unsigned char rspByteBuffer[4];
+    api->rsp->set_property.STATUS = api->status;
+
+    SiTRACE("Si2168 SET_PROPERTY ");
+  #ifdef   DEBUG_RANGE_CHECK
+    SiTRACE("RESERVED %d ", reserved );
+    SiTRACE("PROP 0x%04x ", prop     );
+    SiTRACE("DATA %d "    , data     );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_SET_PROPERTY_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( reserved & Si2168_SET_PROPERTY_CMD_RESERVED_MASK ) << Si2168_SET_PROPERTY_CMD_RESERVED_LSB);
+    cmdByteBuffer[2] = (unsigned char) ( ( prop     & Si2168_SET_PROPERTY_CMD_PROP_MASK     ) << Si2168_SET_PROPERTY_CMD_PROP_LSB    );
+    cmdByteBuffer[3] = (unsigned char) ((( prop     & Si2168_SET_PROPERTY_CMD_PROP_MASK     ) << Si2168_SET_PROPERTY_CMD_PROP_LSB    )>>8);
+    cmdByteBuffer[4] = (unsigned char) ( ( data     & Si2168_SET_PROPERTY_CMD_DATA_MASK     ) << Si2168_SET_PROPERTY_CMD_DATA_LSB    );
+    cmdByteBuffer[5] = (unsigned char) ((( data     & Si2168_SET_PROPERTY_CMD_DATA_MASK     ) << Si2168_SET_PROPERTY_CMD_DATA_LSB    )>>8);
+
+    if (L0_WriteCommandBytes(api->i2c, 6, cmdByteBuffer) != 6) {
+      SiTRACE("Error writing SET_PROPERTY bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    error_code = Si2168_pollForResponse(api, 4, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling SET_PROPERTY response\n");
+      return error_code;
+    }
+
+    api->rsp->set_property.reserved =   (( ( (rspByteBuffer[1]  )) >> Si2168_SET_PROPERTY_RESPONSE_RESERVED_LSB ) & Si2168_SET_PROPERTY_RESPONSE_RESERVED_MASK );
+    api->rsp->set_property.data     =   (( ( (rspByteBuffer[2]  ) | (rspByteBuffer[3]  << 8 )) >> Si2168_SET_PROPERTY_RESPONSE_DATA_LSB     ) & Si2168_SET_PROPERTY_RESPONSE_DATA_MASK     );
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_SET_PROPERTY_CMD */
+#ifdef    Si2168_START_CLK_CMD
+ /*---------------------------------------------------*/
+/* Si2168_START_CLK COMMAND                        */
+/*---------------------------------------------------*/
+unsigned char Si2168_L1_START_CLK                 (L1_Si2168_Context *api,
+                                                   unsigned char   subcode,
+                                                   unsigned char   reserved1,
+                                                   unsigned char   tune_cap,
+                                                   unsigned char   reserved2,
+                                                   unsigned int    clk_mode,
+                                                   unsigned char   reserved3,
+                                                   unsigned char   reserved4,
+                                                   unsigned char   start_clk)
+{
+    /*unsigned char error_code = 0;*/
+    unsigned char cmdByteBuffer[13];
+    api->rsp->start_clk.STATUS = api->status;
+
+    SiTRACE("Si2168 START_CLK ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((subcode   > Si2168_START_CLK_CMD_SUBCODE_MAX  )  || (subcode   < Si2168_START_CLK_CMD_SUBCODE_MIN  ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("SUBCODE %d "  , subcode   );
+    if ((reserved1 > Si2168_START_CLK_CMD_RESERVED1_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED1 %d ", reserved1 );
+    if ((tune_cap  > Si2168_START_CLK_CMD_TUNE_CAP_MAX ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("TUNE_CAP %d " , tune_cap  );
+    if ((reserved2 > Si2168_START_CLK_CMD_RESERVED2_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED2 %d ", reserved2 );
+    if ((clk_mode  > Si2168_START_CLK_CMD_CLK_MODE_MAX )  || (clk_mode  < Si2168_START_CLK_CMD_CLK_MODE_MIN ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("CLK_MODE %d " , clk_mode  );
+    if ((reserved3 > Si2168_START_CLK_CMD_RESERVED3_MAX)  || (reserved3 < Si2168_START_CLK_CMD_RESERVED3_MIN) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED3 %d ", reserved3 );
+    if ((reserved4 > Si2168_START_CLK_CMD_RESERVED4_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED4 %d ", reserved4 );
+    if ((start_clk > Si2168_START_CLK_CMD_START_CLK_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("START_CLK %d ", start_clk );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2168_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2168_START_CLK_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( subcode   & Si2168_START_CLK_CMD_SUBCODE_MASK   ) << Si2168_START_CLK_CMD_SUBCODE_LSB  );
+    cmdByteBuffer[2] = (unsigned char) ( ( reserved1 & Si2168_START_CLK_CMD_RESERVED1_MASK ) << Si2168_START_CLK_CMD_RESERVED1_LSB);
+    cmdByteBuffer[3] = (unsigned char) ( ( tune_cap  & Si2168_START_CLK_CMD_TUNE_CAP_MASK  ) << Si2168_START_CLK_CMD_TUNE_CAP_LSB |
+                                         ( reserved2 & Si2168_START_CLK_CMD_RESERVED2_MASK ) << Si2168_START_CLK_CMD_RESERVED2_LSB);
+    cmdByteBuffer[4] = (unsigned char) ( ( clk_mode  & Si2168_START_CLK_CMD_CLK_MODE_MASK  ) << Si2168_START_CLK_CMD_CLK_MODE_LSB );
+    cmdByteBuffer[5] = (unsigned char) ((( clk_mode  & Si2168_START_CLK_CMD_CLK_MODE_MASK  ) << Si2168_START_CLK_CMD_CLK_MODE_LSB )>>8);
+    cmdByteBuffer[6] = (unsigned char) ( ( reserved3 & Si2168_START_CLK_CMD_RESERVED3_MASK ) << Si2168_START_CLK_CMD_RESERVED3_LSB);
+    cmdByteBuffer[7] = (unsigned char) ( ( reserved4 & Si2168_START_CLK_CMD_RESERVED4_MASK ) << Si2168_START_CLK_CMD_RESERVED4_LSB);
+    cmdByteBuffer[8] = (unsigned char)0x00;
+    cmdByteBuffer[9] = (unsigned char)0x00;
+    cmdByteBuffer[10] = (unsigned char)0x00;
+    cmdByteBuffer[11] = (unsigned char)0x00;
+    cmdByteBuffer[12] = (unsigned char) ( ( start_clk & Si2168_START_CLK_CMD_START_CLK_MASK ) << Si2168_START_CLK_CMD_START_CLK_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 13, cmdByteBuffer) != 13) {
+      SiTRACE("Error writing START_CLK bytes!\n");
+      return ERROR_Si2168_SENDING_COMMAND;
+    }
+
+    return NO_Si2168_ERROR;
+}
+#endif /* Si2168_START_CLK_CMD */
+
+/***********************************************************************************************************************
+  Si2168_L1_SetProperty function
+  Use:        property set function
+              Used to call L1_SET_PROPERTY with the property Id and data provided.
+  Parameter: *api     the Si2168 context
+  Parameter: prop     the property Id
+  Parameter: data     the property bytes
+  Returns:    0 if no error, an error code otherwise
+ ***********************************************************************************************************************/
+unsigned char Si2168_L1_SetProperty(L1_Si2168_Context *api, unsigned int prop, int  data)  {
+    unsigned char  reserved          = 0;
+    return Si2168_L1_SET_PROPERTY (api, reserved, prop, data);
+}
+
+  /* --------------------------------------------*/
+  /* SET_PROPERTY2 FUNCTION                      */
+  /* --------------------------------------------*/
+unsigned char Si2168_L1_SetProperty2(L1_Si2168_Context *api, unsigned int prop_code) {
+    int data = 0;
+#ifdef    Si2168_GET_PROPERTY_STRING
+    char msg[1000];
+#endif /* Si2168_GET_PROPERTY_STRING */
+    switch (prop_code) {
+    #ifdef        Si2168_DD_BER_RESOL_PROP
+     case         Si2168_DD_BER_RESOL_PROP_CODE:
+       data = (api->prop->dd_ber_resol.exp  & Si2168_DD_BER_RESOL_PROP_EXP_MASK ) << Si2168_DD_BER_RESOL_PROP_EXP_LSB  |
+              (api->prop->dd_ber_resol.mant & Si2168_DD_BER_RESOL_PROP_MANT_MASK) << Si2168_DD_BER_RESOL_PROP_MANT_LSB ;
+     break;
+    #endif /*     Si2168_DD_BER_RESOL_PROP */
+    #ifdef        Si2168_DD_CBER_RESOL_PROP
+     case         Si2168_DD_CBER_RESOL_PROP_CODE:
+       data = (api->prop->dd_cber_resol.exp  & Si2168_DD_CBER_RESOL_PROP_EXP_MASK ) << Si2168_DD_CBER_RESOL_PROP_EXP_LSB  |
+              (api->prop->dd_cber_resol.mant & Si2168_DD_CBER_RESOL_PROP_MANT_MASK) << Si2168_DD_CBER_RESOL_PROP_MANT_LSB ;
+     break;
+    #endif /*     Si2168_DD_CBER_RESOL_PROP */
+
+    #ifdef        Si2168_DD_FER_RESOL_PROP
+     case         Si2168_DD_FER_RESOL_PROP_CODE:
+       data = (api->prop->dd_fer_resol.exp  & Si2168_DD_FER_RESOL_PROP_EXP_MASK ) << Si2168_DD_FER_RESOL_PROP_EXP_LSB  |
+              (api->prop->dd_fer_resol.mant & Si2168_DD_FER_RESOL_PROP_MANT_MASK) << Si2168_DD_FER_RESOL_PROP_MANT_LSB ;
+     break;
+    #endif /*     Si2168_DD_FER_RESOL_PROP */
+    #ifdef        Si2168_DD_IEN_PROP
+     case         Si2168_DD_IEN_PROP_CODE:
+       data = (api->prop->dd_ien.ien_bit0 & Si2168_DD_IEN_PROP_IEN_BIT0_MASK) << Si2168_DD_IEN_PROP_IEN_BIT0_LSB  |
+              (api->prop->dd_ien.ien_bit1 & Si2168_DD_IEN_PROP_IEN_BIT1_MASK) << Si2168_DD_IEN_PROP_IEN_BIT1_LSB  |
+              (api->prop->dd_ien.ien_bit2 & Si2168_DD_IEN_PROP_IEN_BIT2_MASK) << Si2168_DD_IEN_PROP_IEN_BIT2_LSB  |
+              (api->prop->dd_ien.ien_bit3 & Si2168_DD_IEN_PROP_IEN_BIT3_MASK) << Si2168_DD_IEN_PROP_IEN_BIT3_LSB  |
+              (api->prop->dd_ien.ien_bit4 & Si2168_DD_IEN_PROP_IEN_BIT4_MASK) << Si2168_DD_IEN_PROP_IEN_BIT4_LSB  |
+              (api->prop->dd_ien.ien_bit5 & Si2168_DD_IEN_PROP_IEN_BIT5_MASK) << Si2168_DD_IEN_PROP_IEN_BIT5_LSB  |
+              (api->prop->dd_ien.ien_bit6 & Si2168_DD_IEN_PROP_IEN_BIT6_MASK) << Si2168_DD_IEN_PROP_IEN_BIT6_LSB  |
+              (api->prop->dd_ien.ien_bit7 & Si2168_DD_IEN_PROP_IEN_BIT7_MASK) << Si2168_DD_IEN_PROP_IEN_BIT7_LSB ;
+     break;
+    #endif /*     Si2168_DD_IEN_PROP */
+    #ifdef        Si2168_DD_IF_INPUT_FREQ_PROP
+     case         Si2168_DD_IF_INPUT_FREQ_PROP_CODE:
+       data = (api->prop->dd_if_input_freq.offset & Si2168_DD_IF_INPUT_FREQ_PROP_OFFSET_MASK) << Si2168_DD_IF_INPUT_FREQ_PROP_OFFSET_LSB ;
+     break;
+    #endif /*     Si2168_DD_IF_INPUT_FREQ_PROP */
+    #ifdef        Si2168_DD_INT_SENSE_PROP
+     case         Si2168_DD_INT_SENSE_PROP_CODE:
+       data = (api->prop->dd_int_sense.neg_bit0 & Si2168_DD_INT_SENSE_PROP_NEG_BIT0_MASK) << Si2168_DD_INT_SENSE_PROP_NEG_BIT0_LSB  |
+              (api->prop->dd_int_sense.neg_bit1 & Si2168_DD_INT_SENSE_PROP_NEG_BIT1_MASK) << Si2168_DD_INT_SENSE_PROP_NEG_BIT1_LSB  |
+              (api->prop->dd_int_sense.neg_bit2 & Si2168_DD_INT_SENSE_PROP_NEG_BIT2_MASK) << Si2168_DD_INT_SENSE_PROP_NEG_BIT2_LSB  |
+              (api->prop->dd_int_sense.neg_bit3 & Si2168_DD_INT_SENSE_PROP_NEG_BIT3_MASK) << Si2168_DD_INT_SENSE_PROP_NEG_BIT3_LSB  |
+              (api->prop->dd_int_sense.neg_bit4 & Si2168_DD_INT_SENSE_PROP_NEG_BIT4_MASK) << Si2168_DD_INT_SENSE_PROP_NEG_BIT4_LSB  |
+              (api->prop->dd_int_sense.neg_bit5 & Si2168_DD_INT_SENSE_PROP_NEG_BIT5_MASK) << Si2168_DD_INT_SENSE_PROP_NEG_BIT5_LSB  |
+              (api->prop->dd_int_sense.neg_bit6 & Si2168_DD_INT_SENSE_PROP_NEG_BIT6_MASK) << Si2168_DD_INT_SENSE_PROP_NEG_BIT6_LSB  |
+              (api->prop->dd_int_sense.neg_bit7 & Si2168_DD_INT_SENSE_PROP_NEG_BIT7_MASK) << Si2168_DD_INT_SENSE_PROP_NEG_BIT7_LSB  |
+              (api->prop->dd_int_sense.pos_bit0 & Si2168_DD_INT_SENSE_PROP_POS_BIT0_MASK) << Si2168_DD_INT_SENSE_PROP_POS_BIT0_LSB  |
+              (api->prop->dd_int_sense.pos_bit1 & Si2168_DD_INT_SENSE_PROP_POS_BIT1_MASK) << Si2168_DD_INT_SENSE_PROP_POS_BIT1_LSB  |
+              (api->prop->dd_int_sense.pos_bit2 & Si2168_DD_INT_SENSE_PROP_POS_BIT2_MASK) << Si2168_DD_INT_SENSE_PROP_POS_BIT2_LSB  |
+              (api->prop->dd_int_sense.pos_bit3 & Si2168_DD_INT_SENSE_PROP_POS_BIT3_MASK) << Si2168_DD_INT_SENSE_PROP_POS_BIT3_LSB  |
+              (api->prop->dd_int_sense.pos_bit4 & Si2168_DD_INT_SENSE_PROP_POS_BIT4_MASK) << Si2168_DD_INT_SENSE_PROP_POS_BIT4_LSB  |
+              (api->prop->dd_int_sense.pos_bit5 & Si2168_DD_INT_SENSE_PROP_POS_BIT5_MASK) << Si2168_DD_INT_SENSE_PROP_POS_BIT5_LSB  |
+              (api->prop->dd_int_sense.pos_bit6 & Si2168_DD_INT_SENSE_PROP_POS_BIT6_MASK) << Si2168_DD_INT_SENSE_PROP_POS_BIT6_LSB  |
+              (api->prop->dd_int_sense.pos_bit7 & Si2168_DD_INT_SENSE_PROP_POS_BIT7_MASK) << Si2168_DD_INT_SENSE_PROP_POS_BIT7_LSB ;
+     break;
+    #endif /*     Si2168_DD_INT_SENSE_PROP */
+    #ifdef        Si2168_DD_MODE_PROP
+     case         Si2168_DD_MODE_PROP_CODE:
+       data = (api->prop->dd_mode.bw              & Si2168_DD_MODE_PROP_BW_MASK             ) << Si2168_DD_MODE_PROP_BW_LSB  |
+              (api->prop->dd_mode.modulation      & Si2168_DD_MODE_PROP_MODULATION_MASK     ) << Si2168_DD_MODE_PROP_MODULATION_LSB  |
+              (api->prop->dd_mode.invert_spectrum & Si2168_DD_MODE_PROP_INVERT_SPECTRUM_MASK) << Si2168_DD_MODE_PROP_INVERT_SPECTRUM_LSB  |
+              (api->prop->dd_mode.auto_detect     & Si2168_DD_MODE_PROP_AUTO_DETECT_MASK    ) << Si2168_DD_MODE_PROP_AUTO_DETECT_LSB ;
+     break;
+    #endif /*     Si2168_DD_MODE_PROP */
+    #ifdef        Si2168_DD_PER_RESOL_PROP
+     case         Si2168_DD_PER_RESOL_PROP_CODE:
+       data = (api->prop->dd_per_resol.exp  & Si2168_DD_PER_RESOL_PROP_EXP_MASK ) << Si2168_DD_PER_RESOL_PROP_EXP_LSB  |
+              (api->prop->dd_per_resol.mant & Si2168_DD_PER_RESOL_PROP_MANT_MASK) << Si2168_DD_PER_RESOL_PROP_MANT_LSB ;
+     break;
+    #endif /*     Si2168_DD_PER_RESOL_PROP */
+    #ifdef        Si2168_DD_RSQ_BER_THRESHOLD_PROP
+     case         Si2168_DD_RSQ_BER_THRESHOLD_PROP_CODE:
+       data = (api->prop->dd_rsq_ber_threshold.exp  & Si2168_DD_RSQ_BER_THRESHOLD_PROP_EXP_MASK ) << Si2168_DD_RSQ_BER_THRESHOLD_PROP_EXP_LSB  |
+              (api->prop->dd_rsq_ber_threshold.mant & Si2168_DD_RSQ_BER_THRESHOLD_PROP_MANT_MASK) << Si2168_DD_RSQ_BER_THRESHOLD_PROP_MANT_LSB ;
+     break;
+    #endif /*     Si2168_DD_RSQ_BER_THRESHOLD_PROP */
+    #ifdef        Si2168_DD_TS_FREQ_PROP
+     case         Si2168_DD_TS_FREQ_PROP_CODE:
+       data = (api->prop->dd_ts_freq.req_freq_10khz & Si2168_DD_TS_FREQ_PROP_REQ_FREQ_10KHZ_MASK) << Si2168_DD_TS_FREQ_PROP_REQ_FREQ_10KHZ_LSB ;
+     break;
+    #endif /*     Si2168_DD_TS_FREQ_PROP */
+    #ifdef        Si2168_DD_TS_MODE_PROP
+     case         Si2168_DD_TS_MODE_PROP_CODE:
+       data = (api->prop->dd_ts_mode.mode          & Si2168_DD_TS_MODE_PROP_MODE_MASK         ) << Si2168_DD_TS_MODE_PROP_MODE_LSB  |
+              (api->prop->dd_ts_mode.clock         & Si2168_DD_TS_MODE_PROP_CLOCK_MASK        ) << Si2168_DD_TS_MODE_PROP_CLOCK_LSB  |
+              (api->prop->dd_ts_mode.clk_gapped_en   & Si2168_DD_TS_MODE_PROP_CLK_GAPPED_EN_MASK  ) << Si2168_DD_TS_MODE_PROP_CLK_GAPPED_EN_LSB  |
+              (api->prop->dd_ts_mode.ts_err_polarity & Si2168_DD_TS_MODE_PROP_TS_ERR_POLARITY_MASK) << Si2168_DD_TS_MODE_PROP_TS_ERR_POLARITY_LSB  |
+              (api->prop->dd_ts_mode.special         & Si2168_DD_TS_MODE_PROP_SPECIAL_MASK        ) << Si2168_DD_TS_MODE_PROP_SPECIAL_LSB ;
+     break;
+    #endif /*     Si2168_DD_TS_MODE_PROP */
+    #ifdef        Si2168_DD_TS_SETUP_PAR_PROP
+     case         Si2168_DD_TS_SETUP_PAR_PROP_CODE:
+       data = (api->prop->dd_ts_setup_par.ts_data_strength & Si2168_DD_TS_SETUP_PAR_PROP_TS_DATA_STRENGTH_MASK) << Si2168_DD_TS_SETUP_PAR_PROP_TS_DATA_STRENGTH_LSB  |
+              (api->prop->dd_ts_setup_par.ts_data_shape    & Si2168_DD_TS_SETUP_PAR_PROP_TS_DATA_SHAPE_MASK   ) << Si2168_DD_TS_SETUP_PAR_PROP_TS_DATA_SHAPE_LSB  |
+              (api->prop->dd_ts_setup_par.ts_clk_strength  & Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_STRENGTH_MASK ) << Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_STRENGTH_LSB  |
+              (api->prop->dd_ts_setup_par.ts_clk_shape     & Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_SHAPE_MASK    ) << Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_SHAPE_LSB  |
+              (api->prop->dd_ts_setup_par.ts_clk_invert    & Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_MASK   ) << Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_LSB  |
+              (api->prop->dd_ts_setup_par.ts_clk_shift     & Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_SHIFT_MASK    ) << Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_SHIFT_LSB ;
+     break;
+    #endif /*     Si2168_DD_TS_SETUP_PAR_PROP */
+    #ifdef        Si2168_DD_TS_SETUP_SER_PROP
+     case         Si2168_DD_TS_SETUP_SER_PROP_CODE:
+       data = (api->prop->dd_ts_setup_ser.ts_data_strength & Si2168_DD_TS_SETUP_SER_PROP_TS_DATA_STRENGTH_MASK) << Si2168_DD_TS_SETUP_SER_PROP_TS_DATA_STRENGTH_LSB  |
+              (api->prop->dd_ts_setup_ser.ts_data_shape    & Si2168_DD_TS_SETUP_SER_PROP_TS_DATA_SHAPE_MASK   ) << Si2168_DD_TS_SETUP_SER_PROP_TS_DATA_SHAPE_LSB  |
+              (api->prop->dd_ts_setup_ser.ts_clk_strength  & Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_STRENGTH_MASK ) << Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_STRENGTH_LSB  |
+              (api->prop->dd_ts_setup_ser.ts_clk_shape     & Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_SHAPE_MASK    ) << Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_SHAPE_LSB  |
+              (api->prop->dd_ts_setup_ser.ts_clk_invert    & Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_MASK   ) << Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_LSB  |
+              (api->prop->dd_ts_setup_ser.ts_sync_duration & Si2168_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_MASK) << Si2168_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_LSB  |
+              (api->prop->dd_ts_setup_ser.ts_byte_order    & Si2168_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_MASK   ) << Si2168_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_LSB ;
+     break;
+    #endif /*     Si2168_DD_TS_SETUP_SER_PROP */
+    #ifdef        Si2168_DVBC_ADC_CREST_FACTOR_PROP
+     case         Si2168_DVBC_ADC_CREST_FACTOR_PROP_CODE:
+       data = (api->prop->dvbc_adc_crest_factor.crest_factor & Si2168_DVBC_ADC_CREST_FACTOR_PROP_CREST_FACTOR_MASK) << Si2168_DVBC_ADC_CREST_FACTOR_PROP_CREST_FACTOR_LSB ;
+     break;
+    #endif /*     Si2168_DVBC_ADC_CREST_FACTOR_PROP */
+    #ifdef        Si2168_DVBC_AFC_RANGE_PROP
+     case         Si2168_DVBC_AFC_RANGE_PROP_CODE:
+       data = (api->prop->dvbc_afc_range.range_khz & Si2168_DVBC_AFC_RANGE_PROP_RANGE_KHZ_MASK) << Si2168_DVBC_AFC_RANGE_PROP_RANGE_KHZ_LSB ;
+     break;
+    #endif /*     Si2168_DVBC_AFC_RANGE_PROP */
+    #ifdef        Si2168_DVBC_CONSTELLATION_PROP
+     case         Si2168_DVBC_CONSTELLATION_PROP_CODE:
+       data = (api->prop->dvbc_constellation.constellation & Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_MASK) << Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_LSB ;
+     break;
+    #endif /*     Si2168_DVBC_CONSTELLATION_PROP */
+    #ifdef        Si2168_DVBC_SYMBOL_RATE_PROP
+     case         Si2168_DVBC_SYMBOL_RATE_PROP_CODE:
+       data = (api->prop->dvbc_symbol_rate.rate & Si2168_DVBC_SYMBOL_RATE_PROP_RATE_MASK) << Si2168_DVBC_SYMBOL_RATE_PROP_RATE_LSB ;
+     break;
+    #endif /*     Si2168_DVBC_SYMBOL_RATE_PROP */
+
+
+    #ifdef        Si2168_DVBT2_ADC_CREST_FACTOR_PROP
+     case         Si2168_DVBT2_ADC_CREST_FACTOR_PROP_CODE:
+       data = (api->prop->dvbt2_adc_crest_factor.crest_factor & Si2168_DVBT2_ADC_CREST_FACTOR_PROP_CREST_FACTOR_MASK) << Si2168_DVBT2_ADC_CREST_FACTOR_PROP_CREST_FACTOR_LSB ;
+     break;
+    #endif /*     Si2168_DVBT2_ADC_CREST_FACTOR_PROP */
+    #ifdef        Si2168_DVBT2_AFC_RANGE_PROP
+     case         Si2168_DVBT2_AFC_RANGE_PROP_CODE:
+       data = (api->prop->dvbt2_afc_range.range_khz & Si2168_DVBT2_AFC_RANGE_PROP_RANGE_KHZ_MASK) << Si2168_DVBT2_AFC_RANGE_PROP_RANGE_KHZ_LSB ;
+     break;
+    #endif /*     Si2168_DVBT2_AFC_RANGE_PROP */
+    #ifdef        Si2168_DVBT2_FEF_TUNER_PROP
+     case         Si2168_DVBT2_FEF_TUNER_PROP_CODE:
+       data = (api->prop->dvbt2_fef_tuner.tuner_delay         & Si2168_DVBT2_FEF_TUNER_PROP_TUNER_DELAY_MASK        ) << Si2168_DVBT2_FEF_TUNER_PROP_TUNER_DELAY_LSB  |
+              (api->prop->dvbt2_fef_tuner.tuner_freeze_time   & Si2168_DVBT2_FEF_TUNER_PROP_TUNER_FREEZE_TIME_MASK  ) << Si2168_DVBT2_FEF_TUNER_PROP_TUNER_FREEZE_TIME_LSB  |
+              (api->prop->dvbt2_fef_tuner.tuner_unfreeze_time & Si2168_DVBT2_FEF_TUNER_PROP_TUNER_UNFREEZE_TIME_MASK) << Si2168_DVBT2_FEF_TUNER_PROP_TUNER_UNFREEZE_TIME_LSB ;
+     break;
+    #endif /*     Si2168_DVBT2_FEF_TUNER_PROP */
+
+    #ifdef        Si2168_DVBT_ADC_CREST_FACTOR_PROP
+     case         Si2168_DVBT_ADC_CREST_FACTOR_PROP_CODE:
+       data = (api->prop->dvbt_adc_crest_factor.crest_factor & Si2168_DVBT_ADC_CREST_FACTOR_PROP_CREST_FACTOR_MASK) << Si2168_DVBT_ADC_CREST_FACTOR_PROP_CREST_FACTOR_LSB ;
+     break;
+    #endif /*     Si2168_DVBT_ADC_CREST_FACTOR_PROP */
+    #ifdef        Si2168_DVBT_AFC_RANGE_PROP
+     case         Si2168_DVBT_AFC_RANGE_PROP_CODE:
+       data = (api->prop->dvbt_afc_range.range_khz & Si2168_DVBT_AFC_RANGE_PROP_RANGE_KHZ_MASK) << Si2168_DVBT_AFC_RANGE_PROP_RANGE_KHZ_LSB ;
+     break;
+    #endif /*     Si2168_DVBT_AFC_RANGE_PROP */
+    #ifdef        Si2168_DVBT_HIERARCHY_PROP
+     case         Si2168_DVBT_HIERARCHY_PROP_CODE:
+       data = (api->prop->dvbt_hierarchy.stream & Si2168_DVBT_HIERARCHY_PROP_STREAM_MASK) << Si2168_DVBT_HIERARCHY_PROP_STREAM_LSB ;
+     break;
+    #endif /*     Si2168_DVBT_HIERARCHY_PROP */
+
+    #ifdef        Si2168_MASTER_IEN_PROP
+     case         Si2168_MASTER_IEN_PROP_CODE:
+       data = (api->prop->master_ien.ddien   & Si2168_MASTER_IEN_PROP_DDIEN_MASK  ) << Si2168_MASTER_IEN_PROP_DDIEN_LSB  |
+              (api->prop->master_ien.scanien & Si2168_MASTER_IEN_PROP_SCANIEN_MASK) << Si2168_MASTER_IEN_PROP_SCANIEN_LSB  |
+              (api->prop->master_ien.errien  & Si2168_MASTER_IEN_PROP_ERRIEN_MASK ) << Si2168_MASTER_IEN_PROP_ERRIEN_LSB  |
+              (api->prop->master_ien.ctsien  & Si2168_MASTER_IEN_PROP_CTSIEN_MASK ) << Si2168_MASTER_IEN_PROP_CTSIEN_LSB ;
+     break;
+    #endif /*     Si2168_MASTER_IEN_PROP */
+    #ifdef        Si2168_SCAN_FMAX_PROP
+     case         Si2168_SCAN_FMAX_PROP_CODE:
+       data = (api->prop->scan_fmax.scan_fmax & Si2168_SCAN_FMAX_PROP_SCAN_FMAX_MASK) << Si2168_SCAN_FMAX_PROP_SCAN_FMAX_LSB ;
+     break;
+    #endif /*     Si2168_SCAN_FMAX_PROP */
+    #ifdef        Si2168_SCAN_FMIN_PROP
+     case         Si2168_SCAN_FMIN_PROP_CODE:
+       data = (api->prop->scan_fmin.scan_fmin & Si2168_SCAN_FMIN_PROP_SCAN_FMIN_MASK) << Si2168_SCAN_FMIN_PROP_SCAN_FMIN_LSB ;
+     break;
+    #endif /*     Si2168_SCAN_FMIN_PROP */
+    #ifdef        Si2168_SCAN_IEN_PROP
+     case         Si2168_SCAN_IEN_PROP_CODE:
+       data = (api->prop->scan_ien.buzien & Si2168_SCAN_IEN_PROP_BUZIEN_MASK) << Si2168_SCAN_IEN_PROP_BUZIEN_LSB  |
+              (api->prop->scan_ien.reqien & Si2168_SCAN_IEN_PROP_REQIEN_MASK) << Si2168_SCAN_IEN_PROP_REQIEN_LSB ;
+     break;
+    #endif /*     Si2168_SCAN_IEN_PROP */
+    #ifdef        Si2168_SCAN_INT_SENSE_PROP
+     case         Si2168_SCAN_INT_SENSE_PROP_CODE:
+       data = (api->prop->scan_int_sense.buznegen & Si2168_SCAN_INT_SENSE_PROP_BUZNEGEN_MASK) << Si2168_SCAN_INT_SENSE_PROP_BUZNEGEN_LSB  |
+              (api->prop->scan_int_sense.reqnegen & Si2168_SCAN_INT_SENSE_PROP_REQNEGEN_MASK) << Si2168_SCAN_INT_SENSE_PROP_REQNEGEN_LSB  |
+              (api->prop->scan_int_sense.buzposen & Si2168_SCAN_INT_SENSE_PROP_BUZPOSEN_MASK) << Si2168_SCAN_INT_SENSE_PROP_BUZPOSEN_LSB  |
+              (api->prop->scan_int_sense.reqposen & Si2168_SCAN_INT_SENSE_PROP_REQPOSEN_MASK) << Si2168_SCAN_INT_SENSE_PROP_REQPOSEN_LSB ;
+     break;
+    #endif /*     Si2168_SCAN_INT_SENSE_PROP */
+
+    #ifdef        Si2168_SCAN_SYMB_RATE_MAX_PROP
+     case         Si2168_SCAN_SYMB_RATE_MAX_PROP_CODE:
+       data = (api->prop->scan_symb_rate_max.scan_symb_rate_max & Si2168_SCAN_SYMB_RATE_MAX_PROP_SCAN_SYMB_RATE_MAX_MASK) << Si2168_SCAN_SYMB_RATE_MAX_PROP_SCAN_SYMB_RATE_MAX_LSB ;
+     break;
+    #endif /*     Si2168_SCAN_SYMB_RATE_MAX_PROP */
+    #ifdef        Si2168_SCAN_SYMB_RATE_MIN_PROP
+     case         Si2168_SCAN_SYMB_RATE_MIN_PROP_CODE:
+       data = (api->prop->scan_symb_rate_min.scan_symb_rate_min & Si2168_SCAN_SYMB_RATE_MIN_PROP_SCAN_SYMB_RATE_MIN_MASK) << Si2168_SCAN_SYMB_RATE_MIN_PROP_SCAN_SYMB_RATE_MIN_LSB ;
+     break;
+    #endif /*     Si2168_SCAN_SYMB_RATE_MIN_PROP */
+    #ifdef        Si2168_SCAN_TER_CONFIG_PROP
+     case         Si2168_SCAN_TER_CONFIG_PROP_CODE:
+       data = (api->prop->scan_ter_config.mode          & Si2168_SCAN_TER_CONFIG_PROP_MODE_MASK         ) << Si2168_SCAN_TER_CONFIG_PROP_MODE_LSB  |
+              (api->prop->scan_ter_config.analog_bw     & Si2168_SCAN_TER_CONFIG_PROP_ANALOG_BW_MASK    ) << Si2168_SCAN_TER_CONFIG_PROP_ANALOG_BW_LSB  |
+              (api->prop->scan_ter_config.search_analog & Si2168_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_MASK) << Si2168_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_LSB ;
+     break;
+    #endif /*     Si2168_SCAN_TER_CONFIG_PROP */
+
+   default : break;
+    }
+#ifdef    Si2168_GET_PROPERTY_STRING
+    Si2168_L1_FillPropertyStringText(api, prop_code, (char*)" ", msg);
+    SiTRACE("%s\n",msg);
+#endif /* Si2168_GET_PROPERTY_STRING */
+    return Si2168_L1_SetProperty(api, prop_code & 0xffff , data);
+  }
+
+/***********************************************************************************************************************
+  Si2168_pollForResponse function
+  Use:        command response retrieval function
+              Used to retrieve the command response in the provided buffer
+  Comments:   The status byte definition being identical for all commands,
+              using this function to fill the status structure helps reducing the code size
+              max timeout = 1000 ms
+
+  Parameter:  nbBytes          the number of response bytes to read
+  Parameter:  pByteBuffer      a buffer into which bytes will be stored
+  Returns:    0 if no error, an error code otherwise
+ ***********************************************************************************************************************/
+unsigned char Si2168_pollForResponse (L1_Si2168_Context *api, unsigned int nbBytes, unsigned char *pByteBuffer)
+{
+  //unsigned int start_time;
+  u32 ulCount, ulTick, ulDelay;
+  ulCount = 0;
+  ulTick = 50;
+  ulDelay = 1000/ulTick;
+ 
+  //start_time = system_time();
+
+  //while (system_time() - start_time <1000)  { /* wait a maximum of 1000ms */
+  while(ulCount <= ulTick) {
+    if ((unsigned int)L0_ReadCommandBytes(api->i2c, nbBytes, pByteBuffer) != nbBytes) {
+      SiTRACE("Si2168_pollForResponse ERROR reading byte 0!\n");
+      return ERROR_Si2168_POLLING_RESPONSE;
+    }
+    /* return response err flag if CTS set */
+    if (pByteBuffer[0] & 0x80)  {
+      return Si2168_CurrentResponseStatus(api, pByteBuffer[0]);
+    }
+    delayMS(ulDelay);
+    ulCount++;
+  }
+
+  SiTRACE("Si2168_pollForResponse ERROR CTS Timeout!\n");
+  return ERROR_Si2168_CTS_TIMEOUT;
+}
+/***********************************************************************************************************************
+  Si2168_L1_API_ERROR_TEXT function
+  Use:        Error information function
+              Used to retrieve a text based on an error code
+  Returns:    the error text
+  Parameter:  error_code the error code.
+  Porting:    Useful for application development for debug purposes.
+  Porting:    May not be required for the final application, can be removed if not used.
+ ***********************************************************************************************************************/
+char*            Si2168_L1_API_ERROR_TEXT(unsigned char error_code) {
+    switch (error_code) {
+        case NO_Si2168_ERROR                     : return (char *)"No Si2168 error";
+        case ERROR_Si2168_ALLOCATING_CONTEXT     : return (char *)"Error while allocating Si2168 context";
+        case ERROR_Si2168_PARAMETER_OUT_OF_RANGE : return (char *)"Si2168 parameter(s) out of range";
+        case ERROR_Si2168_SENDING_COMMAND        : return (char *)"Error while sending Si2168 command";
+        case ERROR_Si2168_CTS_TIMEOUT            : return (char *)"Si2168 CTS timeout";
+        case ERROR_Si2168_ERR                    : return (char *)"Si2168 Error (status 'err' bit 1)";
+        case ERROR_Si2168_POLLING_CTS            : return (char *)"Si2168 Error while polling CTS";
+        case ERROR_Si2168_POLLING_RESPONSE       : return (char *)"Si2168 Error while polling response";
+        case ERROR_Si2168_LOADING_FIRMWARE       : return (char *)"Si2168 Error while loading firmware";
+        case ERROR_Si2168_LOADING_BOOTBLOCK      : return (char *)"Si2168 Error while loading bootblock";
+        case ERROR_Si2168_STARTING_FIRMWARE      : return (char *)"Si2168 Error while starting firmware";
+        case ERROR_Si2168_SW_RESET               : return (char *)"Si2168 Error during software reset";
+        case ERROR_Si2168_INCOMPATIBLE_PART      : return (char *)"Si2168 Error Incompatible part";
+/* _specific_error_text_string_insertion_start */
+/* _specific_error_text_string_insertion_point */
+        default                                  : return (char *)"Unknown Si2168 error code";
+    }
+}
+/***********************************************************************************************************************
+  Si2168_L1_API_Patch function
+  Use:        Patch information function
+              Used to send a number of bytes to the Si2168. Useful to download the firmware.
+  Returns:    0 if no error
+  Parameter:  error_code the error code.
+  Porting:    Useful for application development for debug purposes.
+  Porting:    May not be required for the final application, can be removed if not used.
+ ***********************************************************************************************************************/
+unsigned char    Si2168_L1_API_Patch     (L1_Si2168_Context *api, int iNbBytes, unsigned char *pucDataBuffer) {
+    unsigned char res;
+    unsigned char rspByteBuffer[1];
+
+//    SiTRACE("Si2168 Patch %d bytes\n",iNbBytes);
+
+    res = (unsigned char)L0_WriteCommandBytes(api->i2c, iNbBytes, pucDataBuffer);
+    if (res!=iNbBytes) {
+      SiTRACE("Si2168_L1_API_Patch error 0x%02x writing bytes: %s\n", res, Si2168_L1_API_ERROR_TEXT(res) );
+      return res;
+    }
+
+    res = Si2168_pollForResponse(api, 1, rspByteBuffer);
+    if (res != NO_Si2168_ERROR) {
+      SiTRACE("Si2168_L1_API_Patch error 0x%02x polling response: %s\n", res, Si2168_L1_API_ERROR_TEXT(res) );
+      return ERROR_Si2168_POLLING_RESPONSE;
+    }
+
+    return NO_Si2168_ERROR;
+}
+
+/***********************************************************************************************************************
+  Si2168_L1_API_Init function
+  Use:        software initialisation function
+              Used to initialize the software context
+  Returns:    0 if no error
+  Comments:   It should be called first and once only when starting the application
+  Parameter:   **ppapi         a pointer to the api context to initialize
+  Parameter:  add            the Si2168 I2C address
+  Porting:    Allocation errors need to be properly managed.
+  Porting:    I2C initialization needs to be adapted to use the available I2C functions
+ ***********************************************************************************************************************/
+unsigned char    Si2168_L1_API_Init      (L1_Si2168_Context *api, int add) {
+    api->i2c = &(api->i2cObj);
+
+    L0_Init(api->i2c);
+    L0_SetAddress(api->i2c, add, 0);
+
+    api->cmd    = &(api->cmdObj);
+    api->rsp    = &(api->rspObj);
+    api->prop   = &(api->propObj);
+    api->status = &(api->statusObj);
+
+    api->tuner_ter_chip = 0;
+    api->tuner_ter_clock_input = Si2168_CLOCK_MODE_TER;
+    api->tuner_ter_clock_freq  = Si2168_REF_FREQUENCY_TER;
+
+
+    return NO_Si2168_ERROR;
+}
+/************************************************************************************************************************
+  NAME: Si2168_TerAutoDetect
+  DESCRIPTION: Set the Si2168 in Ter Auto Detect mode
+
+  Parameter:  Pointer to Si2168 Context
+  Returns:    front_end->auto_detect_TER
+************************************************************************************************************************/
+int  Si2168_TerAutoDetect         (Si2168_L2_Context *front_end)
+{
+  front_end->auto_detect_TER = 1;
+  return front_end->auto_detect_TER;
+}
+/************************************************************************************************************************
+  NAME: Si2168_TerAutoDetectOff
+  DESCRIPTION: Set the Si2168 in Ter Auto Detect 'off' mode
+
+  Parameter:  Pointer to Si2168 Context
+  Returns:    front_end->auto_detect_TER
+************************************************************************************************************************/
+int  Si2168_TerAutoDetectOff      (Si2168_L2_Context *front_end)
+{
+  front_end->auto_detect_TER = 0;
+  return front_end->auto_detect_TER;
+}
+
+/************************************************************************************************************************
+  Si2168_L2_Tuner_I2C_Enable function
+  Use:        Tuner i2c bus connection
+              Used to allow communication with the tuners
+  Parameter:  *front_end, the front-end handle
+************************************************************************************************************************/
+unsigned char Si2168_L2_Tuner_I2C_Enable (Si2168_L2_Context *front_end)
+{
+    return Si2168_L1_I2C_PASSTHROUGH(front_end->demod, Si2168_I2C_PASSTHROUGH_CMD_SUBCODE_CODE, Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_CLOSE, Si2168_I2C_PASSTHROUGH_CMD_RESERVED_RESERVED);
+}
+/************************************************************************************************************************
+  Si2168_L2_Tuner_I2C_Disable function
+  Use:        Tuner i2c bus connection
+              Used to disconnect i2c communication with the tuners
+  Parameter:  *front_end, the front-end handle
+************************************************************************************************************************/
+unsigned char Si2168_L2_Tuner_I2C_Disable(Si2168_L2_Context *front_end)
+{
+    return Si2168_L1_I2C_PASSTHROUGH(front_end->demod, Si2168_I2C_PASSTHROUGH_CMD_SUBCODE_CODE, Si2168_I2C_PASSTHROUGH_CMD_I2C_PASSTHRU_OPEN, Si2168_I2C_PASSTHROUGH_CMD_RESERVED_RESERVED);
+}
+/************************************************************************************************************************
+  Si2168_L2_TER_FEF function
+  Use:        TER tuner FEF activation function
+              Used to enable/disable the FEF mode in the terrestrial tuner
+  Comments:   If the tuner is connected via the demodulator's I2C switch, enabling/disabling the i2c_passthru is required before/after tuning.
+  Parameter:  *front_end, the front-end handle
+  Parameter:  fef, a flag controlling the selection between FEF 'off'(0) and FEF 'on'(1)
+  Returns:    1
+************************************************************************************************************************/
+int  Si2168_L2_TER_FEF            (Si2168_L2_Context *front_end, int fef)
+{
+  front_end = front_end; /* To avoid compiler warning if not used */
+  SiTRACE("Si2168_L2_TER_FEF %d\n",fef);
+
+  #ifdef    L1_RF_TER_TUNER_FEF_MODE_FREEZE_PIN
+  if (front_end->demod->fef_mode == Si2168_FEF_MODE_FREEZE_PIN      ) {
+    SiTRACE("FEF mode Si2168_FEF_MODE_FREEZE_PIN\n");
+    L1_RF_TER_TUNER_FEF_MODE_FREEZE_PIN(front_end->tuner_ter, fef);
+  }
+  #endif /* L1_RF_TER_TUNER_FEF_MODE_FREEZE_PIN */
+
+  #ifdef    L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP
+  if (front_end->demod->fef_mode == Si2168_FEF_MODE_SLOW_INITIAL_AGC) {
+    SiTRACE("FEF mode Si2168_FEF_MODE_SLOW_INITIAL_AGC (AGC slowed down after tuning)\n");
+  }
+  #endif /* L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP */
+
+  #ifdef    L1_RF_TER_TUNER_FEF_MODE_SLOW_NORMAL_AGC_SETUP
+  if (front_end->demod->fef_mode == Si2168_FEF_MODE_SLOW_NORMAL_AGC ) {
+    SiTRACE("FEF mode Si2168_FEF_MODE_SLOW_NORMAL_AGC: AGC slowed down\n");
+    L1_RF_TER_TUNER_FEF_MODE_SLOW_NORMAL_AGC(front_end->tuner_ter, fef);
+  }
+  #endif /* L1_RF_TER_TUNER_FEF_MODE_SLOW_NORMAL_AGC_SETUP */
+  SiTRACE("Si2168_L2_TER_FEF done\n");
+  return 1;
+}
+
+/************************************************************************************************************************
+  Si2168_L2_TER_FEF_SETUP function
+  Use:        TER tuner LPF setting function
+              Used to configure the FEF mode in the terrestrial tuner
+  Comments:   If the tuner is connected via the demodulator's I2C switch, enabling/disabling the i2c_passthru is required before/after tuning.
+  Behavior:   This function closes the Si2168's I2C switch then sets the TER FEF mode and finally reopens the I2C switch
+  Parameter:  *front_end, the front-end handle
+  Parameter:  fef, a flag controlling the selection between FEF 'off'(0) and FEF 'on'(1)
+  Returns:    1
+************************************************************************************************************************/
+int  Si2168_L2_TER_FEF_SETUP      (Si2168_L2_Context *front_end, int fef)
+{
+  SiTRACE("Si2168_L2_TER_FEF_SETUP %d\n",fef);
+  #ifdef    L1_RF_TER_TUNER_FEF_MODE_FREEZE_PIN_SETUP
+  if (front_end->demod->fef_mode == Si2168_FEF_MODE_FREEZE_PIN      ) {
+    SiTRACE("FEF mode Si2168_FEF_MODE_FREEZE_PIN\n");
+    L1_RF_TER_TUNER_FEF_MODE_FREEZE_PIN_SETUP(front_end->tuner_ter);
+}
+  #endif /* L1_RF_TER_TUNER_FEF_MODE_FREEZE_PIN_SETUP */
+
+  #ifdef    L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP
+  if (front_end->demod->fef_mode == Si2168_FEF_MODE_SLOW_INITIAL_AGC) {
+    SiTRACE("FEF mode Si2168_FEF_MODE_SLOW_INITIAL_AGC (AGC slowed down after tuning)\n");
+    L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP(front_end->tuner_ter, fef);
+  }
+  #endif /* L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP */
+
+  #ifdef    L1_RF_TER_TUNER_FEF_MODE_SLOW_NORMAL_AGC_SETUP
+  if (front_end->demod->fef_mode == Si2168_FEF_MODE_SLOW_NORMAL_AGC ) {
+    SiTRACE("FEF mode Si2168_FEF_MODE_SLOW_NORMAL_AGC: AGC slowed down\n");
+    L1_RF_TER_TUNER_FEF_MODE_SLOW_NORMAL_AGC_SETUP(front_end->tuner_ter, fef);
+  }
+  #endif /* L1_RF_TER_TUNER_FEF_MODE_SLOW_NORMAL_AGC */
+
+  Si2168_L2_TER_FEF(front_end, fef);
+
+  SiTRACE("Si2168_L2_TER_FEF_SETUP done\n");
+  return 1;
+}
+
+/************************************************************************************************************************
+  Si2168_L2_SW_Init function
+  Use:        software initialization function
+              Used to initialize the Si2168 and tuner structures
+  Behavior:   This function performs all the steps necessary to initialize the Si2168 and tuner instances
+  Parameter:  front_end, a pointer to the Si2168_L2_Context context to be initialized
+  Parameter:  demodAdd, the I2C address of the demod
+  Parameter:  tunerAdd, the I2C address of the tuner
+  Comments:     It MUST be called first and once before using any other function.
+                It can be used to build a multi-demod/multi-tuner application, if called several times from the upper layer with different pointers and addresses
+                After execution, all demod and tuner functions are accessible.
+************************************************************************************************************************/
+char Si2168_L2_SW_Init  (Si2168_L2_Context *front_end
+                                   , int demodAdd
+                                   , int tunerAdd_Ter
+                                   )
+{
+    u32 fef_selection;
+    SiTRACE("Si2168_L2_SW_Init starting...\n");
+
+    /* Pointers initialization */
+    front_end->demod     = &(front_end->demodObj    );
+    front_end->first_init_done     = 0;
+    front_end->tuner_ter = &(front_end->tuner_terObj);
+    front_end->TER_init_done       = 0;
+    front_end->TER_tuner_init_done = 0;
+    front_end->auto_detect_TER     = 0;
+    /* Calling underlying SW initialization functions */
+    Si2168_L1_API_Init      (front_end->demod,     demodAdd);
+    L1_RF_TER_TUNER_Init    (front_end->tuner_ter, tunerAdd_Ter);
+    front_end->demod->fef_mode      = Si2168_FEF_MODE_SLOW_NORMAL_AGC;
+    fef_selection = Si2168_FEF_MODE;
+ #ifdef    L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP
+    /* If the TER tuner has initial AGC speed control and it's the selected mode, activate it */
+    if (fef_selection == Si2168_FEF_MODE_SLOW_INITIAL_AGC) {
+      SiTRACE("TER tuner FEF set to 'SLOW_INITIAL_AGC' mode\n");
+      front_end->demod->fef_mode = Si2168_FEF_MODE_SLOW_INITIAL_AGC;
+    }
+  #ifdef    L1_RF_TER_TUNER_FEF_MODE_FREEZE_PIN_SETUP
+    /* If the TER tuner has an AGC freeze pin and it's the selected mode, activate it */
+    if (fef_selection == Si2168_FEF_MODE_FREEZE_PIN      ) {
+      SiTRACE("TER tuner FEF set to 'FREEZE_PIN' mode\n");
+      front_end->demod->fef_mode = Si2168_FEF_MODE_FREEZE_PIN;
+    }
+  #else  /* L1_RF_TER_TUNER_FEF_MODE_FREEZE_PIN_SETUP */
+    if (fef_selection == Si2168_FEF_MODE_FREEZE_PIN      ) {
+      SiTRACE("TER tuner FEF can not use 'FREEZE_PIN' mode, using 'SLOW_INITIAL_AGC' mode instead\n");
+      front_end->demod->fef_mode = Si2168_FEF_MODE_SLOW_INITIAL_AGC;
+    }
+  #endif /* L1_RF_TER_TUNER_FEF_MODE_FREEZE_PIN_SETUP */
+ #else  /* L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP */
+      SiTRACE("TER tuner FEF set to 'SLOW_NORMAL_AGC' mode\n");
+ #endif /* L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP */
+
+    SiTRACE("Si2168_L2_SW_Init complete\n");
+    return 1;
+}
+
+/************************************************************************************************************************
+  NAME: SiLabs_API_TAG_TEXT
+  DESCRIPTION: SiLabs API information function used to retrieve the version information of the SiLabs API wrapper
+  Returns:    the SiLabs API version information string
+************************************************************************************************************************/
+char* SiLabs_API_TAG_TEXT      (void) { return (char *)"V1.9.7"; }
+
+/************************************************************************************************************************
+  SiLabs_chip_detect function
+  Use:        chip detection function
+              Used to detect whether the demodulator is a DTV demodulator
+  Behavior:   This function uses raw i2c reads to check the presence of either a Si2167 or a Si2168
+  Parameter:  demodAdd, the I2C address of the demod
+  Returns:    2167 if there is a Si2167, 2168 if there is a 2168, 0 otherwise
+************************************************************************************************************************/
+int   SiLabs_chip_detect                  (int demodAdd)
+{
+  int chip;
+  chip = 0;
+  SiTRACE("Detecting chip at address 0x%02x\n", demodAdd);
+  demodAdd = demodAdd;
+#ifdef    Si2168_COMPATIBLE
+/* TODO (mdorval#2#): Find a way to detect the presence of a Si2168 */
+  chip = 2168;
+#endif /* Si2168_COMPATIBLE */
+  SiTRACE("Chip  %d   (%X)\n", chip, chip);
+  return chip;
+}
+
+/************************************************************************************************************************
+  NAME: SiLabs_API_TER_AutoDetect
+  DESCRIPTION: activation function for the TER auto detect mode
+  Parameter: front_end, Pointer to SILABS_FE_Context
+  Parameter: on_off, which is set to '0' to de-activate the TER auto-detect feature,
+              set to '1' to activate it and to any other value to retrieve the current status
+  Returns:    the current state of auto_detect_TER
+************************************************************************************************************************/
+int   SiLabs_API_TER_AutoDetect           (SILABS_FE_Context *front_end, int on_off)
+{
+  front_end = front_end; /* To avoid compiler warning if not used */
+  on_off    = on_off;    /* To avoid compiler warning if not used */
+#ifdef    Si2168_COMPATIBLE
+  if (front_end->chip ==   2168 ) {
+    if (on_off == 0) { Si2168_TerAutoDetectOff(front_end->Si2168_FE); }
+    if (on_off == 1) { Si2168_TerAutoDetect   (front_end->Si2168_FE); }
+    return front_end->Si2168_FE->auto_detect_TER;
+  }
+#endif /* Si2168_COMPATIBLE */
+  return -1;
+}
+
+/************************************************************************************************************************
+  SiLabs_API_SW_Init function
+  Use:        software initialization function
+              Used to initialize the DTV demodulator and tuner structures
+  Behavior:   This function performs all the steps necessary to initialize the demod and tuner instances
+  Parameter:  front_end, a pointer to the SILABS_FE_Context context to be initialized
+  Parameter:  demodAdd, the I2C address of the demod
+  Parameter:  tunerAdd, the I2C address of the tuner
+  Comments:     It MUST be called first and once before using any other function.
+                It can be used to build a multi-demod/multi-tuner application, if called several times from the upper
+                  layer with different pointers and addresses.
+                After execution, all demod and tuner functions are accessible.
+************************************************************************************************************************/
+char  SiLabs_API_SW_Init(SILABS_FE_Context *front_end, int demodAdd, int tunerAdd_Ter, int tunerAdd_Sat)
+ {
+  int chip;
+
+//  tunerAdd_Ter = tunerAdd_Ter; /* To avoid compiler warning */
+//  tunerAdd_Sat = tunerAdd_Sat; /* To avoid compiler warning */
+
+  SiTRACE("Wrapper Source code %s\n", SiLabs_API_TAG_TEXT() );
+  SiTRACE("tunerAdd_Ter 0x%02x\n", tunerAdd_Ter);
+  SiTRACE("tunerAdd_Sat 0x%02x\n", tunerAdd_Sat);
+  /* Start by detecting the chip type */
+  chip = SiLabs_chip_detect(demodAdd);
+  SiTRACE("chip '%d' ('%X')\n", chip, chip);
+  front_end->standard = -1;
+
+  //WrapperI2C = &WrapperI2C_context;
+  //WrapperI2C->indexSize = 0;
+  //WrapperI2C->mustReadWithoutStop = 0;
+
+#ifdef    Si2168_COMPATIBLE
+  if (chip == 2168) {
+    front_end->Si2168_FE = &(front_end->Si2168_FE_Obj);
+    if (Si2168_L2_SW_Init   (front_end->Si2168_FE
+                             , demodAdd
+                             , tunerAdd_Ter
+                             ) ) {
+      front_end->chip = chip;
+      front_end->Silabs_init_done = 1;
+      return 1;
+    } else {
+      SiTRACE("ERROR initializing Si2168 context\n");
+      return 0;
+    }
+  }
+#endif /* Si2168_COMPATIBLE */
+  SiTRACE("Unknown chip '%d'\n", front_end->chip);
+  SiERROR("SiLabs_API_SW_Init: Unknown chip !\n");
+  return 0;
+}
+
+/************************************************************************************************************************
+  Silabs_Constel_Text function
+  Use:        constel text retrieval function
+              Used to retrieve the constel text used by the DTV demodulator
+  Parameter:  front_end, a pointer to the SILABS_FE_Context context
+  Parameter:  constel, the value used by the top-level application (configurable in CUSTOM_Constel_Enum)
+************************************************************************************************************************/
+char *Silabs_Constel_Text                 (CUSTOM_Constel_Enum   constel)
+{
+  switch (constel) {
+    case SILABS_QAMAUTO : { return (char *)"QAMAUTO"; break;}
+    case SILABS_QAM16   : { return (char *)"QAM16"  ; break;}
+    case SILABS_QAM32   : { return (char *)"QAM32"  ; break;}
+    case SILABS_QAM64   : { return (char *)"QAM64"  ; break;}
+    case SILABS_QAM128  : { return (char *)"QAM128" ; break;}
+    case SILABS_QAM256  : { return (char *)"QAM256" ; break;}
+    case SILABS_QPSK    : { return (char *)"QPSK"   ; break;}
+    case SILABS_8PSK    : { return (char *)"8PSK"   ; break;}
+    default             : { return (char *)"UNKNOWN"; break;}
+  }
+}
+/************************************************************************************************************************
+  Silabs_Polarization_Text function
+  Use:        polarization text retrieval function
+              Used to retrieve the polarization text used by the front-end
+  Parameter:  front_end, a pointer to the SILABS_FE_Context context
+  Parameter:  polarization, the value used by the top-level application (configurable in CUSTOM_Polarization_Enum)
+************************************************************************************************************************/
+char *Silabs_Polarization_Text            (CUSTOM_Polarization_Enum   polarization)
+{
+  switch (polarization) {
+    case SILABS_POLARIZATION_HORIZONTAL : { return (char *)"Horizontal"; break;}
+    case SILABS_POLARIZATION_VERTICAL   : { return (char *)"Vertical"  ; break;}
+    default             : { return (char *)"UNKNOWN"   ; break;}
+  }
+}
+
+/************************************************************************************************************************
+  Silabs_Band_Text function
+  Use:        polarization text retrieval function
+              Used to retrieve the polarization text used by the front-end
+  Parameter:  front_end, a pointer to the SILABS_FE_Context context
+  Parameter:  polarization, the value used by the top-level application (configurable in CUSTOM_Band_Enum)
+************************************************************************************************************************/
+char *Silabs_Band_Text                    (CUSTOM_Band_Enum      band)
+{
+  switch (band) {
+    case SILABS_BAND_LOW : { return (char *)"Low "   ; break;}
+    case SILABS_BAND_HIGH: { return (char *)"High"   ; break;}
+    default              : { return (char *)"UNKNOWN"; break;}
+  }
+}
+/************************************************************************************************************************
+  Silabs_Stream_Text function
+  Use:        stream text retrieval function
+              Used to retrieve the stream text used by the DTV demodulator
+  Parameter:  front_end, a pointer to the SILABS_FE_Context context
+  Parameter:  stream, the value used by the top-level application (configurable in CUSTOM_Stream_Enum)
+************************************************************************************************************************/
+char *Silabs_Stream_Text                  (CUSTOM_Stream_Enum    stream)
+{
+  switch (stream) {
+    case SILABS_HP    : { return (char *)"HP"     ; break;}
+    case SILABS_LP    : { return (char *)"LP"     ; break;}
+    default           : { return (char *)"UNKNOWN"; break;}
+  }
+}
+/************************************************************************************************************************
+  Silabs_Standard_Text function
+  Use:        standard text retrieval function
+              Used to retrieve the standard text used by the DTV demodulator
+  Parameter:  front_end, a pointer to the SILABS_FE_Context context
+  Parameter:  standard, the value used by the top-level application (configurable in CUSTOM_Standard_Enum)
+************************************************************************************************************************/
+char *Silabs_Standard_Text                (CUSTOM_Standard_Enum  standard)
+{
+  switch (standard) {
+    case SILABS_ANALOG: {return (char *)"ANALOG" ;}
+    case SILABS_DVB_T : {return (char *)"DVB-T"  ;}
+    case SILABS_DVB_T2: {return (char *)"DVB-T2" ;}
+    case SILABS_DVB_C : {return (char *)"DVB-C"  ;}
+    case SILABS_DVB_C2: {return (char *)"DVB-C2" ;}
+    case SILABS_MCNS  : {return (char *)"MCNS"   ;}
+    case SILABS_DVB_S : {return (char *)"DVB-S"  ;}
+    case SILABS_DVB_S2: {return (char *)"DVB-S2" ;}
+    case SILABS_DSS   : {return (char *)"DSS"    ;}
+    case SILABS_SLEEP : {return (char *)"SLEEP"  ;}
+    default           : {return (char *)"UNKNOWN";}
+  }
+}
+
+/************************************************************************************************************************
+  SiLabs_API_TS_Mode function
+  Use:      Transport Stream control function
+            Used to switch the TS output in the desired mode
+  Parameter: mode the mode to switch to
+************************************************************************************************************************/
+int   SiLabs_API_TS_Mode                  (SILABS_FE_Context *front_end, int ts_mode)
+{
+  int valid_mode;
+#ifdef    USB_Capability
+  int gpif_on;
+  double        retdval;
+  char rettxtBuffer[256];
+  char *rettxt;
+  rettxt = rettxtBuffer;
+  gpif_on = 1;
+#endif /* USB_Capability */
+  valid_mode = 0;
+#ifdef    USB_Capability
+  if (ts_mode != SILABS_TS_GPIF) { L0_Cypress_Configure("-gpif"     ,"off", 0   , &retdval, &rettxt);}
+#endif /* USB_Capability */
+#ifdef    Si2168_COMPATIBLE
+  if (front_end->chip ==   2168 ) {
+    switch (ts_mode) {
+      case SILABS_TS_SERIAL  : 
+      {
+      	SiTRACE("TS Mode = SILABS_TS_SERIAL!\n");
+      	front_end->Si2168_FE->demod->prop->dd_ts_mode.mode = Si2168_DD_TS_MODE_PROP_MODE_SERIAL;
+      	break;
+      }
+      case SILABS_TS_PARALLEL: 
+      {
+      	SiTRACE("TS Mode = SILABS_TS_PARALLEL!\n"); 
+      	front_end->Si2168_FE->demod->prop->dd_ts_mode.mode = Si2168_DD_TS_MODE_PROP_MODE_PARALLEL; 
+      	break; 
+      }
+      case SILABS_TS_GPIF    : { front_end->Si2168_FE->demod->prop->dd_ts_mode.mode = Si2168_DD_TS_MODE_PROP_MODE_GPIF    ; break; }
+      case SILABS_TS_TRISTATE: { front_end->Si2168_FE->demod->prop->dd_ts_mode.mode = Si2168_DD_TS_MODE_PROP_MODE_OFF     ; break; }
+      default                : { return SiLabs_API_TS_Mode(front_end, SILABS_TS_TRISTATE)                                 ; break; }
+    }
+    
+    Si2168_L1_SetProperty2(front_end->Si2168_FE->demod, Si2168_DD_TS_MODE_PROP_CODE);
+    valid_mode = 1;
+  }
+#endif /* Si2168_COMPATIBLE */
+  if (valid_mode) {
+#ifdef    USB_Capability
+    if (ts_mode == SILABS_TS_GPIF ) {
+      L0_Cypress_Configure("-gpif"     ,"on"      , 0, &retdval, &rettxt);  /* Starting Cypress gpif state machine   */
+      L0_Cypress_Configure("-gpif_clk" ,"on"      , 0, &retdval, &rettxt);  /* Starting Cypress gpif clock           */
+      L0_Cypress_Process  ("ts"        ,"start"   , 0, &retdval, &rettxt);  /* Starting Cypress TS transfer over USB */
+    } else {
+      if (gpif_on) {
+      L0_Cypress_Process  ("ts"        ,"stop"    , 0, &retdval, &rettxt);  /* Stopping Cypress TS transfer over USB */
+      L0_Cypress_Configure("-gpif"     ,"off"     , 0, &retdval, &rettxt);  /* Stopping Cypress gpif state machine   */
+      L0_Cypress_Configure("-gpif_clk" ,"tristate", 0, &retdval, &rettxt);  /* Stopping Cypress gpif clock           */
+      }
+    }
+#endif /* USB_Capability */
+    return ts_mode;
+  } else {
+    return -1;
+  }
+}
+
+/************************************************************************************************************************
+  SiLabs_API_Tuner_I2C_Enable function
+  Use:      Demdo Loop through control function
+            Used to switch the I2C loopthrough on, allowing commnication with the tuners
+  Return:    the final mode (-1 if not known)
+************************************************************************************************************************/
+int   SiLabs_API_Tuner_I2C_Enable         (SILABS_FE_Context *front_end)
+{
+#ifdef    Si2168_COMPATIBLE
+  if (front_end->chip ==   2168 ) { Si2168_L2_Tuner_I2C_Enable (front_end->Si2168_FE); return 1;}
+#endif /* Si2168_COMPATIBLE */
+  return -1;
+}
+/************************************************************************************************************************
+  SiLabs_API_Tuner_I2C_Disable function
+  Use:      Demdo Loop through control function
+            Used to switch the I2C loopthrough off, stopping commnication with the tuners
+  Return:    the final mode (-1 if not known)
+************************************************************************************************************************/
+int   SiLabs_API_Tuner_I2C_Disable        (SILABS_FE_Context *front_end)
+{
+#ifdef    Si2168_COMPATIBLE
+  if (front_end->chip ==   2168 ) { Si2168_L2_Tuner_I2C_Disable (front_end->Si2168_FE); return 0;}
+#endif /* Si2168_COMPATIBLE */
+  return -1;
+}
+/************************************************************************************************************************
+  SiLabs_API_SAT_Tuner_status function
+  Use:        Satellite tuner status function
+              Used to retrieve the status of the SAT tuner in a structure
+  Parameter:  front_end, a pointer to the SILABS_FE_Context context
+  Parameter:  status, a pointer to the status structure (configurable in CUSTOM_Status_Struct)
+  Return:     1 if successful, 0 otherwise
+************************************************************************************************************************/
+int   SiLabs_API_SAT_Tuner_status         (SILABS_FE_Context* front_end, CUSTOM_Status_Struct *status)
+{
+//  int ref_level;
+//  status    = status;    /* To avoid compiler warning */
+//  ref_level = 0;
+//  front_end = front_end; /* To avoid compiler warning */
+//  status    = status;    /* To avoid compiler warning */
+  return 1;
+}
+
+/************************************************************************************************************************
+  SiLabs_API_TER_Tuner_status function
+  Use:        Terrestrial tuner status function
+              Used to retrieve the status of the TER tuner in a structure
+  Parameter:  front_end, a pointer to the SILABS_FE_Context context
+  Parameter:  status, a pointer to the status structure (configurable in CUSTOM_Status_Struct)
+  Return:     1 if successful, 0 otherwise
+************************************************************************************************************************/
+int   SiLabs_API_TER_Tuner_status         (SILABS_FE_Context* front_end, CUSTOM_Status_Struct *status)
+{
+//  SiLabs_API_Tuner_I2C_Enable  (front_end);
+#ifdef    TER_TUNER_CUSTOMTER
+  TUNERNAME_TER_Context *tuner_ter;
+#endif /* TER_TUNER_CUSTOMTER */
+#ifdef    TER_TUNER_DTT759x
+  DTT759x_Context *tuner_ter;
+#endif /* TER_TUNER_DTT759x */
+#ifdef    TER_TUNER_Si2146
+  L1_Si2146_Context *tuner_ter;
+#endif /* TER_TUNER_Si2146 */
+#ifdef    TER_TUNER_Si2148
+  L1_Si2148_Context *tuner_ter;
+#endif /* TER_TUNER_Si2148 */
+#ifdef    TER_TUNER_Si2156
+  L1_Si2156_Context *tuner_ter;
+#endif /* TER_TUNER_Si2156 */
+#ifdef    TER_TUNER_Si2158
+  L1_Si2158_Context *tuner_ter;
+#endif /* TER_TUNER_Si2158 */
+#ifdef    TER_TUNER_Si2173
+  L1_Si2173_Context *tuner_ter;
+#endif /* TER_TUNER_Si2173 */
+#ifdef    TER_TUNER_Si2176
+  L1_Si2176_Context *tuner_ter;
+#endif /* TER_TUNER_Si2176 */
+#ifdef    TER_TUNER_Si2178
+  L1_Si2178_Context *tuner_ter;
+#endif /* TER_TUNER_Si2178 */
+#ifdef    TER_TUNER_Si2185
+  L1_Si2185_Context *tuner_ter;
+#endif /* TER_TUNER_Si2185 */
+#ifdef    TER_TUNER_Si2196
+  L1_Si2196_Context *tuner_ter;
+#endif /* TER_TUNER_Si2196 */
+#ifdef    TER_TUNER_NO_TER
+  TER_TUNER_CONTEXT *tuner_ter;
+#endif /* TER_TUNER_NO_TER */
+  tuner_ter = NULL;
+  SiTRACE("SiLabs_API_TER_Tuner_status\n");
+#ifdef    Si2168_COMPATIBLE
+  if (front_end->chip ==   2168 ) { tuner_ter = front_end->Si2168_FE->tuner_ter; }
+#endif /* Si2168_COMPATIBLE */
+  if (tuner_ter == NULL) {
+      SiTRACE("No tuner_ter defined, SiLabs_API_TER_Tuner_status can't be executed!\n");
+    return 0;
+  }
+  SiLabs_API_Tuner_I2C_Enable  (front_end);
+#ifdef    TER_TUNER_DTT759x
+  status->freq     =  tuner_ter->RF;
+#endif /* TER_TUNER_DTT759x */
+#ifdef    TER_TUNER_Si2146
+  Si2146_L1_TUNER_STATUS            (tuner_ter, Si2146_TUNER_STATUS_CMD_INTACK_OK );
+  status->vco_code =  tuner_ter->rsp->tuner_status.vco_code;
+  status->tc       =  tuner_ter->rsp->tuner_status.tc;
+  status->rssil    =  tuner_ter->rsp->tuner_status.rssil;
+  status->rssih    =  tuner_ter->rsp->tuner_status.rssih;
+  status->freq     =  tuner_ter->rsp->tuner_status.freq;
+  status->mode     =  tuner_ter->rsp->tuner_status.mode;
+  status->rssi     =  tuner_ter->rsp->tuner_status.rssi;
+  if (front_end->standard == SILABS_ANALOG) {
+    Si2146_L1_ATV_STATUS            (tuner_ter, Si2146_ATV_STATUS_CMD_INTACK_OK );
+  } else {
+    Si2146_L1_DTV_STATUS            (tuner_ter, Si2146_DTV_STATUS_CMD_INTACK_OK );
+    status->chl                =  tuner_ter->rsp->dtv_status.chl;
+    status->bw                 =  tuner_ter->rsp->dtv_status.bw;
+    status->modulation         =  tuner_ter->rsp->dtv_status.modulation;
+  }
+  status->RSSI = tuner_ter->rsp->tuner_status.rssi;
+#endif /* TER_TUNER_Si2146 */
+#ifdef    TER_TUNER_Si2148
+  Si2148_L1_TUNER_STATUS            (tuner_ter, Si2148_TUNER_STATUS_CMD_INTACK_OK );
+  status->vco_code =  tuner_ter->rsp->tuner_status.vco_code;
+  status->tc       =  tuner_ter->rsp->tuner_status.tc;
+  status->rssil    =  tuner_ter->rsp->tuner_status.rssil;
+  status->rssih    =  tuner_ter->rsp->tuner_status.rssih;
+  status->freq     =  tuner_ter->rsp->tuner_status.freq;
+  status->mode     =  tuner_ter->rsp->tuner_status.mode;
+  status->rssi     =  tuner_ter->rsp->tuner_status.rssi;
+  status->RSSI = tuner_ter->rsp->tuner_status.rssi;
+#endif /* TER_TUNER_Si2148 */
+#ifdef    TER_TUNER_Si2156
+  Si2156_L1_TUNER_STATUS            (tuner_ter, Si2156_TUNER_STATUS_CMD_INTACK_OK );
+  status->vco_code =  tuner_ter->rsp->tuner_status.vco_code;
+  status->tc       =  tuner_ter->rsp->tuner_status.tc;
+  status->rssil    =  tuner_ter->rsp->tuner_status.rssil;
+  status->rssih    =  tuner_ter->rsp->tuner_status.rssih;
+  status->freq     =  tuner_ter->rsp->tuner_status.freq;
+  status->mode     =  tuner_ter->rsp->tuner_status.mode;
+  status->rssi     =  tuner_ter->rsp->tuner_status.rssi;
+  if (front_end->standard == SILABS_ANALOG) {
+    Si2156_L1_ATV_STATUS            (tuner_ter, Si2156_ATV_STATUS_CMD_INTACK_OK );
+  } else {
+    Si2156_L1_DTV_STATUS            (tuner_ter, Si2156_DTV_STATUS_CMD_INTACK_OK );
+    status->chl                =  tuner_ter->rsp->dtv_status.chl;
+    status->bw                 =  tuner_ter->rsp->dtv_status.bw;
+    status->modulation         =  tuner_ter->rsp->dtv_status.modulation;
+  }
+  status->RSSI = tuner_ter->rsp->tuner_status.rssi;
+#endif /* TER_TUNER_Si2156 */
+#ifdef    TER_TUNER_Si2158
+  Si2158_L1_TUNER_STATUS            (tuner_ter, Si2158_TUNER_STATUS_CMD_INTACK_OK );
+  status->vco_code =  tuner_ter->rsp->tuner_status.vco_code;
+  status->tc       =  tuner_ter->rsp->tuner_status.tc;
+  status->rssil    =  tuner_ter->rsp->tuner_status.rssil;
+  status->rssih    =  tuner_ter->rsp->tuner_status.rssih;
+  status->freq     =  tuner_ter->rsp->tuner_status.freq;
+  status->mode     =  tuner_ter->rsp->tuner_status.mode;
+  status->rssi     =  tuner_ter->rsp->tuner_status.rssi;
+  if (front_end->standard == SILABS_ANALOG) {
+    Si2158_L1_ATV_STATUS            (tuner_ter, Si2158_ATV_STATUS_CMD_INTACK_OK );
+  } else {
+    Si2158_L1_DTV_STATUS            (tuner_ter, Si2158_DTV_STATUS_CMD_INTACK_OK );
+    status->chl                =  tuner_ter->rsp->dtv_status.chl;
+    status->bw                 =  tuner_ter->rsp->dtv_status.bw;
+    status->modulation         =  tuner_ter->rsp->dtv_status.modulation;
+  }
+  status->RSSI = tuner_ter->rsp->tuner_status.rssi;
+#endif /* TER_TUNER_Si2158 */
+#ifdef    TER_TUNER_Si2173
+  Si2173_L1_TUNER_STATUS            (tuner_ter, Si2173_TUNER_STATUS_CMD_INTACK_OK );
+  status->vco_code =  tuner_ter->rsp->tuner_status.vco_code;
+  status->tc       =  tuner_ter->rsp->tuner_status.tc;
+  status->rssil    =  tuner_ter->rsp->tuner_status.rssil;
+  status->rssih    =  tuner_ter->rsp->tuner_status.rssih;
+  status->freq     =  tuner_ter->rsp->tuner_status.freq;
+  status->mode     =  tuner_ter->rsp->tuner_status.mode;
+  status->rssi     =  tuner_ter->rsp->tuner_status.rssi;
+  if (front_end->standard == SILABS_ANALOG) {
+    Si2173_L1_ATV_STATUS            (tuner_ter, Si2173_ATV_STATUS_CMD_INTACK_OK );
+    status->audio_chan_filt_bw =  tuner_ter->rsp->atv_status.audio_chan_bw;
+    status->chl                =  tuner_ter->rsp->atv_status.chl;
+    status->ATV_Sync_Lock      =  tuner_ter->rsp->atv_status.pcl;
+    status->ATV_Master_Lock    =  tuner_ter->rsp->atv_status.dl;
+    status->snrl               =  tuner_ter->rsp->atv_status.snrl;
+    status->snrh               =  tuner_ter->rsp->atv_status.snrh;
+    status->video_snr          =  tuner_ter->rsp->atv_status.video_snr;
+    status->afc_freq           =  tuner_ter->rsp->atv_status.afc_freq;
+    status->video_sc_spacing   =  tuner_ter->rsp->atv_status.video_sc_spacing;
+    status->video_sys          =  tuner_ter->rsp->atv_status.video_sys;
+    status->color              =  tuner_ter->rsp->atv_status.color;
+    status->trans              =  tuner_ter->rsp->atv_status.trans;
+    status->audio_sys          =  tuner_ter->rsp->atv_status.audio_sys;
+  } else {
+    Si2173_L1_DTV_STATUS            (tuner_ter, Si2173_DTV_STATUS_CMD_INTACK_OK );
+    status->chl                =  tuner_ter->rsp->dtv_status.chl;
+    status->bw                 =  tuner_ter->rsp->dtv_status.bw;
+    status->modulation         =  tuner_ter->rsp->dtv_status.modulation;
+  }
+#endif /* TER_TUNER_Si2173 */
+#ifdef    TER_TUNER_Si2176
+  Si2176_L1_TUNER_STATUS            (tuner_ter, Si2176_TUNER_STATUS_CMD_INTACK_OK );
+  status->vco_code =  tuner_ter->rsp->tuner_status.vco_code;
+  status->tc       =  tuner_ter->rsp->tuner_status.tc;
+  status->rssil    =  tuner_ter->rsp->tuner_status.rssil;
+  status->rssih    =  tuner_ter->rsp->tuner_status.rssih;
+  status->rssi     =  tuner_ter->rsp->tuner_status.rssi;
+  status->freq     =  tuner_ter->rsp->tuner_status.freq;
+  status->mode     =  tuner_ter->rsp->tuner_status.mode;
+  if (front_end->standard == SILABS_ANALOG) {
+    Si2176_L1_ATV_STATUS            (tuner_ter, Si2176_ATV_STATUS_CMD_INTACK_OK );
+    status->audio_chan_filt_bw =  tuner_ter->rsp->atv_status.audio_chan_bw;
+    status->chl                =  tuner_ter->rsp->atv_status.chl;
+    status->ATV_Sync_Lock      =  tuner_ter->rsp->atv_status.pcl;
+    status->ATV_Master_Lock    =  tuner_ter->rsp->atv_status.dl;
+    status->snrl               =  tuner_ter->rsp->atv_status.snrl;
+    status->snrh               =  tuner_ter->rsp->atv_status.snrh;
+    status->video_snr          =  tuner_ter->rsp->atv_status.video_snr;
+    status->afc_freq           =  tuner_ter->rsp->atv_status.afc_freq;
+    status->video_sc_spacing   =  tuner_ter->rsp->atv_status.video_sc_spacing;
+    status->video_sys          =  tuner_ter->rsp->atv_status.video_sys;
+    status->color              =  tuner_ter->rsp->atv_status.color;
+    status->trans              =  tuner_ter->rsp->atv_status.trans;
+    status->audio_sys          =  tuner_ter->rsp->atv_status.audio_sys;
+    status->audio_demod_mode   =  tuner_ter->rsp->atv_status.audio_demod_mode;
+  } else {
+    Si2176_L1_DTV_STATUS            (tuner_ter, Si2176_DTV_STATUS_CMD_INTACK_OK );
+    status->chl                =  tuner_ter->rsp->dtv_status.chl;
+    status->bw                 =  tuner_ter->rsp->dtv_status.bw;
+    status->modulation         =  tuner_ter->rsp->dtv_status.modulation;
+  }
+#endif /* TER_TUNER_Si2176 */
+#ifdef    TER_TUNER_Si2178
+  Si2178_L1_TUNER_STATUS            (tuner_ter, Si2178_TUNER_STATUS_CMD_INTACK_OK );
+  status->vco_code =  tuner_ter->rsp->tuner_status.vco_code;
+  status->tc       =  tuner_ter->rsp->tuner_status.tc;
+  status->rssil    =  tuner_ter->rsp->tuner_status.rssil;
+  status->rssih    =  tuner_ter->rsp->tuner_status.rssih;
+  status->rssi     =  tuner_ter->rsp->tuner_status.rssi;
+  status->freq     =  tuner_ter->rsp->tuner_status.freq;
+  status->mode     =  tuner_ter->rsp->tuner_status.mode;
+  if (front_end->standard == SILABS_ANALOG) {
+    Si2178_L1_ATV_STATUS            (tuner_ter, Si2178_ATV_STATUS_CMD_INTACK_OK );
+    status->audio_chan_filt_bw =  tuner_ter->rsp->atv_status.audio_chan_bw;
+    status->chl                =  tuner_ter->rsp->atv_status.chl;
+    status->ATV_Sync_Lock      =  tuner_ter->rsp->atv_status.pcl;
+    status->ATV_Master_Lock    =  tuner_ter->rsp->atv_status.dl;
+    status->snrl               =  tuner_ter->rsp->atv_status.snrl;
+    status->snrh               =  tuner_ter->rsp->atv_status.snrh;
+    status->video_snr          =  tuner_ter->rsp->atv_status.video_snr;
+    status->afc_freq           =  tuner_ter->rsp->atv_status.afc_freq;
+    status->video_sc_spacing   =  tuner_ter->rsp->atv_status.video_sc_spacing;
+    status->video_sys          =  tuner_ter->rsp->atv_status.video_sys;
+    status->color              =  tuner_ter->rsp->atv_status.color;
+    status->audio_sys          =  tuner_ter->rsp->atv_status.audio_sys;
+  } else {
+    Si2178_L1_DTV_STATUS            (tuner_ter, Si2178_DTV_STATUS_CMD_INTACK_OK );
+    status->chl                =  tuner_ter->rsp->dtv_status.chl;
+    status->bw                 =  tuner_ter->rsp->dtv_status.bw;
+    status->modulation         =  tuner_ter->rsp->dtv_status.modulation;
+  }
+#endif /* TER_TUNER_Si2178 */
+#ifdef    TER_TUNER_Si2196
+  Si2196_L1_TUNER_STATUS            (tuner_ter, Si2196_TUNER_STATUS_CMD_INTACK_OK );
+  status->vco_code =  tuner_ter->rsp->tuner_status.vco_code;
+  status->tc       =  tuner_ter->rsp->tuner_status.tc;
+  status->rssil    =  tuner_ter->rsp->tuner_status.rssil;
+  status->rssih    =  tuner_ter->rsp->tuner_status.rssih;
+  status->rssi     =  tuner_ter->rsp->tuner_status.rssi;
+  status->freq     =  tuner_ter->rsp->tuner_status.freq;
+  status->mode     =  tuner_ter->rsp->tuner_status.mode;
+  if (front_end->standard == SILABS_ANALOG) {
+    Si2196_L1_ATV_STATUS            (tuner_ter, Si2196_ATV_STATUS_CMD_INTACK_OK );
+    status->audio_chan_filt_bw =  tuner_ter->rsp->atv_status.audio_chan_filt_bw;
+    status->chl                =  tuner_ter->rsp->atv_status.chl;
+    status->ATV_Sync_Lock      =  tuner_ter->rsp->atv_status.pcl;
+    status->ATV_Master_Lock    =  tuner_ter->rsp->atv_status.dl;
+    status->snrl               =  tuner_ter->rsp->atv_status.snrl;
+    status->snrh               =  tuner_ter->rsp->atv_status.snrh;
+    status->video_snr          =  tuner_ter->rsp->atv_status.video_snr;
+    status->afc_freq           =  tuner_ter->rsp->atv_status.afc_freq;
+    status->video_sc_spacing   =  tuner_ter->rsp->atv_status.video_sc_spacing;
+    status->video_sys          =  tuner_ter->rsp->atv_status.video_sys;
+    status->color              =  tuner_ter->rsp->atv_status.color;
+    status->trans              =  tuner_ter->rsp->atv_status.trans;
+    status->audio_sys          =  tuner_ter->rsp->atv_status.audio_sys;
+  } else {
+    Si2196_L1_DTV_STATUS            (tuner_ter, Si2196_DTV_STATUS_CMD_INTACK_OK );
+    status->chl                =  tuner_ter->rsp->dtv_status.chl;
+    status->bw                 =  tuner_ter->rsp->dtv_status.bw;
+    status->modulation         =  tuner_ter->rsp->dtv_status.modulation;
+  }
+#endif /* TER_TUNER_Si2196 */
+  SiLabs_API_Tuner_I2C_Disable (front_end);
+  front_end = front_end; /* To avoid compiler warning */
+  status    = status;    /* To avoid compiler warning */
+  return 1;
+}
+
+/************************************************************************************************************************
+  SiLabs_API_Demod_status function
+  Use:        stream code function
+              Used to retrieve the status of the demod in a structure
+  Parameter:  front_end, a pointer to the SILABS_FE_Context context
+  Parameter:  status, a pointer to the status structure (configurable in CUSTOM_Status_Struct)
+  Return:     1 if successful, 0 otherwise
+************************************************************************************************************************/
+int   SiLabs_API_Demod_status             (SILABS_FE_Context* front_end, CUSTOM_Status_Struct *status)
+{
+  SiTRACE("SiLabs_API_Demod_status %d\n", front_end->chip);
+  /* Set to 0 all info used to relock */
+  status->demod_lock         =  0;
+  status->fec_lock           =  0;
+  status->bandwidth_Hz       =  0;
+  status->symbol_rate        =  0;
+  status->stream             =  0;
+  status->constellation      =  0;
+  status->c_n                =  0;
+  status->freq_offset        =  0;
+  status->timing_offset      =  0;
+  status->code_rate          = -1;
+  status->ber                = -1; /* Set to '-1' to signal unavailability if not set later on */
+  status->per                = -1; /* Set to '-1' to signal unavailability if not set later on */
+  status->fer                = -1; /* Set to '-1' to signal unavailability if not set later on */
+  status->uncorrs            = -1; /* Set to '-1' to signal unavailability if not set later on */
+  status->num_plp            = -1; /* Set to '-1' to allow 'auto' plp mode selection           */
+  status->plp_id             =  0;
+  status->RSSI               =  0;
+  status->SSI                =  0;
+  status->SQI                =  0;
+  status->TS_bitrate_kHz     =  0;
+  status->TS_clock_kHz       =  0;
+
+  if (front_end->standard == SILABS_SLEEP) {status->standard = SILABS_SLEEP; return 0;}
+
+#ifdef    Si2168_COMPATIBLE
+  if (front_end->chip ==   2168 ) {
+    if (Si2168_L1_DD_STATUS (front_end->Si2168_FE->demod, Si2168_DD_STATUS_CMD_INTACK_OK) != NO_Si2168_ERROR) {
+      SiERROR("Si2168_L1_DD_STATUS ERROR\n");
+      return 0;
+    }
+    status->standard = (CUSTOM_Standard_Enum)Custom_standardCode(front_end, front_end->Si2168_FE->demod->rsp->dd_status.modulation);
+    /* Retrieving TS  values */
+    status->TS_bitrate_kHz  = front_end->Si2168_FE->demod->rsp->dd_status.ts_bit_rate*10;
+    status->TS_clock_kHz    = front_end->Si2168_FE->demod->rsp->dd_status.ts_clk_freq*10;
+    SiTRACE("SiLabs_API_Demod_status, TS bitrate=%d, TS clock=%d\n", status->TS_bitrate_kHz, status->TS_clock_kHz);
+    
+    /* Retrieving AGC values */
+    switch (status->standard) {
+      case SILABS_DVB_T :
+      case SILABS_DVB_C :
+      case SILABS_DVB_T2:
+      {
+        front_end->Si2168_FE->demod->cmd->dd_ext_agc_ter.agc_1_mode  = Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_NO_CHANGE;
+        front_end->Si2168_FE->demod->cmd->dd_ext_agc_ter.agc_2_mode  = Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_NO_CHANGE;
+        SiTRACE("Si2168_L1_SendCommand2(front_end->Si2168_FE->demod, Si2168_DD_EXT_AGC_TER_CMD_CODE)\n");
+        Si2168_L1_SendCommand2(front_end->Si2168_FE->demod, Si2168_DD_EXT_AGC_TER_CMD_CODE);
+        status->RFagc              = 0;
+        status->IFagc              = front_end->Si2168_FE->demod->rsp->dd_ext_agc_ter.agc_2_level;
+        break;
+      }
+      default           : {
+        status->RFagc              = 0;
+        status->IFagc              = 0;
+        break;
+      }
+    }
+    switch (status->standard) {
+      case SILABS_ANALOG: {
+        return 1;
+        break;
+      }
+      case SILABS_DVB_T :
+      case SILABS_DVB_C :
+      {
+        front_end->Si2168_FE->demod->tuner_rssi = status->rssi;
+        if ( Si2168_L1_DD_BER    (front_end->Si2168_FE->demod, Si2168_DD_BER_CMD_RST_RUN  ) != NO_Si2168_ERROR ) return 0;
+        /* Mimick Si2167 clock_mode register values */
+        status->clock_mode =  33;
+        /* CHECK the exponent value to know if the BER is available or not */
+        if(front_end->Si2168_FE->demod->rsp->dd_ber.exp!=0) {
+          //status->ber                = (front_end->Si2168_FE->demod->rsp->dd_ber.mant/10.0) / power_of_n(10, front_end->Si2168_FE->demod->rsp->dd_ber.exp);
+          status->ber                = (front_end->Si2168_FE->demod->rsp->dd_ber.mant/10) / power_of_n(10, front_end->Si2168_FE->demod->rsp->dd_ber.exp);
+        }
+        if ( Si2168_L1_DD_PER    (front_end->Si2168_FE->demod, Si2168_DD_PER_CMD_RST_RUN  ) != NO_Si2168_ERROR ) return 0;
+        /* CHECK the exponent value to know if the PER is available or not */
+        if (front_end->Si2168_FE->demod->rsp->dd_per.exp!=0) {
+          //status->per                = (front_end->Si2168_FE->demod->rsp->dd_per.mant/10.0) / power_of_n(10, front_end->Si2168_FE->demod->rsp->dd_per.exp);
+          status->per                = (front_end->Si2168_FE->demod->rsp->dd_per.mant/10) / power_of_n(10, front_end->Si2168_FE->demod->rsp->dd_per.exp);
+        }
+        if ( Si2168_L1_DD_UNCOR  (front_end->Si2168_FE->demod, Si2168_DD_UNCOR_CMD_RST_RUN) != NO_Si2168_ERROR ) return 0;
+        status->uncorrs            = (front_end->Si2168_FE->demod->rsp->dd_uncor.uncor_msb<<16) + front_end->Si2168_FE->demod->rsp->dd_uncor.uncor_lsb;
+        break;
+      }
+      case SILABS_DVB_T2:
+       {
+        /* Mimick Si2167 clock_mode register values */
+        switch (front_end->Si2168_FE->demod->cmd->start_clk.clk_mode) {
+          case Si2168_START_CLK_CMD_CLK_MODE_CLK_CLKIO   : status->clock_mode =  32; break;
+          case Si2168_START_CLK_CMD_CLK_MODE_CLK_XTAL_IN : status->clock_mode =  34; break;
+          case Si2168_START_CLK_CMD_CLK_MODE_XTAL        : status->clock_mode =  33; break;
+          default                                        : status->clock_mode =   0; break;
+        }
+        if ( Si2168_L1_DD_BER    (front_end->Si2168_FE->demod, Si2168_DD_BER_CMD_RST_RUN  ) != NO_Si2168_ERROR ) return 0;
+        /* CHECK the exponent value to know if the BER is available or not*/
+        if(front_end->Si2168_FE->demod->rsp->dd_ber.exp!=0) {
+          //status->ber                = (front_end->Si2168_FE->demod->rsp->dd_ber.mant/10.0) / power_of_n(10, front_end->Si2168_FE->demod->rsp->dd_ber.exp);
+          status->ber                = (front_end->Si2168_FE->demod->rsp->dd_ber.mant/10) / power_of_n(10, front_end->Si2168_FE->demod->rsp->dd_ber.exp);
+        }
+        if ( Si2168_L1_DD_FER    (front_end->Si2168_FE->demod, Si2168_DD_FER_CMD_RST_RUN  ) != NO_Si2168_ERROR ) return 0;
+        /* CHECK the exponent value to know if the FER is available or not*/
+        if(front_end->Si2168_FE->demod->rsp->dd_fer.exp!=0) {
+          //status->fer                = (front_end->Si2168_FE->demod->rsp->dd_fer.mant/10.0) / power_of_n(10, front_end->Si2168_FE->demod->rsp->dd_fer.exp);
+          status->fer                = (front_end->Si2168_FE->demod->rsp->dd_fer.mant/10) / power_of_n(10, front_end->Si2168_FE->demod->rsp->dd_fer.exp);
+        }
+        if ( Si2168_L1_DD_PER    (front_end->Si2168_FE->demod, Si2168_DD_PER_CMD_RST_RUN  ) != NO_Si2168_ERROR ) return 0;
+        /* CHECK the exponent value to know if the PER is available or not*/
+        if(front_end->Si2168_FE->demod->rsp->dd_per.exp!=0) {
+          //status->per                = (front_end->Si2168_FE->demod->rsp->dd_per.mant/10.0) / power_of_n(10, front_end->Si2168_FE->demod->rsp->dd_per.exp);
+          status->per                = (front_end->Si2168_FE->demod->rsp->dd_per.mant/10) / power_of_n(10, front_end->Si2168_FE->demod->rsp->dd_per.exp);
+        }
+        if ( Si2168_L1_DD_UNCOR  (front_end->Si2168_FE->demod, Si2168_DD_UNCOR_CMD_RST_RUN) != NO_Si2168_ERROR ) return 0;
+        status->uncorrs            = (front_end->Si2168_FE->demod->rsp->dd_uncor.uncor_msb<<16) + front_end->Si2168_FE->demod->rsp->dd_uncor.uncor_lsb;
+        break;
+      }
+      default           : { return 0; break; }
+    }
+    switch (status->standard) {
+      case SILABS_DVB_T : {
+        if (Si2168_L1_DVBT_STATUS    (front_end->Si2168_FE->demod, Si2168_DVBT_STATUS_CMD_INTACK_OK)                        != NO_Si2168_ERROR) return 0;
+        if (Si2168_L1_DVBT_TPS_EXTRA (front_end->Si2168_FE->demod)                                                          != NO_Si2168_ERROR) return 0;
+#ifdef    TUNERTER_API
+        status->RSSI               = front_end->Si2168_FE->tuner_ter->rsp->tuner_status.rssi;
+#else  /* TUNERTER_API */
+        status->RSSI               = front_end->Si2168_FE->tuner_ter->rssi;
+#endif /* TUNERTER_API */
+        if (Si2168_L1_DD_SSI_SQI     (front_end->Si2168_FE->demod, (char)status->RSSI) != NO_Si2168_ERROR) return 0;
+        status->demod_lock         = front_end->Si2168_FE->demod->rsp->dvbt_status.pcl;
+        status->fec_lock           = front_end->Si2168_FE->demod->rsp->dvbt_status.dl;
+        status->spectral_inversion = front_end->Si2168_FE->demod->rsp->dvbt_status.sp_inv;
+        //status->c_n                = front_end->Si2168_FE->demod->rsp->dvbt_status.cnr/4.0;
+        status->c_n                = front_end->Si2168_FE->demod->rsp->dvbt_status.cnr/4;
+        
+        status->freq_offset        = front_end->Si2168_FE->demod->rsp->dvbt_status.afc_freq;
+        status->timing_offset      = front_end->Si2168_FE->demod->rsp->dvbt_status.timing_offset;
+        status->bandwidth_Hz       = front_end->Si2168_FE->demod->prop->dd_mode.bw*1000000;
+        status->stream             = Custom_streamCode   (front_end, front_end->Si2168_FE->demod->prop->dvbt_hierarchy.stream);
+        status->fft_mode           = Custom_fftCode      (front_end, front_end->Si2168_FE->demod->rsp->dvbt_status.fft_mode);
+        status->guard_interval     = Custom_giCode       (front_end, front_end->Si2168_FE->demod->rsp->dvbt_status.guard_int);
+        status->constellation      = Custom_constelCode  (front_end, front_end->Si2168_FE->demod->rsp->dvbt_status.constellation);
+        status->hierarchy          = Custom_hierarchyCode(front_end, front_end->Si2168_FE->demod->rsp->dvbt_status.hierarchy);
+        status->code_rate_hp       = Custom_coderateCode (front_end, front_end->Si2168_FE->demod->rsp->dvbt_status.rate_hp);
+        status->code_rate_lp       = Custom_coderateCode (front_end, front_end->Si2168_FE->demod->rsp->dvbt_status.rate_lp);
+        status->symbol_rate        = 0;
+        status->SSI                = front_end->Si2168_FE->demod->rsp->dd_ssi_sqi.ssi;
+        status->SQI                = front_end->Si2168_FE->demod->rsp->dd_ssi_sqi.sqi;
+        break;
+      }
+      case SILABS_DVB_T2 : {
+        if (Si2168_L1_DVBT2_STATUS   (front_end->Si2168_FE->demod, Si2168_DVBT2_STATUS_CMD_INTACK_OK)                       != NO_Si2168_ERROR) return 0;
+        status->demod_lock         = front_end->Si2168_FE->demod->rsp->dvbt2_status.pcl;
+        status->fec_lock           = front_end->Si2168_FE->demod->rsp->dvbt2_status.dl;
+        status->spectral_inversion = front_end->Si2168_FE->demod->rsp->dvbt2_status.sp_inv;
+        //status->c_n                = front_end->Si2168_FE->demod->rsp->dvbt2_status.cnr/4.0;
+        status->c_n                = front_end->Si2168_FE->demod->rsp->dvbt2_status.cnr/4;
+        
+        status->freq_offset        = front_end->Si2168_FE->demod->rsp->dvbt2_status.afc_freq;
+        status->timing_offset      = front_end->Si2168_FE->demod->rsp->dvbt2_status.timing_offset;
+        status->bandwidth_Hz       = front_end->Si2168_FE->demod->prop->dd_mode.bw*1000000;
+        status->stream             = Custom_streamCode      (front_end, 0);
+        status->fft_mode           = Custom_fftCode         (front_end, front_end->Si2168_FE->demod->rsp->dvbt2_status.fft_mode);
+        status->guard_interval     = Custom_giCode          (front_end, front_end->Si2168_FE->demod->rsp->dvbt2_status.guard_int);
+        status->constellation      = Custom_constelCode     (front_end, front_end->Si2168_FE->demod->rsp->dvbt2_status.constellation);
+        status->code_rate          = Custom_coderateCode    (front_end, front_end->Si2168_FE->demod->rsp->dvbt2_status.code_rate);
+        status->num_plp            = front_end->Si2168_FE->demod->rsp->dvbt2_status.num_plp;
+        status->rotated            = front_end->Si2168_FE->demod->rsp->dvbt2_status.rotated;
+        status->pilot_pattern      = Custom_pilotPatternCode(front_end, front_end->Si2168_FE->demod->rsp->dvbt2_status.pilot_pattern);
+        status->bw_ext             = front_end->Si2168_FE->demod->rsp->dvbt2_status.bw_ext;
+        status->num_plp            = front_end->Si2168_FE->demod->rsp->dvbt2_status.num_plp;
+        status->plp_id             = front_end->Si2168_FE->demod->rsp->dvbt2_status.plp_id;
+        status->tx_mode            = front_end->Si2168_FE->demod->rsp->dvbt2_status.tx_mode;
+        status->short_frame        = front_end->Si2168_FE->demod->rsp->dvbt2_status.short_frame;
+        status->fef                = front_end->Si2168_FE->demod->rsp->dvbt2_status.fef;
+#ifdef    TUNERTER_API
+        status->RSSI               = front_end->Si2168_FE->tuner_ter->rsp->tuner_status.rssi;
+#else  /* TUNERTER_API */
+        status->RSSI               = front_end->Si2168_FE->tuner_ter->rssi;
+#endif /* TUNERTER_API */
+        if (Si2168_L1_DD_SSI_SQI     (front_end->Si2168_FE->demod, (char)status->RSSI) != NO_Si2168_ERROR) return 0;
+        status->SSI                = front_end->Si2168_FE->demod->rsp->dd_ssi_sqi.ssi;
+        status->SQI                = front_end->Si2168_FE->demod->rsp->dd_ssi_sqi.sqi;
+        status->symbol_rate        = 0;
+        break;
+      }
+      case SILABS_DVB_C : {
+        if (Si2168_L1_DVBC_STATUS    (front_end->Si2168_FE->demod, Si2168_DVBC_STATUS_CMD_INTACK_OK) != NO_Si2168_ERROR) return 0;
+        status->demod_lock         = front_end->Si2168_FE->demod->rsp->dvbc_status.pcl;
+        status->fec_lock           = front_end->Si2168_FE->demod->rsp->dvbc_status.dl;
+        status->symbol_rate        = front_end->Si2168_FE->demod->prop->dvbc_symbol_rate.rate*1000;
+        status->constellation      = Custom_constelCode (front_end, front_end->Si2168_FE->demod->rsp->dvbc_status.constellation);
+        status->spectral_inversion = front_end->Si2168_FE->demod->rsp->dvbc_status.sp_inv;
+        //status->c_n                = front_end->Si2168_FE->demod->rsp->dvbc_status.cnr/4.0;
+        status->c_n                = front_end->Si2168_FE->demod->rsp->dvbc_status.cnr/4;
+        
+        status->freq_offset        = front_end->Si2168_FE->demod->rsp->dvbc_status.afc_freq;
+        status->timing_offset      = front_end->Si2168_FE->demod->rsp->dvbc_status.timing_offset;
+#ifdef    TUNERTER_API
+        status->RSSI               = front_end->Si2168_FE->tuner_ter->rsp->tuner_status.rssi;
+#else  /* TUNERTER_API */
+        status->RSSI               = front_end->Si2168_FE->tuner_ter->rssi;
+#endif /* TUNERTER_API */
+        status->SSI                = 0;
+        status->SQI                = 0;
+        break;
+      }
+      default           : {
+        return 0;
+        break;
+      }
+    }
+  }
+#endif /* Si2168_COMPATIBLE */
+  return 0;
+}
+
+/************************************************************************************************************************
+  SiLabs_API_FE_status function
+  Use:        Front-End status function
+              Used to retrieve the status of the front-end in a structure
+  Parameter:  front_end, a pointer to the SILABS_FE_Context context
+  Parameter:  status, a pointer to the status structure (configurable in CUSTOM_Status_Struct)
+  Return:     1 if successful, 0 otherwise
+************************************************************************************************************************/
+int   SiLabs_API_FE_status                (SILABS_FE_Context* front_end, CUSTOM_Status_Struct *status)
+{
+
+  SiTRACE("SiLabs_API_FE_status in %s\n", Silabs_Standard_Text((CUSTOM_Standard_Enum)(front_end->standard)));
+  switch (front_end->standard) {
+    case SILABS_ANALOG: {
+      SiLabs_API_TER_Tuner_status   (front_end, status);
+      return 1;
+      break;
+    }
+    case SILABS_DVB_T :
+    case SILABS_DVB_T2:
+    case SILABS_DVB_C :
+    case SILABS_DVB_C2:
+    case SILABS_MCNS  : {
+      SiLabs_API_TER_Tuner_status   (front_end, status);
+      break;
+    }
+    case SILABS_DVB_S :
+    case SILABS_DVB_S2:
+    case SILABS_DSS   : {
+      SiLabs_API_SAT_Tuner_status   (front_end, status);
+      break;
+    }
+    case SILABS_SLEEP : {
+      status->standard = SILABS_SLEEP;
+      return 0; break;
+    }
+    default           : { return 0; break; }
+  }
+  SiLabs_API_Demod_status       (front_end, status);
+  return 1;
+}
+
+/************************************************************************************************************************
+  Silabs_standardCode function
+  Use:        standard code function
+              Used to retrieve the standard value used by the DTV demodulator
+  Parameter:  front_end, a pointer to the SILABS_FE_Context context
+  Parameter:  standard, the value used by the top-level application (configurable in CUSTOM_Standard_Enum)
+************************************************************************************************************************/
+int   Silabs_standardCode                 (SILABS_FE_Context* front_end, CUSTOM_Standard_Enum          standard)
+{
+  front_end = front_end; /* to avoid compiler warning if not used */
+#ifdef    Si2168_COMPATIBLE
+  if (front_end->chip ==   2168 ) {
+    switch (standard) {
+      case SILABS_DVB_T : return Si2168_DD_MODE_PROP_MODULATION_DVBT;
+      case SILABS_DVB_T2: return Si2168_DD_MODE_PROP_MODULATION_DVBT2;
+      case SILABS_DVB_C : return Si2168_DD_MODE_PROP_MODULATION_DVBC;
+      default           : return -1;
+    }
+  }
+#endif /* Si2168_COMPATIBLE */
+  return -1;
+}
+/************************************************************************************************************************
+  Silabs_constelCode function
+  Use:        constel code function
+              Used to retrieve the constel value used by the DTV demodulator
+  Parameter:  front_end, a pointer to the SILABS_FE_Context context
+  Parameter:  constel, the value used by the top-level application (configurable in CUSTOM_Constel_Enum)
+************************************************************************************************************************/
+int   Silabs_constelCode                  (SILABS_FE_Context* front_end, CUSTOM_Constel_Enum           constel)
+{
+  front_end = front_end; /* to avoid compiler warning if not used */
+#ifdef    Si2168_COMPATIBLE
+  if (front_end->chip ==   2168 ) {
+    switch (constel) {
+      case SILABS_QAMAUTO : return Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_AUTO ;
+      case SILABS_QAM16   : return Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM16 ;
+      case SILABS_QAM32   : return Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM32 ;
+      case SILABS_QAM64   : return Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM64 ;
+      case SILABS_QAM128  : return Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM128;
+      case SILABS_QAM256  : return Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM256;
+      default             : return -1;
+    }
+  }
+#endif /* Si2168_COMPATIBLE */
+  return -1;
+}
+/************************************************************************************************************************
+  Silabs_streamCode function
+  Use:        stream code function
+              Used to retrieve the stream value used by the DTV demodulator
+  Parameter:  front_end, a pointer to the SILABS_FE_Context context
+  Parameter:  stream, the value used by the top-level application (configurable in CUSTOM_Stream_Enum)
+************************************************************************************************************************/
+int   Silabs_streamCode                   (SILABS_FE_Context* front_end, CUSTOM_Stream_Enum            stream)
+{
+  front_end = front_end; /* to avoid compiler warning if not used */
+  stream    = stream;    /* to avoid compiler warning if not used */
+#ifdef    Si2168_COMPATIBLE
+  if (front_end->chip ==   2168 ) {
+    switch (stream) {
+      case SILABS_HP : return Si2168_DVBT_HIERARCHY_PROP_STREAM_HP   ;
+      case SILABS_LP : return Si2168_DVBT_HIERARCHY_PROP_STREAM_LP   ;
+      default           : return -1;
+    }
+  }
+#endif /* Si2168_COMPATIBLE */
+  return -1;
+}
+
+/************************************************************************************************************************
+  Custom_standardCode function
+  Use:        standard code function
+              Used to retrieve the standard value used by the DTV demodulator in custom format
+  Parameter:  front_end, a pointer to the SILABS_FE_Context context
+  Parameter:  standard, the value used by the top-level application (as returned by the demod)
+************************************************************************************************************************/
+int   Custom_standardCode                 (SILABS_FE_Context* front_end, int standard)
+{
+#ifdef    Si2168_COMPATIBLE
+  if (front_end->chip ==   2168 ) {
+    switch (standard) {
+      case Si2168_DD_MODE_PROP_MODULATION_DVBT : return SILABS_DVB_T ;
+      case Si2168_DD_MODE_PROP_MODULATION_DVBT2: return SILABS_DVB_T2;
+      case Si2168_DD_MODE_PROP_MODULATION_DVBC : return SILABS_DVB_C ;
+      default                                  : return -1;
+    }
+  }
+#endif /* Si2168_COMPATIBLE */
+  return -1;
+}
+
+/************************************************************************************************************************
+  Custom_streamCode function
+  Use:        stream code function
+              Used to retrieve the stream value used by the DTV demodulator in custom format
+  Parameter:  front_end, a pointer to the SILABS_FE_Context context
+  Parameter:  stream, the value used by the top-level application (as returned by the demod)
+************************************************************************************************************************/
+int   Custom_streamCode                   (SILABS_FE_Context* front_end, int stream)
+{
+  front_end = front_end; /* To avoid compiler warning if not supported */
+  stream    = stream;    /* To avoid compiler warning if not supported */
+#ifdef    Si2168_COMPATIBLE
+  if (front_end->chip ==   2168 ) {
+    switch (stream) {
+      case Si2168_DVBT_HIERARCHY_PROP_STREAM_HP: return SILABS_HP;
+      case Si2168_DVBT_HIERARCHY_PROP_STREAM_LP: return SILABS_LP;
+      default                                  : return -1;
+    }
+  }
+#endif /* Si2168_COMPATIBLE */
+  return -1;
+}
+/************************************************************************************************************************
+  Custom_fftCode function
+  Use:        fft code function
+              Used to retrieve the fft value used by the DTV demodulator in custom format
+  Parameter:  front_end, a pointer to the SILABS_FE_Context context
+  Parameter:  fft, the value used by the top-level application (as returned by the demod)
+************************************************************************************************************************/
+int   Custom_fftCode                      (SILABS_FE_Context* front_end, int fft)
+{
+  front_end = front_end; /* To avoid compiler warning if not supported */
+  fft       = fft;       /* To avoid compiler warning if not supported */
+#ifdef    Si2168_COMPATIBLE
+  if (front_end->chip ==   2168 ) {
+    switch (fft) {    	
+      case Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_1K  : return SILABS_FFT_MODE_1K ;
+      case Si2168_DVBT_STATUS_RESPONSE_FFT_MODE_2K  : return SILABS_FFT_MODE_2K ;
+      case Si2168_DVBT_STATUS_RESPONSE_FFT_MODE_4K  : return SILABS_FFT_MODE_4K ;
+      case Si2168_DVBT_STATUS_RESPONSE_FFT_MODE_8K  : return SILABS_FFT_MODE_8K ;
+      case Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_16K: return SILABS_FFT_MODE_16K;
+      case Si2168_DVBT2_STATUS_RESPONSE_FFT_MODE_32K: return SILABS_FFT_MODE_32K;
+      default                                       : return -1;
+    }
+  }
+#endif /* Si2168_COMPATIBLE */
+  return -1;
+}
+/************************************************************************************************************************
+  Custom_giCode function
+  Use:        gi code function
+              Used to retrieve the gi value used by the DTV demodulator in custom format
+  Parameter:  front_end, a pointer to the SILABS_FE_Context context
+  Parameter:  gi, the value used by the top-level application (as returned by the demod)
+************************************************************************************************************************/
+int   Custom_giCode                       (SILABS_FE_Context* front_end, int gi)
+{
+  front_end = front_end; /* To avoid compiler warning if not supported */
+  gi        = gi;        /* To avoid compiler warning if not supported */
+#ifdef    Si2168_COMPATIBLE
+  if (front_end->chip ==   2168 ) {
+    switch (gi) {
+      case Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_1_32  : return SILABS_GUARD_INTERVAL_1_32  ;
+      case Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_1_16  : return SILABS_GUARD_INTERVAL_1_16  ;
+      case Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_1_8   : return SILABS_GUARD_INTERVAL_1_8   ;
+      case Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_1_4   : return SILABS_GUARD_INTERVAL_1_4   ;
+      case Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_1_128 : return SILABS_GUARD_INTERVAL_1_128 ;
+      case Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_19_128: return SILABS_GUARD_INTERVAL_19_128;
+      case Si2168_DVBT2_STATUS_RESPONSE_GUARD_INT_19_256: return SILABS_GUARD_INTERVAL_19_256;
+      default                                           : return -1;
+    }
+  }
+#endif /* Si2168_COMPATIBLE */
+  return -1;
+}
+/************************************************************************************************************************
+  Custom_constelCode function
+  Use:        constel code function
+              Used to retrieve the constel value  used by the DTV demodulator in custom format
+  Parameter:  front_end, a pointer to the SILABS_FE_Context context
+  Parameter:  constel, the value used by the top-level application (as returned by the demod)
+************************************************************************************************************************/
+int   Custom_constelCode                  (SILABS_FE_Context* front_end, int constel)
+{
+#ifdef    Si2168_COMPATIBLE
+  if (front_end->chip ==   2168 ) {
+    switch (constel) {
+      case Si2168_DVBT_STATUS_RESPONSE_CONSTELLATION_QPSK  : return SILABS_QPSK ;
+      case Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_AUTO  : return SILABS_QAMAUTO ;
+      case Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM16 : return SILABS_QAM16   ;
+      case Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM32 : return SILABS_QAM32   ;
+      case Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM64 : return SILABS_QAM64   ;
+      case Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM128: return SILABS_QAM128  ;
+      case Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM256: return SILABS_QAM256  ;
+      default                                                 : return -1;
+    }
+  }
+#endif /* Si2168_COMPATIBLE */
+  return -1;
+}
+/************************************************************************************************************************
+  Custom_hierarchyCode function
+  Use:        hierarchy code function
+              Used to retrieve the hierarchy value used by the DTV demodulator in custom format
+  Parameter:  front_end, a pointer to the SILABS_FE_Context context
+  Parameter:  hierarchy, the value used by the top-level application (as returned by the demod)
+************************************************************************************************************************/
+int   Custom_hierarchyCode                (SILABS_FE_Context* front_end, int hierarchy)
+{
+  front_end = front_end; /* To avoid compiler warning if not supported */
+  hierarchy = hierarchy; /* To avoid compiler warning if not supported */
+#ifdef    Si2168_COMPATIBLE
+  if (front_end->chip ==   2168 ) {
+    switch (hierarchy) {
+      case Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_NONE : return SILABS_HIERARCHY_NONE;
+      case Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_ALFA1: return SILABS_HIERARCHY_ALFA1;
+      case Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_ALFA2: return SILABS_HIERARCHY_ALFA2;
+      case Si2168_DVBT_STATUS_RESPONSE_HIERARCHY_ALFA4: return SILABS_HIERARCHY_ALFA4;
+      default                                         : return -1;
+    }
+  }
+#endif /* Si2168_COMPATIBLE */
+  return -1;
+}
+/************************************************************************************************************************
+  Custom_coderateCode function
+  Use:        coderate code function
+              Used to retrieve the coderate value used by the DTV demodulator in custom format
+  Parameter:  front_end, a pointer to the SILABS_FE_Context context
+  Parameter:  coderate, the value used by the top-level application (as returned by the demod)
+************************************************************************************************************************/
+int   Custom_coderateCode                 (SILABS_FE_Context* front_end, int coderate)
+{
+  front_end = front_end; /* To avoid compiler warning if not supported */
+  coderate  = coderate;  /* To avoid compiler warning if not supported */
+#ifdef    Si2168_COMPATIBLE
+  if (front_end->chip ==   2168 ) {
+    switch (coderate) {     
+      case Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_3_5    : return SILABS_CODERATE_3_5;
+      case Si2168_DVBT2_STATUS_RESPONSE_CODE_RATE_4_5    : return SILABS_CODERATE_4_5;
+      case Si2168_DVBT_STATUS_RESPONSE_RATE_HP_1_2    : return SILABS_CODERATE_1_2;
+      case Si2168_DVBT_STATUS_RESPONSE_RATE_HP_2_3    : return SILABS_CODERATE_2_3;
+      case Si2168_DVBT_STATUS_RESPONSE_RATE_HP_3_4    : return SILABS_CODERATE_3_4;
+      case Si2168_DVBT_STATUS_RESPONSE_RATE_HP_5_6    : return SILABS_CODERATE_5_6;
+      case Si2168_DVBT_STATUS_RESPONSE_RATE_HP_7_8    : return SILABS_CODERATE_7_8;
+      default                                         : return -1;
+    }
+  }
+#endif /* Si2168_COMPATIBLE */
+  return -1;
+}
+/************************************************************************************************************************
+  Custom_pilotPatternCode function
+  Use:        pilot pattern code function
+              Used to retrieve the pilot pattern value used by the DVB-T2 demodulator in custom format
+  Parameter:  front_end, a pointer to the SILABS_FE_Context context
+  Parameter:  pilot_pattern, the value used by the top-level application (as returned by the demod)
+************************************************************************************************************************/
+int   Custom_pilotPatternCode             (SILABS_FE_Context* front_end, int pilot_pattern)
+{
+  front_end->chip = front_end->chip; /* To avoid compiler warning if not supported */
+  pilot_pattern   = pilot_pattern  ; /* To avoid compiler warning if not supported */
+#ifdef    Si2168_COMPATIBLE
+  if (front_end->chip ==   2168 ) {
+    switch (pilot_pattern) {
+      case Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP1: return SILABS_PILOT_PATTERN_PP1;
+      case Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP2: return SILABS_PILOT_PATTERN_PP2;
+      case Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP3: return SILABS_PILOT_PATTERN_PP3;
+      case Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP4: return SILABS_PILOT_PATTERN_PP4;
+      case Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP5: return SILABS_PILOT_PATTERN_PP5;
+      case Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP6: return SILABS_PILOT_PATTERN_PP6;
+      case Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP7: return SILABS_PILOT_PATTERN_PP7;
+      case Si2168_DVBT2_STATUS_RESPONSE_PILOT_PATTERN_PP8: return SILABS_PILOT_PATTERN_PP8;
+      default                                            : return -1;
+    }
+  }
+#endif /* Si2168_COMPATIBLE */
+  return -1;
+}
+/************************************************************************************************************************
+  NAME: Si2168_Configure
+  DESCRIPTION: Setup TER and SAT AGCs, Common Properties startup
+  Parameter:  Pointer to Si2168 Context
+  Returns:    I2C transaction error code, NO_Si2168_ERROR if successful
+************************************************************************************************************************/
+int Si2168_Configure           (L1_Si2168_Context *api)
+{
+    int return_code;
+    return_code = NO_Si2168_ERROR;
+
+    SiTRACE("media %d\n",api->media);
+
+    /* AGC settings when not used */
+    api->cmd->dd_mp_defaults.mp_a_mode   = Si2168_DD_MP_DEFAULTS_CMD_MP_A_MODE_DISABLE;
+    if (api->fef_mode == Si2168_FEF_MODE_FREEZE_PIN) {
+      api->cmd->dd_mp_defaults.mp_b_mode   = Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_DRIVE_0;
+    } else {
+    api->cmd->dd_mp_defaults.mp_b_mode   = Si2168_DD_MP_DEFAULTS_CMD_MP_B_MODE_DISABLE;
+    }
+    api->cmd->dd_mp_defaults.mp_c_mode   = Si2168_DD_MP_DEFAULTS_CMD_MP_C_MODE_DISABLE;
+    api->cmd->dd_mp_defaults.mp_d_mode   = Si2168_DD_MP_DEFAULTS_CMD_MP_D_MODE_DISABLE;
+    Si2168_L1_SendCommand2(api, Si2168_DD_MP_DEFAULTS_CMD_CODE);
+
+    /* LEDS MANAGEMENT */
+    /* set hardware lock on green LED */
+    api->cmd->config_pins.gpio0_mode     = Si2168_CONFIG_PINS_CMD_GPIO0_MODE_HW_LOCK;
+    api->cmd->config_pins.gpio0_read     = Si2168_CONFIG_PINS_CMD_GPIO0_READ_DO_NOT_READ;
+
+    if (api->media == Si2168_TERRESTRIAL) {
+      /* Settings for TER AGC. These settings need to match the HW design for TER AGCs */
+      api->cmd->dd_ext_agc_ter.agc_1_mode  = Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MODE_NOT_USED;
+      #ifdef    Si2168_TER_AGC_INVERTED
+      api->cmd->dd_ext_agc_ter.agc_1_inv   = Si2168_DD_EXT_AGC_TER_CMD_AGC_1_INV_INVERTED;
+      #else  /* Si2168_TER_AGC_INVERTED */
+      api->cmd->dd_ext_agc_ter.agc_1_inv   = Si2168_DD_EXT_AGC_TER_CMD_AGC_1_INV_NOT_INVERTED;
+      #endif /* Si2168_TER_AGC_INVERTED */
+      api->cmd->dd_ext_agc_ter.agc_1_kloop = Si2168_DD_EXT_AGC_TER_CMD_AGC_1_KLOOP_MIN;
+      api->cmd->dd_ext_agc_ter.agc_1_min   = Si2168_DD_EXT_AGC_TER_CMD_AGC_1_MIN_MIN;
+
+      api->cmd->dd_ext_agc_ter.agc_2_mode  = Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MODE_MP_A;
+      #ifdef    Si2168_TER_AGC_INVERTED
+      api->cmd->dd_ext_agc_ter.agc_2_inv   = Si2168_DD_EXT_AGC_TER_CMD_AGC_2_INV_INVERTED;
+      #else  /* Si2168_TER_AGC_INVERTED */
+      api->cmd->dd_ext_agc_ter.agc_2_inv   = Si2168_DD_EXT_AGC_TER_CMD_AGC_2_INV_NOT_INVERTED;
+      #endif /* Si2168_TER_AGC_INVERTED */
+      api->cmd->dd_ext_agc_ter.agc_2_kloop = 18;
+      api->cmd->dd_ext_agc_ter.agc_2_min   = Si2168_DD_EXT_AGC_TER_CMD_AGC_2_MIN_MIN;
+      Si2168_L1_SendCommand2(api, Si2168_DD_EXT_AGC_TER_CMD_CODE);
+
+      if (api->fef_mode == Si2168_FEF_MODE_FREEZE_PIN) {
+      /* SET FEF capability ON MP_B pins and Active HIGH*/
+      api->cmd->dvbt2_fef.fef_tuner_flag      = Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_MP_B;
+      api->cmd->dvbt2_fef.fef_tuner_flag_inv  = Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_INV_FEF_HIGH;
+      } else {
+        api->cmd->dvbt2_fef.fef_tuner_flag      = Si2168_DVBT2_FEF_CMD_FEF_TUNER_FLAG_NOT_USED;
+      }
+      Si2168_L1_SendCommand2(api, Si2168_DVBT2_FEF_CMD_CODE);
+    }
+
+
+    api->cmd->config_pins.gpio1_mode     = Si2168_CONFIG_PINS_CMD_GPIO1_MODE_TS_ERR;
+    api->cmd->config_pins.gpio1_read     = Si2168_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ;
+    Si2168_L1_SendCommand2(api, Si2168_CONFIG_PINS_CMD_CODE);
+
+    /* Set All Properties startup configuration */
+    Si2168_setupAllDefaults     (api);
+    Si2168_downloadAllProperties(api);
+
+    return return_code;
+}
+
+/************************************************************************************************************************
+  NAME: Si2168_STANDBY
+  DESCRIPTION:
+  Parameter:  Pointer to Si2168 Context
+  Returns:    I2C transaction error code, NO_Si2168_ERROR if successful
+************************************************************************************************************************/
+int Si2168_STANDBY             (L1_Si2168_Context *api)
+{
+    return Si2168_L1_POWER_DOWN (api);
+}
+/************************************************************************************************************************
+  NAME: Si2168_WAKEUP
+  DESCRIPTION:
+  Parameter:  Pointer to Si2168 Context
+  Returns:    I2C transaction error code, NO_Si2168_ERROR if successful
+************************************************************************************************************************/
+int Si2168_WAKEUP              (L1_Si2168_Context *api)
+{
+    int return_code;
+    int media;
+
+    return_code = NO_Si2168_ERROR;
+    media       = Si2168_Media(api, api->standard);
+    SiTRACE ("Si2168_WAKEUP: media %d\n", media);
+
+    /* Clock source selection */
+    switch (media) {
+      default                                  :
+      case Si2168_TERRESTRIAL : {
+        api->cmd->start_clk.clk_mode = api->tuner_ter_clock_input;
+        break;
+      }
+    }
+
+    Si2168_L1_START_CLK (api,
+                            Si2168_START_CLK_CMD_SUBCODE_CODE,
+                            Si2168_START_CLK_CMD_RESERVED1_RESERVED,
+                            Si2168_START_CLK_CMD_TUNE_CAP_15P6,
+                            Si2168_START_CLK_CMD_RESERVED2_RESERVED,
+                            api->cmd->start_clk.clk_mode,
+                            Si2168_START_CLK_CMD_RESERVED3_RESERVED,
+                            Si2168_START_CLK_CMD_RESERVED4_RESERVED,
+                            Si2168_START_CLK_CMD_START_CLK_START_CLK);
+    /* Reference frequency selection */
+    switch (media) {
+      default                 :
+      case Si2168_TERRESTRIAL : {
+        if (api->tuner_ter_clock_freq == 16) {
+          SiTRACE("Si2168_POWER_UP_CMD_CLOCK_FREQ_CLK_16MHZ\n");
+          api->cmd->power_up.clock_freq = Si2168_POWER_UP_CMD_CLOCK_FREQ_CLK_16MHZ;
+        } else if (api->tuner_ter_clock_freq == 24) {
+          SiTRACE("Si2168_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ\n");
+          api->cmd->power_up.clock_freq = Si2168_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ;
+        } else {
+          SiTRACE("Si2168_POWER_UP_CMD_CLOCK_FREQ_CLK_27MHZ\n");
+          api->cmd->power_up.clock_freq = Si2168_POWER_UP_CMD_CLOCK_FREQ_CLK_27MHZ;
+        }
+        break;
+      }
+    }
+
+    return_code = Si2168_L1_POWER_UP (api,
+                            Si2168_POWER_UP_CMD_SUBCODE_CODE,
+                            api->cmd->power_up.reset,
+                            Si2168_POWER_UP_CMD_RESERVED2_RESERVED,
+                            Si2168_POWER_UP_CMD_RESERVED4_RESERVED,
+                            Si2168_POWER_UP_CMD_RESERVED1_RESERVED,
+                            Si2168_POWER_UP_CMD_ADDR_MODE_CURRENT,
+                            Si2168_POWER_UP_CMD_RESERVED5_RESERVED,
+                            api->cmd->power_up.func,
+                            api->cmd->power_up.clock_freq,
+                            Si2168_POWER_UP_CMD_CTSIEN_DISABLE,
+                            Si2168_POWER_UP_CMD_WAKE_UP_WAKE_UP);
+
+         if (api->cmd->start_clk.clk_mode == Si2168_START_CLK_CMD_CLK_MODE_CLK_CLKIO  ) { SiTRACE ("Si2168_START_CLK_CMD_CLK_MODE_CLK_CLKIO\n"  );}
+    else if (api->cmd->start_clk.clk_mode == Si2168_START_CLK_CMD_CLK_MODE_CLK_XTAL_IN) { SiTRACE ("Si2168_START_CLK_CMD_CLK_MODE_CLK_XTAL_IN\n");}
+    else if (api->cmd->start_clk.clk_mode == Si2168_START_CLK_CMD_CLK_MODE_XTAL       ) { SiTRACE ("Si2168_START_CLK_CMD_CLK_MODE_XTAL\n"       );}
+
+         if (api->cmd->power_up.reset == Si2168_POWER_UP_CMD_RESET_RESET  ) { SiTRACE ("Si2168_POWER_UP_CMD_RESET_RESET\n"  );}
+    else if (api->cmd->power_up.reset == Si2168_POWER_UP_CMD_RESET_RESUME ) { SiTRACE ("Si2168_POWER_UP_CMD_RESET_RESUME\n");}
+
+    if (return_code != NO_Si2168_ERROR ) {
+      SiTRACE("Si2168_WAKEUP: POWER_UP ERROR!\n");
+      SiERROR("Si2168_WAKEUP: POWER_UP ERROR!\n");
+      return return_code;
+    }
+    /* After a successful POWER_UP, set values for 'resume' only */
+    api->cmd->power_up.reset = Si2168_POWER_UP_CMD_RESET_RESUME;
+    api->cmd->power_up.func  = Si2168_POWER_UP_CMD_FUNC_NORMAL;
+
+    return NO_Si2168_ERROR;
+}
+/************************************************************************************************************************
+  NAME: Si2168_PowerUpWithPatch
+  DESCRIPTION: Send Si2168 API PowerUp Command with PowerUp to bootloader,
+  Check the Chip rev and part, and ROMID are compared to expected values.
+  Load the Firmware Patch then Start the Firmware.
+  Programming Guide Reference:    Flowchart A.2 (POWER_UP with patch flowchart)
+
+  Parameter:  pointer to Si2168 Context
+  Returns:    Si2168/I2C transaction error code, NO_Si2168_ERROR if successful
+************************************************************************************************************************/
+int Si2168_PowerUpWithPatch    (L1_Si2168_Context *api)
+{
+    int return_code;
+    int fw_loaded;
+    return_code = NO_Si2168_ERROR;
+    fw_loaded   = 0;
+
+    /* Before patching, set POWER_UP values for 'RESET' and 'BOOTLOADER' */
+    api->cmd->power_up.reset = Si2168_POWER_UP_CMD_RESET_RESET;
+    api->cmd->power_up.func  = Si2168_POWER_UP_CMD_FUNC_BOOTLOADER,
+
+    return_code = Si2168_WAKEUP(api);
+
+    if (return_code != NO_Si2168_ERROR) {
+      SiERROR("Si2168_PowerUpWithPatch: WAKEUP error!\n");
+        return return_code;
+    }
+
+    /* Get the Part Info from the chip.   This command is only valid in Bootloader mode */
+    if ((return_code = Si2168_L1_PART_INFO(api)) != NO_Si2168_ERROR) {
+        SiTRACE ("Si2168_L1_PART_INFO error 0x%02x: %s\n", return_code, Si2168_L1_API_ERROR_TEXT((unsigned char)return_code) );
+        return return_code;
+    }
+    SiTRACE("chiprev %d\n",        api->rsp->part_info.chiprev);
+    SiTRACE("part    Si21%d\n",    api->rsp->part_info.part   );
+    SiTRACE("romid   %d\n",        api->rsp->part_info.romid  );
+    SiTRACE("pmajor  0x%02x\n",    api->rsp->part_info.pmajor );
+    SiTRACE("pminor  0x%02x\n",    api->rsp->part_info.pminor );
+    SiTRACE("pbuild  %d\n",        api->rsp->part_info.pbuild );
+    if ((api->rsp->part_info.pmajor >= 0x30) & (api->rsp->part_info.pminor >= 0x30)) {
+    SiTRACE("pmajor  '%c'\n",    api->rsp->part_info.pmajor );
+    SiTRACE("pminor  '%c'\n",    api->rsp->part_info.pminor );
+    SiTRACE("Full Info       'Si21%2d_ROM%x_%c_%c_b%d'\n", api->rsp->part_info.part, api->rsp->part_info.romid, api->rsp->part_info.pmajor, api->rsp->part_info.pminor, api->rsp->part_info.pbuild );
+    }
+
+    /* Check part info values and load the proper firmware */
+#ifdef    Si2166B_00_COMPATIBLE
+    #ifdef    Si2166B_Patch_1_Ab3_LINES
+    if (!fw_loaded) {
+      SiTRACE  ("Is this part a  'Si21%2d_ROM%x_%c_%c_b%d'?\n", Si2166B_PATCH_1_Ab3_PART, Si2166B_PATCH_1_Ab3_ROM, Si2166B_PATCH_1_Ab3_PMAJOR, Si2166B_PATCH_1_Ab3_PMINOR, Si2166B_PATCH_1_Ab3_PBUILD );
+      if ((api->rsp->part_info.romid  == Si2166B_PATCH_1_Ab3_ROM   )
+        & (api->rsp->part_info.part   == Si2166B_PATCH_1_Ab3_PART  )
+        & (api->rsp->part_info.pmajor == Si2166B_PATCH_1_Ab3_PMAJOR)
+        & (api->rsp->part_info.pminor == Si2166B_PATCH_1_Ab3_PMINOR)
+        & (api->rsp->part_info.pbuild == Si2166B_PATCH_1_Ab3_PBUILD)) {
+        SiTRACE("Downloading 'Si21%2d_FW_%c_%c_b%d'\n", api->rsp->part_info.part, api->rsp->part_info.pmajor, api->rsp->part_info.pminor, api->rsp->part_info.pbuild );
+        if ((return_code = Si2168_LoadFirmware(api, Si2166B_Patch_1_Ab3, Si2166B_Patch_1_Ab3_LINES)) != NO_Si2168_ERROR) {
+          SiTRACE ("Si2168_LoadPatch error 0x%02x: %s\n", return_code, Si2168_L1_API_ERROR_TEXT(return_code) );
+          return return_code;
+      }
+        fw_loaded++;
+      }
+    }
+    #endif /* Si2166B_Patch_1_Ab3_LINES */
+#endif /* Si2166B_00_COMPATIBLE */
+#ifdef    Si2167B_00_COMPATIBLE
+    #ifdef    Si2167B_Patch_1_Ab3_LINES
+    if (!fw_loaded) {
+      SiTRACE  ("Is this part a  'Si21%2d_ROM%x_%c_%c_b%d'?\n", Si2167B_PATCH_1_Ab3_PART, Si2167B_PATCH_1_Ab3_ROM, Si2167B_PATCH_1_Ab3_PMAJOR, Si2167B_PATCH_1_Ab3_PMINOR, Si2167B_PATCH_1_Ab3_PBUILD );
+      if ((api->rsp->part_info.romid  == Si2167B_PATCH_1_Ab3_ROM   )
+        & (api->rsp->part_info.part   == Si2167B_PATCH_1_Ab3_PART  )
+        & (api->rsp->part_info.pmajor == Si2167B_PATCH_1_Ab3_PMAJOR)
+        & (api->rsp->part_info.pminor == Si2167B_PATCH_1_Ab3_PMINOR)
+        & (api->rsp->part_info.pbuild == Si2167B_PATCH_1_Ab3_PBUILD)) {
+        SiTRACE("Downloading 'Si21%2d_FW_%c_%c_b%d'\n", api->rsp->part_info.part, api->rsp->part_info.pmajor, api->rsp->part_info.pminor, api->rsp->part_info.pbuild );
+        if ((return_code = Si2168_LoadFirmware(api, Si2167B_Patch_1_Ab3, Si2167B_Patch_1_Ab3_LINES)) != NO_Si2168_ERROR) {
+          SiTRACE ("Si2168_LoadPatch error 0x%02x: %s\n", return_code, Si2168_L1_API_ERROR_TEXT(return_code) );
+          return return_code;
+      }
+        fw_loaded++;
+      }
+    }
+    #endif /* Si2167B_Patch_1_Ab3_LINES */
+#endif /* Si2167B_00_COMPATIBLE */
+#ifdef    Si2168_0B_COMPATIBLE
+    #ifdef    Si2168_Firmware_0_Cb14_LINES
+    if (!fw_loaded) {
+      SiTRACE  ("Is this part a  'Si21%2d_ROM%x_%c_%c_b%d'?\n", Si2168_FIRMWARE_0_Cb14_PART, Si2168_FIRMWARE_0_Cb14_ROM, Si2168_FIRMWARE_0_Cb14_PMAJOR, Si2168_FIRMWARE_0_Cb14_PMINOR, Si2168_FIRMWARE_0_Cb14_PBUILD );
+      if ((api->rsp->part_info.romid  == Si2168_FIRMWARE_0_Cb14_ROM   )
+        & (api->rsp->part_info.part   == Si2168_FIRMWARE_0_Cb14_PART  )
+        & (api->rsp->part_info.pmajor == Si2168_FIRMWARE_0_Cb14_PMAJOR)
+        & (api->rsp->part_info.pminor == Si2168_FIRMWARE_0_Cb14_PMINOR)
+        & (api->rsp->part_info.pbuild == Si2168_FIRMWARE_0_Cb14_PBUILD)) {
+        SiTRACE("Updating FW for 'Si21%2d_FW_%c_%c_b%d'\n", api->rsp->part_info.part, api->rsp->part_info.pmajor, api->rsp->part_info.pminor, api->rsp->part_info.pbuild );
+        if ((return_code = Si2168_LoadFirmware(api, Si2168_Firmware_0_Cb14, Si2168_Firmware_0_Cb14_LINES)) != NO_Si2168_ERROR) {
+          SiTRACE ("Si2168_LoadFirmware error 0x%02x: %s\n", return_code, Si2168_L1_API_ERROR_TEXT(return_code) );
+          return return_code;
+      }
+        fw_loaded++;
+      }
+    }
+    #endif /* Si2168_Firmware_0_Cb14_LINES */
+#endif /* Si2168_0B_COMPATIBLE */
+#ifdef    Si2168_10_COMPATIBLE
+    #ifdef    Si2168_Patch_0_Cb14_LINES
+    if (!fw_loaded) {
+      SiTRACE  ("Is this part a  'Si21%2d_ROM%x_%c_%c_b%d'?\n", Si2168_PATCH_0_Cb14_PART, Si2168_PATCH_0_Cb14_ROM, Si2168_PATCH_0_Cb14_PMAJOR, Si2168_PATCH_0_Cb14_PMINOR, Si2168_PATCH_0_Cb14_PBUILD );
+      if ((api->rsp->part_info.romid  == Si2168_PATCH_0_Cb14_ROM   )
+        & (api->rsp->part_info.part   == Si2168_PATCH_0_Cb14_PART  )
+        & (api->rsp->part_info.pmajor == Si2168_PATCH_0_Cb14_PMAJOR)
+        & (api->rsp->part_info.pminor == Si2168_PATCH_0_Cb14_PMINOR)
+        & (api->rsp->part_info.pbuild == Si2168_PATCH_0_Cb14_PBUILD)) {
+        SiTRACE("Updating FW for 'Si21%2d_FW_%c_%c_b%d'\n", api->rsp->part_info.part, api->rsp->part_info.pmajor, api->rsp->part_info.pminor, api->rsp->part_info.pbuild );
+        if ((return_code = Si2168_LoadFirmware(api, Si2168_Patch_0_Cb14, Si2168_Patch_0_Cb14_LINES)) != NO_Si2168_ERROR) {
+            SiTRACE ("Si2168_LoadFirmware error 0x%02x: %s\n", return_code, Si2168_L1_API_ERROR_TEXT(return_code) );
+            return return_code;
+          }
+        fw_loaded++;
+      }
+    }
+    #endif /* Si2168_Patch_0_Cb14_LINES */
+#endif /* Si2168_10_COMPATIBLE */
+#ifdef    Si2168_20_COMPATIBLE
+    #ifdef    Si2168_Patch_2_0b5_LINES
+    if (!fw_loaded) {
+      SiTRACE  ("Is this part a  'Si21%2d_ROM%x_%c_%c_b%d'?\n", Si2168_PATCH_2_0b5_PART, Si2168_PATCH_2_0b5_ROM, Si2168_PATCH_2_0b5_PMAJOR, Si2168_PATCH_2_0b5_PMINOR, Si2168_PATCH_2_0b5_PBUILD );
+      if ((api->rsp->part_info.romid  == Si2168_PATCH_2_0b5_ROM   )
+        & (api->rsp->part_info.part   == Si2168_PATCH_2_0b5_PART  )
+        & (api->rsp->part_info.pmajor == Si2168_PATCH_2_0b5_PMAJOR)
+        & (api->rsp->part_info.pminor == Si2168_PATCH_2_0b5_PMINOR)
+        & (api->rsp->part_info.pbuild == Si2168_PATCH_2_0b5_PBUILD)) {
+        SiTRACE("Updating FW for 'Si21%2d_ROM%x %c_%c_b%d'\n", api->rsp->part_info.part, api->rsp->part_info.romid, api->rsp->part_info.pmajor, api->rsp->part_info.pminor, api->rsp->part_info.pbuild );
+        if ((return_code = Si2168_LoadFirmware(api, Si2168_Patch_2_0b5, Si2168_Patch_2_0b5_LINES)) != NO_Si2168_ERROR) {
+            SiTRACE ("Si2168_LoadFirmware error 0x%02x: %s\n", return_code, Si2168_L1_API_ERROR_TEXT((unsigned char)return_code) );
+            return return_code;
+          }
+        fw_loaded++;
+        }
+    }
+    #endif /* Si2168_Patch_2_0b5_LINES */
+#endif /* Si2168_20_COMPATIBLE */
+
+    if (!fw_loaded) {
+      SiTRACE ("Si2168_LoadFirmware error: NO Firmware Loaded! Possible part/code incompatibility !\n");
+      SiERROR ("Si2168_LoadFirmware error: NO Firmware Loaded! Possible part/code incompatibility !\n");
+      return ERROR_Si2168_LOADING_FIRMWARE;
+    }
+
+    /*Start the Firmware */
+    if ((return_code = Si2168_StartFirmware(api)) != NO_Si2168_ERROR) {
+       /* Start firmware */
+        SiTRACE ("Si2168_StartFirmware error 0x%02x: %s\n", return_code, Si2168_L1_API_ERROR_TEXT((unsigned char)return_code) );
+        return return_code;
+    }
+
+    Si2168_L1_GET_REV (api);
+    SiTRACE("Si21%2d Part running 'FW_%c_%c_b%d'\n", api->rsp->part_info.part, api->rsp->get_rev.cmpmajor, api->rsp->get_rev.cmpminor, api->rsp->get_rev.cmpbuild );
+
+    return NO_Si2168_ERROR;
+}
+/************************************************************************************************************************
+  NAME: Si2168_LoadFirmware
+  DESCRIPTON: Load firmware from FIRMWARE_TABLE array in Si2168_Firmware_x_y_build_z.h file into Si2168
+              Requires Si2168 to be in bootloader mode after PowerUp
+  Programming Guide Reference:    Flowchart A.3 (Download FW PATCH flowchart)
+
+  Parameter:  Si2168 Context (I2C address)
+  Parameter:  pointer to firmware table array
+  Parameter:  number of lines in firmware table array (size in bytes / BYTES_PER_LINE)
+  Returns:    Si2168/I2C transaction error code, NO_Si2168_ERROR if successful
+************************************************************************************************************************/
+int Si2168_LoadFirmware        (L1_Si2168_Context *api, unsigned char fw_table[], int nbLines)
+{
+    int return_code;
+    int line;
+    return_code = NO_Si2168_ERROR;
+
+    SiTRACE ("Si2168_LoadFirmware starting...\n");
+    SiTRACE ("Si2168_LoadFirmware nbLines %d\n", nbLines);
+
+    /* for each line in fw_table */
+    for (line = 0; line < nbLines; line++)
+    {
+        /* send Si2168_BYTES_PER_LINE fw bytes to Si2168 */
+        if ((return_code = Si2168_L1_API_Patch(api, Si2168_BYTES_PER_LINE, fw_table + Si2168_BYTES_PER_LINE*line)) != NO_Si2168_ERROR)
+        {
+          SiTRACE("Si2168_LoadFirmware error 0x%02x patching line %d: %s\n", return_code, line, Si2168_L1_API_ERROR_TEXT((unsigned char)return_code) );
+          if (line == 0) {
+          SiTRACE("The firmware is incompatible with the part!\n");
+          }
+          return ERROR_Si2168_LOADING_FIRMWARE;
+        }
+        //if (line==3) SiTraceConfiguration("traces suspend");
+    }
+    //SiTraceConfiguration("traces resume");
+    SiTRACE ("Si2168_LoadFirmware complete...\n");
+    return NO_Si2168_ERROR;
+}
+/************************************************************************************************************************
+  NAME: Si2168_StartFirmware
+  DESCRIPTION: Start Si2168 firmware (put the Si2168 into run mode)
+  Parameter:   Si2168 Context (I2C address)
+  Parameter (passed by Reference):   ExitBootloadeer Response Status byte : tunint, atvint, dtvint, err, cts
+  Returns:     I2C transaction error code, NO_Si2168_ERROR if successful
+************************************************************************************************************************/
+int Si2168_StartFirmware       (L1_Si2168_Context *api)
+{
+
+    if (Si2168_L1_EXIT_BOOTLOADER(api, Si2168_EXIT_BOOTLOADER_CMD_FUNC_NORMAL, Si2168_EXIT_BOOTLOADER_CMD_CTSIEN_OFF) != NO_Si2168_ERROR)
+    {
+        return ERROR_Si2168_STARTING_FIRMWARE;
+    }
+
+    return NO_Si2168_ERROR;
+}
+/************************************************************************************************************************
+  NAME: Si2168_Init
+  DESCRIPTION:Reset and Initialize Si2168
+  Parameter:  Si2168 Context (I2C address)
+  Returns:    I2C transaction error code, NO_Si2168_ERROR if successful
+************************************************************************************************************************/
+int Si2168_Init                (L1_Si2168_Context *api)
+{
+    int return_code;
+    SiTRACE("Si2168_Init starting...\n");
+
+    if ((return_code = Si2168_PowerUpWithPatch(api)) != NO_Si2168_ERROR) {   /* PowerUp into bootloader */
+        SiTRACE ("Si2168_PowerUpWithPatch error 0x%02x: %s\n", return_code, Si2168_L1_API_ERROR_TEXT((unsigned char)return_code) );
+        return return_code;
+    }
+    SiTRACE("Si2168_Init complete...\n");
+    return NO_Si2168_ERROR;
+}
+/************************************************************************************************************************
+  Si2168_Media function
+  Use:        media retrieval function
+              Used to retrieve the media used by the Si2168
+************************************************************************************************************************/
+int  Si2168_Media              (L1_Si2168_Context *api, int modulation)
+{
+  switch (modulation) {
+    default             :
+    case Si2168_DD_MODE_PROP_MODULATION_AUTO_DETECT : {
+      switch (api->prop->dd_mode.auto_detect) {
+        default             :
+        case Si2168_DD_MODE_PROP_AUTO_DETECT_AUTO_DVB_T_T2     : return Si2168_TERRESTRIAL; break;
+      }
+    }
+    case Si2168_DD_MODE_PROP_MODULATION_DVBT :
+    case Si2168_DD_MODE_PROP_MODULATION_DVBT2:
+    case Si2168_DD_MODE_PROP_MODULATION_DVBC : return Si2168_TERRESTRIAL; break;
+  }
+  SiERROR("UNKNOWW media!\n");
+  return 0;
+}
+/************************************************************************************************************************
+  Si2168_L2_switch_to_standard function
+  Use:      Standard switching function selection
+            Used to switch nicely to the wanted standard, taking into account the previous state
+  Parameter: new_standard the wanted standard to switch to
+  Behavior: This function positions a set of flags to easily decide what needs to be done to
+              switch between standards.
+************************************************************************************************************************/
+int  Si2168_L2_switch_to_standard (Si2168_L2_Context *front_end, int new_standard, unsigned char force_full_init)
+{
+  /* previous state flags */
+  int dtv_demod_already_used = 0;
+  int ter_tuner_already_used = 0;
+  int ter_clock_already_used = 0;
+  /* new state flags      */
+  int dtv_demod_needed       = 0;
+  int ter_tuner_needed       = 0;
+  int ter_clock_needed       = 0;
+  int dtv_demod_sleep_request= 0;
+  int res;
+
+#ifdef    PROFILING
+  int start;
+  int ter_tuner_delay   = 0;
+  int dtv_demod_delay   = 0;
+  int switch_start;
+  char sequence[100];
+  #define TER_DELAY  ter_tuner_delay=ter_tuner_delay+system_time()-start;start=system_time();
+  #define DTV_DELAY  dtv_demod_delay=dtv_demod_delay+system_time()-start;start=system_time();
+#else
+  #define TER_DELAY
+  #define DTV_DELAY
+#endif /* PROFILING */
+
+#ifdef    PROFILING
+  start = switch_start = system_time();
+  SiTRACE("%s->%s\n", Si2168_standardName(front_end->previous_standard), Si2168_standardName(new_standard) );
+#endif /* PROFILING */
+
+  SiTRACE("Si2168_switch_to_standard starting...\n");
+  SiTRACE("starting with Si2168_init_done %d, first_init_done     %d ", front_end->Si2168_init_done, front_end->first_init_done);
+  SiTRACE("TER flags:    TER_init_done    %d, TER_tuner_init_done %d ", front_end->TER_init_done, front_end->TER_tuner_init_done);
+
+  /* In this function is called for the first time, force a full init */
+  if (front_end->first_init_done == 0) {force_full_init = 1;}
+  /* ------------------------------------------------------------ */
+  /* Set Previous Flags                                           */
+  /* Setting flags representing the previous state                */
+  /* NB: Any value not matching a known standard will init as ATV */
+  /* Logic applied:                                               */
+  /*  dtv demod was used for TERRESTRIAL and SATELLITE reception  */
+  /*  ter tuner was used for TERRESTRIAL reception                */
+  /*   and for SATELLITE reception if it is the SAT clock source  */
+  /*  sat tuner was used for SATELLITE reception                  */
+  /*   and for TERRESTRIAL reception if it is the TER clock source*/
+  /* ------------------------------------------------------------ */
+  switch (front_end->previous_standard) {
+    case Si2168_DD_MODE_PROP_MODULATION_DVBT :
+    case Si2168_DD_MODE_PROP_MODULATION_DVBT2:
+    case Si2168_DD_MODE_PROP_MODULATION_DVBC : {
+      dtv_demod_already_used = 1;
+      ter_tuner_already_used = 1;
+      if ( Si2168_TER_CLOCK_SOURCE == Si2168_TER_Tuner_clock) {
+        ter_clock_already_used = 1;
+      }
+      break;
+    }
+    case Si2168_DD_MODE_PROP_MODULATION_ANALOG: {
+      ter_tuner_already_used = 1;
+    }
+    default : /* SLEEP */   {
+      ter_tuner_already_used = 0;
+      break;
+    }
+  }
+
+  /* ------------------------------------------------------------ */
+  /* Set Needed Flags                                             */
+  /* Setting flags representing the new state                     */
+  /* Logic applied:                                               */
+  /*  dtv demod is needed for TERRESTRIAL and SATELLITE reception */
+  /*  ter tuner is needed for TERRESTRIAL reception               */
+  /*   and for SATELLITE reception if it is the SAT clock source  */
+  /*  sat tuner is needed for SATELLITE reception                 */
+  /*   and for TERRESTRIAL reception if it is the TER clock source*/
+  /* ------------------------------------------------------------ */
+  switch (new_standard) {
+    case Si2168_DD_MODE_PROP_MODULATION_DVBT :
+    case Si2168_DD_MODE_PROP_MODULATION_DVBT2:
+    case Si2168_DD_MODE_PROP_MODULATION_DVBC : {
+      dtv_demod_needed = 1;
+      ter_tuner_needed = 1;
+      if ( Si2168_TER_CLOCK_SOURCE == Si2168_TER_Tuner_clock) {
+        ter_clock_needed = 1;
+      }
+      break;
+    }
+    case Si2168_DD_MODE_PROP_MODULATION_ANALOG: {
+      ter_tuner_needed = 1;
+    }
+    default : /* SLEEP */   {
+      ter_tuner_needed = 0;
+      break;
+    }
+  }
+
+  /* ------------------------------------------------------------ */
+  /* if 'force' flag is set, set flags to trigger a full init     */
+  /* This can be used to re-init the NIM after a power cycle      */
+  /*  or a HW reset                                               */
+  /* ------------------------------------------------------------ */
+  if (force_full_init) {
+    SiTRACE("Forcing full init\n");
+    /* set 'init_done' flags to force full init     */
+    front_end->first_init_done     = 0;
+    front_end->Si2168_init_done    = 0;
+    front_end->TER_init_done       = 0;
+    front_end->TER_tuner_init_done = 0;
+    /* set 'already used' flags to force full init  */
+    ter_tuner_already_used = 0;
+    dtv_demod_already_used = 0;
+  }
+
+  /* ------------------------------------------------------------ */
+  /* Request demodulator sleep if its clock will be stopped       */
+  /* ------------------------------------------------------------ */
+  if ((ter_clock_already_used == 1) & (ter_clock_needed == 0) ) { SiTRACE("TER clock 1->0 "); dtv_demod_sleep_request = 1; }
+  if ((ter_clock_already_used == 0) & (ter_clock_needed == 1) ) { SiTRACE("TER clock 0->1 "); dtv_demod_sleep_request = 1; }
+  /* ------------------------------------------------------------ */
+  /* Request demodulator sleep if transition from '1' to '0'      */
+  /* ------------------------------------------------------------ */
+  if ((dtv_demod_already_used == 1) & (dtv_demod_needed == 0) ) { dtv_demod_sleep_request = 1; }
+  SiTRACE("dtv_demod_already_used %d, dtv_demod_needed %d, dtv_demod_sleep_request %d\n", dtv_demod_already_used , dtv_demod_needed, dtv_demod_sleep_request);
+  /* ------------------------------------------------------------ */
+  /* Sleep dtv demodulator if requested                           */
+  /* ------------------------------------------------------------ */
+  if (dtv_demod_sleep_request == 1) {
+    SiTRACE("Sleep DTV demod\n");
+    Si2168_STANDBY (front_end->demod);
+    DTV_DELAY
+  }
+
+  /* ------------------------------------------------------------ */
+  /* Set media for new standard                                   */
+  /* ------------------------------------------------------------ */
+  front_end->demod->prop->dd_mode.modulation = (unsigned char)new_standard;
+  front_end->demod->media = Si2168_Media(front_end->demod, front_end->demod->prop->dd_mode.modulation);
+
+  /* ------------------------------------------------------------ */
+  /* Allow i2c traffic to reach the tuners                        */
+  /* ------------------------------------------------------------ */
+  SiTRACE("Connect    tuners i2c\n");
+  Si2168_L2_Tuner_I2C_Enable(front_end);
+  DTV_DELAY
+
+  /* ------------------------------------------------------------ */
+  /* Sleep Ter Tuner                                              */
+  /* Sleep terrestrial tuner  if transition from '1' to '0'       */
+  /* ------------------------------------------------------------ */
+  if ((ter_tuner_already_used == 1) & (ter_tuner_needed == 0) ) {
+    SiTRACE("Sleep terrestrial tuner\n");
+    #ifdef    TER_TUNER_CLOCK_OFF
+    SiTRACE("Terrestrial tuner clock OFF\n");
+    if ((res= TER_TUNER_CLOCK_OFF(front_end->tuner_ter)) !=0 ) {
+      SiTRACE("Terrestrial tuner CLOCK OFF error: 0x%02x : %s\n",res, TER_TUNER_ERROR_TEXT((unsigned char)res) );
+      SiERROR("Terrestrial tuner CLOCK OFF error!\n");
+      return 0;
+    };
+    #endif /* TER_TUNER_CLOCK_OFF */
+    #ifdef    TER_TUNER_STANDBY
+    SiTRACE("Terrestrial tuner STANDBY\n");
+    if ((res= TER_TUNER_STANDBY(front_end->tuner_ter)) !=0 ) {
+      SiTRACE("Terrestrial tuner Standby error: 0x%02x : %s\n",res, TER_TUNER_ERROR_TEXT((unsigned char)res) );
+      SiERROR("Terrestrial tuner Standby error!\n");
+      return 0;
+    };
+    #endif /* TER_TUNER_STANDBY */
+    TER_DELAY
+  }
+
+
+  /* ------------------------------------------------------------ */
+  /* Wakeup Ter Tuner                                             */
+  /* Wake up terrestrial tuner if transition from '0' to '1'      */
+  /* ------------------------------------------------------------ */
+  if ((ter_tuner_already_used == 0) & (ter_tuner_needed == 1)) {
+    /* Do a full init of the Ter Tuner only if it has not been already done */
+    if (front_end->TER_tuner_init_done==0) {
+      SiTRACE("Init terrestrial tuner\n");
+      #ifdef    TER_TUNER_INIT
+      if ((res= TER_TUNER_INIT(front_end->tuner_ter)) !=0) {
+        #ifdef    TER_TUNER_ERROR_TEXT
+        SiTRACE("Terrestrial tuner HW init error: 0x%02x : %s\n",res, TER_TUNER_ERROR_TEXT((unsigned char)res) );
+        #endif /* TER_TUNER_ERROR_TEXT */
+        SiERROR("Terrestrial tuner HW init error!\n");
+        return 0;
+      };
+      #endif /* TER_TUNER_INIT */
+      front_end->TER_tuner_init_done++;
+    } else {
+      SiTRACE("Wakeup terrestrial tuner\n");
+      #ifdef    TER_TUNER_WAKEUP
+      if ((res= TER_TUNER_WAKEUP(front_end->tuner_ter)) !=0) {
+        SiTRACE("Terrestrial tuner wake up error: 0x%02x : %s\n",res, TER_TUNER_ERROR_TEXT((unsigned char)res) );
+        SiERROR("Terrestrial tuner wake up error!\n");
+        return 0;
+      };
+      #endif /* TER_TUNER_WAKEUP */
+    }
+    TER_DELAY
+  }
+    /* ------------------------------------------------------------ */
+    /* If the terrestrial tuner's clock is required, activate it    */
+    /* ------------------------------------------------------------ */
+  SiTRACE("ter_clock_needed %d\n",ter_clock_needed);
+  if (ter_clock_needed) {
+    SiTRACE("Turn terrestrial tuner clock on\n");
+    #ifdef    TER_TUNER_CLOCK_ON
+    SiTRACE("Terrestrial tuner CLOCK ON\n");
+    if ((res= TER_TUNER_CLOCK_ON(front_end->tuner_ter) ) !=0) {
+      SiTRACE("Terrestrial tuner CLOCK ON error: 0x%02x : %s\n",res, TER_TUNER_ERROR_TEXT((unsigned char)res) );
+      SiERROR("Terrestrial tuner CLOCK ON error!\n");
+      return 0;
+    };
+    #endif /* TER_TUNER_CLOCK_ON */
+    TER_DELAY
+  }
+  if ((front_end->previous_standard != new_standard) & (dtv_demod_needed == 0) & (front_end->demod->media == Si2168_TERRESTRIAL)) {
+   if (front_end->demod->media == Si2168_TERRESTRIAL) {
+    #ifdef    TER_TUNER_ATV_LO_INJECTION
+     TER_TUNER_ATV_LO_INJECTION(front_end->tuner_ter);
+    #endif /* TER_TUNER_ATV_LO_INJECTION */
+
+  }
+ }
+
+  /* ------------------------------------------------------------ */
+  /* Change Dtv Demod standard if required                        */
+  /* ------------------------------------------------------------ */
+  if ((front_end->previous_standard != new_standard) & (dtv_demod_needed == 1)) {
+    SiTRACE("Store demod standard (%d)\n", new_standard);
+    front_end->demod->standard = new_standard;
+    DTV_DELAY
+    /* Set flag to trigger Si2168 init or re_init, to complete    */
+    /*  the standard change                                       */
+    dtv_demod_already_used = 0;
+    if (front_end->demod->media == Si2168_TERRESTRIAL) {
+    #ifdef    TER_TUNER_DTV_LO_INJECTION
+     TER_TUNER_DTV_LO_INJECTION(front_end->tuner_ter);
+    #endif /* TER_TUNER_DTV_LO_INJECTION */
+    }
+  }
+
+  /* ------------------------------------------------------------ */
+  /* Wakeup Dtv Demod                                             */
+  /*  if it has been put in 'standby mode' and is needed          */
+  /* ------------------------------------------------------------ */
+  if (front_end->Si2168_init_done) {
+    SiTRACE("dtv_demod_sleep_request %d\n",dtv_demod_sleep_request);
+    if ((dtv_demod_sleep_request == 1) & (dtv_demod_needed == 1) ) {
+      SiTRACE("Wake UP DTV demod\n");
+      if (Si2168_WAKEUP (front_end->demod) == NO_Si2168_ERROR) {
+        SiTRACE("Wake UP DTV demod OK\n");
+      } else {
+        SiERROR("Wake UP DTV demod failed!\n");
+        SiTRACE("Wake UP DTV demod failed!\n");
+        return 0;
+      }
+    }
+  }
+  /* ------------------------------------------------------------ */
+  /* Setup Dtv Demod                                              */
+  /* Setup dtv demodulator if transition from '0' to '1'          */
+  /* ------------------------------------------------------------ */
+  if ((dtv_demod_already_used == 0)       & (dtv_demod_needed == 1)) {
+    /* Do the 'first init' only the first time, plus if requested  */
+    /* (when 'force' flag is 1, Si2168_init_done is set to '0')   */
+    if (!front_end->Si2168_init_done) {
+      SiTRACE("Init demod\n");
+      if (Si2168_Init(front_end->demod) == NO_Si2168_ERROR) {
+        front_end->Si2168_init_done = 1;
+        SiTRACE("Demod init OK\n");
+      } else {
+        SiTRACE("Demod init failed!\n");
+        SiERROR("Demod init failed!\n");
+        return 0;
+      }
+    }
+    if (front_end->demod->media == Si2168_TERRESTRIAL) {
+      SiTRACE("front_end->demod->media Si2168_TERRESTRIAL\n");
+      if (front_end->TER_init_done == 0) {
+        SiTRACE("Configure demod for TER\n");
+        if (Si2168_Configure(front_end->demod) == NO_Si2168_ERROR) {
+          /* set dd_mode.modulation again, as it is overwritten by Si2168_Configure */
+          front_end->demod->prop->dd_mode.modulation = (unsigned char)new_standard;
+          /* set dd_mode.invert_spectrum again, as it is overwritten by Si2168_Configure */
+          front_end->demod->prop->dd_mode.invert_spectrum = Si2168_DD_MODE_PROP_INVERT_SPECTRUM_NORMAL;
+          front_end->TER_init_done = 1;
+        } else {
+          SiTRACE("Demod TER configuration failed !\n");
+          SiERROR("Demod TER configuration failed !\n");
+          return 0;
+        }
+      }
+      DTV_DELAY
+      /* ------------------------------------------------------------ */
+      /* Manage FEF mode in TER tuner                                 */
+      /* ------------------------------------------------------------ */
+      if (new_standard == Si2168_DD_MODE_PROP_MODULATION_DVBT2) {
+        Si2168_L2_TER_FEF_SETUP (front_end, 1);
+      } else {
+        Si2168_L2_TER_FEF_SETUP (front_end, 0);
+      }
+      TER_DELAY
+    }
+    if (Si2168_L1_SetProperty2(front_end->demod, Si2168_DD_MODE_PROP_CODE)==0) {
+      Si2168_L1_DD_RESTART(front_end->demod);
+    } else {
+      SiTRACE("Demod restart failed !\n");
+      return 0;
+    }
+    DTV_DELAY
+  }
+
+  /* ------------------------------------------------------------ */
+  /* Forbid i2c traffic to reach the tuners                       */
+  /* ------------------------------------------------------------ */
+  SiTRACE("Disconnect tuners i2c\n");
+  Si2168_L2_Tuner_I2C_Disable(front_end);
+  DTV_DELAY
+
+  /* ------------------------------------------------------------ */
+  /* update value of previous_standard to prepare next call       */
+  /* ------------------------------------------------------------ */
+  front_end->previous_standard = new_standard;
+  front_end->demod->standard   = new_standard;
+
+  front_end->first_init_done = 1;
+#ifdef    PROFILING
+  sprintf(sequence,"%s","");
+  sprintf(sequence,"%s| TER: %4d ms ", sequence, ter_tuner_delay);
+  sprintf(sequence,"%s| DTV: %4d ms ", sequence, dtv_demod_delay);
+  sprintf(sequence,"%s| (%5d ms) ",    sequence, system_time()-switch_start);
+  SiTRACE("%s\n", sequence);
+#endif /* PROFILING */
+
+  SiTRACE("Si2168_switch_to_standard complete\n");
+  return 1;
+}
+
+/************************************************************************************************************************
+  SiLabs_API_switch_to_standard function
+  Use:      Standard switching function selection
+            Used to switch nicely to the wanted standard, taking into account the previous state
+  Parameter: new_standard the wanted standard to switch to
+  Return:    1 if sucessful, 0 otherwise
+************************************************************************************************************************/
+int   SiLabs_API_switch_to_standard       (SILABS_FE_Context *front_end, int standard, unsigned char force_full_init)
+{
+  front_end->init_ok = 0;
+  SiTRACE("Wrapper switching to %s\n", Silabs_Standard_Text((CUSTOM_Standard_Enum)standard) );
+#ifdef    Si2168_COMPATIBLE
+  if (front_end->chip ==   2168 ) { front_end->init_ok = Si2168_L2_switch_to_standard (front_end->Si2168_FE , Silabs_standardCode(front_end, (CUSTOM_Standard_Enum)standard), force_full_init);}
+#endif /* Si2168_COMPATIBLE */
+  if (front_end->init_ok == 0) {
+    SiTRACE("Problem switching to %s\n", Silabs_Standard_Text((CUSTOM_Standard_Enum)standard));
+  } else {
+    front_end->standard = standard;
+  }
+  return front_end->init_ok;
+}
+
+/////////////////////////////////////////////////////////////////////////////////
+void Si2168_setupCOMMONDefaults     (L1_Si2168_Context *api)
+{
+  SiTRACE("Si2168_setupCOMMONDefaults    \n");
+  api->prop->master_ien.ddien                       = Si2168_MASTER_IEN_PROP_DDIEN_OFF   ; /* (default 'OFF') */
+  api->prop->master_ien.scanien                     = Si2168_MASTER_IEN_PROP_SCANIEN_OFF ; /* (default 'OFF') */
+  api->prop->master_ien.errien                      = Si2168_MASTER_IEN_PROP_ERRIEN_OFF  ; /* (default 'OFF') */
+  api->prop->master_ien.ctsien                      = Si2168_MASTER_IEN_PROP_CTSIEN_OFF  ; /* (default 'OFF') */
+
+}
+
+void Si2168_setupDDDefaults         (L1_Si2168_Context *api)
+{
+  SiTRACE("Si2168_setupDDDefaults        \n");
+  api->prop->dd_ber_resol.exp                       =     7; /* (default     7) */
+  api->prop->dd_ber_resol.mant                      =     1; /* (default     1) */
+
+  api->prop->dd_cber_resol.exp                      =     5; /* (default     5) */
+  api->prop->dd_cber_resol.mant                     =     1; /* (default     1) */
+
+
+  api->prop->dd_fer_resol.exp                       =     2; /* (default     3) */
+  api->prop->dd_fer_resol.mant                      =     1; /* (default     1) */
+
+  api->prop->dd_ien.ien_bit0                        = Si2168_DD_IEN_PROP_IEN_BIT0_DISABLE ; /* (default 'DISABLE') */
+  api->prop->dd_ien.ien_bit1                        = Si2168_DD_IEN_PROP_IEN_BIT1_DISABLE ; /* (default 'DISABLE') */
+  api->prop->dd_ien.ien_bit2                        = Si2168_DD_IEN_PROP_IEN_BIT2_ENABLE  ; /* (default 'DISABLE') Used for DVB-T/T2 'LOCK'       */
+  api->prop->dd_ien.ien_bit3                        = Si2168_DD_IEN_PROP_IEN_BIT3_DISABLE ; /* (default 'DISABLE') */
+  api->prop->dd_ien.ien_bit4                        = Si2168_DD_IEN_PROP_IEN_BIT4_DISABLE ; /* (default 'DISABLE') */
+  api->prop->dd_ien.ien_bit5                        = Si2168_DD_IEN_PROP_IEN_BIT5_ENABLE  ; /* (default 'DISABLE') Used for DVB-T/T2 'NO_CHANNEL' */
+  api->prop->dd_ien.ien_bit6                        = Si2168_DD_IEN_PROP_IEN_BIT6_DISABLE ; /* (default 'DISABLE') */
+  api->prop->dd_ien.ien_bit7                        = Si2168_DD_IEN_PROP_IEN_BIT7_DISABLE ; /* (default 'DISABLE') */
+
+  api->prop->dd_if_input_freq.offset                =  5000; /* (default  5000) */
+
+  api->prop->dd_int_sense.neg_bit0                  = Si2168_DD_INT_SENSE_PROP_NEG_BIT0_DISABLE ; /* (default 'DISABLE') */
+  api->prop->dd_int_sense.neg_bit1                  = Si2168_DD_INT_SENSE_PROP_NEG_BIT1_DISABLE ; /* (default 'DISABLE') */
+  api->prop->dd_int_sense.neg_bit2                  = Si2168_DD_INT_SENSE_PROP_NEG_BIT2_DISABLE ; /* (default 'DISABLE') */
+  api->prop->dd_int_sense.neg_bit3                  = Si2168_DD_INT_SENSE_PROP_NEG_BIT3_DISABLE ; /* (default 'DISABLE') */
+  api->prop->dd_int_sense.neg_bit4                  = Si2168_DD_INT_SENSE_PROP_NEG_BIT4_DISABLE ; /* (default 'DISABLE') */
+  api->prop->dd_int_sense.neg_bit5                  = Si2168_DD_INT_SENSE_PROP_NEG_BIT5_DISABLE ; /* (default 'DISABLE') */
+  api->prop->dd_int_sense.neg_bit6                  = Si2168_DD_INT_SENSE_PROP_NEG_BIT6_DISABLE ; /* (default 'DISABLE') */
+  api->prop->dd_int_sense.neg_bit7                  = Si2168_DD_INT_SENSE_PROP_NEG_BIT7_DISABLE ; /* (default 'DISABLE') */
+  api->prop->dd_int_sense.pos_bit0                  = Si2168_DD_INT_SENSE_PROP_POS_BIT0_DISABLE ; /* (default 'DISABLE') */
+  api->prop->dd_int_sense.pos_bit1                  = Si2168_DD_INT_SENSE_PROP_POS_BIT1_DISABLE ; /* (default 'DISABLE') */
+  api->prop->dd_int_sense.pos_bit2                  = Si2168_DD_INT_SENSE_PROP_POS_BIT2_ENABLE  ; /* (default 'DISABLE') Sense DVB-T/T2 'LOCK'       changes from '0' to '1' */
+  api->prop->dd_int_sense.pos_bit3                  = Si2168_DD_INT_SENSE_PROP_POS_BIT3_DISABLE ; /* (default 'DISABLE') */
+  api->prop->dd_int_sense.pos_bit4                  = Si2168_DD_INT_SENSE_PROP_POS_BIT4_DISABLE ; /* (default 'DISABLE') */
+  api->prop->dd_int_sense.pos_bit5                  = Si2168_DD_INT_SENSE_PROP_POS_BIT5_ENABLE  ; /* (default 'DISABLE') Sense DVB-T/T2 'NO_CHANNEL' changes from '0' to '1' */
+  api->prop->dd_int_sense.pos_bit6                  = Si2168_DD_INT_SENSE_PROP_POS_BIT6_DISABLE ; /* (default 'DISABLE') */
+  api->prop->dd_int_sense.pos_bit7                  = Si2168_DD_INT_SENSE_PROP_POS_BIT7_DISABLE ; /* (default 'DISABLE') */
+
+  api->prop->dd_mode.bw                             = Si2168_DD_MODE_PROP_BW_BW_8MHZ              ; /* (default 'BW_8MHZ') */
+  api->prop->dd_mode.modulation                     = Si2168_DD_MODE_PROP_MODULATION_DVBT         ; /* (default 'DVBT') */
+  api->prop->dd_mode.invert_spectrum                = Si2168_DD_MODE_PROP_INVERT_SPECTRUM_NORMAL  ; /* (default 'NORMAL') */
+  api->prop->dd_mode.auto_detect                    = Si2168_DD_MODE_PROP_AUTO_DETECT_NONE        ; /* (default 'NONE') */
+
+  api->prop->dd_per_resol.exp                       =     5; /* (default     5) */
+  api->prop->dd_per_resol.mant                      =     1; /* (default     1) */
+
+  api->prop->dd_rsq_ber_threshold.exp               =     1; /* (default     1) */
+  api->prop->dd_rsq_ber_threshold.mant              =    10; /* (default    10) */
+
+  api->prop->dd_ts_freq.req_freq_10khz              =   760; /* (default   720) */
+
+  if(api->ts_bus_mode == SILABS_TS_SERIAL) {
+  	api->prop->dd_ts_mode.mode = Si2168_DD_TS_MODE_PROP_MODE_SERIAL;
+  	SiTRACE("Si2168_setupDDDefaults,   Si2168_DD_TS_MODE_PROP_MODE_SERIAL\n");
+  } else if(api->ts_bus_mode == SILABS_TS_PARALLEL) {
+  	api->prop->dd_ts_mode.mode = Si2168_DD_TS_MODE_PROP_MODE_PARALLEL;
+  	SiTRACE("Si2168_setupDDDefaults,   Si2168_DD_TS_MODE_PROP_MODE_PARALLEL\n");
+  } else {
+  	api->prop->dd_ts_mode.mode = Si2168_DD_TS_MODE_PROP_MODE_TRISTATE;
+  	SiTRACE("Si2168_setupDDDefaults,   Si2168_DD_TS_MODE_PROP_MODE_TRISTATE\n");
+  }
+  if(api->ts_clock_mode == 1)
+  	api->prop->dd_ts_mode.clock                       = Si2168_DD_TS_MODE_PROP_CLOCK_MANUAL;
+  else
+  	api->prop->dd_ts_mode.clock                       = Si2168_DD_TS_MODE_PROP_CLOCK_AUTO_ADAPT;
+
+  api->prop->dd_ts_mode.clk_gapped_en               = Si2168_DD_TS_MODE_PROP_CLK_GAPPED_EN_DISABLED;  
+  api->prop->dd_ts_mode.ts_err_polarity             = Si2168_DD_TS_MODE_PROP_TS_ERR_POLARITY_NOT_INVERTED ; /* (default 'NOT_INVERTED') */
+  api->prop->dd_ts_mode.special                     = Si2168_DD_TS_MODE_PROP_SPECIAL_FULL_TS              ; /* (default 'FULL_TS') */
+
+  api->prop->dd_ts_setup_par.ts_data_strength       =     15;//3; /* (default     3) */
+  api->prop->dd_ts_setup_par.ts_data_shape          =     3;//2; /* (default     1) */
+  api->prop->dd_ts_setup_par.ts_clk_strength        =     15;//3; /* (default     3) */
+  api->prop->dd_ts_setup_par.ts_clk_shape           =     3;//2; /* (default     1) */
+  api->prop->dd_ts_setup_par.ts_clk_invert          = Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_INVERTED    ; /* (default 'INVERTED') */
+  api->prop->dd_ts_setup_par.ts_clk_shift           =     0; /* (default     0) */
+
+  api->prop->dd_ts_setup_ser.ts_data_strength       =     15;//3; /* (default    15) */
+  api->prop->dd_ts_setup_ser.ts_data_shape          =     3;//1; /* (default     3) */
+  api->prop->dd_ts_setup_ser.ts_clk_strength        =     15;//3; /* (default    15) */
+  api->prop->dd_ts_setup_ser.ts_clk_shape           =     3;//1; /* (default     3) */
+  api->prop->dd_ts_setup_ser.ts_clk_invert          = Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_INVERTED      ; /* (default 'INVERTED') */
+  api->prop->dd_ts_setup_ser.ts_sync_duration       = Si2168_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_FIRST_BIT; /* (default 'FIRST_BYTE') */
+  api->prop->dd_ts_setup_ser.ts_byte_order          = Si2168_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_MSB_FIRST     ; /* (default 'MSB_FIRST') */
+
+}
+
+void Si2168_setupDVBCDefaults       (L1_Si2168_Context *api)
+{
+  SiTRACE("Si2168_setupDVBCDefaults      \n");
+  api->prop->dvbc_adc_crest_factor.crest_factor     =   112; /* (default   112) */
+
+  api->prop->dvbc_afc_range.range_khz               =   100; /* (default   100) */
+
+  api->prop->dvbc_constellation.constellation       = Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_AUTO ; /* (default 'AUTO') */
+
+  api->prop->dvbc_symbol_rate.rate                  =  6900; /* (default  6900) */
+
+}
+
+void Si2168_setupDVBTDefaults       (L1_Si2168_Context *api)
+{
+  SiTRACE("Si2168_setupDVBTDefaults      \n");
+  api->prop->dvbt_adc_crest_factor.crest_factor     =   130; /* (default   130) */
+
+  api->prop->dvbt_afc_range.range_khz               =   550; /* (default   550) */
+
+  api->prop->dvbt_hierarchy.stream                  = Si2168_DVBT_HIERARCHY_PROP_STREAM_HP ; /* (default 'HP') */
+
+}
+
+void Si2168_setupDVBT2Defaults      (L1_Si2168_Context *api)
+{
+  SiTRACE("Si2168_setupDVBT2Defaults     \n");
+  api->prop->dvbt2_adc_crest_factor.crest_factor    =   130; /* (default   130) */
+
+  api->prop->dvbt2_afc_range.range_khz              =   550; /* (default   550) */
+
+  api->prop->dvbt2_fef_tuner.tuner_delay            =     1; /* (default     1) */
+  api->prop->dvbt2_fef_tuner.tuner_freeze_time      =     1; /* (default     1) */
+  api->prop->dvbt2_fef_tuner.tuner_unfreeze_time    =     1; /* (default     1) */
+
+}
+
+
+void Si2168_setupSCANDefaults       (L1_Si2168_Context *api)
+{
+  SiTRACE("Si2168_setupSCANDefaults      \n");
+  api->prop->scan_fmax.scan_fmax                    =     0; /* (default     0) */
+
+  api->prop->scan_fmin.scan_fmin                    =     0; /* (default     0) */
+
+  api->prop->scan_ien.buzien                        = Si2168_SCAN_IEN_PROP_BUZIEN_DISABLE ; /* (default 'DISABLE') */
+  api->prop->scan_ien.reqien                        = Si2168_SCAN_IEN_PROP_REQIEN_DISABLE ; /* (default 'DISABLE') */
+
+  api->prop->scan_int_sense.buznegen                = Si2168_SCAN_INT_SENSE_PROP_BUZNEGEN_ENABLE  ; /* (default 'ENABLE') */
+  api->prop->scan_int_sense.reqnegen                = Si2168_SCAN_INT_SENSE_PROP_REQNEGEN_DISABLE ; /* (default 'DISABLE') */
+  api->prop->scan_int_sense.buzposen                = Si2168_SCAN_INT_SENSE_PROP_BUZPOSEN_DISABLE ; /* (default 'DISABLE') */
+  api->prop->scan_int_sense.reqposen                = Si2168_SCAN_INT_SENSE_PROP_REQPOSEN_ENABLE  ; /* (default 'ENABLE') */
+
+
+  api->prop->scan_symb_rate_max.scan_symb_rate_max  =     0; /* (default     0) */
+
+  api->prop->scan_symb_rate_min.scan_symb_rate_min  =     0; /* (default     0) */
+
+  api->prop->scan_ter_config.mode                   = Si2168_SCAN_TER_CONFIG_PROP_MODE_BLIND_SCAN          ; /* (default 'BLIND_SCAN') */
+  api->prop->scan_ter_config.analog_bw              = Si2168_SCAN_TER_CONFIG_PROP_ANALOG_BW_8MHZ           ; /* (default '8MHZ') */
+  api->prop->scan_ter_config.search_analog          = Si2168_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_DISABLE    ; /* (default 'DISABLE') */
+}
+
+void Si2168_setupAllDefaults       (L1_Si2168_Context *api)
+{
+  Si2168_setupCOMMONDefaults    (api);
+  Si2168_setupDDDefaults        (api);
+  Si2168_setupDVBCDefaults      (api);
+
+
+  Si2168_setupDVBTDefaults      (api);
+
+  Si2168_setupDVBT2Defaults     (api);
+
+  Si2168_setupSCANDefaults      (api);
+}
+
+ /*****************************************************************************************
+ NAME: Si2168_downloadCOMMONProperties
+  DESCRIPTION: Setup Si2168 COMMON properties configuration
+  This function will download all the COMMON configuration properties.
+  The function SetupCOMMONDefaults() should be called before the first call to this function.
+  Parameter:  Pointer to Si2168 Context
+  Returns:    I2C transaction error code, NO_Si2168_ERROR if successful
+  Programming Guide Reference:    COMMON setup flowchart
+******************************************************************************************/
+int  Si2168_downloadCOMMONProperties(L1_Si2168_Context *api)
+{
+  SiTRACE("Si2168_downloadCOMMONProperties      \n");
+#ifdef    Si2168_MASTER_IEN_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_MASTER_IEN_PROP_CODE            ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_MASTER_IEN_PROP */
+return NO_Si2168_ERROR;
+}
+ /*****************************************************************************************
+ NAME: Si2168_downloadDDProperties
+  DESCRIPTION: Setup Si2168 DD properties configuration
+  This function will download all the DD configuration properties.
+  The function SetupDDDefaults() should be called before the first call to this function.
+  Parameter:  Pointer to Si2168 Context
+  Returns:    I2C transaction error code, NO_Si2168_ERROR if successful
+  Programming Guide Reference:    DD setup flowchart
+******************************************************************************************/
+int  Si2168_downloadDDProperties(L1_Si2168_Context *api)
+{
+  SiTRACE("Si2168_downloadDDProperties            \n");
+#ifdef    Si2168_DD_BER_RESOL_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_BER_RESOL_PROP_CODE          ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DD_BER_RESOL_PROP */
+#ifdef    Si2168_DD_CBER_RESOL_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_CBER_RESOL_PROP_CODE         ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DD_CBER_RESOL_PROP */
+
+#ifdef    Si2168_DD_FER_RESOL_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_FER_RESOL_PROP_CODE          ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DD_FER_RESOL_PROP */
+#ifdef    Si2168_DD_IEN_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_IEN_PROP_CODE                ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DD_IEN_PROP */
+#ifdef    Si2168_DD_IF_INPUT_FREQ_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_IF_INPUT_FREQ_PROP_CODE      ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DD_IF_INPUT_FREQ_PROP */
+#ifdef    Si2168_DD_INT_SENSE_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_INT_SENSE_PROP_CODE          ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DD_INT_SENSE_PROP */
+#ifdef    Si2168_DD_MODE_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_MODE_PROP_CODE               ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DD_MODE_PROP */
+#ifdef    Si2168_DD_PER_RESOL_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_PER_RESOL_PROP_CODE          ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DD_PER_RESOL_PROP */
+#ifdef    Si2168_DD_RSQ_BER_THRESHOLD_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_RSQ_BER_THRESHOLD_PROP_CODE  ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DD_RSQ_BER_THRESHOLD_PROP */
+#ifdef    Si2168_DD_TS_FREQ_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_TS_FREQ_PROP_CODE            ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DD_TS_FREQ_PROP */
+#ifdef    Si2168_DD_TS_MODE_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_TS_MODE_PROP_CODE            ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DD_TS_MODE_PROP */
+#ifdef    Si2168_DD_TS_SETUP_PAR_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_TS_SETUP_PAR_PROP_CODE       ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DD_TS_SETUP_PAR_PROP */
+#ifdef    Si2168_DD_TS_SETUP_SER_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DD_TS_SETUP_SER_PROP_CODE       ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DD_TS_SETUP_SER_PROP */
+return NO_Si2168_ERROR;
+}
+ /*****************************************************************************************
+ NAME: Si2168_downloadDVBCProperties
+  DESCRIPTION: Setup Si2168 DVBC properties configuration
+  This function will download all the DVBC configuration properties.
+  The function SetupDVBCDefaults() should be called before the first call to this function.
+  Parameter:  Pointer to Si2168 Context
+  Returns:    I2C transaction error code, NO_Si2168_ERROR if successful
+  Programming Guide Reference:    DVBC setup flowchart
+******************************************************************************************/
+int  Si2168_downloadDVBCProperties(L1_Si2168_Context *api)
+{
+  SiTRACE("Si2168_downloadDVBCProperties       \n");
+#ifdef    Si2168_DVBC_ADC_CREST_FACTOR_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DVBC_ADC_CREST_FACTOR_PROP_CODE ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DVBC_ADC_CREST_FACTOR_PROP */
+#ifdef    Si2168_DVBC_AFC_RANGE_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DVBC_AFC_RANGE_PROP_CODE        ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DVBC_AFC_RANGE_PROP */
+#ifdef    Si2168_DVBC_CONSTELLATION_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DVBC_CONSTELLATION_PROP_CODE    ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DVBC_CONSTELLATION_PROP */
+#ifdef    Si2168_DVBC_SYMBOL_RATE_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DVBC_SYMBOL_RATE_PROP_CODE      ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DVBC_SYMBOL_RATE_PROP */
+return NO_Si2168_ERROR;
+}
+ /*****************************************************************************************
+ NAME: Si2168_downloadDVBTProperties
+  DESCRIPTION: Setup Si2168 DVBT properties configuration
+  This function will download all the DVBT configuration properties.
+  The function SetupDVBTDefaults() should be called before the first call to this function.
+  Parameter:  Pointer to Si2168 Context
+  Returns:    I2C transaction error code, NO_Si2168_ERROR if successful
+  Programming Guide Reference:    DVBT setup flowchart
+******************************************************************************************/
+int  Si2168_downloadDVBTProperties(L1_Si2168_Context *api)
+{
+  SiTRACE("Si2168_downloadDVBTProperties     \n");
+#ifdef    Si2168_DVBT_ADC_CREST_FACTOR_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DVBT_ADC_CREST_FACTOR_PROP_CODE ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DVBT_ADC_CREST_FACTOR_PROP */
+#ifdef    Si2168_DVBT_AFC_RANGE_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DVBT_AFC_RANGE_PROP_CODE        ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DVBT_AFC_RANGE_PROP */
+#ifdef    Si2168_DVBT_HIERARCHY_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DVBT_HIERARCHY_PROP_CODE        ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DVBT_HIERARCHY_PROP */
+return NO_Si2168_ERROR;
+}
+ /*****************************************************************************************
+ NAME: Si2168_downloadDVBT2Properties
+  DESCRIPTION: Setup Si2168 DVBT2 properties configuration
+  This function will download all the DVBT2 configuration properties.
+  The function SetupDVBT2Defaults() should be called before the first call to this function.
+  Parameter:  Pointer to Si2168 Context
+  Returns:    I2C transaction error code, NO_Si2168_ERROR if successful
+  Programming Guide Reference:    DVBT2 setup flowchart
+******************************************************************************************/
+int  Si2168_downloadDVBT2Properties(L1_Si2168_Context *api)
+{
+  SiTRACE("Si2168_downloadDVBT2Properties        \n");
+#ifdef    Si2168_DVBT2_ADC_CREST_FACTOR_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DVBT2_ADC_CREST_FACTOR_PROP_CODE) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DVBT2_ADC_CREST_FACTOR_PROP */
+#ifdef    Si2168_DVBT2_AFC_RANGE_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DVBT2_AFC_RANGE_PROP_CODE       ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DVBT2_AFC_RANGE_PROP */
+#ifdef    Si2168_DVBT2_FEF_TUNER_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_DVBT2_FEF_TUNER_PROP_CODE       ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_DVBT2_FEF_TUNER_PROP */
+return NO_Si2168_ERROR;
+}
+ /*****************************************************************************************
+ NAME: Si2168_downloadSCANProperties
+  DESCRIPTION: Setup Si2168 SCAN properties configuration
+  This function will download all the SCAN configuration properties.
+  The function SetupSCANDefaults() should be called before the first call to this function.
+  Parameter:  Pointer to Si2168 Context
+  Returns:    I2C transaction error code, NO_Si2168_ERROR if successful
+  Programming Guide Reference:    SCAN setup flowchart
+******************************************************************************************/
+int  Si2168_downloadSCANProperties(L1_Si2168_Context *api)
+{
+  SiTRACE("Si2168_downloadSCANProperties       \n");
+#ifdef    Si2168_SCAN_FMAX_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_SCAN_FMAX_PROP_CODE             ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_SCAN_FMAX_PROP */
+#ifdef    Si2168_SCAN_FMIN_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_SCAN_FMIN_PROP_CODE             ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_SCAN_FMIN_PROP */
+#ifdef    Si2168_SCAN_IEN_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_SCAN_IEN_PROP_CODE              ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_SCAN_IEN_PROP */
+#ifdef    Si2168_SCAN_INT_SENSE_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_SCAN_INT_SENSE_PROP_CODE        ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_SCAN_INT_SENSE_PROP */
+
+#ifdef    Si2168_SCAN_SYMB_RATE_MAX_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_SCAN_SYMB_RATE_MAX_PROP_CODE    ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_SCAN_SYMB_RATE_MAX_PROP */
+#ifdef    Si2168_SCAN_SYMB_RATE_MIN_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_SCAN_SYMB_RATE_MIN_PROP_CODE    ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_SCAN_SYMB_RATE_MIN_PROP */
+#ifdef    Si2168_SCAN_TER_CONFIG_PROP
+  if (Si2168_L1_SetProperty2(api, Si2168_SCAN_TER_CONFIG_PROP_CODE       ) != NO_Si2168_ERROR) {return ERROR_Si2168_SENDING_COMMAND;}
+#endif /* Si2168_SCAN_TER_CONFIG_PROP */
+return NO_Si2168_ERROR;
+}
+////////////////////////////////////////////////////////////////////////////////
+int Si2168_downloadAllProperties       (L1_Si2168_Context *api)
+{
+  Si2168_downloadCOMMONProperties    (api);
+  Si2168_downloadDDProperties        (api);
+  if (api->media == Si2168_TERRESTRIAL) {
+  Si2168_downloadDVBCProperties      (api);
+  }
+
+
+  if (api->media == Si2168_TERRESTRIAL) {
+  Si2168_downloadDVBTProperties      (api);
+  }
+
+  if (api->media == Si2168_TERRESTRIAL) {
+  Si2168_downloadDVBT2Properties     (api);
+  }
+
+  Si2168_downloadSCANProperties      (api);
+  return 0;
+}
+
+/************************************************************************************************************************
+  Si2168_standardName function
+  Use:        standard text retrieval function
+              Used to retrieve the standard text used by the Si2168
+  Parameter:  standard, the value of the standard
+************************************************************************************************************************/
+char *Si2168_standardName (int standard)
+{
+  switch (standard)
+  {
+    case Si2168_DD_MODE_PROP_MODULATION_DVBT    : {return (char*)"DVB-T"  ;}
+    case Si2168_DD_MODE_PROP_MODULATION_DVBC    : {return (char*)"DVB-C"  ;}
+    case Si2168_DD_MODE_PROP_MODULATION_DVBT2   : {return (char*)"DVB-T2" ;}
+    default                                     : {return (char*)"UNKNOWN";}
+  }
+}
+
+/************************************************************************************************************************
+  Si2168_L2_Tune function
+  Use:        tuner current frequency retrieval function
+              Used to retrieve the current RF from the tuner's driver.
+  Porting:    Replace the internal TUNER function calls by the final tuner's corresponding calls
+  Comments:   If the tuner is connected via the demodulator's I2C switch, enabling/disabling the i2c_passthru is required before/after tuning.
+  Behavior:   This function closes the Si2168's I2C switch then tunes and finally reopens the I2C switch
+  Parameter:  *front_end, the front-end handle
+  Parameter:  rf, the frequency to tune at
+  Returns:    rf
+************************************************************************************************************************/
+int  Si2168_L2_Tune               (Si2168_L2_Context *front_end, int rf)
+{
+#ifdef    TUNERTER_API
+    char bw;
+    char modulation;
+#endif /* TUNERTER_API */
+
+    SiTRACE("Si2168_L2_Tune at %d\n",rf);
+
+    Si2168_L2_Tuner_I2C_Enable(front_end);
+
+    if (front_end->demod->media == Si2168_TERRESTRIAL) {
+      Si2168_L2_TER_FEF (front_end, 0);
+#ifdef    TUNERTER_API
+      if (front_end->demod->prop->dd_mode.modulation == Si2168_DD_MODE_PROP_MODULATION_DVBC ) {
+        modulation = L1_RF_TER_TUNER_MODULATION_DVBC;
+        bw         = 8;
+      } else {
+        modulation = L1_RF_TER_TUNER_MODULATION_DVBT;
+        switch (front_end->demod->prop->dd_mode.bw) {
+          case Si2168_DD_MODE_PROP_BW_BW_1D7MHZ   : bw = 6; break;
+          case Si2168_DD_MODE_PROP_BW_BW_5MHZ     : bw = 6; break;
+          case Si2168_DD_MODE_PROP_BW_BW_6MHZ     : bw = 6; break;
+          case Si2168_DD_MODE_PROP_BW_BW_7MHZ     : bw = 7; break;
+          case Si2168_DD_MODE_PROP_BW_BW_8MHZ     : bw = 8; break;
+          default: SiERROR("Invalid dd_mode.bw\n"); bw = 8; break;
+        }
+      }
+#endif /* TUNERTER_API */
+      L1_RF_TER_TUNER_Tune       (front_end->tuner_ter , rf);
+#ifdef    TUNERTER_API
+      if (front_end->demod->prop->dd_mode.modulation == Si2168_DD_MODE_PROP_MODULATION_DVBT2) { Si2168_L2_TER_FEF (front_end, 1); }
+#endif /* TUNERTER_API */
+    }
+
+
+    Si2168_L2_Tuner_I2C_Disable(front_end);
+
+    return rf;
+}
+
+/************************************************************************************************************************
+  Si2168_lock_to_carrier function
+  Use:      relocking function
+            Used to relock on a channel for the current standard
+  Parameter: standard the standard to lock to
+  Parameter: freq                the frequency to lock to (in Hz for TER, in kHz for SAT)
+  Parameter: dvb_t_bandwidth_hz  the channel bandwidth in Hz (only for DVB-T)
+  Parameter: dvb_t_stream        the HP/LP stream  (only for DVB-T)
+  Parameter: symbol_rate_bps     the symbol rate   (for DVB-S and SAT)
+  Parameter: dvb_c_constellation the DVB-C constellation (only for DVB-C)
+  Return:    1 if locked, 0 otherwise
+************************************************************************************************************************/
+int   Si2168_L2_lock_to_carrier   (Si2168_L2_Context *front_end, int standard, int freq, int dvb_t_bandwidth_hz, int dvb_t_stream, unsigned int symbol_rate_bps, int dvb_c_constellation, int dvb_t2_plp_id)
+{
+  int return_code;
+//  int searchStartTime;
+//  int searchDelay;
+  int lock;
+  int max_lock_time_ms;
+  int min_lock_time_ms;
+  u32 ulCount, ulTick, ulDelay;
+
+
+  SiTRACE ("relock to %s at %d\n", Si2168_standardName(standard), freq);
+
+
+  switch (standard)
+  {
+    case Si2168_DD_MODE_PROP_MODULATION_DVBT :
+    case Si2168_DD_MODE_PROP_MODULATION_DVBT2: {
+      front_end->demod->prop->dd_mode.bw                = dvb_t_bandwidth_hz/1000000;
+      if (front_end->auto_detect_TER) {
+        SiTRACE("DVB-T/T2 auto detect\n");
+        max_lock_time_ms = Si2168_DVBT2_MAX_LOCK_TIME;
+        min_lock_time_ms = Si2168_DVBT_MIN_LOCK_TIME;
+        front_end->demod->prop->dvbt_hierarchy.stream     = (unsigned char)dvb_t_stream;
+        front_end->demod->prop->dd_mode.modulation  = Si2168_DD_MODE_PROP_MODULATION_AUTO_DETECT;
+        front_end->demod->prop->dd_mode.auto_detect = Si2168_DD_MODE_PROP_AUTO_DETECT_AUTO_DVB_T_T2;
+        Si2168_L1_SetProperty2(front_end->demod, Si2168_DVBT_HIERARCHY_PROP_CODE);
+      } else {
+        if (standard == Si2168_DD_MODE_PROP_MODULATION_DVBT ) {
+          max_lock_time_ms = Si2168_DVBT_MAX_LOCK_TIME;
+          min_lock_time_ms = Si2168_DVBT_MIN_LOCK_TIME;
+          front_end->demod->prop->dvbt_hierarchy.stream     = (unsigned char)dvb_t_stream;
+          Si2168_L1_SetProperty2(front_end->demod, Si2168_DVBT_HIERARCHY_PROP_CODE);
+        }
+        if (standard == Si2168_DD_MODE_PROP_MODULATION_DVBT2) {
+          max_lock_time_ms = Si2168_DVBT2_MAX_LOCK_TIME;
+          min_lock_time_ms = Si2168_DVBT2_MIN_LOCK_TIME;
+          if (dvb_t_bandwidth_hz == 1700000) {
+            front_end->demod->prop->dd_mode.bw              = Si2168_DD_MODE_PROP_BW_BW_1D7MHZ;
+          }
+        }
+      }
+      Si2168_L1_SetProperty2(front_end->demod, Si2168_DD_MODE_PROP_CODE);
+      SiTRACE("bw %d Hz\n", dvb_t_bandwidth_hz);
+      break;
+    }
+    case Si2168_DD_MODE_PROP_MODULATION_DVBC : {
+      max_lock_time_ms = Si2168_DVBC_MAX_LOCK_TIME;
+      min_lock_time_ms = Si2168_DVBC_MIN_LOCK_TIME;
+      front_end->demod->prop->dd_mode.bw                       = 8;
+      front_end->demod->prop->dvbc_symbol_rate.rate            = symbol_rate_bps/1000;
+      front_end->demod->prop->dvbc_constellation.constellation = (unsigned char)dvb_c_constellation;
+      Si2168_L1_SetProperty2(front_end->demod, Si2168_DD_MODE_PROP_CODE);
+      Si2168_L1_SetProperty2(front_end->demod, Si2168_DVBC_SYMBOL_RATE_PROP_CODE);
+      Si2168_L1_SetProperty2(front_end->demod, Si2168_DVBC_CONSTELLATION_PROP_CODE);
+      SiTRACE("sr %d bps, constel %d\n", symbol_rate_bps, dvb_c_constellation);
+      break;
+    }
+    default : /* ATV */   {
+      SiTRACE("'%d' standard (%s) is not managed by Si2168_lock_to_carrier\n", standard, Si2168_standardName(standard));
+      return 0;
+      break;
+    }
+  }
+
+  if (front_end->demod->rsp->dd_status.modulation == Si2168_DD_MODE_PROP_MODULATION_DVBT2) {
+    front_end->demod->cmd->dvbt2_plp_select.plp_id = (unsigned char)dvb_t2_plp_id;
+    if (dvb_t2_plp_id != -1) {
+      Si2168_L1_DVBT2_PLP_SELECT    (front_end->demod, (unsigned char)dvb_t2_plp_id, Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_MANUAL);
+    } else {
+      Si2168_L1_DVBT2_PLP_SELECT    (front_end->demod, (unsigned char)dvb_t2_plp_id, Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_AUTO);
+    }
+  }
+
+//  searchStartTime = system_time();
+  Si2168_L2_Tune                  (front_end,       freq);
+//  SiTRACE ("Si2168_lock_to_carrier 'tune'  took %3d ms\n"        , system_time() - searchStartTime);
+
+//  searchStartTime = system_time();
+
+  Si2168_L1_DD_RESTART            (front_end->demod);
+//  SiTRACE ("Si2168_lock_to_carrier 'reset' took %3d ms\n"        , system_time() - searchStartTime);
+
+  lock = 0;
+//  searchStartTime = system_time();
+
+  /* as we will not lock in less than min_lock_time_ms, wait a while...*/
+//  system_wait(min_lock_time_ms);
+	delayMS(min_lock_time_ms);
+
+  ulCount = 0;
+  ulDelay = 10;
+  ulTick = max_lock_time_ms/ulDelay;
+  
+  while (1) {
+
+    ulCount++;
+//    searchDelay = system_time() - searchStartTime;
+
+    /* Check the status for the current modulation */
+
+    switch (standard) {
+      default                                   :
+      case Si2168_DD_MODE_PROP_MODULATION_DVBT  :
+      case Si2168_DD_MODE_PROP_MODULATION_DVBT2 : {
+        /* DVB-T/T2 auto detect seek loop, using Si2168_L1_DD_STATUS                                          */
+        /* if DL LOCKED                            : demod is locked on a dd_status->modulation signal        */
+        /* if DL NO_LOCK and rsqint_bit5 NO_CHANGE : demod is searching for a DVB-T/T2 signal                 */
+        /* if DL NO_LOCK and rsqint_bit5 CHANGE    : demod says this is not a DVB-T/T2 signal (= 'neverlock') */
+        return_code = Si2168_L1_DD_STATUS(front_end->demod, Si2168_DD_STATUS_CMD_INTACK_CLEAR);
+
+        if (return_code != NO_Si2168_ERROR) {
+          SiTRACE("Si2168_lock_to_carrier: Si2168_L1_DD_STATUS error\n");
+          SiERROR("Si2168_lock_to_carrier: Si2168_L1_DD_STATUS error\n");
+          goto exit_lock;
+          break;
+        }
+
+        if (  front_end->demod->rsp->dd_status.dl  == Si2168_DD_STATUS_RESPONSE_DL_LOCKED   ) {
+          /* Return 1 to signal that the Si2168 is locked on a valid DVB-T/T2 channel */
+          SiTRACE("Si2168_lock_to_carrier: locked on a %s signal\n", Si2168_standardName(front_end->demod->rsp->dd_status.modulation) );
+          lock = 1;
+          if ( (front_end->demod->rsp->dd_status.modulation == Si2168_DD_MODE_PROP_MODULATION_DVBT2) && (standard == Si2168_DD_MODE_PROP_MODULATION_DVBT) ) {
+            if (dvb_t2_plp_id != -1) {
+              Si2168_L1_DVBT2_PLP_SELECT    (front_end->demod, (unsigned char)dvb_t2_plp_id, Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_MANUAL);
+            } else {
+              Si2168_L1_DVBT2_PLP_SELECT    (front_end->demod, (unsigned char)dvb_t2_plp_id, Si2168_DVBT2_PLP_SELECT_CMD_PLP_ID_SEL_MODE_AUTO);
+            }
+            //system_wait(340);
+            delayMS(340);
+          }
+          goto exit_lock;
+        } else {
+          if (  front_end->demod->rsp->dd_status.rsqint_bit5 == Si2168_DD_STATUS_RESPONSE_RSQINT_BIT5_CHANGED ) {
+          /* Return 0 if firmware signals 'no DVB-T/T2 channel' */
+          //SiTRACE ("'no DVB-T/T2 channel': not locked after %3d ms\n", searchDelay);
+          SiTRACE ("'no DVB-T/T2 channel': not locked after %3d ms\n", ulCount*10);
+          goto exit_lock;
+          }
+        }
+        break;
+      }
+      case Si2168_DD_MODE_PROP_MODULATION_DVBC  : {
+        return_code = Si2168_L1_DD_STATUS(front_end->demod, Si2168_DD_STATUS_CMD_INTACK_CLEAR);
+
+        if (return_code != NO_Si2168_ERROR) {
+          SiTRACE("Si2168_lock_to_carrier: Si2168_L1_DD_STATUS error\n");
+          SiERROR("Si2168_lock_to_carrier: Si2168_L1_DD_STATUS error\n");
+          return return_code;
+          break;
+        }
+
+        if ( (front_end->demod->rsp->dd_status.dl    == Si2168_DD_STATUS_RESPONSE_DL_LOCKED     ) ) {
+          /* Return 1 to signal that the Si2168 is locked on a valid SAT channel */
+          SiTRACE("%s lock\n", Si2168_standardName(front_end->demod->rsp->dd_status.modulation));
+          lock = 1;
+          goto exit_lock;
+        }
+        break;
+      }
+    }
+
+    /* timeout management (this should never happen if timeout values are correctly set) */
+    //if (searchDelay >= max_lock_time_ms) {
+    if (ulCount >= ulTick) {
+      //SiTRACE ("Si2168_lock_to_carrier timeout(%d) after %d ms\n", max_lock_time_ms,searchDelay);
+      SiTRACE ("Si2168_lock_to_carrier timeout(%d)\n", max_lock_time_ms);
+      break;
+    }
+
+    /* Check status every 10 ms */
+    //system_wait(10);
+    delayMS(10);
+  }
+
+  exit_lock:
+
+//  searchDelay = system_time() - searchStartTime;
+
+  if (lock) {
+    //SiTRACE ("Si2168_lock_to_carrier 'lock'  took %3d ms\n"        , searchDelay);
+    SiTRACE ("Si2168_lock_to_carrier 'lock'  took %3d ms\n"        , ulCount*10);
+  } else {
+    //SiTRACE ("Si2168_lock_to_carrier at %10d (%s) failed after %d ms\n",freq, Si2168_standardName(front_end->demod->rsp->dd_status.modulation), searchDelay);
+    SiTRACE ("Si2168_lock_to_carrier at %10d (%s) failed after %d ms\n",freq, Si2168_standardName(front_end->demod->rsp->dd_status.modulation), ulCount*10);
+  }
+
+  return lock;
+}
+
+/************************************************************************************************************************
+  SiLabs_API_lock_to_carrier function
+  Use:      relocking function
+            Used to relock on a channel for the required standard
+  Parameter: standard the standard to lock to
+  Parameter: freq                the frequency to lock to (in Hz for TER, in kHz for SAT)
+  Parameter: bandwidth_Hz        the channel bandwidth in Hz (only for DVB-T and DVB-T2)
+  Parameter: dvb_t_stream        the HP/LP stream  (only for DVB-T)
+  Parameter: symbol_rate_bps     the symbol rate in baud/s  (for DVB-C and SAT)
+  Parameter: dvb_c_constellation the DVB-C constellation (only for DVB-C)
+  Parameter: plp_id              the PLP Id (only for DVB-T2 and DVB-C2 when num_plp > 1)
+  Return:    1 if locked, 0 otherwise
+************************************************************************************************************************/
+int   SiLabs_API_lock_to_carrier          (SILABS_FE_Context *front_end, int standard, int freq, int bandwidth_Hz, int stream, unsigned int symbol_rate_bps, int constellation, int polarization, int band, int plp_id)
+{
+  int standard_code;
+  int constel_code;
+  int stream_code;
+  plp_id = plp_id; /* to avoid compiler warining if not used */
+
+  SiTRACE("SiLabs_API_lock_to_carrier (front_end, %8d, %d, %d, %2d, %d, %d, %d, %d, %d)\n", standard, freq, bandwidth_Hz, stream, symbol_rate_bps, constellation, polarization, band, plp_id);
+
+  standard_code = Silabs_standardCode(front_end, (CUSTOM_Standard_Enum)standard);
+  constel_code  = Silabs_constelCode (front_end, (CUSTOM_Constel_Enum)constellation);
+  stream_code   = Silabs_streamCode  (front_end, (CUSTOM_Stream_Enum)stream);
+
+  SiTRACE("SiLabs_API_lock_to_carrier (front_end, %8s, %d, %d, %2s, %d, %s, %s, %s, %d)\n", Silabs_Standard_Text((CUSTOM_Standard_Enum)standard), freq, bandwidth_Hz, Silabs_Stream_Text((CUSTOM_Stream_Enum)stream), symbol_rate_bps, Silabs_Constel_Text((CUSTOM_Constel_Enum)constellation), Silabs_Polarization_Text((CUSTOM_Polarization_Enum)polarization), Silabs_Band_Text((CUSTOM_Band_Enum)band) , plp_id );
+
+  /* Use the API wrapper function to switch standard if required. */
+  if (standard != front_end->standard) {
+    if (SiLabs_API_switch_to_standard(front_end, standard, 0) == 0) {
+      return 0;
+    }
+  }
+
+#ifdef    Si2168_COMPATIBLE
+  if (front_end->chip ==   2168 ) {
+    SiTRACE("Si2168_lock_to_carrier     (front_end->Si2168_FE, %d, %d, %d, %d, %d, %d, %d)\n", standard_code, freq, bandwidth_Hz, stream_code, symbol_rate_bps, constel_code, plp_id);
+    return   Si2168_L2_lock_to_carrier  (front_end->Si2168_FE,                                 standard_code, freq, bandwidth_Hz, stream_code, symbol_rate_bps, constel_code, plp_id);
+  }
+#endif /* Si2168_COMPATIBLE */
+  SiTRACE("Unknown chip '%d'\n", front_end->chip);
+  return 0;
+}
diff -urN a/drivers/media/dvb-frontends/si2168_drv.c b/drivers/media/dvb-frontends/si2168_drv.c
--- a/drivers/media/dvb-frontends/si2168_drv.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/si2168_drv.c	2013-03-31 23:44:31.924797127 +0800
@@ -0,0 +1,574 @@
+/*
+    SI2168/SI2158  - DVB-T2/T/C demodulator and tuner
+
+    Copyright (C) 2013 Max Nibble <nibble.max@gmail.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include "si2168_priv.h"
+#include "si2168.h"
+
+int si2168_debug;
+module_param(si2168_debug, int, 0644);
+MODULE_PARM_DESC(si2168_debug, "Activates frontend debugging (default:0)");
+
+/*global state*/
+struct si2168_state {
+	const struct si2168_config *config;
+	struct dvb_frontend frontend;
+	
+	SILABS_FE_Context fe_context;
+	CUSTOM_Status_Struct custom_status;
+	u32 standard;
+	u32 stream;
+	int plp_id;
+};
+
+/* L0 functions */
+void L0_Init(L0_Context *i2c)
+{
+  i2c->address             = 0;
+  i2c->indexSize           = 0;
+  i2c->connectionType      = CUSTOMER;
+  i2c->trackWrite          = 0;
+  i2c->trackRead           = 0;
+  i2c->mustReadWithoutStop = 0;
+}
+
+int L0_SetAddress(L0_Context* i2c, unsigned int add, int addSize)
+{
+  i2c->address   = (u8)add;
+  i2c->indexSize = addSize;
+  return 1;
+}
+
+int L0_WriteCommandBytes(L0_Context* i2c, int iNbBytes, unsigned char *pucDataBuffer)
+{
+  return L0_WriteBytes(i2c, 0x00, iNbBytes, pucDataBuffer);
+}
+
+int L0_WriteBytes(L0_Context* i2c, unsigned int iI2CIndex, int iNbBytes, unsigned char *pucDataBuffer)
+{
+  int r, i, nbWrittenBytes, ret;
+  struct i2c_msg msg = { .flags = 0 };
+  nbWrittenBytes = 0;
+  if (i2c->indexSize > 0) {
+  	for (i=0; i <i2c->indexSize;i++) {
+    		r = 8*(i2c->indexSize -1 -i);
+    		i2c->pucBuffer[i] = (unsigned char)((iI2CIndex & (0xff<<r) ) >> r);
+    		i2c->pucAddressBuffer[i] = i2c->pucBuffer[i];
+  	}
+  }
+  for (i=0; i < iNbBytes ; i++) {
+    i2c->pucBuffer[i+i2c->indexSize] = pucDataBuffer[i];
+  }
+  
+  msg.addr = i2c->address;
+  msg.buf = i2c->pucBuffer;
+  msg.len = iNbBytes + i2c->indexSize; 
+  ret = i2c_transfer(i2c->i2c, &msg, 1);
+  if (ret == 1)
+  	nbWrittenBytes = iNbBytes + i2c->indexSize;
+
+  return nbWrittenBytes - i2c->indexSize;
+}
+
+int L0_ReadCommandBytes(L0_Context* i2c, int iNbBytes, unsigned char *pucDataBuffer)
+{
+  return L0_ReadBytes (i2c, 0x00, iNbBytes, pucDataBuffer);
+}
+
+int L0_ReadBytes(L0_Context* i2c, unsigned int iI2CIndex, int iNbBytes, unsigned char *pucDataBuffer)
+{
+  int r,i,nbReadBytes, ret;
+  struct i2c_msg r_msg[1] = {
+  	{
+  		.addr = i2c->address, 
+  		.flags = I2C_M_RD,
+  		.len = iNbBytes,
+  		.buf = pucDataBuffer,
+  	}
+  };
+  struct i2c_msg wr_msg[2] = {
+  	{
+  		.addr = i2c->address, 
+  		.flags = 0,
+  		.len = i2c->indexSize,
+  		.buf = i2c->pucAddressBuffer,
+  	}, {
+  		.addr = i2c->address, 
+  		.flags = I2C_M_RD,
+  		.len = iNbBytes,
+  		.buf = pucDataBuffer,  		
+  	}
+  };
+  
+  nbReadBytes = 0;
+  if (i2c->indexSize > 0) {
+  	for (i=0;i<i2c->indexSize;i++) {
+    		r = 8*(i2c->indexSize -1 -i);
+    		i2c->pucAddressBuffer[i] = (unsigned char)((iI2CIndex & (0xff<<r) ) >> r);
+  	}
+  	ret = i2c_transfer(i2c->i2c, wr_msg, 2);
+  	if (ret == 2)
+  		nbReadBytes = iNbBytes;
+  } else {
+  	ret = i2c_transfer(i2c->i2c, r_msg, 1);
+  	if (ret == 1)
+  		nbReadBytes = iNbBytes;
+  }
+  return nbReadBytes;
+}
+  
+int delayMS(int ms)
+{
+	msleep(ms);
+	return 0;
+}
+
+int power_of_n (int n, int m)
+{
+  int i;
+  int p;
+  p = 1;
+  for (i=1; i<= m; i++) {
+    p = p*n;
+  }
+  return p;
+}
+
+static int si2168_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct si2168_state *state = fe->demodulator_priv;
+	SiLabs_API_TER_Tuner_status(&state->fe_context, &state->custom_status);
+	*strength = state->custom_status.RSSI + 128;
+	/* scale value to 0x0000-0xffff from 0x0000-0x00ff */
+	*strength = *strength * 0xffff / 0x00ff;
+	return 0;
+}
+
+static int si2168_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	struct si2168_state *state = fe->demodulator_priv;
+	SiLabs_API_Demod_status(&state->fe_context, &state->custom_status);
+	*ucblocks = state->custom_status.uncorrs;
+	return 0;
+}
+
+static int si2168_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	struct si2168_state *state = fe->demodulator_priv;
+	SiLabs_API_Demod_status(&state->fe_context, &state->custom_status);
+	*ber = state->custom_status.ber;
+	return 0;
+}
+
+static int si2168_read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct si2168_state *state = fe->demodulator_priv;
+	/* report SNR in dB * 10 */
+	SiLabs_API_Demod_status(&state->fe_context, &state->custom_status);
+	*snr = state->custom_status.c_n/10;
+	return 0;
+}
+
+static int si2168_read_status(struct dvb_frontend *fe, fe_status_t *status)
+{
+	struct si2168_state *state = fe->demodulator_priv;
+	*status = 0;
+
+	SiLabs_API_Demod_status(&state->fe_context, &state->custom_status);
+	if (state->custom_status.demod_lock)
+		*status = FE_HAS_SIGNAL | FE_HAS_CARRIER
+		    | FE_HAS_SYNC | FE_HAS_VITERBI;
+	if (state->custom_status.fec_lock)
+		*status = FE_HAS_SIGNAL | FE_HAS_CARRIER
+		    | FE_HAS_SYNC | FE_HAS_VITERBI | FE_HAS_LOCK;
+	return 0;
+}
+
+static int si2168_get_frontend_algo(struct dvb_frontend *fe)
+{
+	return DVBFE_ALGO_HW;
+}
+
+static fe_modulation_t si2168_convert_modulation(int constellation)
+{
+	fe_modulation_t ret;
+	switch (constellation) {
+	case SILABS_QAM16:
+		ret = QAM_16;
+		break;
+	case SILABS_QAM32:
+		ret = QAM_32;
+		break;
+	case SILABS_QAM64:
+		ret = QAM_64;
+		break;
+	case SILABS_QAM128:
+		ret = QAM_128;
+		break;
+	case SILABS_QAM256:
+		ret = QAM_256;
+		break;
+	case SILABS_QPSK:
+		ret = QPSK;
+		break;
+	default:
+		ret = QAM_AUTO;
+		break;		
+	}
+	return ret;				
+}
+
+static fe_transmit_mode_t si2168_convert_fftcode(int fftcode)
+{
+	fe_transmit_mode_t ret;
+	switch (fftcode) {	
+	case SILABS_FFT_MODE_1K:
+		ret = TRANSMISSION_MODE_1K;
+		break;
+	case SILABS_FFT_MODE_2K:
+		ret = TRANSMISSION_MODE_2K;
+		break;
+	case SILABS_FFT_MODE_4K:
+		ret = TRANSMISSION_MODE_4K;
+		break;
+	case SILABS_FFT_MODE_8K:
+		ret = TRANSMISSION_MODE_8K;
+		break;
+	case SILABS_FFT_MODE_16K:
+		ret = TRANSMISSION_MODE_16K;
+		break;
+	case SILABS_FFT_MODE_32K:
+		ret = TRANSMISSION_MODE_32K;
+		break;
+	default:
+		ret = TRANSMISSION_MODE_AUTO;
+	}
+	return ret;
+}
+
+static fe_guard_interval_t si2168_convert_gicode(int gicode)
+{
+	fe_guard_interval_t ret;
+	switch (gicode) {
+	case SILABS_GUARD_INTERVAL_1_32:
+		ret = GUARD_INTERVAL_1_32;
+		break;
+	case SILABS_GUARD_INTERVAL_1_16:
+		ret = GUARD_INTERVAL_1_16;
+		break;
+	case SILABS_GUARD_INTERVAL_1_8:
+		ret = GUARD_INTERVAL_1_8;
+		break;
+	case SILABS_GUARD_INTERVAL_1_4:
+		ret = GUARD_INTERVAL_1_4;
+		break;
+	case SILABS_GUARD_INTERVAL_1_128:
+		ret = GUARD_INTERVAL_1_128;
+		break;
+	case SILABS_GUARD_INTERVAL_19_128:
+		ret = GUARD_INTERVAL_19_128;
+		break;
+	case SILABS_GUARD_INTERVAL_19_256:
+		ret = GUARD_INTERVAL_19_256;
+		break;		
+	default:
+		ret = GUARD_INTERVAL_AUTO;
+	}
+	return ret;
+}
+
+static fe_hierarchy_t si2168_convert_hierarchycode(int hierarchycode)
+{
+	fe_hierarchy_t ret;
+	switch (hierarchycode) {
+	case SILABS_HIERARCHY_NONE:
+		ret = HIERARCHY_NONE;
+		break;
+	case SILABS_HIERARCHY_ALFA1:
+		ret = HIERARCHY_1;
+		break;
+	case SILABS_HIERARCHY_ALFA2:
+		ret = HIERARCHY_2;
+		break;
+	case SILABS_HIERARCHY_ALFA4:
+		ret = HIERARCHY_4;
+		break;
+	default:
+		ret = HIERARCHY_AUTO;
+	}
+	return ret;
+}
+
+static fe_code_rate_t si2168_convert_coderate(int coderate)
+{
+	fe_code_rate_t ret;
+	switch (coderate) {
+	case SILABS_CODERATE_1_2:
+		ret = FEC_1_2;
+		break;
+	case SILABS_CODERATE_2_3:
+		ret = FEC_2_3;
+		break;
+	case SILABS_CODERATE_3_4:
+		ret = FEC_3_4;
+		break;
+	case SILABS_CODERATE_5_6:
+		ret = FEC_5_6;
+		break;
+	case SILABS_CODERATE_7_8:
+		ret = FEC_7_8;
+		break;
+	case SILABS_CODERATE_4_5:
+		ret = FEC_4_5;
+		break;
+	case SILABS_CODERATE_3_5:
+		ret = FEC_3_5;
+		break;		
+	default:
+		ret = FEC_AUTO;
+	}
+	return ret;
+}
+
+static int si2168_get_frontend(struct dvb_frontend *fe)
+{
+	struct si2168_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int ret = 0;
+	
+	SiLabs_API_Demod_status(&state->fe_context, &state->custom_status);
+
+	switch (c->delivery_system) {
+	case SYS_DVBT:
+		c->modulation = si2168_convert_modulation(state->custom_status.constellation);
+		c->transmission_mode = si2168_convert_fftcode(state->custom_status.fft_mode);
+		c->guard_interval = si2168_convert_gicode(state->custom_status.guard_interval);
+		c->hierarchy = si2168_convert_hierarchycode(state->custom_status.hierarchy);
+		c->code_rate_HP = si2168_convert_coderate(state->custom_status.code_rate_hp);
+		c->code_rate_LP = si2168_convert_coderate(state->custom_status.code_rate_lp);
+		c->inversion =
+			(state->custom_status.spectral_inversion == Si2168_DVBT_STATUS_RESPONSE_SP_INV_INVERTED) ? INVERSION_ON : INVERSION_OFF;
+		break;
+	case SYS_DVBT2:
+		c->modulation = si2168_convert_modulation(state->custom_status.constellation);
+		c->transmission_mode = si2168_convert_fftcode(state->custom_status.fft_mode);
+		c->guard_interval = si2168_convert_gicode(state->custom_status.guard_interval);
+		c->fec_inner = si2168_convert_coderate(state->custom_status.code_rate);
+		c->inversion =
+			(state->custom_status.spectral_inversion == Si2168_DVBT_STATUS_RESPONSE_SP_INV_INVERTED) ? INVERSION_ON : INVERSION_OFF;		
+		break;
+	case SYS_DVBC_ANNEX_A:
+		c->symbol_rate = state->custom_status.symbol_rate;
+		c->modulation = si2168_convert_modulation(state->custom_status.constellation);
+		c->inversion =
+			(state->custom_status.spectral_inversion == Si2168_DVBT_STATUS_RESPONSE_SP_INV_INVERTED) ? INVERSION_ON : INVERSION_OFF;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int si2168_set_frontend(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	struct si2168_state *state = fe->demodulator_priv;
+	int ret, req_standard, req_qam, req_plp_id = 0;
+	printk(KERN_INFO
+	     "%s: system=%d frequency=%d bandwidth=%d symrate=%d qam=%d stream_id=%d\n",
+	     __func__, c->delivery_system, c->frequency, c->bandwidth_hz, c->symbol_rate, c->modulation, c->stream_id);
+	     
+	switch (c->delivery_system) {
+	case SYS_DVBT:
+	case SYS_DVBT2:
+		req_standard = SILABS_DVB_T;
+		break;
+	case SYS_DVBC_ANNEX_A:
+		req_standard = SILABS_DVB_C;
+		break;
+	default:
+		printk(KERN_ERR "%s: %d is not supported!\n", __func__, c->delivery_system);
+		return -EINVAL;
+	}
+	if (state->standard != req_standard) {
+		ret = SiLabs_API_switch_to_standard(&state->fe_context, req_standard, 0);
+		if (ret == 0)
+			return -EREMOTEIO;
+		state->standard = req_standard;
+	}
+	switch (c->modulation) {
+	case QAM_64:
+		req_qam = SILABS_QAM64;
+		break;
+	case QAM_16:
+		req_qam = SILABS_QAM16;
+		break;
+	case QAM_32:
+		req_qam = SILABS_QAM32;
+		break;
+	case QAM_128:
+		req_qam = SILABS_QAM128;
+		break;	
+	case QAM_256:
+		req_qam = SILABS_QAM256;
+		break;	
+	default: /* QAM_AUTO */
+		req_qam = SILABS_QAMAUTO;
+		break;
+	}
+	if (c->stream_id == NO_STREAM_ID_FILTER)
+		req_plp_id = state->plp_id;
+	else if ((c->stream_id >= 0) && (c->stream_id <= 255)) {
+		req_plp_id = c->stream_id;
+		state->plp_id = req_plp_id;
+	}
+	ret = SiLabs_API_lock_to_carrier(&state->fe_context, req_standard, c->frequency,
+		c->bandwidth_hz, state->stream, c->symbol_rate, req_qam, 0, 0, req_plp_id);
+	if (ret && state->config->start_ctrl)
+		state->config->start_ctrl(fe);
+	return 0;
+}
+
+static int si2168_tune(struct dvb_frontend *fe,
+			bool re_tune,
+			unsigned int mode_flags,
+			unsigned int *delay,
+			fe_status_t *status)
+{	
+	*delay = HZ / 5;	
+	if (re_tune) {
+		int ret = si2168_set_frontend(fe);
+		if (ret)
+			return ret;
+	}	
+	return si2168_read_status(fe, status);
+}
+
+static int si2168_init(struct dvb_frontend *fe)
+{
+	struct si2168_state *state = fe->demodulator_priv;
+
+	SiLabs_API_switch_to_standard(&state->fe_context, state->fe_context.standard, 0);
+	state->standard = state->fe_context.standard;
+	if (state->standard != SILABS_SLEEP)
+		SiLabs_API_TS_Mode(&state->fe_context, state->config->ts_bus_mode);
+	return 0;
+}
+
+static int si2168_sleep(struct dvb_frontend *fe)
+{
+	struct si2168_state *state = fe->demodulator_priv;
+	
+	SiLabs_API_switch_to_standard(&state->fe_context, SILABS_SLEEP, 0);
+	state->standard = SILABS_SLEEP;
+	return 0;
+}
+
+static void si2168_release(struct dvb_frontend *fe)
+{
+	struct si2168_state *state = fe->demodulator_priv;
+	kfree(state);
+}
+
+static const struct dvb_frontend_ops si2168_ops = {
+	.delsys = { SYS_DVBT, SYS_DVBT2, SYS_DVBC_ANNEX_A },
+	/*.delsys = { SYS_DVBC_ANNEX_A },*/
+	/* default: DVB-T/T2 */
+	.info = {
+		.name = "Si2168 DVB-T2/C",
+		.frequency_stepsize = 62500,
+		.frequency_min = 48000000,
+		.frequency_max = 870000000,
+		.symbol_rate_min = 870000,
+		.symbol_rate_max = 7500000,
+		.caps =	FE_CAN_FEC_1_2			|
+			FE_CAN_FEC_2_3			|
+			FE_CAN_FEC_3_4			|
+			FE_CAN_FEC_5_6			|
+			FE_CAN_FEC_7_8			|
+			FE_CAN_FEC_AUTO			|
+			FE_CAN_QPSK			|
+			FE_CAN_QAM_16			|
+			FE_CAN_QAM_32			|
+			FE_CAN_QAM_64			|
+			FE_CAN_QAM_128			|
+			FE_CAN_QAM_256			|
+			FE_CAN_QAM_AUTO			|
+			FE_CAN_TRANSMISSION_MODE_AUTO	|
+			FE_CAN_GUARD_INTERVAL_AUTO	|
+			FE_CAN_HIERARCHY_AUTO		|
+			FE_CAN_MUTE_TS			|
+			FE_CAN_2G_MODULATION		|
+			FE_CAN_MULTISTREAM
+		},
+
+	.release		= si2168_release,
+	.init			= si2168_init,
+	.sleep			= si2168_sleep,
+
+	.tune			= si2168_tune,
+	.set_frontend		= si2168_set_frontend,
+	.get_frontend		= si2168_get_frontend,
+	.get_frontend_algo	= si2168_get_frontend_algo,
+
+	.read_status		= si2168_read_status,
+	.read_snr		= si2168_read_snr,
+	.read_ber		= si2168_read_ber,
+	.read_ucblocks		= si2168_read_ucblocks,
+	.read_signal_strength	= si2168_read_signal_strength,
+};
+
+struct dvb_frontend *si2168_attach(const struct si2168_config *config,
+		struct i2c_adapter *i2c)
+{
+	struct si2168_state *state = NULL;
+	state = kzalloc(sizeof(struct si2168_state), GFP_KERNEL);
+	if (!state) {
+		dev_err(&i2c->dev, "%s: kzalloc() failed\n",
+				KBUILD_MODNAME);
+		goto error;
+	}
+	
+	state->config = config;
+	state->standard = 0xff;
+	state->stream = 0;
+	state->plp_id = 0;
+	state->fe_context.Silabs_init_done = 0;
+	SiLabs_API_SW_Init(&state->fe_context, SI2168_DEMOD_ADDRESS, SI2158_TUNER_ADDRESS, 0);
+	SiLabs_API_TER_AutoDetect(&state->fe_context, 1);
+	state->fe_context.Si2168_FE->demod->i2c->i2c = i2c;
+	state->fe_context.Si2168_FE->tuner_ter->i2c->i2c = i2c;
+	state->fe_context.Si2168_FE->demod->ts_bus_mode = state->config->ts_bus_mode;
+	state->fe_context.Si2168_FE->demod->ts_clock_mode = state->config->ts_clock_mode;	
+
+	memcpy(&state->frontend.ops, &si2168_ops,
+	       sizeof(struct dvb_frontend_ops));
+	state->frontend.demodulator_priv = state;
+	return &state->frontend;
+error:
+	kfree(state);
+	return NULL;
+}
+EXPORT_SYMBOL(si2168_attach);
+
+MODULE_DESCRIPTION("SI2168 demodulator driver");
+MODULE_AUTHOR("Max Nibble <nibble.max@gmail.com>");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.00");
diff -urN a/drivers/media/dvb-frontends/si2168.h b/drivers/media/dvb-frontends/si2168.h
--- a/drivers/media/dvb-frontends/si2168.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/si2168.h	2013-02-14 23:21:25.000000000 +0800
@@ -0,0 +1,45 @@
+/*
+    SI2168/SI2158  - DVB-T2/T/C demodulator and tuner
+
+    Copyright (C) 2013 Max Nibble <nibble.max@gmail.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef SI2168_H
+#define SI2168_H
+
+#include <linux/dvb/frontend.h>
+
+struct si2168_config {
+	u8 ts_bus_mode; /*1-serial, 2-parallel.*/
+	u8 ts_clock_mode; /*0-auto, 1-manual.*/
+	
+	int (*start_ctrl)(struct dvb_frontend *fe);
+};
+
+#if defined(CONFIG_DVB_SI2168) || (defined(CONFIG_DVB_SI2168_MODULE) && defined(MODULE))
+extern struct dvb_frontend *si2168_attach(const struct si2168_config *config,
+					    struct i2c_adapter *i2c);
+#else
+static inline struct dvb_frontend *si2168_attach(const struct si2168_config *config,
+					    struct i2c_adapter *i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif /* CONFIG_DVB_SI2168 */
+
+#endif /* SI2168_H */
diff -urN a/drivers/media/dvb-frontends/si2168_priv.h b/drivers/media/dvb-frontends/si2168_priv.h
--- a/drivers/media/dvb-frontends/si2168_priv.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/si2168_priv.h	2013-03-31 23:44:39.928796846 +0800
@@ -0,0 +1,944 @@
+/*
+    SI2168/SI2158  - DVB-T2/T/C demodulator and tuner
+*/
+
+#ifndef SI2168_PRIV_H
+#define SI2168_PRIV_H
+
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <asm/div64.h>
+#include "dvb_frontend.h"
+
+#define Si2158_COMPATIBLE
+#define Si2158_COMMAND_PROTOTYPES
+#define TER_TUNER_Si2158
+
+#define Si2168_COMPATIBLE
+#define Si2168_COMMAND_PROTOTYPES
+#define Si2168_20_COMPATIBLE
+
+#include "si2158_commands.h"
+#include "si2158_properties.h"
+#include "si2168_commands.h"
+#include "si2168_properties.h"
+
+/*L0 typedef*/
+typedef enum CONNECTION_TYPE
+{
+    SIMU = 0,
+    USB,
+    CUSTOMER,
+    none
+}  CONNECTION_TYPE;
+
+typedef struct L0_Context
+{
+    struct i2c_adapter *i2c;
+    u8 pucAddressBuffer[4];
+    u8 pucBuffer[64];    
+    unsigned char   address;
+    int             indexSize;
+    CONNECTION_TYPE connectionType;
+    int             trackWrite;
+    int             trackRead;
+    int             mustReadWithoutStop;
+} L0_Context;
+
+/*si2158 typedef*/
+#define Si2158_BYTES_PER_LINE 8
+/*chip rev constants for integrity checking */
+#define Si2158_chiprev         1
+/* Last 2 digits of part number */
+#define Si2158_part            58 /* Change this value if using a chip other than a Si2158 */
+#define Si2158_partMajorVersion '2'
+#define Si2158_partMinorVersion '0'
+#define Si2158_partRomid        0x33
+
+#define NO_Si2158_ERROR                     0x00
+#define ERROR_Si2158_PARAMETER_OUT_OF_RANGE 0x01
+#define ERROR_Si2158_ALLOCATING_CONTEXT     0x02
+#define ERROR_Si2158_SENDING_COMMAND        0x03
+#define ERROR_Si2158_CTS_TIMEOUT            0x04
+#define ERROR_Si2158_ERR                    0x05
+#define ERROR_Si2158_POLLING_CTS            0x06
+#define ERROR_Si2158_POLLING_RESPONSE       0x07
+#define ERROR_Si2158_LOADING_FIRMWARE       0x08
+#define ERROR_Si2158_LOADING_BOOTBLOCK      0x09
+#define ERROR_Si2158_STARTING_FIRMWARE      0x0a
+#define ERROR_Si2158_SW_RESET               0x0b
+#define ERROR_Si2158_INCOMPATIBLE_PART      0x0c
+/* _specific_error_value_insertion_start */
+#define ERROR_Si2158_TUNINT_TIMEOUT         0x0d
+#define ERROR_Si2158_xTVINT_TIMEOUT         0x0e
+
+/* define the maximum possible channels (1002MHz - 43MHz) / 6MHz  (required for the channelscan array)*/
+#define MAX_POSSIBLE_CHANNELS 160
+
+typedef struct L1_Si2158_Context {
+  L0_Context                 *i2c;
+  L0_Context                  i2cObj;
+  Si2158_CmdObj              *cmd;
+  Si2158_CmdObj               cmdObj;
+  Si2158_CmdReplyObj         *rsp;
+  Si2158_CmdReplyObj          rspObj;
+  Si2158_PropObj             *prop;
+  Si2158_PropObj              propObj;
+  Si2158_COMMON_REPLY_struct *status;
+  Si2158_COMMON_REPLY_struct  statusObj;
+  /*chip rev constants for integrity checking */
+  unsigned char chiprev;
+  unsigned char part;
+  /* Last 2 digits of part number */
+  unsigned char partMajorVersion;
+  unsigned char partMinorVersion;
+  unsigned char partRomid;
+ /* Channel Scan Globals */
+  /* Global array to store the list of found channels */
+  unsigned long ChannelList[MAX_POSSIBLE_CHANNELS];
+  /* ChannelScanPal needs to store the PAL type also so allocate 4 chars each for that */
+  char ChannelType[MAX_POSSIBLE_CHANNELS][4];
+  /* Number of found channels from a channel scan */
+  int ChannelListSize;
+} L1_Si2158_Context;
+
+#ifndef __FIRMWARE_STRUCT__
+#define __FIRMWARE_STRUCT__
+typedef struct firmware_struct {
+	unsigned char firmware_len;
+	unsigned char firmware_table[16];
+} firmware_struct;
+#endif /* __FIRMWARE_STRUCT__ */
+
+/*tuner definition for si2158*/
+    #define Si2168_CLOCK_MODE_TER              Si2168_START_CLK_CMD_CLK_MODE_CLK_CLKIO
+    #define Si2168_REF_FREQUENCY_TER           24
+
+    #define TUNERTER_API
+    #define TER_TUNER_CONTEXT            L1_Si2158_Context
+    #define TUNER_ADDRESS_TER            0x60 /*0xc0*/
+
+    #define TER_TUNER_INIT(api)           Si2158_Init(api)
+    #define TER_TUNER_WAKEUP(api)         Si2158_pollForCTS(api)
+    /* Compatibility with Si2158 ROM12 & ROM13 APIs */
+    #define TER_TUNER_STANDBY(api)        Si2158_L1_STANDBY(api, Si2158_STANDBY_CMD_TYPE_MIN)
+
+    #define TER_TUNER_CLOCK_OFF(api)      Si2158_XoutOff(api)
+    #define TER_TUNER_CLOCK_ON(api)       Si2158_XoutOn(api)
+    #define TER_TUNER_ERROR_TEXT(res)     Si2158_L1_API_ERROR_TEXT(res)
+
+    #define TER_TUNER_MODULATION_DVBT     Si2158_DTV_MODE_PROP_MODULATION_DVBT
+    #define TER_TUNER_MODULATION_DVBC     Si2158_DTV_MODE_PROP_MODULATION_DVBC
+
+    #define L1_RF_TER_TUNER_Init(api,add) Si2158_L1_API_Init(api, add);
+    #define L1_RF_TER_TUNER_Tune(api,rf)  Si2158_DTVTune(api, rf, bw, modulation, Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_NORMAL)
+
+    #define L1_RF_TER_TUNER_Get_RF
+
+    #define L1_RF_TER_TUNER_MODULATION_DVBC  Si2158_DTV_MODE_PROP_MODULATION_DVBC
+    #define L1_RF_TER_TUNER_MODULATION_DVBT  Si2158_DTV_MODE_PROP_MODULATION_DVBT
+    #define L1_RF_TER_TUNER_MODULATION_DVBT2 Si2158_DTV_MODE_PROP_MODULATION_DVBT
+
+    #define   L1_RF_TER_TUNER_FEF_MODE_FREEZE_PIN_SETUP(api) \
+    api->cmd->config_pins.gpio1_mode               = Si2158_CONFIG_PINS_CMD_GPIO1_MODE_DISABLE;\
+    api->cmd->config_pins.gpio1_read               = Si2158_CONFIG_PINS_CMD_GPIO1_READ_DO_NOT_READ;\
+    api->cmd->config_pins.gpio2_mode               = Si2158_CONFIG_PINS_CMD_GPIO2_MODE_DISABLE;\
+    api->cmd->config_pins.gpio2_read               = Si2158_CONFIG_PINS_CMD_GPIO2_READ_DO_NOT_READ;\
+    api->cmd->config_pins.reserved1                = Si2158_CONFIG_PINS_CMD_RESERVED1_RESERVED;\
+    api->cmd->config_pins.reserved2                = Si2158_CONFIG_PINS_CMD_RESERVED2_RESERVED;\
+    api->cmd->config_pins.reserved3                = Si2158_CONFIG_PINS_CMD_RESERVED3_RESERVED;\
+    api->prop->dtv_initial_agc_speed.agc_decim     = Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_OFF;\
+    api->prop->dtv_initial_agc_speed.if_agc_speed  = Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO;\
+    api->prop->dtv_initial_agc_speed_period.period = 0;\
+    api->prop->dtv_agc_speed.agc_decim             = Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF;\
+    api->prop->dtv_agc_speed.if_agc_speed          = Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO;\
+    Si2158_L1_SendCommand2(api, Si2158_CONFIG_PINS_CMD_CODE);\
+    Si2158_L1_SetProperty2(api, Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_CODE);\
+    Si2158_L1_SetProperty2(api, Si2158_DTV_AGC_SPEED_PROP_CODE);
+
+    #define   L1_RF_TER_TUNER_FEF_MODE_FREEZE_PIN(api,fef) \
+    api->prop->dtv_agc_freeze_input.level          = Si2158_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_HIGH;\
+    if (fef == 0) {\
+      api->prop->dtv_agc_freeze_input.pin          = Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_NONE;\
+    } else {\
+      api->prop->dtv_agc_freeze_input.pin          = Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_GPIO1;\
+    }\
+    Si2158_L1_SetProperty2(api, Si2158_DTV_AGC_FREEZE_INPUT_PROP_CODE);
+
+    #define   L1_RF_TER_TUNER_FEF_MODE_SLOW_INITIAL_AGC_SETUP(api,fef) \
+      if (fef == 0) {\
+        api->prop->dtv_initial_agc_speed.agc_decim     = Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_OFF;\
+        api->prop->dtv_initial_agc_speed.if_agc_speed  = Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO;\
+        api->prop->dtv_initial_agc_speed_period.period = 0;\
+        api->prop->dtv_agc_speed.agc_decim             = Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF;\
+        api->prop->dtv_agc_speed.if_agc_speed          = Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO;\
+      } else {\
+        api->prop->dtv_initial_agc_speed.agc_decim     = Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_OFF;\
+        api->prop->dtv_initial_agc_speed.if_agc_speed  = Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO;\
+        api->prop->dtv_initial_agc_speed_period.period = 310;\
+        api->prop->dtv_agc_speed.agc_decim             = Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_4;\
+        api->prop->dtv_agc_speed.if_agc_speed          = Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_39;\
+      }\
+      Si2158_L1_SetProperty2(api, Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_CODE);\
+      Si2158_L1_SetProperty2(api, Si2158_DTV_AGC_SPEED_PROP_CODE);
+
+
+    #define   L1_RF_TER_TUNER_FEF_MODE_SLOW_NORMAL_AGC_SETUP(api,fef) \
+      api->prop->dtv_initial_agc_speed_period.period = 0;\
+      if (fef == 0) {\
+        api->prop->dtv_agc_speed.agc_decim             = Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF;\
+        api->prop->dtv_agc_speed.if_agc_speed          = Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO;\
+      } else {\
+        api->prop->dtv_agc_speed.if_agc_speed          = Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_39;\
+        api->prop->dtv_agc_speed.agc_decim             = Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_4;\
+      }\
+      Si2158_L1_SetProperty2(api, Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_CODE);\
+      Si2158_L1_SetProperty2(api, Si2158_DTV_AGC_SPEED_PROP_CODE);
+
+    #define   L1_RF_TER_TUNER_FEF_MODE_SLOW_NORMAL_AGC(api,fef) \
+      if (fef == 0) {\
+        api->prop->dtv_agc_speed.agc_decim             = Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF;\
+        api->prop->dtv_agc_speed.if_agc_speed          = Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO;\
+      } else {\
+        api->prop->dtv_agc_speed.if_agc_speed          = Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_39;\
+        api->prop->dtv_agc_speed.agc_decim             = Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_4;\
+      }\
+      Si2158_L1_SetProperty2(api, Si2158_DTV_AGC_SPEED_PROP_CODE);
+
+    #define TER_TUNER_ATV_LO_INJECTION(api) \
+      api->prop->tuner_lo_injection.band_1 = Si2158_TUNER_LO_INJECTION_PROP_BAND_1_HIGH_SIDE;\
+      api->prop->tuner_lo_injection.band_2 = Si2158_TUNER_LO_INJECTION_PROP_BAND_2_HIGH_SIDE;\
+      api->prop->tuner_lo_injection.band_3 = Si2158_TUNER_LO_INJECTION_PROP_BAND_3_HIGH_SIDE;\
+      Si2158_L1_SetProperty2(api, Si2158_TUNER_LO_INJECTION_PROP_CODE);
+
+    #define TER_TUNER_DTV_LO_INJECTION(api) \
+      api->prop->tuner_lo_injection.band_1 = Si2158_TUNER_LO_INJECTION_PROP_BAND_1_HIGH_SIDE;\
+      api->prop->tuner_lo_injection.band_2 = Si2158_TUNER_LO_INJECTION_PROP_BAND_2_LOW_SIDE;\
+      api->prop->tuner_lo_injection.band_3 = Si2158_TUNER_LO_INJECTION_PROP_BAND_3_LOW_SIDE;\
+      Si2158_L1_SetProperty2(api, Si2158_TUNER_LO_INJECTION_PROP_CODE);
+
+/*si2168 typedef*/
+#define Si2168_BYTES_PER_LINE 8
+
+#define Si2168_TERRESTRIAL 1
+  #define Si2168_DVBT_MIN_LOCK_TIME    100
+  #define Si2168_DVBT_MAX_LOCK_TIME   5000
+
+  #define Si2168_DVBT2_MIN_LOCK_TIME   100
+  #define Si2168_DVBT2_MAX_LOCK_TIME  5000
+
+  #define Si2168_DVBC_MIN_LOCK_TIME     80
+  #define Si2168_DVBC_MAX_LOCK_TIME   2000
+  #define Si2168_DVBC_MAX_SEARCH_TIME 5000
+
+  #define Si2168_TER_MAX_SEARCH_TIME 10000
+    
+/******************************************************************************/
+/* Clock sources definition (allows using 'clear' names for clock sources)    */
+/******************************************************************************/
+typedef enum Si2168_CLOCK_SOURCE {
+  Si2168_Xtal_clock = 0,
+  Si2168_TER_Tuner_clock,
+  Si2168_SAT_Tuner_clock
+} Si2168_CLOCK_SOURCE;
+/******************************************************************************/
+/* TER and SAT clock source selection (used by Si2168_switch_to_standard)     */
+/* ( possible values are those defined above in Si2168_CLOCK_SOURCE )         */
+/******************************************************************************/
+#define Si2168_TER_CLOCK_SOURCE            Si2168_TER_Tuner_clock
+#define Si2168_SAT_CLOCK_SOURCE            Si2168_TER_Tuner_clock
+
+/******************************************************************************/
+/* TER Tuner FEF management options */
+/******************************************************************************/
+#define Si2168_FEF_MODE_SLOW_NORMAL_AGC  0
+#define Si2168_FEF_MODE_FREEZE_PIN       1
+#define Si2168_FEF_MODE_SLOW_INITIAL_AGC 2
+/******************************************************************************/
+/* TER Tuner FEF management selection (possible values are defined above) */
+/* NB : This selection is the referred?solution.                           */
+/* The code will use more compilation flags to slect the final mode based     */
+/*  on what the TER tuner can actually do.                                    */
+/******************************************************************************/
+#define Si2168_FEF_MODE    Si2168_FEF_MODE_FREEZE_PIN
+
+#define NO_Si2168_ERROR                     0x00
+#define ERROR_Si2168_PARAMETER_OUT_OF_RANGE 0x01
+#define ERROR_Si2168_ALLOCATING_CONTEXT     0x02
+#define ERROR_Si2168_SENDING_COMMAND        0x03
+#define ERROR_Si2168_CTS_TIMEOUT            0x04
+#define ERROR_Si2168_ERR                    0x05
+#define ERROR_Si2168_POLLING_CTS            0x06
+#define ERROR_Si2168_POLLING_RESPONSE       0x07
+#define ERROR_Si2168_LOADING_FIRMWARE       0x08
+#define ERROR_Si2168_LOADING_BOOTBLOCK      0x09
+#define ERROR_Si2168_STARTING_FIRMWARE      0x0a
+#define ERROR_Si2168_SW_RESET               0x0b
+#define ERROR_Si2168_INCOMPATIBLE_PART      0x0c
+
+typedef struct L1_Si2168_Context {
+  L0_Context                 *i2c;
+  L0_Context                  i2cObj;
+  Si2168_CmdObj              *cmd;
+  Si2168_CmdObj               cmdObj;
+  Si2168_CmdReplyObj         *rsp;
+  Si2168_CmdReplyObj          rspObj;
+  Si2168_PropObj             *prop;
+  Si2168_PropObj              propObj;
+  Si2168_COMMON_REPLY_struct *status;
+  Si2168_COMMON_REPLY_struct  statusObj;
+  int                         standard;
+  int                         media;
+  unsigned int                tuner_ter_chip;
+  unsigned int                tuner_ter_clock_freq;
+  unsigned int                tuner_ter_clock_input;
+  unsigned int  tuner_rssi;
+  unsigned int  fef_mode;
+  unsigned int  ts_bus_mode;
+  unsigned int  ts_clock_mode;
+} L1_Si2168_Context;
+
+typedef struct Si2168_L2_Context {
+   L1_Si2168_Context *demod;
+   TER_TUNER_CONTEXT *tuner_ter;
+   L1_Si2168_Context  demodObj;
+   TER_TUNER_CONTEXT  tuner_terObj;
+   int                first_init_done;
+   int                Si2168_init_done;
+   int                TER_init_done;
+   int                TER_tuner_init_done;
+   unsigned char      auto_detect_TER;
+   int                standard;
+   int                detected_rf;
+   int                previous_standard;
+   int                tuneUnitHz;
+   int                rangeMin;
+   int                rangeMax;
+   int                seekBWHz;
+   int                seekStepHz;
+   int                minSRbps;
+   int                maxSRbps;
+   int                minRSSIdBm;
+   int                maxRSSIdBm;
+   int                minSNRHalfdB;
+   int                maxSNRHalfdB;
+   int                seekAbort;
+   unsigned char      seekRunning;
+   int                center_rf;
+} Si2168_L2_Context;
+
+typedef struct SILABS_TER_TUNER_Config       {
+  unsigned char nSel_dtv_out_type;
+  unsigned char nSel_dtv_agc_source;
+  int           nSel_dtv_lif_freq_offset;
+  unsigned char nSel_dtv_mode_bw;
+  unsigned char nSel_dtv_mode_invert_spectrum;
+  unsigned char nSel_dtv_mode_modulation;
+  unsigned char nSel_atv_video_mode_video_sys;
+  unsigned char nSel_atv_audio_mode_audio_sys;
+  unsigned char nSel_atv_atv_video_mode_tran;
+  unsigned char nSel_atv_video_mod_color;
+  unsigned char nSel_atv_mode_invert_spectrum;
+  unsigned char nSel_atv_mode_invert_signal;
+  char          nSel_atv_cvbs_out_fine_amp;
+  char          nSel_atv_cvbs_out_fine_offset;
+  unsigned char nSel_atv_sif_out_amp;
+  unsigned char nSel_atv_sif_out_offset;
+  unsigned char if_agc_speed;
+  char          nSel_dtv_rf_top;
+  char          nSel_atv_rf_top;
+  unsigned long nLocked_Freq;
+  unsigned long nCenter_Freq;
+  int           nCriteriaStep;
+  int           nLeftMax;
+  int           nRightMax;
+  int           nReal_Step;
+  int           nBeforeStep;
+} SILABS_TER_TUNER_Config;
+
+typedef struct SILABS_SAT_TUNER_Config       {
+    int    RF;
+    int    IF;
+    int    minRF;
+    int    maxRF;
+    u32 xtal;
+    u32 LPF;
+    int    tunerBytesCount;
+    int    I2CMuxChannel;
+    u32 RefDiv_value;
+    int    Mash_Per;
+    CONNECTION_TYPE connType;
+    unsigned char tuner_log[40];
+    unsigned char tuner_read[7];
+    char          nSel_att_top;
+} SILABS_SAT_TUNER_Config;
+
+typedef struct SILABS_CARRIER_Config         {
+  int                freq;
+  int                bandwidth;
+  int                stream;
+  int                symbol_rate;
+  int                constellation;
+  int                polarization;
+  int                band;
+} SILABS_CARRIER_Config;
+
+typedef struct SILABS_ANALOG_CARRIER_Config  {
+  unsigned char      video_sys;
+  unsigned char      trans;
+  unsigned char      color;
+  unsigned char      invert_signal;
+  unsigned char      invert_spectrum;
+} SILABS_ANALOG_CARRIER_Config;
+
+typedef struct SILABS_ANALOG_SIF_Config      {
+  unsigned char      stereo_sys;
+} SILABS_ANALOG_SIF_Config;
+
+typedef struct SILABS_FE_Context             {
+  struct i2c_adapter *i2c;
+  u32 Silabs_init_done;
+  unsigned int       chip;
+  unsigned int       tuner_ter;
+  unsigned int       tuner_sat;
+#ifdef    Si2168_COMPATIBLE
+  Si2168_L2_Context *Si2168_FE;
+  Si2168_L2_Context  Si2168_FE_Obj;
+#endif /* Si2168_COMPATIBLE */
+  int                standard;
+  int                init_ok;
+  int                polarization;
+  int                band;
+  SILABS_TER_TUNER_Config      TER_Tuner_Cfg;
+  SILABS_SAT_TUNER_Config      SAT_Tuner_Cfg;
+  SILABS_CARRIER_Config        Carrier_Cfg;
+  SILABS_ANALOG_CARRIER_Config Analog_Cfg;
+  SILABS_ANALOG_SIF_Config     Analog_Sif_Cfg;
+} SILABS_FE_Context;
+
+/* Standard code values used by the top-level application               */
+/* <porting> set these values to match the top-level application values */
+typedef enum   CUSTOM_Standard_Enum          {
+  SILABS_ANALOG = 4,
+  SILABS_DVB_T  = 0,
+  SILABS_DVB_C  = 1,
+  SILABS_DVB_S  = 2,
+  SILABS_DVB_S2 = 3,
+  SILABS_DVB_T2 = 5,
+  SILABS_DSS    = 6,
+  SILABS_MCNS   = 7,
+  SILABS_DVB_C2 = 8,
+  SILABS_SLEEP  = 100,
+} CUSTOM_Standard_Enum;
+
+typedef enum   CUSTOM_Polarization_Enum      {
+  SILABS_POLARIZATION_HORIZONTAL  = 0,
+  SILABS_POLARIZATION_VERTICAL    = 1,
+
+} CUSTOM_Polarization_Enum;
+
+typedef enum   CUSTOM_Band_Enum              {
+  SILABS_BAND_LOW  = 0,
+  SILABS_BAND_HIGH = 1,
+
+} CUSTOM_Band_Enum;
+
+typedef enum   CUSTOM_Stream_Enum            {
+  SILABS_HP = 0,
+  SILABS_LP = 1
+} CUSTOM_Stream_Enum;
+
+typedef enum   CUSTOM_FFT_Mode_Enum          {
+  SILABS_FFT_MODE_2K  = 0,
+  SILABS_FFT_MODE_4K  = 1,
+  SILABS_FFT_MODE_8K  = 2,
+  SILABS_FFT_MODE_16K = 3,
+  SILABS_FFT_MODE_32K = 4,
+  SILABS_FFT_MODE_1K = 5
+} CUSTOM_FFT_Mode_Enum;
+
+typedef enum   CUSTOM_GI_Enum                {
+  SILABS_GUARD_INTERVAL_1_32    = 0,
+  SILABS_GUARD_INTERVAL_1_16    = 1,
+  SILABS_GUARD_INTERVAL_1_8     = 2,
+  SILABS_GUARD_INTERVAL_1_4     = 3,
+  SILABS_GUARD_INTERVAL_1_128   = 4,
+  SILABS_GUARD_INTERVAL_19_128  = 5,
+  SILABS_GUARD_INTERVAL_19_256  = 6
+} CUSTOM_GI_Enum;
+
+typedef enum   CUSTOM_Constel_Enum           {
+  SILABS_QAMAUTO = -1,
+  SILABS_QAM16   = 0,
+  SILABS_QAM32   = 1,
+  SILABS_QAM64   = 2,
+  SILABS_QAM128  = 3,
+  SILABS_QAM256  = 4,
+  SILABS_QPSK    = 5,
+  SILABS_8PSK    = 6
+} CUSTOM_Constel_Enum;
+
+typedef enum   CUSTOM_Hierarchy_Enum         {
+  SILABS_HIERARCHY_NONE  = 0,
+  SILABS_HIERARCHY_ALFA1 = 1,
+  SILABS_HIERARCHY_ALFA2 = 2,
+  SILABS_HIERARCHY_ALFA4 = 3
+} CUSTOM_Hierarchy_Enum;
+
+typedef enum   CUSTOM_Coderate_Enum          {
+  SILABS_CODERATE_1_2  = 0,
+  SILABS_CODERATE_2_3  = 1,
+  SILABS_CODERATE_3_4  = 2,
+  SILABS_CODERATE_4_5  = 3,
+  SILABS_CODERATE_5_6  = 4,
+  SILABS_CODERATE_7_8  = 5,
+  SILABS_CODERATE_8_9  = 6,
+  SILABS_CODERATE_9_10 = 7,
+  SILABS_CODERATE_1_3  = 8,
+  SILABS_CODERATE_1_4  = 9,
+  SILABS_CODERATE_2_5  = 10,
+  SILABS_CODERATE_3_5  = 11,
+} CUSTOM_Coderate_Enum;
+
+typedef enum   CUSTOM_Pilot_Pattern_Enum     {
+  SILABS_PILOT_PATTERN_PP1 = 1,
+  SILABS_PILOT_PATTERN_PP2 = 2,
+  SILABS_PILOT_PATTERN_PP3 = 3,
+  SILABS_PILOT_PATTERN_PP4 = 4,
+  SILABS_PILOT_PATTERN_PP5 = 5,
+  SILABS_PILOT_PATTERN_PP6 = 6,
+  SILABS_PILOT_PATTERN_PP7 = 7,
+  SILABS_PILOT_PATTERN_PP8 = 8,
+} CUSTOM_Pilot_Pattern_Enum;
+
+typedef enum   CUSTOM_TS_Mode_Enum           {
+  SILABS_TS_TRISTATE = 0,
+  SILABS_TS_SERIAL   = 1,
+  SILABS_TS_PARALLEL = 2,
+  SILABS_TS_GPIF     = 3
+} CUSTOM_TS_Mode_Enum;
+
+typedef struct CUSTOM_Status_Struct          {
+  CUSTOM_Standard_Enum standard;
+  int      clock_mode;
+  int      demod_lock;
+  int      fec_lock;
+  int      fec_lock_in_range;
+  u32   c_n;
+  u32   ber;
+  u32   per;
+  u32   fer;
+    
+  int      uncorrs;
+  int      RFagc;
+  int      IFagc;
+  int      RFlevel;
+  long     freq_offset;
+  long     timing_offset;
+  int      bandwidth_Hz;
+  int      stream;
+  int      fft_mode;
+  int      guard_interval;
+  int      constellation;
+  unsigned int symbol_rate;
+  int      code_rate_hp;
+  int      code_rate_lp;
+  int      hierarchy;
+  int      spectral_inversion;
+  int      code_rate;
+  int      pilots;
+  int      cell_id;
+  int RSSI;  
+  int      SSI;
+  int      SQI;
+  int      tuner_lock;
+  int      rotated;
+  int      pilot_pattern;
+  int      bw_ext;
+  int      TS_bitrate_kHz;
+  int      TS_clock_kHz;
+  /*        T2/C2 specifics (PLP) */
+  int      num_plp;
+  int      plp_id;
+  /* End of T2/C2 specifics (PLP) */
+  int      tx_mode;
+  int      short_frame;
+  unsigned char attctrl;
+  /* TUNER_STATUS */
+  unsigned char   tcint;
+  unsigned char   rssilint;
+  unsigned char   rssihint;
+           int    vco_code;
+  unsigned char   tc;
+  unsigned char   rssil;
+  unsigned char   rssih;
+           char   rssi;
+  unsigned long   freq;
+  unsigned char   mode;
+  /* ATV_STATUS & DTV_STATUS */
+  unsigned char   chl;
+  /* ATV_STATUS */
+  int      ATV_Sync_Lock;
+  int      ATV_Master_Lock;
+  unsigned char   audio_chan_filt_bw;
+  unsigned char   snrl;
+  unsigned char   snrh;
+  unsigned char   video_snr;
+           int    afc_freq;
+           int    video_sc_spacing;
+  unsigned char   video_sys;
+  unsigned char   color;
+  unsigned char   trans;
+  unsigned char   audio_sys;
+  unsigned char   audio_demod_mode;
+  /* DTV_STATUS */
+  unsigned char   chlint;
+  unsigned char   bw;
+  unsigned char   modulation;
+  unsigned char   fef;
+  /* MCNS STATUS */
+  unsigned char   interleaving;
+} CUSTOM_Status_Struct;
+
+/*SI2168 demod*/
+unsigned char Si2168_CurrentResponseStatus (L1_Si2168_Context *api, unsigned char ptDataBuffer);
+unsigned char Si2168_L1_DD_STATUS                 (L1_Si2168_Context *api,
+                                           unsigned char   intack);
+unsigned char Si2168_L1_I2C_PASSTHROUGH (L1_Si2168_Context *api,
+                                           unsigned char   subcode,
+                                           unsigned char   i2c_passthru,
+                                           unsigned char   reserved);
+unsigned char Si2168_L1_CONFIG_CLKIO              (L1_Si2168_Context *api,
+                                           unsigned char   output,
+                                           unsigned char   pre_driver_str,
+                                           unsigned char   driver_str);
+unsigned char Si2168_L1_CONFIG_PINS               (L1_Si2168_Context *api,
+                                           unsigned char   gpio0_mode,
+                                           unsigned char   gpio0_read,
+                                           unsigned char   gpio1_mode,
+                                           unsigned char   gpio1_read);
+unsigned char Si2168_L1_DD_BER                    (L1_Si2168_Context *api,
+                                           unsigned char   rst);                                                   
+unsigned char Si2168_L1_DD_CBER                   (L1_Si2168_Context *api,
+                                           unsigned char   rst);
+unsigned char Si2168_L1_DD_EXT_AGC_TER            (L1_Si2168_Context *api,
+                                           unsigned char   agc_1_mode,
+                                           unsigned char   agc_1_inv,
+                                           unsigned char   agc_2_mode,
+                                           unsigned char   agc_2_inv,
+                                           unsigned char   agc_1_kloop,
+                                           unsigned char   agc_2_kloop,
+                                           unsigned char   agc_1_min,
+                                           unsigned char   agc_2_min);
+unsigned char Si2168_L1_DD_FER                    (L1_Si2168_Context *api,
+                                           unsigned char   rst);
+unsigned char Si2168_L1_DD_GET_REG                (L1_Si2168_Context *api,
+                                           unsigned char   reg_code_lsb,
+                                           unsigned char   reg_code_mid,
+                                           unsigned char   reg_code_msb);                                                   
+unsigned char Si2168_L1_DD_MP_DEFAULTS            (L1_Si2168_Context *api,
+                                           unsigned char   mp_a_mode,
+                                           unsigned char   mp_b_mode,
+                                           unsigned char   mp_c_mode,
+                                           unsigned char   mp_d_mode);
+unsigned char Si2168_L1_DD_PER                    (L1_Si2168_Context *api,
+                                           unsigned char   rst);
+unsigned char Si2168_L1_DD_RESTART                (L1_Si2168_Context *api);
+unsigned char Si2168_L1_DD_SET_REG                (L1_Si2168_Context *api,
+                                           unsigned char   reg_code_lsb,
+                                           unsigned char   reg_code_mid,
+                                           unsigned char   reg_code_msb,
+                                           unsigned long   value);
+unsigned char Si2168_L1_DD_SSI_SQI                (L1_Si2168_Context *api,
+                                                     char  tuner_rssi);                                                   
+unsigned char Si2168_L1_DD_UNCOR                  (L1_Si2168_Context *api,
+                                           unsigned char   rst);
+unsigned char Si2168_L1_DOWNLOAD_DATASET_CONTINUE (L1_Si2168_Context *api,
+                                           unsigned char   data0,
+                                           unsigned char   data1,
+                                           unsigned char   data2,
+                                           unsigned char   data3,
+                                           unsigned char   data4,
+                                           unsigned char   data5,
+                                           unsigned char   data6);
+unsigned char Si2168_L1_DOWNLOAD_DATASET_START    (L1_Si2168_Context *api,
+                                           unsigned char   dataset_id,
+                                           unsigned char   dataset_checksum,
+                                           unsigned char   data0,
+                                           unsigned char   data1,
+                                           unsigned char   data2,
+                                           unsigned char   data3,
+                                           unsigned char   data4);
+unsigned char Si2168_L1_DVBC_STATUS               (L1_Si2168_Context *api,
+                                           unsigned char   intack);
+unsigned char Si2168_L1_DVBT2_FEF                 (L1_Si2168_Context *api,
+                                           unsigned char   fef_tuner_flag,
+                                           unsigned char   fef_tuner_flag_inv);
+unsigned char Si2168_L1_DVBT2_PLP_INFO            (L1_Si2168_Context *api,
+                                           unsigned char   plp_index);
+unsigned char Si2168_L1_DVBT2_PLP_SELECT          (L1_Si2168_Context *api,
+                                           unsigned char   plp_id,
+                                           unsigned char   plp_id_sel_mode);
+unsigned char Si2168_L1_DVBT2_STATUS              (L1_Si2168_Context *api,
+                                           unsigned char   intack);
+unsigned char Si2168_L1_DVBT2_TX_ID               (L1_Si2168_Context *api);
+unsigned char Si2168_L1_DVBT_STATUS               (L1_Si2168_Context *api,
+                                           unsigned char   intack);
+unsigned char Si2168_L1_DVBT_TPS_EXTRA            (L1_Si2168_Context *api);
+unsigned char Si2168_L1_EXIT_BOOTLOADER           (L1_Si2168_Context *api,
+                                           unsigned char   func,
+                                           unsigned char   ctsien);
+unsigned char Si2168_L1_GET_PROPERTY              (L1_Si2168_Context *api,
+                                           unsigned char   reserved,
+                                           unsigned int    prop);
+unsigned char Si2168_L1_GET_REV                   (L1_Si2168_Context *api);
+unsigned char Si2168_L1_PART_INFO                 (L1_Si2168_Context *api);
+unsigned char Si2168_L1_POWER_DOWN                (L1_Si2168_Context *api);
+unsigned char Si2168_L1_POWER_UP                  (L1_Si2168_Context *api,
+                                           unsigned char   subcode,
+                                           unsigned char   reset,
+                                           unsigned char   reserved2,
+                                           unsigned char   reserved4,
+                                           unsigned char   reserved1,
+                                           unsigned char   addr_mode,
+                                           unsigned char   reserved5,
+                                           unsigned char   func,
+                                           unsigned char   clock_freq,
+                                           unsigned char   ctsien,
+                                           unsigned char   wake_up);
+unsigned char Si2168_L1_RSSI_ADC                  (L1_Si2168_Context *api,
+                                           unsigned char   on_off);
+unsigned char Si2168_L1_SCAN_CTRL                 (L1_Si2168_Context *api,
+                                           unsigned char   action,
+                                           unsigned long   tuned_rf_freq);
+unsigned char Si2168_L1_SCAN_STATUS               (L1_Si2168_Context *api,
+                                           unsigned char   intack);
+unsigned char Si2168_L1_SET_PROPERTY              (L1_Si2168_Context *api,
+                                           unsigned char   reserved,
+                                           unsigned int    prop,
+                                           unsigned int    data);
+unsigned char Si2168_L1_START_CLK                 (L1_Si2168_Context *api,
+                                           unsigned char   subcode,
+                                           unsigned char   reserved1,
+                                           unsigned char   tune_cap,
+                                           unsigned char   reserved2,
+                                           unsigned int    clk_mode,
+                                           unsigned char   reserved3,
+                                           unsigned char   reserved4,
+                                           unsigned char   start_clk);
+char*            Si2168_L1_API_ERROR_TEXT(unsigned char error_code);
+unsigned char    Si2168_L1_API_Patch     (L1_Si2168_Context *api, int iNbBytes, unsigned char *pucDataBuffer);
+unsigned char   Si2168_L1_SendCommand2(L1_Si2168_Context *api, unsigned int cmd_code);
+unsigned char    Si2168_L1_API_Init      (L1_Si2168_Context *api, int add);
+unsigned char Si2168_L1_SetProperty(L1_Si2168_Context *api, unsigned int prop, int  data);
+unsigned char Si2168_L1_SetProperty2(L1_Si2168_Context *api, unsigned int prop_code);
+unsigned char Si2168_pollForResponse (L1_Si2168_Context *api, unsigned int nbBytes, unsigned char *pByteBuffer);
+
+unsigned char Si2168_L2_Tuner_I2C_Enable (Si2168_L2_Context *front_end);
+unsigned char Si2168_L2_Tuner_I2C_Disable(Si2168_L2_Context *front_end);
+int  Si2168_L2_TER_FEF            (Si2168_L2_Context *front_end, int fef);	
+int  Si2168_L2_TER_FEF_SETUP      (Si2168_L2_Context *front_end, int fef);
+int  Si2168_TerAutoDetect         (Si2168_L2_Context *front_end);
+int  Si2168_TerAutoDetectOff      (Si2168_L2_Context *front_end);
+char Si2168_L2_SW_Init(Si2168_L2_Context *front_end, int demodAdd, int tunerAdd_Ter);
+                          
+char* SiLabs_API_TAG_TEXT      (void);
+int   SiLabs_chip_detect                  (int demodAdd);
+int   SiLabs_API_TER_AutoDetect           (SILABS_FE_Context *front_end, int on_off);
+char  SiLabs_API_SW_Init(SILABS_FE_Context *front_end, int demodAdd, int tunerAdd_Ter, int tunerAdd_Sat);
+int   SiLabs_API_TS_Mode                  (SILABS_FE_Context *front_end, int ts_mode);
+int   SiLabs_API_Tuner_I2C_Enable         (SILABS_FE_Context *front_end);
+int   SiLabs_API_Tuner_I2C_Disable        (SILABS_FE_Context *front_end);
+char *Silabs_Constel_Text                 (CUSTOM_Constel_Enum   constel);
+char *Silabs_Polarization_Text            (CUSTOM_Polarization_Enum   polarization);
+char *Silabs_Band_Text                    (CUSTOM_Band_Enum      band);
+char *Silabs_Stream_Text                  (CUSTOM_Stream_Enum    stream);
+char *Silabs_Standard_Text                (CUSTOM_Standard_Enum  standard);
+char *Si2168_standardName (int standard);
+int   SiLabs_API_SAT_Tuner_status         (SILABS_FE_Context* front_end, CUSTOM_Status_Struct *status);
+int   SiLabs_API_TER_Tuner_status         (SILABS_FE_Context* front_end, CUSTOM_Status_Struct *status);
+int   SiLabs_API_Demod_status             (SILABS_FE_Context* front_end, CUSTOM_Status_Struct *status);
+int   SiLabs_API_FE_status                (SILABS_FE_Context* front_end, CUSTOM_Status_Struct *status);	
+int   Custom_standardCode                 (SILABS_FE_Context* front_end, int standard);
+int   Custom_streamCode                   (SILABS_FE_Context* front_end, int stream);
+int   Custom_fftCode                      (SILABS_FE_Context* front_end, int fft);
+int   Custom_giCode                       (SILABS_FE_Context* front_end, int gi);
+int   Custom_constelCode                  (SILABS_FE_Context* front_end, int constel);
+int   Custom_hierarchyCode                (SILABS_FE_Context* front_end, int hierarchy);
+int   Custom_coderateCode                 (SILABS_FE_Context* front_end, int coderate);
+int   Custom_pilotPatternCode             (SILABS_FE_Context* front_end, int pilot_pattern);
+int   Silabs_standardCode                 (SILABS_FE_Context* front_end, CUSTOM_Standard_Enum          standard);
+int   Silabs_constelCode                  (SILABS_FE_Context* front_end, CUSTOM_Constel_Enum           constel);
+int   Silabs_streamCode                   (SILABS_FE_Context* front_end, CUSTOM_Stream_Enum            stream);
+
+int Si2168_Configure           (L1_Si2168_Context *api);
+int Si2168_STANDBY             (L1_Si2168_Context *api);
+int Si2168_WAKEUP              (L1_Si2168_Context *api);
+int  Si2168_Media              (L1_Si2168_Context *api, int modulation);
+int Si2168_PowerUpWithPatch    (L1_Si2168_Context *api);
+int Si2168_LoadFirmware        (L1_Si2168_Context *api, unsigned char fw_table[], int nbLines);
+int Si2168_StartFirmware       (L1_Si2168_Context *api);
+int Si2168_Init                (L1_Si2168_Context *api);
+
+int  Si2168_L2_switch_to_standard (Si2168_L2_Context *front_end, int new_standard, unsigned char force_full_init);
+int   SiLabs_API_switch_to_standard       (SILABS_FE_Context *front_end, int standard, unsigned char force_full_init);
+
+void Si2168_setupCOMMONDefaults     (L1_Si2168_Context *api);
+void Si2168_setupDDDefaults         (L1_Si2168_Context *api);
+void Si2168_setupDVBCDefaults       (L1_Si2168_Context *api);
+void Si2168_setupDVBTDefaults       (L1_Si2168_Context *api);
+void Si2168_setupDVBT2Defaults      (L1_Si2168_Context *api);
+void Si2168_setupSCANDefaults       (L1_Si2168_Context *api);	
+void Si2168_setupAllDefaults       (L1_Si2168_Context *api);
+
+int  Si2168_downloadCOMMONProperties(L1_Si2168_Context *api);
+int  Si2168_downloadDDProperties(L1_Si2168_Context *api);
+int  Si2168_downloadDVBCProperties(L1_Si2168_Context *api);
+int  Si2168_downloadDVBTProperties(L1_Si2168_Context *api);
+int  Si2168_downloadDVBT2Properties(L1_Si2168_Context *api);
+int  Si2168_downloadSCANProperties(L1_Si2168_Context *api);
+int Si2168_downloadAllProperties       (L1_Si2168_Context *api);
+
+int  Si2168_L2_Tune               (Si2168_L2_Context *front_end, int rf);
+int   Si2168_L2_lock_to_carrier   (Si2168_L2_Context *front_end, int standard, int freq, int dvb_t_bandwidth_hz, int dvb_t_stream, unsigned int symbol_rate_bps, int dvb_c_constellation, int dvb_t2_plp_id);
+int   SiLabs_API_lock_to_carrier          (SILABS_FE_Context *front_end, int standard, int freq, int bandwidth_Hz, int stream, unsigned int symbol_rate_bps, int constellation, int polarization, int band, int plp_id);
+
+/* SI2158 Tuner*/
+char*            Si2158_L1_API_ERROR_TEXT(unsigned char error_code);
+unsigned char Si2158_L1_DTV_STATUS      (L1_Si2158_Context *api, unsigned char   intack);
+unsigned char Si2158_L1_ATV_STATUS      (L1_Si2158_Context *api, unsigned char   intack);
+unsigned char Si2158_L1_TUNER_STATUS    (L1_Si2158_Context *api, unsigned char   intack);
+unsigned char Si2158_L1_STANDBY         (L1_Si2158_Context *api, unsigned char   type);
+unsigned char Si2158_L1_AGC_OVERRIDE    (L1_Si2158_Context *api,
+                                 unsigned char   force_max_gain,
+                                 unsigned char   force_top_gain);
+unsigned char Si2158_L1_ATV_CW_TEST     (L1_Si2158_Context *api,
+                                 unsigned char   pc_lock);
+unsigned char Si2158_L1_ATV_RESTART     (L1_Si2158_Context *api);
+unsigned char Si2158_L1_CONFIG_PINS     (L1_Si2158_Context *api,
+                                 unsigned char   gpio1_mode,
+                                 unsigned char   gpio1_read,
+                                 unsigned char   gpio2_mode,
+                                 unsigned char   gpio2_read,
+                                 unsigned char   reserved1,
+                                 unsigned char   reserved2,
+                                 unsigned char   reserved3);
+unsigned char Si2158_L1_DTV_RESTART     (L1_Si2158_Context *api);
+unsigned char Si2158_L1_EXIT_BOOTLOADER (L1_Si2158_Context *api,
+                                 unsigned char   func,
+                                 unsigned char   ctsien);
+unsigned char Si2158_L1_FINE_TUNE       (L1_Si2158_Context *api,
+                                 unsigned char   persistence,
+                                 unsigned char   apply_to_lif,
+                                           int   offset_500hz);
+unsigned char Si2158_L1_GET_PROPERTY    (L1_Si2158_Context *api,
+                                 unsigned char   reserved,
+                                 unsigned int    prop);
+unsigned char Si2158_L1_GET_REV         (L1_Si2158_Context *api);
+unsigned char Si2158_L1_PART_INFO       (L1_Si2158_Context *api);
+unsigned char Si2158_L1_POWER_DOWN      (L1_Si2158_Context *api);
+unsigned char Si2158_L1_POWER_DOWN_HW   (L1_Si2158_Context *api,
+                                 unsigned char   subcode,
+                                 unsigned char   pd_xo_osc,
+                                 unsigned char   reserved1,
+                                 unsigned char   en_xout,
+                                 unsigned char   reserved2,
+                                 unsigned char   pd_ldo,
+                                 unsigned char   reserved3,
+                                 unsigned char   reserved4,
+                                 unsigned char   reserved5,
+                                 unsigned char   reserved6,
+                                 unsigned char   reserved7,
+                                 unsigned char   reserved8);
+unsigned char Si2158_L1_POWER_UP        (L1_Si2158_Context *api,
+                                 unsigned char   subcode,
+                                 unsigned char   clock_mode,
+                                 unsigned char   en_xout,
+                                 unsigned char   pd_ldo,
+                                 unsigned char   reserved2,
+                                 unsigned char   reserved3,
+                                 unsigned char   reserved4,
+                                 unsigned char   reserved5,
+                                 unsigned char   reserved6,
+                                 unsigned char   reserved7,
+                                 unsigned char   reset,
+                                 unsigned char   clock_freq,
+                                 unsigned char   reserved8,
+                                 unsigned char   func,
+                                 unsigned char   ctsien,
+                                 unsigned char   wake_up);
+unsigned char Si2158_L1_TUNER_TUNE_FREQ (L1_Si2158_Context *api,
+                                 unsigned char   mode,
+                                 unsigned long   freq);
+unsigned char   Si2158_L1_SendCommand2(L1_Si2158_Context *api, unsigned int cmd_code);
+unsigned char Si2158_CurrentResponseStatus (L1_Si2158_Context *api, unsigned char ptDataBuffer);
+unsigned char Si2158_pollForCTS (L1_Si2158_Context *api);
+unsigned char Si2158_pollForResponse (L1_Si2158_Context *api, unsigned int nbBytes, unsigned char *pByteBuffer);
+unsigned char    Si2158_L1_API_Init      (L1_Si2158_Context *api, int add);
+unsigned char    Si2158_L1_API_Patch     (L1_Si2158_Context *api, int iNbBytes, unsigned char *pucDataBuffer);
+unsigned char    Si2158_L1_CheckStatus   (L1_Si2158_Context *api);
+
+int Si2158_XoutOn             (L1_Si2158_Context *api);
+int Si2158_XoutOff            (L1_Si2158_Context *api);
+int Si2158_Configure           (L1_Si2158_Context *api);
+int Si2158_PowerUpWithPatch    (L1_Si2158_Context *api);
+int Si2158_LoadFirmware_16        (L1_Si2158_Context *api, firmware_struct fw_table[], int nbLines);
+int Si2158_LoadFirmware        (L1_Si2158_Context *api, unsigned char fw_table[], int nbLines);
+int Si2158_StartFirmware       (L1_Si2158_Context *api);
+int Si2158_Init                (L1_Si2158_Context *api);
+
+unsigned char Si2158_L1_CONFIG_CLOCKS   (L1_Si2158_Context *api,
+                                 unsigned char   subcode,
+                                 unsigned char   clock_mode,
+                                 unsigned char   en_xout);
+unsigned char Si2158_L1_SET_PROPERTY    (L1_Si2158_Context *api,
+                                 unsigned char   reserved,
+                                 unsigned int    prop,
+                                 unsigned int    data);
+
+unsigned char Si2158_L1_SetProperty(L1_Si2158_Context *api, unsigned int prop, int  data);
+unsigned char Si2158_L1_SetProperty2(L1_Si2158_Context *api, unsigned int prop_code);
+
+void Si2158_setupATVDefaults        (L1_Si2158_Context *api);
+void Si2158_setupCOMMONDefaults     (L1_Si2158_Context *api);
+void Si2158_setupDTVDefaults        (L1_Si2158_Context *api);
+void Si2158_setupTUNERDefaults      (L1_Si2158_Context *api);
+void Si2158_setupAllDefaults       (L1_Si2158_Context *api);
+
+int  Si2158_downloadATVProperties(L1_Si2158_Context *api);
+int  Si2158_downloadCOMMONProperties(L1_Si2158_Context *api);
+int  Si2158_downloadDTVProperties(L1_Si2158_Context *api);
+int  Si2158_downloadTUNERProperties(L1_Si2158_Context *api);
+int Si2158_downloadAllProperties       (L1_Si2158_Context *api);
+
+int  Si2158_Tune              (L1_Si2158_Context *api, unsigned char mode, unsigned long freq);
+int  Si2158_DTVTune           (L1_Si2158_Context *api, unsigned long freq, unsigned char bw, unsigned char modulation, unsigned char invert_spectrum);
+
+/*i2c*/
+void    L0_Init              (L0_Context *i2c);
+int     L0_SetAddress        (L0_Context* i2c, unsigned int add, int addSize);
+int     L0_WriteCommandBytes (L0_Context* i2c, int iNbBytes, unsigned char *pucDataBuffer);
+int     L0_WriteBytes        (L0_Context* i2c, unsigned int iI2CIndex, int iNbBytes, unsigned char *pucDataBuffer);
+int     L0_ReadCommandBytes  (L0_Context* i2c, int iNbBytes, unsigned char *pucDataBuffer);
+int     L0_ReadBytes         (L0_Context* i2c, unsigned int iI2CIndex, int iNbBytes, unsigned char *pucDataBuffer);
+int		delayMS(int ms);
+int		power_of_n (int n, int m);
+
+#define SI2168_DEMOD_ADDRESS  0x64 /*0xc8*/
+#define SI2158_TUNER_ADDRESS  0x60 /*0xc0*/
+
+extern int si2168_debug;
+#define SiTRACE(args...) \
+	do { \
+		if (si2168_debug) \
+			printk(KERN_INFO "si2168: " args); \
+	} while (0)
+	
+#define SiERROR           SiTRACE
+
+#endif /* SI2168_PRIV_H */
diff -urN a/drivers/media/dvb-frontends/si2168_properties.h b/drivers/media/dvb-frontends/si2168_properties.h
--- a/drivers/media/dvb-frontends/si2168_properties.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/si2168_properties.h	2013-02-17 18:09:43.000000000 +0800
@@ -0,0 +1,1150 @@
+/*************************************************************************/
+#ifndef   _Si2168_PROPERTIES_H_
+#define   _Si2168_PROPERTIES_H_
+
+/* _properties_defines_insertion_start */
+/* Si2168 DD_BER_RESOL property definition */
+#define   Si2168_DD_BER_RESOL_PROP 0x1003
+
+#ifdef    Si2168_DD_BER_RESOL_PROP
+  #define Si2168_DD_BER_RESOL_PROP_CODE 0x001003
+
+
+    typedef struct { /* Si2168_DD_BER_RESOL_PROP_struct */
+      unsigned char   exp;
+      unsigned char   mant;
+   } Si2168_DD_BER_RESOL_PROP_struct;
+
+   /* DD_BER_RESOL property, EXP field definition (NO TITLE)*/
+   #define  Si2168_DD_BER_RESOL_PROP_EXP_LSB         0
+   #define  Si2168_DD_BER_RESOL_PROP_EXP_MASK        0x0f
+   #define  Si2168_DD_BER_RESOL_PROP_EXP_DEFAULT    7
+    #define Si2168_DD_BER_RESOL_PROP_EXP_EXPLO_MIN  1
+    #define Si2168_DD_BER_RESOL_PROP_EXP_EXPLO_MAX  8
+
+   /* DD_BER_RESOL property, MANT field definition (NO TITLE)*/
+   #define  Si2168_DD_BER_RESOL_PROP_MANT_LSB         4
+   #define  Si2168_DD_BER_RESOL_PROP_MANT_MASK        0x0f
+   #define  Si2168_DD_BER_RESOL_PROP_MANT_DEFAULT    1
+    #define Si2168_DD_BER_RESOL_PROP_MANT_MANTLO_MIN  1
+    #define Si2168_DD_BER_RESOL_PROP_MANT_MANTLO_MAX  9
+
+#endif /* Si2168_DD_BER_RESOL_PROP */
+
+/* Si2168 DD_CBER_RESOL property definition */
+#define   Si2168_DD_CBER_RESOL_PROP 0x1002
+
+#ifdef    Si2168_DD_CBER_RESOL_PROP
+  #define Si2168_DD_CBER_RESOL_PROP_CODE 0x001002
+
+
+    typedef struct { /* Si2168_DD_CBER_RESOL_PROP_struct */
+      unsigned char   exp;
+      unsigned char   mant;
+   } Si2168_DD_CBER_RESOL_PROP_struct;
+
+   /* DD_CBER_RESOL property, EXP field definition (NO TITLE)*/
+   #define  Si2168_DD_CBER_RESOL_PROP_EXP_LSB         0
+   #define  Si2168_DD_CBER_RESOL_PROP_EXP_MASK        0x0f
+   #define  Si2168_DD_CBER_RESOL_PROP_EXP_DEFAULT    5
+    #define Si2168_DD_CBER_RESOL_PROP_EXP_EXPLO_MIN  1
+    #define Si2168_DD_CBER_RESOL_PROP_EXP_EXPLO_MAX  8
+
+   /* DD_CBER_RESOL property, MANT field definition (NO TITLE)*/
+   #define  Si2168_DD_CBER_RESOL_PROP_MANT_LSB         4
+   #define  Si2168_DD_CBER_RESOL_PROP_MANT_MASK        0x0f
+   #define  Si2168_DD_CBER_RESOL_PROP_MANT_DEFAULT    1
+    #define Si2168_DD_CBER_RESOL_PROP_MANT_MANTLO_MIN  1
+    #define Si2168_DD_CBER_RESOL_PROP_MANT_MANTLO_MAX  9
+
+#endif /* Si2168_DD_CBER_RESOL_PROP */
+
+
+/* Si2168 DD_FER_RESOL property definition */
+#define   Si2168_DD_FER_RESOL_PROP 0x100c
+
+#ifdef    Si2168_DD_FER_RESOL_PROP
+  #define Si2168_DD_FER_RESOL_PROP_CODE 0x00100c
+
+
+    typedef struct { /* Si2168_DD_FER_RESOL_PROP_struct */
+      unsigned char   exp;
+      unsigned char   mant;
+   } Si2168_DD_FER_RESOL_PROP_struct;
+
+   /* DD_FER_RESOL property, EXP field definition (NO TITLE)*/
+   #define  Si2168_DD_FER_RESOL_PROP_EXP_LSB         0
+   #define  Si2168_DD_FER_RESOL_PROP_EXP_MASK        0x0f
+   #define  Si2168_DD_FER_RESOL_PROP_EXP_DEFAULT    3
+    #define Si2168_DD_FER_RESOL_PROP_EXP_EXP_MIN  1
+    #define Si2168_DD_FER_RESOL_PROP_EXP_EXP_MAX  4
+
+   /* DD_FER_RESOL property, MANT field definition (NO TITLE)*/
+   #define  Si2168_DD_FER_RESOL_PROP_MANT_LSB         4
+   #define  Si2168_DD_FER_RESOL_PROP_MANT_MASK        0x0f
+   #define  Si2168_DD_FER_RESOL_PROP_MANT_DEFAULT    1
+    #define Si2168_DD_FER_RESOL_PROP_MANT_MANT_MIN  1
+    #define Si2168_DD_FER_RESOL_PROP_MANT_MANT_MAX  9
+
+#endif /* Si2168_DD_FER_RESOL_PROP */
+
+/* Si2168 DD_IEN property definition */
+#define   Si2168_DD_IEN_PROP 0x1006
+
+#ifdef    Si2168_DD_IEN_PROP
+  #define Si2168_DD_IEN_PROP_CODE 0x001006
+
+
+    typedef struct { /* Si2168_DD_IEN_PROP_struct */
+      unsigned char   ien_bit0;
+      unsigned char   ien_bit1;
+      unsigned char   ien_bit2;
+      unsigned char   ien_bit3;
+      unsigned char   ien_bit4;
+      unsigned char   ien_bit5;
+      unsigned char   ien_bit6;
+      unsigned char   ien_bit7;
+   } Si2168_DD_IEN_PROP_struct;
+
+   /* DD_IEN property, IEN_BIT0 field definition (NO TITLE)*/
+   #define  Si2168_DD_IEN_PROP_IEN_BIT0_LSB         0
+   #define  Si2168_DD_IEN_PROP_IEN_BIT0_MASK        0x01
+   #define  Si2168_DD_IEN_PROP_IEN_BIT0_DEFAULT    0
+    #define Si2168_DD_IEN_PROP_IEN_BIT0_DISABLE  0
+    #define Si2168_DD_IEN_PROP_IEN_BIT0_ENABLE   1
+
+   /* DD_IEN property, IEN_BIT1 field definition (NO TITLE)*/
+   #define  Si2168_DD_IEN_PROP_IEN_BIT1_LSB         1
+   #define  Si2168_DD_IEN_PROP_IEN_BIT1_MASK        0x01
+   #define  Si2168_DD_IEN_PROP_IEN_BIT1_DEFAULT    0
+    #define Si2168_DD_IEN_PROP_IEN_BIT1_DISABLE  0
+    #define Si2168_DD_IEN_PROP_IEN_BIT1_ENABLE   1
+
+   /* DD_IEN property, IEN_BIT2 field definition (NO TITLE)*/
+   #define  Si2168_DD_IEN_PROP_IEN_BIT2_LSB         2
+   #define  Si2168_DD_IEN_PROP_IEN_BIT2_MASK        0x01
+   #define  Si2168_DD_IEN_PROP_IEN_BIT2_DEFAULT    0
+    #define Si2168_DD_IEN_PROP_IEN_BIT2_DISABLE  0
+    #define Si2168_DD_IEN_PROP_IEN_BIT2_ENABLE   1
+
+   /* DD_IEN property, IEN_BIT3 field definition (NO TITLE)*/
+   #define  Si2168_DD_IEN_PROP_IEN_BIT3_LSB         3
+   #define  Si2168_DD_IEN_PROP_IEN_BIT3_MASK        0x01
+   #define  Si2168_DD_IEN_PROP_IEN_BIT3_DEFAULT    0
+    #define Si2168_DD_IEN_PROP_IEN_BIT3_DISABLE  0
+    #define Si2168_DD_IEN_PROP_IEN_BIT3_ENABLE   1
+
+   /* DD_IEN property, IEN_BIT4 field definition (NO TITLE)*/
+   #define  Si2168_DD_IEN_PROP_IEN_BIT4_LSB         4
+   #define  Si2168_DD_IEN_PROP_IEN_BIT4_MASK        0x01
+   #define  Si2168_DD_IEN_PROP_IEN_BIT4_DEFAULT    0
+    #define Si2168_DD_IEN_PROP_IEN_BIT4_DISABLE  0
+    #define Si2168_DD_IEN_PROP_IEN_BIT4_ENABLE   1
+
+   /* DD_IEN property, IEN_BIT5 field definition (NO TITLE)*/
+   #define  Si2168_DD_IEN_PROP_IEN_BIT5_LSB         5
+   #define  Si2168_DD_IEN_PROP_IEN_BIT5_MASK        0x01
+   #define  Si2168_DD_IEN_PROP_IEN_BIT5_DEFAULT    0
+    #define Si2168_DD_IEN_PROP_IEN_BIT5_DISABLE  0
+    #define Si2168_DD_IEN_PROP_IEN_BIT5_ENABLE   1
+
+   /* DD_IEN property, IEN_BIT6 field definition (NO TITLE)*/
+   #define  Si2168_DD_IEN_PROP_IEN_BIT6_LSB         6
+   #define  Si2168_DD_IEN_PROP_IEN_BIT6_MASK        0x01
+   #define  Si2168_DD_IEN_PROP_IEN_BIT6_DEFAULT    0
+    #define Si2168_DD_IEN_PROP_IEN_BIT6_DISABLE  0
+    #define Si2168_DD_IEN_PROP_IEN_BIT6_ENABLE   1
+
+   /* DD_IEN property, IEN_BIT7 field definition (NO TITLE)*/
+   #define  Si2168_DD_IEN_PROP_IEN_BIT7_LSB         7
+   #define  Si2168_DD_IEN_PROP_IEN_BIT7_MASK        0x01
+   #define  Si2168_DD_IEN_PROP_IEN_BIT7_DEFAULT    0
+    #define Si2168_DD_IEN_PROP_IEN_BIT7_DISABLE  0
+    #define Si2168_DD_IEN_PROP_IEN_BIT7_ENABLE   1
+
+#endif /* Si2168_DD_IEN_PROP */
+
+/* Si2168 DD_IF_INPUT_FREQ property definition */
+#define   Si2168_DD_IF_INPUT_FREQ_PROP 0x100b
+
+#ifdef    Si2168_DD_IF_INPUT_FREQ_PROP
+  #define Si2168_DD_IF_INPUT_FREQ_PROP_CODE 0x00100b
+
+
+    typedef struct { /* Si2168_DD_IF_INPUT_FREQ_PROP_struct */
+      unsigned int    offset;
+   } Si2168_DD_IF_INPUT_FREQ_PROP_struct;
+
+   /* DD_IF_INPUT_FREQ property, OFFSET field definition (NO TITLE)*/
+   #define  Si2168_DD_IF_INPUT_FREQ_PROP_OFFSET_LSB         0
+   #define  Si2168_DD_IF_INPUT_FREQ_PROP_OFFSET_MASK        0xffff
+   #define  Si2168_DD_IF_INPUT_FREQ_PROP_OFFSET_DEFAULT    5000
+    #define Si2168_DD_IF_INPUT_FREQ_PROP_OFFSET_OFFSET_MIN  0
+    #define Si2168_DD_IF_INPUT_FREQ_PROP_OFFSET_OFFSET_MAX  36000
+
+#endif /* Si2168_DD_IF_INPUT_FREQ_PROP */
+
+/* Si2168 DD_INT_SENSE property definition */
+#define   Si2168_DD_INT_SENSE_PROP 0x1007
+
+#ifdef    Si2168_DD_INT_SENSE_PROP
+  #define Si2168_DD_INT_SENSE_PROP_CODE 0x001007
+
+
+    typedef struct { /* Si2168_DD_INT_SENSE_PROP_struct */
+      unsigned char   neg_bit0;
+      unsigned char   neg_bit1;
+      unsigned char   neg_bit2;
+      unsigned char   neg_bit3;
+      unsigned char   neg_bit4;
+      unsigned char   neg_bit5;
+      unsigned char   neg_bit6;
+      unsigned char   neg_bit7;
+      unsigned char   pos_bit0;
+      unsigned char   pos_bit1;
+      unsigned char   pos_bit2;
+      unsigned char   pos_bit3;
+      unsigned char   pos_bit4;
+      unsigned char   pos_bit5;
+      unsigned char   pos_bit6;
+      unsigned char   pos_bit7;
+   } Si2168_DD_INT_SENSE_PROP_struct;
+
+   /* DD_INT_SENSE property, NEG_BIT0 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT0_LSB         0
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT0_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT0_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT0_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT0_ENABLE   1
+
+   /* DD_INT_SENSE property, NEG_BIT1 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT1_LSB         1
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT1_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT1_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT1_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT1_ENABLE   1
+
+   /* DD_INT_SENSE property, NEG_BIT2 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT2_LSB         2
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT2_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT2_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT2_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT2_ENABLE   1
+
+   /* DD_INT_SENSE property, NEG_BIT3 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT3_LSB         3
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT3_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT3_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT3_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT3_ENABLE   1
+
+   /* DD_INT_SENSE property, NEG_BIT4 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT4_LSB         4
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT4_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT4_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT4_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT4_ENABLE   1
+
+   /* DD_INT_SENSE property, NEG_BIT5 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT5_LSB         5
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT5_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT5_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT5_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT5_ENABLE   1
+
+   /* DD_INT_SENSE property, NEG_BIT6 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT6_LSB         6
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT6_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT6_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT6_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT6_ENABLE   1
+
+   /* DD_INT_SENSE property, NEG_BIT7 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT7_LSB         7
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT7_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_NEG_BIT7_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT7_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_NEG_BIT7_ENABLE   1
+
+   /* DD_INT_SENSE property, POS_BIT0 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT0_LSB         8
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT0_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT0_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT0_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT0_ENABLE   1
+
+   /* DD_INT_SENSE property, POS_BIT1 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT1_LSB         9
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT1_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT1_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT1_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT1_ENABLE   1
+
+   /* DD_INT_SENSE property, POS_BIT2 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT2_LSB         10
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT2_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT2_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT2_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT2_ENABLE   1
+
+   /* DD_INT_SENSE property, POS_BIT3 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT3_LSB         11
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT3_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT3_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT3_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT3_ENABLE   1
+
+   /* DD_INT_SENSE property, POS_BIT4 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT4_LSB         12
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT4_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT4_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT4_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT4_ENABLE   1
+
+   /* DD_INT_SENSE property, POS_BIT5 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT5_LSB         13
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT5_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT5_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT5_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT5_ENABLE   1
+
+   /* DD_INT_SENSE property, POS_BIT6 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT6_LSB         14
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT6_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT6_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT6_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT6_ENABLE   1
+
+   /* DD_INT_SENSE property, POS_BIT7 field definition (NO TITLE)*/
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT7_LSB         15
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT7_MASK        0x01
+   #define  Si2168_DD_INT_SENSE_PROP_POS_BIT7_DEFAULT    0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT7_DISABLE  0
+    #define Si2168_DD_INT_SENSE_PROP_POS_BIT7_ENABLE   1
+
+#endif /* Si2168_DD_INT_SENSE_PROP */
+
+/* Si2168 DD_MODE property definition */
+#define   Si2168_DD_MODE_PROP 0x100a
+
+#ifdef    Si2168_DD_MODE_PROP
+  #define Si2168_DD_MODE_PROP_CODE 0x00100a
+
+
+    typedef struct { /* Si2168_DD_MODE_PROP_struct */
+      unsigned char   auto_detect;
+      unsigned char   bw;
+      unsigned char   invert_spectrum;
+      unsigned char   modulation;
+   } Si2168_DD_MODE_PROP_struct;
+
+   /* DD_MODE property, AUTO_DETECT field definition (NO TITLE)*/
+   #define  Si2168_DD_MODE_PROP_AUTO_DETECT_LSB         9
+   #define  Si2168_DD_MODE_PROP_AUTO_DETECT_MASK        0x07
+   #define  Si2168_DD_MODE_PROP_AUTO_DETECT_DEFAULT    0
+    #define Si2168_DD_MODE_PROP_AUTO_DETECT_NONE               0
+    #define Si2168_DD_MODE_PROP_AUTO_DETECT_AUTO_DVB_T_T2      1
+    #define Si2168_DD_MODE_PROP_AUTO_DETECT_AUTO_DVB_S_S2      2
+    #define Si2168_DD_MODE_PROP_AUTO_DETECT_AUTO_DVB_S_S2_DSS  3
+
+   /* DD_MODE property, BW field definition (NO TITLE)*/
+   #define  Si2168_DD_MODE_PROP_BW_LSB         0
+   #define  Si2168_DD_MODE_PROP_BW_MASK        0x0f
+   #define  Si2168_DD_MODE_PROP_BW_DEFAULT    8
+    #define Si2168_DD_MODE_PROP_BW_BW_5MHZ    5
+    #define Si2168_DD_MODE_PROP_BW_BW_6MHZ    6
+    #define Si2168_DD_MODE_PROP_BW_BW_7MHZ    7
+    #define Si2168_DD_MODE_PROP_BW_BW_8MHZ    8
+    #define Si2168_DD_MODE_PROP_BW_BW_1D7MHZ  2
+
+   /* DD_MODE property, INVERT_SPECTRUM field definition (NO TITLE)*/
+   #define  Si2168_DD_MODE_PROP_INVERT_SPECTRUM_LSB         8
+   #define  Si2168_DD_MODE_PROP_INVERT_SPECTRUM_MASK        0x01
+   #define  Si2168_DD_MODE_PROP_INVERT_SPECTRUM_DEFAULT    0
+    #define Si2168_DD_MODE_PROP_INVERT_SPECTRUM_NORMAL    0
+    #define Si2168_DD_MODE_PROP_INVERT_SPECTRUM_INVERTED  1
+
+   /* DD_MODE property, MODULATION field definition (NO TITLE)*/
+   #define  Si2168_DD_MODE_PROP_MODULATION_LSB         4
+   #define  Si2168_DD_MODE_PROP_MODULATION_MASK        0x0f
+   #define  Si2168_DD_MODE_PROP_MODULATION_DEFAULT    2
+    #define Si2168_DD_MODE_PROP_MODULATION_DVBT         2
+    #define Si2168_DD_MODE_PROP_MODULATION_DVBC         3
+    #define Si2168_DD_MODE_PROP_MODULATION_DVBT2        7
+    #define Si2168_DD_MODE_PROP_MODULATION_DVBS         8
+    #define Si2168_DD_MODE_PROP_MODULATION_DVBS2        9
+    #define Si2168_DD_MODE_PROP_MODULATION_DSS          10
+    #define Si2168_DD_MODE_PROP_MODULATION_AUTO_DETECT  15
+    #define Si2168_DD_MODE_PROP_MODULATION_ANALOG     100
+
+#endif /* Si2168_DD_MODE_PROP */
+
+/* Si2168 DD_PER_RESOL property definition */
+#define   Si2168_DD_PER_RESOL_PROP 0x1004
+
+#ifdef    Si2168_DD_PER_RESOL_PROP
+  #define Si2168_DD_PER_RESOL_PROP_CODE 0x001004
+
+
+    typedef struct { /* Si2168_DD_PER_RESOL_PROP_struct */
+      unsigned char   exp;
+      unsigned char   mant;
+   } Si2168_DD_PER_RESOL_PROP_struct;
+
+   /* DD_PER_RESOL property, EXP field definition (NO TITLE)*/
+   #define  Si2168_DD_PER_RESOL_PROP_EXP_LSB         0
+   #define  Si2168_DD_PER_RESOL_PROP_EXP_MASK        0x0f
+   #define  Si2168_DD_PER_RESOL_PROP_EXP_DEFAULT    5
+    #define Si2168_DD_PER_RESOL_PROP_EXP_EXPLO_MIN  1
+    #define Si2168_DD_PER_RESOL_PROP_EXP_EXPLO_MAX  9
+
+   /* DD_PER_RESOL property, MANT field definition (NO TITLE)*/
+   #define  Si2168_DD_PER_RESOL_PROP_MANT_LSB         4
+   #define  Si2168_DD_PER_RESOL_PROP_MANT_MASK        0x0f
+   #define  Si2168_DD_PER_RESOL_PROP_MANT_DEFAULT    1
+    #define Si2168_DD_PER_RESOL_PROP_MANT_MANTLO_MIN  1
+    #define Si2168_DD_PER_RESOL_PROP_MANT_MANTLO_MAX  9
+
+#endif /* Si2168_DD_PER_RESOL_PROP */
+
+/* Si2168 DD_RSQ_BER_THRESHOLD property definition */
+#define   Si2168_DD_RSQ_BER_THRESHOLD_PROP 0x1005
+
+#ifdef    Si2168_DD_RSQ_BER_THRESHOLD_PROP
+  #define Si2168_DD_RSQ_BER_THRESHOLD_PROP_CODE 0x001005
+
+
+    typedef struct { /* Si2168_DD_RSQ_BER_THRESHOLD_PROP_struct */
+      unsigned char   exp;
+      unsigned char   mant;
+   } Si2168_DD_RSQ_BER_THRESHOLD_PROP_struct;
+
+   /* DD_RSQ_BER_THRESHOLD property, EXP field definition (NO TITLE)*/
+   #define  Si2168_DD_RSQ_BER_THRESHOLD_PROP_EXP_LSB         0
+   #define  Si2168_DD_RSQ_BER_THRESHOLD_PROP_EXP_MASK        0x0f
+   #define  Si2168_DD_RSQ_BER_THRESHOLD_PROP_EXP_DEFAULT    1
+    #define Si2168_DD_RSQ_BER_THRESHOLD_PROP_EXP_EXP_MIN  1
+    #define Si2168_DD_RSQ_BER_THRESHOLD_PROP_EXP_EXP_MAX  8
+
+   /* DD_RSQ_BER_THRESHOLD property, MANT field definition (NO TITLE)*/
+   #define  Si2168_DD_RSQ_BER_THRESHOLD_PROP_MANT_LSB         4
+   #define  Si2168_DD_RSQ_BER_THRESHOLD_PROP_MANT_MASK        0x0f
+   #define  Si2168_DD_RSQ_BER_THRESHOLD_PROP_MANT_DEFAULT    10
+    #define Si2168_DD_RSQ_BER_THRESHOLD_PROP_MANT_MANT_MIN  0
+    #define Si2168_DD_RSQ_BER_THRESHOLD_PROP_MANT_MANT_MAX  99
+
+#endif /* Si2168_DD_RSQ_BER_THRESHOLD_PROP */
+
+/* Si2168 DD_TS_FREQ property definition */
+#define   Si2168_DD_TS_FREQ_PROP 0x100d
+
+#ifdef    Si2168_DD_TS_FREQ_PROP
+  #define Si2168_DD_TS_FREQ_PROP_CODE 0x00100d
+
+
+    typedef struct { /* Si2168_DD_TS_FREQ_PROP_struct */
+      unsigned int    req_freq_10khz;
+   } Si2168_DD_TS_FREQ_PROP_struct;
+
+   /* DD_TS_FREQ property, REQ_FREQ_10KHZ field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_FREQ_PROP_REQ_FREQ_10KHZ_LSB         0
+   #define  Si2168_DD_TS_FREQ_PROP_REQ_FREQ_10KHZ_MASK        0x3fff
+   #define  Si2168_DD_TS_FREQ_PROP_REQ_FREQ_10KHZ_DEFAULT    720
+    #define Si2168_DD_TS_FREQ_PROP_REQ_FREQ_10KHZ_REQ_FREQ_10KHZ_MIN  0
+    #define Si2168_DD_TS_FREQ_PROP_REQ_FREQ_10KHZ_REQ_FREQ_10KHZ_MAX  14550
+
+#endif /* Si2168_DD_TS_FREQ_PROP */
+
+/* Si2168 DD_TS_MODE property definition */
+#define   Si2168_DD_TS_MODE_PROP 0x1001
+
+#ifdef    Si2168_DD_TS_MODE_PROP
+  #define Si2168_DD_TS_MODE_PROP_CODE 0x001001
+
+
+    typedef struct { /* Si2168_DD_TS_MODE_PROP_struct */
+      unsigned char   clk_gapped_en;
+      unsigned char   clock;
+      unsigned char   mode;
+      unsigned char   special;
+      unsigned char   ts_err_polarity;
+   } Si2168_DD_TS_MODE_PROP_struct;
+
+   /* DD_TS_MODE property, CLK_GAPPED_EN field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_MODE_PROP_CLK_GAPPED_EN_LSB         6
+   #define  Si2168_DD_TS_MODE_PROP_CLK_GAPPED_EN_MASK        0x01
+   #define  Si2168_DD_TS_MODE_PROP_CLK_GAPPED_EN_DEFAULT    0
+    #define Si2168_DD_TS_MODE_PROP_CLK_GAPPED_EN_DISABLED  0
+    #define Si2168_DD_TS_MODE_PROP_CLK_GAPPED_EN_ENABLED   1
+
+   /* DD_TS_MODE property, CLOCK field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_MODE_PROP_CLOCK_LSB         4
+   #define  Si2168_DD_TS_MODE_PROP_CLOCK_MASK        0x03
+   #define  Si2168_DD_TS_MODE_PROP_CLOCK_DEFAULT    0
+    #define Si2168_DD_TS_MODE_PROP_CLOCK_AUTO_FIXED  0
+    #define Si2168_DD_TS_MODE_PROP_CLOCK_AUTO_ADAPT  1
+    #define Si2168_DD_TS_MODE_PROP_CLOCK_MANUAL      2
+
+   /* DD_TS_MODE property, MODE field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_MODE_PROP_MODE_LSB         0
+   #define  Si2168_DD_TS_MODE_PROP_MODE_MASK        0x0f
+   #define  Si2168_DD_TS_MODE_PROP_MODE_DEFAULT    0
+    #define Si2168_DD_TS_MODE_PROP_MODE_TRISTATE  0
+    #define Si2168_DD_TS_MODE_PROP_MODE_OFF       1
+    #define Si2168_DD_TS_MODE_PROP_MODE_SERIAL    3
+    #define Si2168_DD_TS_MODE_PROP_MODE_PARALLEL  6
+    #define Si2168_DD_TS_MODE_PROP_MODE_GPIF      7
+
+   /* DD_TS_MODE property, SPECIAL field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_MODE_PROP_SPECIAL_LSB         8
+   #define  Si2168_DD_TS_MODE_PROP_SPECIAL_MASK        0x03
+   #define  Si2168_DD_TS_MODE_PROP_SPECIAL_DEFAULT    0
+    #define Si2168_DD_TS_MODE_PROP_SPECIAL_FULL_TS         0
+    #define Si2168_DD_TS_MODE_PROP_SPECIAL_DATAS_TRISTATE  1
+
+   /* DD_TS_MODE property, TS_ERR_POLARITY field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_MODE_PROP_TS_ERR_POLARITY_LSB         7
+   #define  Si2168_DD_TS_MODE_PROP_TS_ERR_POLARITY_MASK        0x01
+   #define  Si2168_DD_TS_MODE_PROP_TS_ERR_POLARITY_DEFAULT    0
+    #define Si2168_DD_TS_MODE_PROP_TS_ERR_POLARITY_NOT_INVERTED  0
+    #define Si2168_DD_TS_MODE_PROP_TS_ERR_POLARITY_INVERTED      1
+
+#endif /* Si2168_DD_TS_MODE_PROP */
+
+/* Si2168 DD_TS_SETUP_PAR property definition */
+#define   Si2168_DD_TS_SETUP_PAR_PROP 0x1009
+
+#ifdef    Si2168_DD_TS_SETUP_PAR_PROP
+  #define Si2168_DD_TS_SETUP_PAR_PROP_CODE 0x001009
+
+
+    typedef struct { /* Si2168_DD_TS_SETUP_PAR_PROP_struct */
+      unsigned char   ts_clk_invert;
+      unsigned char   ts_clk_shape;
+      unsigned char   ts_clk_shift;
+      unsigned char   ts_clk_strength;
+      unsigned char   ts_data_shape;
+      unsigned char   ts_data_strength;
+   } Si2168_DD_TS_SETUP_PAR_PROP_struct;
+
+   /* DD_TS_SETUP_PAR property, TS_CLK_INVERT field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_LSB         12
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_MASK        0x01
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_DEFAULT    1
+    #define Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_NOT_INVERTED  0
+    #define Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_INVERT_INVERTED      1
+
+   /* DD_TS_SETUP_PAR property, TS_CLK_SHAPE field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_SHAPE_LSB         10
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_SHAPE_MASK        0x03
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_SHAPE_DEFAULT    1
+   /* DD_TS_SETUP_PAR property, TS_CLK_SHIFT field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_SHIFT_LSB         13
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_SHIFT_MASK        0x07
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_SHIFT_DEFAULT    0
+   /* DD_TS_SETUP_PAR property, TS_CLK_STRENGTH field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_STRENGTH_LSB         6
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_STRENGTH_MASK        0x0f
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_CLK_STRENGTH_DEFAULT    3
+   /* DD_TS_SETUP_PAR property, TS_DATA_SHAPE field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_DATA_SHAPE_LSB         4
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_DATA_SHAPE_MASK        0x03
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_DATA_SHAPE_DEFAULT    1
+   /* DD_TS_SETUP_PAR property, TS_DATA_STRENGTH field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_DATA_STRENGTH_LSB         0
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_DATA_STRENGTH_MASK        0x0f
+   #define  Si2168_DD_TS_SETUP_PAR_PROP_TS_DATA_STRENGTH_DEFAULT    3
+#endif /* Si2168_DD_TS_SETUP_PAR_PROP */
+
+/* Si2168 DD_TS_SETUP_SER property definition */
+#define   Si2168_DD_TS_SETUP_SER_PROP 0x1008
+
+#ifdef    Si2168_DD_TS_SETUP_SER_PROP
+  #define Si2168_DD_TS_SETUP_SER_PROP_CODE 0x001008
+
+
+    typedef struct { /* Si2168_DD_TS_SETUP_SER_PROP_struct */
+      unsigned char   ts_byte_order;
+      unsigned char   ts_clk_invert;
+      unsigned char   ts_clk_shape;
+      unsigned char   ts_clk_strength;
+      unsigned char   ts_data_shape;
+      unsigned char   ts_data_strength;
+      unsigned char   ts_sync_duration;
+   } Si2168_DD_TS_SETUP_SER_PROP_struct;
+
+   /* DD_TS_SETUP_SER property, TS_BYTE_ORDER field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_LSB         14
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_MASK        0x01
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_DEFAULT    0
+    #define Si2168_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_MSB_FIRST  0
+    #define Si2168_DD_TS_SETUP_SER_PROP_TS_BYTE_ORDER_LSB_FIRST  1
+
+   /* DD_TS_SETUP_SER property, TS_CLK_INVERT field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_LSB         12
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_MASK        0x01
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_DEFAULT    1
+    #define Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_NOT_INVERTED  0
+    #define Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_INVERT_INVERTED      1
+
+   /* DD_TS_SETUP_SER property, TS_CLK_SHAPE field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_SHAPE_LSB         10
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_SHAPE_MASK        0x03
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_SHAPE_DEFAULT    3
+   /* DD_TS_SETUP_SER property, TS_CLK_STRENGTH field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_STRENGTH_LSB         6
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_STRENGTH_MASK        0x0f
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_CLK_STRENGTH_DEFAULT    15
+   /* DD_TS_SETUP_SER property, TS_DATA_SHAPE field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_DATA_SHAPE_LSB         4
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_DATA_SHAPE_MASK        0x03
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_DATA_SHAPE_DEFAULT    3
+   /* DD_TS_SETUP_SER property, TS_DATA_STRENGTH field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_DATA_STRENGTH_LSB         0
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_DATA_STRENGTH_MASK        0x0f
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_DATA_STRENGTH_DEFAULT    15
+   /* DD_TS_SETUP_SER property, TS_SYNC_DURATION field definition (NO TITLE)*/
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_LSB         13
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_MASK        0x01
+   #define  Si2168_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_DEFAULT    0
+    #define Si2168_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_FIRST_BYTE  0
+    #define Si2168_DD_TS_SETUP_SER_PROP_TS_SYNC_DURATION_FIRST_BIT   1
+
+#endif /* Si2168_DD_TS_SETUP_SER_PROP */
+
+/* Si2168 DVBC_ADC_CREST_FACTOR property definition */
+#define   Si2168_DVBC_ADC_CREST_FACTOR_PROP 0x1104
+
+#ifdef    Si2168_DVBC_ADC_CREST_FACTOR_PROP
+  #define Si2168_DVBC_ADC_CREST_FACTOR_PROP_CODE 0x001104
+
+
+    typedef struct { /* Si2168_DVBC_ADC_CREST_FACTOR_PROP_struct */
+      unsigned char   crest_factor;
+   } Si2168_DVBC_ADC_CREST_FACTOR_PROP_struct;
+
+   /* DVBC_ADC_CREST_FACTOR property, CREST_FACTOR field definition (NO TITLE)*/
+   #define  Si2168_DVBC_ADC_CREST_FACTOR_PROP_CREST_FACTOR_LSB         0
+   #define  Si2168_DVBC_ADC_CREST_FACTOR_PROP_CREST_FACTOR_MASK        0xff
+   #define  Si2168_DVBC_ADC_CREST_FACTOR_PROP_CREST_FACTOR_DEFAULT    112
+#endif /* Si2168_DVBC_ADC_CREST_FACTOR_PROP */
+
+/* Si2168 DVBC_AFC_RANGE property definition */
+#define   Si2168_DVBC_AFC_RANGE_PROP 0x1103
+
+#ifdef    Si2168_DVBC_AFC_RANGE_PROP
+  #define Si2168_DVBC_AFC_RANGE_PROP_CODE 0x001103
+
+
+    typedef struct { /* Si2168_DVBC_AFC_RANGE_PROP_struct */
+      unsigned int    range_khz;
+   } Si2168_DVBC_AFC_RANGE_PROP_struct;
+
+   /* DVBC_AFC_RANGE property, RANGE_KHZ field definition (NO TITLE)*/
+   #define  Si2168_DVBC_AFC_RANGE_PROP_RANGE_KHZ_LSB         0
+   #define  Si2168_DVBC_AFC_RANGE_PROP_RANGE_KHZ_MASK        0xffff
+   #define  Si2168_DVBC_AFC_RANGE_PROP_RANGE_KHZ_DEFAULT    100
+#endif /* Si2168_DVBC_AFC_RANGE_PROP */
+
+/* Si2168 DVBC_CONSTELLATION property definition */
+#define   Si2168_DVBC_CONSTELLATION_PROP 0x1101
+
+#ifdef    Si2168_DVBC_CONSTELLATION_PROP
+  #define Si2168_DVBC_CONSTELLATION_PROP_CODE 0x001101
+
+
+    typedef struct { /* Si2168_DVBC_CONSTELLATION_PROP_struct */
+      unsigned char   constellation;
+   } Si2168_DVBC_CONSTELLATION_PROP_struct;
+
+   /* DVBC_CONSTELLATION property, CONSTELLATION field definition (NO TITLE)*/
+   #define  Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_LSB         0
+   #define  Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_MASK        0x3f
+   #define  Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_DEFAULT    0
+    #define Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_AUTO    0
+    #define Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM16   7
+    #define Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM32   8
+    #define Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM64   9
+    #define Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM128  10
+    #define Si2168_DVBC_CONSTELLATION_PROP_CONSTELLATION_QAM256  11
+
+#endif /* Si2168_DVBC_CONSTELLATION_PROP */
+
+/* Si2168 DVBC_SYMBOL_RATE property definition */
+#define   Si2168_DVBC_SYMBOL_RATE_PROP 0x1102
+
+#ifdef    Si2168_DVBC_SYMBOL_RATE_PROP
+  #define Si2168_DVBC_SYMBOL_RATE_PROP_CODE 0x001102
+
+
+    typedef struct { /* Si2168_DVBC_SYMBOL_RATE_PROP_struct */
+      unsigned int    rate;
+   } Si2168_DVBC_SYMBOL_RATE_PROP_struct;
+
+   /* DVBC_SYMBOL_RATE property, RATE field definition (NO TITLE)*/
+   #define  Si2168_DVBC_SYMBOL_RATE_PROP_RATE_LSB         0
+   #define  Si2168_DVBC_SYMBOL_RATE_PROP_RATE_MASK        0xffff
+   #define  Si2168_DVBC_SYMBOL_RATE_PROP_RATE_DEFAULT    6800
+#endif /* Si2168_DVBC_SYMBOL_RATE_PROP */
+
+
+
+/* Si2168 DVBT2_ADC_CREST_FACTOR property definition */
+#define   Si2168_DVBT2_ADC_CREST_FACTOR_PROP 0x1303
+
+#ifdef    Si2168_DVBT2_ADC_CREST_FACTOR_PROP
+  #define Si2168_DVBT2_ADC_CREST_FACTOR_PROP_CODE 0x001303
+
+
+    typedef struct { /* Si2168_DVBT2_ADC_CREST_FACTOR_PROP_struct */
+      unsigned char   crest_factor;
+   } Si2168_DVBT2_ADC_CREST_FACTOR_PROP_struct;
+
+   /* DVBT2_ADC_CREST_FACTOR property, CREST_FACTOR field definition (NO TITLE)*/
+   #define  Si2168_DVBT2_ADC_CREST_FACTOR_PROP_CREST_FACTOR_LSB         0
+   #define  Si2168_DVBT2_ADC_CREST_FACTOR_PROP_CREST_FACTOR_MASK        0xff
+   #define  Si2168_DVBT2_ADC_CREST_FACTOR_PROP_CREST_FACTOR_DEFAULT    130
+#endif /* Si2168_DVBT2_ADC_CREST_FACTOR_PROP */
+
+/* Si2168 DVBT2_AFC_RANGE property definition */
+#define   Si2168_DVBT2_AFC_RANGE_PROP 0x1301
+
+#ifdef    Si2168_DVBT2_AFC_RANGE_PROP
+  #define Si2168_DVBT2_AFC_RANGE_PROP_CODE 0x001301
+
+
+    typedef struct { /* Si2168_DVBT2_AFC_RANGE_PROP_struct */
+      unsigned int    range_khz;
+   } Si2168_DVBT2_AFC_RANGE_PROP_struct;
+
+   /* DVBT2_AFC_RANGE property, RANGE_KHZ field definition (NO TITLE)*/
+   #define  Si2168_DVBT2_AFC_RANGE_PROP_RANGE_KHZ_LSB         0
+   #define  Si2168_DVBT2_AFC_RANGE_PROP_RANGE_KHZ_MASK        0xffff
+   #define  Si2168_DVBT2_AFC_RANGE_PROP_RANGE_KHZ_DEFAULT    550
+#endif /* Si2168_DVBT2_AFC_RANGE_PROP */
+
+/* Si2168 DVBT2_FEF_TUNER property definition */
+#define   Si2168_DVBT2_FEF_TUNER_PROP 0x1302
+
+#ifdef    Si2168_DVBT2_FEF_TUNER_PROP
+  #define Si2168_DVBT2_FEF_TUNER_PROP_CODE 0x001302
+
+
+    typedef struct { /* Si2168_DVBT2_FEF_TUNER_PROP_struct */
+      unsigned char   tuner_delay;
+      unsigned char   tuner_freeze_time;
+      unsigned char   tuner_unfreeze_time;
+   } Si2168_DVBT2_FEF_TUNER_PROP_struct;
+
+   /* DVBT2_FEF_TUNER property, TUNER_DELAY field definition (NO TITLE)*/
+   #define  Si2168_DVBT2_FEF_TUNER_PROP_TUNER_DELAY_LSB         0
+   #define  Si2168_DVBT2_FEF_TUNER_PROP_TUNER_DELAY_MASK        0xff
+   #define  Si2168_DVBT2_FEF_TUNER_PROP_TUNER_DELAY_DEFAULT    1
+   /* DVBT2_FEF_TUNER property, TUNER_FREEZE_TIME field definition (NO TITLE)*/
+   #define  Si2168_DVBT2_FEF_TUNER_PROP_TUNER_FREEZE_TIME_LSB         8
+   #define  Si2168_DVBT2_FEF_TUNER_PROP_TUNER_FREEZE_TIME_MASK        0x0f
+   #define  Si2168_DVBT2_FEF_TUNER_PROP_TUNER_FREEZE_TIME_DEFAULT    1
+   /* DVBT2_FEF_TUNER property, TUNER_UNFREEZE_TIME field definition (NO TITLE)*/
+   #define  Si2168_DVBT2_FEF_TUNER_PROP_TUNER_UNFREEZE_TIME_LSB         12
+   #define  Si2168_DVBT2_FEF_TUNER_PROP_TUNER_UNFREEZE_TIME_MASK        0x0f
+   #define  Si2168_DVBT2_FEF_TUNER_PROP_TUNER_UNFREEZE_TIME_DEFAULT    1
+#endif /* Si2168_DVBT2_FEF_TUNER_PROP */
+
+
+/* Si2168 DVBT_ADC_CREST_FACTOR property definition */
+#define   Si2168_DVBT_ADC_CREST_FACTOR_PROP 0x1203
+
+#ifdef    Si2168_DVBT_ADC_CREST_FACTOR_PROP
+  #define Si2168_DVBT_ADC_CREST_FACTOR_PROP_CODE 0x001203
+
+
+    typedef struct { /* Si2168_DVBT_ADC_CREST_FACTOR_PROP_struct */
+      unsigned char   crest_factor;
+   } Si2168_DVBT_ADC_CREST_FACTOR_PROP_struct;
+
+   /* DVBT_ADC_CREST_FACTOR property, CREST_FACTOR field definition (NO TITLE)*/
+   #define  Si2168_DVBT_ADC_CREST_FACTOR_PROP_CREST_FACTOR_LSB         0
+   #define  Si2168_DVBT_ADC_CREST_FACTOR_PROP_CREST_FACTOR_MASK        0xff
+   #define  Si2168_DVBT_ADC_CREST_FACTOR_PROP_CREST_FACTOR_DEFAULT    130
+#endif /* Si2168_DVBT_ADC_CREST_FACTOR_PROP */
+
+/* Si2168 DVBT_AFC_RANGE property definition */
+#define   Si2168_DVBT_AFC_RANGE_PROP 0x1202
+
+#ifdef    Si2168_DVBT_AFC_RANGE_PROP
+  #define Si2168_DVBT_AFC_RANGE_PROP_CODE 0x001202
+
+
+    typedef struct { /* Si2168_DVBT_AFC_RANGE_PROP_struct */
+      unsigned int    range_khz;
+   } Si2168_DVBT_AFC_RANGE_PROP_struct;
+
+   /* DVBT_AFC_RANGE property, RANGE_KHZ field definition (NO TITLE)*/
+   #define  Si2168_DVBT_AFC_RANGE_PROP_RANGE_KHZ_LSB         0
+   #define  Si2168_DVBT_AFC_RANGE_PROP_RANGE_KHZ_MASK        0xffff
+   #define  Si2168_DVBT_AFC_RANGE_PROP_RANGE_KHZ_DEFAULT    550
+#endif /* Si2168_DVBT_AFC_RANGE_PROP */
+
+/* Si2168 DVBT_HIERARCHY property definition */
+#define   Si2168_DVBT_HIERARCHY_PROP 0x1201
+
+#ifdef    Si2168_DVBT_HIERARCHY_PROP
+  #define Si2168_DVBT_HIERARCHY_PROP_CODE 0x001201
+
+
+    typedef struct { /* Si2168_DVBT_HIERARCHY_PROP_struct */
+      unsigned char   stream;
+   } Si2168_DVBT_HIERARCHY_PROP_struct;
+
+   /* DVBT_HIERARCHY property, STREAM field definition (NO TITLE)*/
+   #define  Si2168_DVBT_HIERARCHY_PROP_STREAM_LSB         0
+   #define  Si2168_DVBT_HIERARCHY_PROP_STREAM_MASK        0x01
+   #define  Si2168_DVBT_HIERARCHY_PROP_STREAM_DEFAULT    0
+    #define Si2168_DVBT_HIERARCHY_PROP_STREAM_HP  0
+    #define Si2168_DVBT_HIERARCHY_PROP_STREAM_LP  1
+
+#endif /* Si2168_DVBT_HIERARCHY_PROP */
+
+
+/* Si2168 MASTER_IEN property definition */
+#define   Si2168_MASTER_IEN_PROP 0x0401
+
+#ifdef    Si2168_MASTER_IEN_PROP
+  #define Si2168_MASTER_IEN_PROP_CODE 0x000401
+
+
+    typedef struct { /* Si2168_MASTER_IEN_PROP_struct */
+      unsigned char   ctsien;
+      unsigned char   ddien;
+      unsigned char   errien;
+      unsigned char   scanien;
+   } Si2168_MASTER_IEN_PROP_struct;
+
+   /* MASTER_IEN property, CTSIEN field definition (NO TITLE)*/
+   #define  Si2168_MASTER_IEN_PROP_CTSIEN_LSB         7
+   #define  Si2168_MASTER_IEN_PROP_CTSIEN_MASK        0x01
+   #define  Si2168_MASTER_IEN_PROP_CTSIEN_DEFAULT    0
+    #define Si2168_MASTER_IEN_PROP_CTSIEN_OFF  0
+    #define Si2168_MASTER_IEN_PROP_CTSIEN_ON   1
+
+   /* MASTER_IEN property, DDIEN field definition (NO TITLE)*/
+   #define  Si2168_MASTER_IEN_PROP_DDIEN_LSB         0
+   #define  Si2168_MASTER_IEN_PROP_DDIEN_MASK        0x01
+   #define  Si2168_MASTER_IEN_PROP_DDIEN_DEFAULT    0
+    #define Si2168_MASTER_IEN_PROP_DDIEN_OFF  0
+    #define Si2168_MASTER_IEN_PROP_DDIEN_ON   1
+
+   /* MASTER_IEN property, ERRIEN field definition (NO TITLE)*/
+   #define  Si2168_MASTER_IEN_PROP_ERRIEN_LSB         6
+   #define  Si2168_MASTER_IEN_PROP_ERRIEN_MASK        0x01
+   #define  Si2168_MASTER_IEN_PROP_ERRIEN_DEFAULT    0
+    #define Si2168_MASTER_IEN_PROP_ERRIEN_OFF  0
+    #define Si2168_MASTER_IEN_PROP_ERRIEN_ON   1
+
+   /* MASTER_IEN property, SCANIEN field definition (NO TITLE)*/
+   #define  Si2168_MASTER_IEN_PROP_SCANIEN_LSB         1
+   #define  Si2168_MASTER_IEN_PROP_SCANIEN_MASK        0x01
+   #define  Si2168_MASTER_IEN_PROP_SCANIEN_DEFAULT    0
+    #define Si2168_MASTER_IEN_PROP_SCANIEN_OFF  0
+    #define Si2168_MASTER_IEN_PROP_SCANIEN_ON   1
+
+#endif /* Si2168_MASTER_IEN_PROP */
+
+/* Si2168 SCAN_FMAX property definition */
+#define   Si2168_SCAN_FMAX_PROP 0x0304
+
+#ifdef    Si2168_SCAN_FMAX_PROP
+  #define Si2168_SCAN_FMAX_PROP_CODE 0x000304
+
+
+    typedef struct { /* Si2168_SCAN_FMAX_PROP_struct */
+      unsigned int    scan_fmax;
+   } Si2168_SCAN_FMAX_PROP_struct;
+
+   /* SCAN_FMAX property, SCAN_FMAX field definition (NO TITLE)*/
+   #define  Si2168_SCAN_FMAX_PROP_SCAN_FMAX_LSB         0
+   #define  Si2168_SCAN_FMAX_PROP_SCAN_FMAX_MASK        0xffff
+   #define  Si2168_SCAN_FMAX_PROP_SCAN_FMAX_DEFAULT    0
+#endif /* Si2168_SCAN_FMAX_PROP */
+
+/* Si2168 SCAN_FMIN property definition */
+#define   Si2168_SCAN_FMIN_PROP 0x0303
+
+#ifdef    Si2168_SCAN_FMIN_PROP
+  #define Si2168_SCAN_FMIN_PROP_CODE 0x000303
+
+
+    typedef struct { /* Si2168_SCAN_FMIN_PROP_struct */
+      unsigned int    scan_fmin;
+   } Si2168_SCAN_FMIN_PROP_struct;
+
+   /* SCAN_FMIN property, SCAN_FMIN field definition (NO TITLE)*/
+   #define  Si2168_SCAN_FMIN_PROP_SCAN_FMIN_LSB         0
+   #define  Si2168_SCAN_FMIN_PROP_SCAN_FMIN_MASK        0xffff
+   #define  Si2168_SCAN_FMIN_PROP_SCAN_FMIN_DEFAULT    0
+#endif /* Si2168_SCAN_FMIN_PROP */
+
+/* Si2168 SCAN_IEN property definition */
+#define   Si2168_SCAN_IEN_PROP 0x0308
+
+#ifdef    Si2168_SCAN_IEN_PROP
+  #define Si2168_SCAN_IEN_PROP_CODE 0x000308
+
+
+    typedef struct { /* Si2168_SCAN_IEN_PROP_struct */
+      unsigned char   buzien;
+      unsigned char   reqien;
+   } Si2168_SCAN_IEN_PROP_struct;
+
+   /* SCAN_IEN property, BUZIEN field definition (NO TITLE)*/
+   #define  Si2168_SCAN_IEN_PROP_BUZIEN_LSB         0
+   #define  Si2168_SCAN_IEN_PROP_BUZIEN_MASK        0x01
+   #define  Si2168_SCAN_IEN_PROP_BUZIEN_DEFAULT    0
+    #define Si2168_SCAN_IEN_PROP_BUZIEN_DISABLE  0
+    #define Si2168_SCAN_IEN_PROP_BUZIEN_ENABLE   1
+
+   /* SCAN_IEN property, REQIEN field definition (NO TITLE)*/
+   #define  Si2168_SCAN_IEN_PROP_REQIEN_LSB         1
+   #define  Si2168_SCAN_IEN_PROP_REQIEN_MASK        0x01
+   #define  Si2168_SCAN_IEN_PROP_REQIEN_DEFAULT    0
+    #define Si2168_SCAN_IEN_PROP_REQIEN_DISABLE  0
+    #define Si2168_SCAN_IEN_PROP_REQIEN_ENABLE   1
+
+#endif /* Si2168_SCAN_IEN_PROP */
+
+/* Si2168 SCAN_INT_SENSE property definition */
+#define   Si2168_SCAN_INT_SENSE_PROP 0x0307
+
+#ifdef    Si2168_SCAN_INT_SENSE_PROP
+  #define Si2168_SCAN_INT_SENSE_PROP_CODE 0x000307
+
+
+    typedef struct { /* Si2168_SCAN_INT_SENSE_PROP_struct */
+      unsigned char   buznegen;
+      unsigned char   buzposen;
+      unsigned char   reqnegen;
+      unsigned char   reqposen;
+   } Si2168_SCAN_INT_SENSE_PROP_struct;
+
+   /* SCAN_INT_SENSE property, BUZNEGEN field definition (NO TITLE)*/
+   #define  Si2168_SCAN_INT_SENSE_PROP_BUZNEGEN_LSB         0
+   #define  Si2168_SCAN_INT_SENSE_PROP_BUZNEGEN_MASK        0x01
+   #define  Si2168_SCAN_INT_SENSE_PROP_BUZNEGEN_DEFAULT    1
+    #define Si2168_SCAN_INT_SENSE_PROP_BUZNEGEN_DISABLE  0
+    #define Si2168_SCAN_INT_SENSE_PROP_BUZNEGEN_ENABLE   1
+
+   /* SCAN_INT_SENSE property, BUZPOSEN field definition (NO TITLE)*/
+   #define  Si2168_SCAN_INT_SENSE_PROP_BUZPOSEN_LSB         8
+   #define  Si2168_SCAN_INT_SENSE_PROP_BUZPOSEN_MASK        0x01
+   #define  Si2168_SCAN_INT_SENSE_PROP_BUZPOSEN_DEFAULT    0
+    #define Si2168_SCAN_INT_SENSE_PROP_BUZPOSEN_DISABLE  0
+    #define Si2168_SCAN_INT_SENSE_PROP_BUZPOSEN_ENABLE   1
+
+   /* SCAN_INT_SENSE property, REQNEGEN field definition (NO TITLE)*/
+   #define  Si2168_SCAN_INT_SENSE_PROP_REQNEGEN_LSB         1
+   #define  Si2168_SCAN_INT_SENSE_PROP_REQNEGEN_MASK        0x01
+   #define  Si2168_SCAN_INT_SENSE_PROP_REQNEGEN_DEFAULT    0
+    #define Si2168_SCAN_INT_SENSE_PROP_REQNEGEN_DISABLE  0
+    #define Si2168_SCAN_INT_SENSE_PROP_REQNEGEN_ENABLE   1
+
+   /* SCAN_INT_SENSE property, REQPOSEN field definition (NO TITLE)*/
+   #define  Si2168_SCAN_INT_SENSE_PROP_REQPOSEN_LSB         9
+   #define  Si2168_SCAN_INT_SENSE_PROP_REQPOSEN_MASK        0x01
+   #define  Si2168_SCAN_INT_SENSE_PROP_REQPOSEN_DEFAULT    1
+    #define Si2168_SCAN_INT_SENSE_PROP_REQPOSEN_DISABLE  0
+    #define Si2168_SCAN_INT_SENSE_PROP_REQPOSEN_ENABLE   1
+
+#endif /* Si2168_SCAN_INT_SENSE_PROP */
+
+
+/* Si2168 SCAN_SYMB_RATE_MAX property definition */
+#define   Si2168_SCAN_SYMB_RATE_MAX_PROP 0x0306
+
+#ifdef    Si2168_SCAN_SYMB_RATE_MAX_PROP
+  #define Si2168_SCAN_SYMB_RATE_MAX_PROP_CODE 0x000306
+
+
+    typedef struct { /* Si2168_SCAN_SYMB_RATE_MAX_PROP_struct */
+      unsigned int    scan_symb_rate_max;
+   } Si2168_SCAN_SYMB_RATE_MAX_PROP_struct;
+
+   /* SCAN_SYMB_RATE_MAX property, SCAN_SYMB_RATE_MAX field definition (NO TITLE)*/
+   #define  Si2168_SCAN_SYMB_RATE_MAX_PROP_SCAN_SYMB_RATE_MAX_LSB         0
+   #define  Si2168_SCAN_SYMB_RATE_MAX_PROP_SCAN_SYMB_RATE_MAX_MASK        0xffff
+   #define  Si2168_SCAN_SYMB_RATE_MAX_PROP_SCAN_SYMB_RATE_MAX_DEFAULT    0
+#endif /* Si2168_SCAN_SYMB_RATE_MAX_PROP */
+
+/* Si2168 SCAN_SYMB_RATE_MIN property definition */
+#define   Si2168_SCAN_SYMB_RATE_MIN_PROP 0x0305
+
+#ifdef    Si2168_SCAN_SYMB_RATE_MIN_PROP
+  #define Si2168_SCAN_SYMB_RATE_MIN_PROP_CODE 0x000305
+
+
+    typedef struct { /* Si2168_SCAN_SYMB_RATE_MIN_PROP_struct */
+      unsigned int    scan_symb_rate_min;
+   } Si2168_SCAN_SYMB_RATE_MIN_PROP_struct;
+
+   /* SCAN_SYMB_RATE_MIN property, SCAN_SYMB_RATE_MIN field definition (NO TITLE)*/
+   #define  Si2168_SCAN_SYMB_RATE_MIN_PROP_SCAN_SYMB_RATE_MIN_LSB         0
+   #define  Si2168_SCAN_SYMB_RATE_MIN_PROP_SCAN_SYMB_RATE_MIN_MASK        0xffff
+   #define  Si2168_SCAN_SYMB_RATE_MIN_PROP_SCAN_SYMB_RATE_MIN_DEFAULT    0
+#endif /* Si2168_SCAN_SYMB_RATE_MIN_PROP */
+
+/* Si2168 SCAN_TER_CONFIG property definition */
+#define   Si2168_SCAN_TER_CONFIG_PROP 0x0301
+
+#ifdef    Si2168_SCAN_TER_CONFIG_PROP
+  #define Si2168_SCAN_TER_CONFIG_PROP_CODE 0x000301
+
+
+    typedef struct { /* Si2168_SCAN_TER_CONFIG_PROP_struct */
+      unsigned char   analog_bw;
+      unsigned char   mode;
+      unsigned char   search_analog;
+   } Si2168_SCAN_TER_CONFIG_PROP_struct;
+
+   /* SCAN_TER_CONFIG property, ANALOG_BW field definition (NO TITLE)*/
+   #define  Si2168_SCAN_TER_CONFIG_PROP_ANALOG_BW_LSB         2
+   #define  Si2168_SCAN_TER_CONFIG_PROP_ANALOG_BW_MASK        0x03
+   #define  Si2168_SCAN_TER_CONFIG_PROP_ANALOG_BW_DEFAULT    3
+    #define Si2168_SCAN_TER_CONFIG_PROP_ANALOG_BW_6MHZ  1
+    #define Si2168_SCAN_TER_CONFIG_PROP_ANALOG_BW_7MHZ  2
+    #define Si2168_SCAN_TER_CONFIG_PROP_ANALOG_BW_8MHZ  3
+
+   /* SCAN_TER_CONFIG property, MODE field definition (NO TITLE)*/
+   #define  Si2168_SCAN_TER_CONFIG_PROP_MODE_LSB         0
+   #define  Si2168_SCAN_TER_CONFIG_PROP_MODE_MASK        0x03
+   #define  Si2168_SCAN_TER_CONFIG_PROP_MODE_DEFAULT    0
+    #define Si2168_SCAN_TER_CONFIG_PROP_MODE_BLIND_SCAN    0
+    #define Si2168_SCAN_TER_CONFIG_PROP_MODE_MAPPING_SCAN  1
+    #define Si2168_SCAN_TER_CONFIG_PROP_MODE_BLIND_LOCK    2
+
+   /* SCAN_TER_CONFIG property, SEARCH_ANALOG field definition (NO TITLE)*/
+   #define  Si2168_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_LSB         4
+   #define  Si2168_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_MASK        0x01
+   #define  Si2168_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_DEFAULT    0
+    #define Si2168_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_DISABLE  0
+    #define Si2168_SCAN_TER_CONFIG_PROP_SEARCH_ANALOG_ENABLE   1
+
+#endif /* Si2168_SCAN_TER_CONFIG_PROP */
+
+
+/* _properties_defines_insertion_point */
+
+/* _properties_struct_insertion_start */
+
+  /* --------------------------------------------*/
+  /* PROPERTIES STRUCT                           */
+  /* This stores all property fields             */
+  /* --------------------------------------------*/
+  typedef struct {
+    #ifdef    Si2168_DD_BER_RESOL_PROP
+              Si2168_DD_BER_RESOL_PROP_struct            dd_ber_resol;
+    #endif /* Si2168_DD_BER_RESOL_PROP */
+    #ifdef    Si2168_DD_CBER_RESOL_PROP
+              Si2168_DD_CBER_RESOL_PROP_struct           dd_cber_resol;
+    #endif /* Si2168_DD_CBER_RESOL_PROP */
+
+    #ifdef    Si2168_DD_FER_RESOL_PROP
+              Si2168_DD_FER_RESOL_PROP_struct            dd_fer_resol;
+    #endif /* Si2168_DD_FER_RESOL_PROP */
+    #ifdef    Si2168_DD_IEN_PROP
+              Si2168_DD_IEN_PROP_struct                  dd_ien;
+    #endif /* Si2168_DD_IEN_PROP */
+    #ifdef    Si2168_DD_IF_INPUT_FREQ_PROP
+              Si2168_DD_IF_INPUT_FREQ_PROP_struct        dd_if_input_freq;
+    #endif /* Si2168_DD_IF_INPUT_FREQ_PROP */
+    #ifdef    Si2168_DD_INT_SENSE_PROP
+              Si2168_DD_INT_SENSE_PROP_struct            dd_int_sense;
+    #endif /* Si2168_DD_INT_SENSE_PROP */
+    #ifdef    Si2168_DD_MODE_PROP
+              Si2168_DD_MODE_PROP_struct                 dd_mode;
+    #endif /* Si2168_DD_MODE_PROP */
+    #ifdef    Si2168_DD_PER_RESOL_PROP
+              Si2168_DD_PER_RESOL_PROP_struct            dd_per_resol;
+    #endif /* Si2168_DD_PER_RESOL_PROP */
+    #ifdef    Si2168_DD_RSQ_BER_THRESHOLD_PROP
+              Si2168_DD_RSQ_BER_THRESHOLD_PROP_struct    dd_rsq_ber_threshold;
+    #endif /* Si2168_DD_RSQ_BER_THRESHOLD_PROP */
+    #ifdef    Si2168_DD_TS_FREQ_PROP
+              Si2168_DD_TS_FREQ_PROP_struct              dd_ts_freq;
+    #endif /* Si2168_DD_TS_FREQ_PROP */
+    #ifdef    Si2168_DD_TS_MODE_PROP
+              Si2168_DD_TS_MODE_PROP_struct              dd_ts_mode;
+    #endif /* Si2168_DD_TS_MODE_PROP */
+    #ifdef    Si2168_DD_TS_SETUP_PAR_PROP
+              Si2168_DD_TS_SETUP_PAR_PROP_struct         dd_ts_setup_par;
+    #endif /* Si2168_DD_TS_SETUP_PAR_PROP */
+    #ifdef    Si2168_DD_TS_SETUP_SER_PROP
+              Si2168_DD_TS_SETUP_SER_PROP_struct         dd_ts_setup_ser;
+    #endif /* Si2168_DD_TS_SETUP_SER_PROP */
+    #ifdef    Si2168_DVBC_ADC_CREST_FACTOR_PROP
+              Si2168_DVBC_ADC_CREST_FACTOR_PROP_struct   dvbc_adc_crest_factor;
+    #endif /* Si2168_DVBC_ADC_CREST_FACTOR_PROP */
+    #ifdef    Si2168_DVBC_AFC_RANGE_PROP
+              Si2168_DVBC_AFC_RANGE_PROP_struct          dvbc_afc_range;
+    #endif /* Si2168_DVBC_AFC_RANGE_PROP */
+    #ifdef    Si2168_DVBC_CONSTELLATION_PROP
+              Si2168_DVBC_CONSTELLATION_PROP_struct      dvbc_constellation;
+    #endif /* Si2168_DVBC_CONSTELLATION_PROP */
+    #ifdef    Si2168_DVBC_SYMBOL_RATE_PROP
+              Si2168_DVBC_SYMBOL_RATE_PROP_struct        dvbc_symbol_rate;
+    #endif /* Si2168_DVBC_SYMBOL_RATE_PROP */
+
+
+    #ifdef    Si2168_DVBT2_ADC_CREST_FACTOR_PROP
+              Si2168_DVBT2_ADC_CREST_FACTOR_PROP_struct  dvbt2_adc_crest_factor;
+    #endif /* Si2168_DVBT2_ADC_CREST_FACTOR_PROP */
+    #ifdef    Si2168_DVBT2_AFC_RANGE_PROP
+              Si2168_DVBT2_AFC_RANGE_PROP_struct         dvbt2_afc_range;
+    #endif /* Si2168_DVBT2_AFC_RANGE_PROP */
+    #ifdef    Si2168_DVBT2_FEF_TUNER_PROP
+              Si2168_DVBT2_FEF_TUNER_PROP_struct         dvbt2_fef_tuner;
+    #endif /* Si2168_DVBT2_FEF_TUNER_PROP */
+
+    #ifdef    Si2168_DVBT_ADC_CREST_FACTOR_PROP
+              Si2168_DVBT_ADC_CREST_FACTOR_PROP_struct   dvbt_adc_crest_factor;
+    #endif /* Si2168_DVBT_ADC_CREST_FACTOR_PROP */
+    #ifdef    Si2168_DVBT_AFC_RANGE_PROP
+              Si2168_DVBT_AFC_RANGE_PROP_struct          dvbt_afc_range;
+    #endif /* Si2168_DVBT_AFC_RANGE_PROP */
+    #ifdef    Si2168_DVBT_HIERARCHY_PROP
+              Si2168_DVBT_HIERARCHY_PROP_struct          dvbt_hierarchy;
+    #endif /* Si2168_DVBT_HIERARCHY_PROP */
+
+    #ifdef    Si2168_MASTER_IEN_PROP
+              Si2168_MASTER_IEN_PROP_struct              master_ien;
+    #endif /* Si2168_MASTER_IEN_PROP */
+    #ifdef    Si2168_SCAN_FMAX_PROP
+              Si2168_SCAN_FMAX_PROP_struct               scan_fmax;
+    #endif /* Si2168_SCAN_FMAX_PROP */
+    #ifdef    Si2168_SCAN_FMIN_PROP
+              Si2168_SCAN_FMIN_PROP_struct               scan_fmin;
+    #endif /* Si2168_SCAN_FMIN_PROP */
+    #ifdef    Si2168_SCAN_IEN_PROP
+              Si2168_SCAN_IEN_PROP_struct                scan_ien;
+    #endif /* Si2168_SCAN_IEN_PROP */
+    #ifdef    Si2168_SCAN_INT_SENSE_PROP
+              Si2168_SCAN_INT_SENSE_PROP_struct          scan_int_sense;
+    #endif /* Si2168_SCAN_INT_SENSE_PROP */
+
+    #ifdef    Si2168_SCAN_SYMB_RATE_MAX_PROP
+              Si2168_SCAN_SYMB_RATE_MAX_PROP_struct      scan_symb_rate_max;
+    #endif /* Si2168_SCAN_SYMB_RATE_MAX_PROP */
+    #ifdef    Si2168_SCAN_SYMB_RATE_MIN_PROP
+              Si2168_SCAN_SYMB_RATE_MIN_PROP_struct      scan_symb_rate_min;
+    #endif /* Si2168_SCAN_SYMB_RATE_MIN_PROP */
+    #ifdef    Si2168_SCAN_TER_CONFIG_PROP
+              Si2168_SCAN_TER_CONFIG_PROP_struct         scan_ter_config;
+    #endif /* Si2168_SCAN_TER_CONFIG_PROP */
+
+  } Si2168_PropObj;
+/* _properties_struct_insertion_point */
+
+#endif /* _Si2168_PROPERTIES_H_ */
+
+
+
+
+
diff -urN a/drivers/media/dvb-frontends/si2168_si2158.c b/drivers/media/dvb-frontends/si2168_si2158.c
--- a/drivers/media/dvb-frontends/si2168_si2158.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/dvb-frontends/si2168_si2158.c	2013-02-17 17:52:14.000000000 +0800
@@ -0,0 +1,2294 @@
+/****************************************************************/
+#include "si2158_firmware_0_E_build_15.h"
+#include "si2158_firmware_2_0_build_x.h"
+#include "si2168_priv.h"
+
+/************************************************************************************************************************
+  NAME: Si2158_XoutOn
+  Parameter:  Pointer to Si2158 Context (I2C address)
+  Returns:    I2C transaction error code, NO_Si2158_ERROR if successful
+************************************************************************************************************************/
+int Si2158_XoutOn             (L1_Si2158_Context *api)
+{
+    int return_code;
+    SiTRACE("Si2158_XoutOn:  Turning Xout ON\n");
+
+     if ((return_code = Si2158_L1_CONFIG_CLOCKS(api,
+                                              Si2158_CONFIG_CLOCKS_CMD_SUBCODE_CODE,
+                                              Si2158_CONFIG_CLOCKS_CMD_CLOCK_MODE_XTAL,
+                                              Si2158_CONFIG_CLOCKS_CMD_EN_XOUT_EN_XOUT)) != NO_Si2158_ERROR)
+    return return_code;
+
+    return NO_Si2158_ERROR;
+}
+
+ /************************************************************************************************************************
+  NAME: Si2158_XoutOff
+  Parameter:  Pointer to Si2158 Context (I2C address)
+  Returns:    I2C transaction error code, NO_Si2158_ERROR if successful
+************************************************************************************************************************/
+int Si2158_XoutOff            (L1_Si2158_Context *api)
+{
+    int return_code;
+    SiTRACE("Si2158_XoutOff:  Turning Xout OFF\n");
+    if ((return_code = Si2158_L1_CONFIG_CLOCKS(api,
+                                              Si2158_CONFIG_CLOCKS_CMD_SUBCODE_CODE,
+                                              Si2158_CONFIG_CLOCKS_CMD_CLOCK_MODE_XTAL,
+                                              Si2158_CONFIG_CLOCKS_CMD_EN_XOUT_DIS_XOUT)) != NO_Si2158_ERROR)
+
+    return return_code;
+
+    return NO_Si2158_ERROR;
+}
+/***********************************************************************************************************************
+  Si2158_CurrentResponseStatus function
+  Use:        status checking function
+              Used to fill the Si2158_COMMON_REPLY_struct members with the ptDataBuffer byte's bits
+  Comments:   The status byte definition being identical for all commands,
+              using this function to fill the status structure helps reducing the code size
+  Parameter: ptDataBuffer  a single byte received when reading a command's response (the first byte)
+  Returns:   0 if the err bit (bit 6) is unset, 1 otherwise
+ ***********************************************************************************************************************/
+unsigned char Si2158_CurrentResponseStatus (L1_Si2158_Context *api, unsigned char ptDataBuffer)
+{
+/* _status_code_insertion_start */
+    api->status->tunint = ((ptDataBuffer >> 0 ) & 0x01);
+    api->status->atvint = ((ptDataBuffer >> 1 ) & 0x01);
+    api->status->dtvint = ((ptDataBuffer >> 2 ) & 0x01);
+    api->status->err    = ((ptDataBuffer >> 6 ) & 0x01);
+    api->status->cts    = ((ptDataBuffer >> 7 ) & 0x01);
+/* _status_code_insertion_point */
+  return (api->status->err ? ERROR_Si2158_ERR : NO_Si2158_ERROR);
+}
+
+/***********************************************************************************************************************
+  Si2158_pollForResponse function
+  Use:        command response retrieval function
+              Used to retrieve the command response in the provided buffer
+  Comments:   The status byte definition being identical for all commands,
+              using this function to fill the status structure helps reducing the code size
+              max timeout = 1000 ms
+
+  Parameter:  nbBytes          the number of response bytes to read
+  Parameter:  pByteBuffer      a buffer into which bytes will be stored
+  Returns:    0 if no error, an error code otherwise
+ ***********************************************************************************************************************/
+unsigned char Si2158_pollForResponse (L1_Si2158_Context *api, unsigned int nbBytes, unsigned char *pByteBuffer)
+{
+  u32 ulCount, ulTick, ulDelay;
+  ulCount = 0;
+  ulTick = 50;
+  ulDelay = 1000/ulTick;
+
+  //start_time = system_time();
+
+  //while (system_time() - start_time <1000)  { /* wait a maximum of 1000ms */
+  while(ulCount <= ulTick) {
+    if ((unsigned int)L0_ReadCommandBytes(api->i2c, nbBytes, pByteBuffer) != nbBytes) {
+      SiTRACE("Si2158_pollForResponse ERROR reading byte 0!\n");
+      return ERROR_Si2158_POLLING_RESPONSE;
+    }
+    /* return response err flag if CTS set */
+    if (pByteBuffer[0] & 0x80)  {
+      return Si2158_CurrentResponseStatus(api, pByteBuffer[0]);
+    }
+    delayMS(ulDelay);
+    ulCount++;    
+  }
+
+  SiTRACE("Si2158_pollForResponse ERROR CTS Timeout!\n");
+  return ERROR_Si2158_CTS_TIMEOUT;
+}
+/***********************************************************************************************************************
+  Si2158_pollForCTS function
+  Use:        CTS checking function
+              Used to check the CTS bit until it is set before sending the next command
+  Comments:   The status byte definition being identical for all commands,
+              using this function to fill the status structure helps reducing the code size
+              max timeout = 1000 ms
+
+  Returns:   1 if the CTS bit is set, 0 otherwise
+ ***********************************************************************************************************************/
+unsigned char Si2158_pollForCTS (L1_Si2158_Context *api)
+{
+  unsigned char rspByteBuffer[1];
+  u32 ulCount, ulTick, ulDelay;
+  ulCount = 0;
+  ulTick = 50;
+  ulDelay = 1000/ulTick;
+  //start_time = system_time();
+
+  //while (system_time() - start_time <1000)  { /* wait a maximum of 1000ms */
+  while(ulCount <= ulTick) {
+    if (L0_ReadCommandBytes(api->i2c, 1, rspByteBuffer) != 1) {
+      SiTRACE("Si2158_pollForCTS ERROR reading byte 0!\n");
+      return ERROR_Si2158_POLLING_CTS;
+    }
+    /* return OK if CTS set */
+    if (rspByteBuffer[0] & 0x80) {
+      return NO_Si2158_ERROR;
+    }
+    delayMS(ulDelay);
+    ulCount++;
+  }
+
+  SiTRACE("Si2158_pollForCTS ERROR CTS Timeout!\n");
+  return ERROR_Si2158_CTS_TIMEOUT;
+}
+
+#ifdef    Si2158_CONFIG_CLOCKS_CMD
+ /*---------------------------------------------------*/
+/* Si2158_CONFIG_CLOCKS COMMAND                    */
+/*---------------------------------------------------*/
+unsigned char Si2158_L1_CONFIG_CLOCKS   (L1_Si2158_Context *api,
+                                         unsigned char   subcode,
+                                         unsigned char   clock_mode,
+                                         unsigned char   en_xout)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[3];
+    unsigned char rspByteBuffer[1];
+    api->rsp->config_clocks.STATUS = api->status;
+
+    SiTRACE("Si2158 CONFIG_CLOCKS ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((subcode    > Si2158_CONFIG_CLOCKS_CMD_SUBCODE_MAX   ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("SUBCODE %d "   , subcode    );
+    if ((clock_mode > Si2158_CONFIG_CLOCKS_CMD_CLOCK_MODE_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("CLOCK_MODE %d ", clock_mode );
+    if ((en_xout    > Si2158_CONFIG_CLOCKS_CMD_EN_XOUT_MAX   ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("EN_XOUT %d "   , en_xout    );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2158_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2158_CONFIG_CLOCKS_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( subcode    & Si2158_CONFIG_CLOCKS_CMD_SUBCODE_MASK    ) << Si2158_CONFIG_CLOCKS_CMD_SUBCODE_LSB   );
+    cmdByteBuffer[2] = (unsigned char) ( ( clock_mode & Si2158_CONFIG_CLOCKS_CMD_CLOCK_MODE_MASK ) << Si2158_CONFIG_CLOCKS_CMD_CLOCK_MODE_LSB|
+                                         ( en_xout    & Si2158_CONFIG_CLOCKS_CMD_EN_XOUT_MASK    ) << Si2158_CONFIG_CLOCKS_CMD_EN_XOUT_LSB   );
+
+    if (L0_WriteCommandBytes(api->i2c, 3, cmdByteBuffer) != 3) {
+      SiTRACE("Error writing CONFIG_CLOCKS bytes!\n");
+      return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    error_code = Si2158_pollForResponse(api, 1, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling CONFIG_CLOCKS response\n");
+      return error_code;
+    }
+
+
+    return NO_Si2158_ERROR;
+}
+#endif /* Si2158_CONFIG_CLOCKS_CMD */
+
+#ifdef    Si2158_DTV_STATUS_CMD
+ /*---------------------------------------------------*/
+/* Si2158_DTV_STATUS COMMAND                       */
+/*---------------------------------------------------*/
+unsigned char Si2158_L1_DTV_STATUS      (L1_Si2158_Context *api,
+                                         unsigned char   intack)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[4];
+    api->rsp->dtv_status.STATUS = api->status;
+
+    SiTRACE("Si2158 DTV_STATUS ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((intack > Si2158_DTV_STATUS_CMD_INTACK_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("INTACK %d ", intack );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2158_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2158_DTV_STATUS_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( intack & Si2158_DTV_STATUS_CMD_INTACK_MASK ) << Si2158_DTV_STATUS_CMD_INTACK_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing DTV_STATUS bytes!\n");
+      return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    error_code = Si2158_pollForResponse(api, 4, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DTV_STATUS response\n");
+      return error_code;
+    }
+
+    api->rsp->dtv_status.chlint     =   (( ( (rspByteBuffer[1]  )) >> Si2158_DTV_STATUS_RESPONSE_CHLINT_LSB     ) & Si2158_DTV_STATUS_RESPONSE_CHLINT_MASK     );
+    api->rsp->dtv_status.chl        =   (( ( (rspByteBuffer[2]  )) >> Si2158_DTV_STATUS_RESPONSE_CHL_LSB        ) & Si2158_DTV_STATUS_RESPONSE_CHL_MASK        );
+    api->rsp->dtv_status.bw         =   (( ( (rspByteBuffer[3]  )) >> Si2158_DTV_STATUS_RESPONSE_BW_LSB         ) & Si2158_DTV_STATUS_RESPONSE_BW_MASK         );
+    api->rsp->dtv_status.modulation =   (( ( (rspByteBuffer[3]  )) >> Si2158_DTV_STATUS_RESPONSE_MODULATION_LSB ) & Si2158_DTV_STATUS_RESPONSE_MODULATION_MASK );
+
+    return NO_Si2158_ERROR;
+}
+#endif /* Si2158_DTV_STATUS_CMD */
+
+#ifdef    Si2158_ATV_STATUS_CMD
+ /*---------------------------------------------------*/
+/* Si2158_ATV_STATUS COMMAND                       */
+/*---------------------------------------------------*/
+unsigned char Si2158_L1_ATV_STATUS      (L1_Si2158_Context *api,
+                                         unsigned char   intack)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[9];
+    api->rsp->atv_status.STATUS = api->status;
+
+    SiTRACE("Si2158 ATV_STATUS ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((intack > Si2158_ATV_STATUS_CMD_INTACK_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("INTACK %d ", intack );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2158_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2158_ATV_STATUS_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( intack & Si2158_ATV_STATUS_CMD_INTACK_MASK ) << Si2158_ATV_STATUS_CMD_INTACK_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing ATV_STATUS bytes!\n");
+      return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    error_code = Si2158_pollForResponse(api, 9, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling ATV_STATUS response\n");
+      return error_code;
+    }
+
+    api->rsp->atv_status.chlint    =   (( ( (rspByteBuffer[1]  )) >> Si2158_ATV_STATUS_RESPONSE_CHLINT_LSB    ) & Si2158_ATV_STATUS_RESPONSE_CHLINT_MASK    );
+    api->rsp->atv_status.pclint    =   (( ( (rspByteBuffer[1]  )) >> Si2158_ATV_STATUS_RESPONSE_PCLINT_LSB    ) & Si2158_ATV_STATUS_RESPONSE_PCLINT_MASK    );
+    api->rsp->atv_status.chl       =   (( ( (rspByteBuffer[2]  )) >> Si2158_ATV_STATUS_RESPONSE_CHL_LSB       ) & Si2158_ATV_STATUS_RESPONSE_CHL_MASK       );
+    api->rsp->atv_status.pcl       =   (( ( (rspByteBuffer[2]  )) >> Si2158_ATV_STATUS_RESPONSE_PCL_LSB       ) & Si2158_ATV_STATUS_RESPONSE_PCL_MASK       );
+    api->rsp->atv_status.afc_freq  = (((( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 )) >> Si2158_ATV_STATUS_RESPONSE_AFC_FREQ_LSB  ) & Si2158_ATV_STATUS_RESPONSE_AFC_FREQ_MASK) <<Si2158_ATV_STATUS_RESPONSE_AFC_FREQ_SHIFT ) >>Si2158_ATV_STATUS_RESPONSE_AFC_FREQ_SHIFT  );
+    api->rsp->atv_status.video_sys =   (( ( (rspByteBuffer[8]  )) >> Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_LSB ) & Si2158_ATV_STATUS_RESPONSE_VIDEO_SYS_MASK );
+    api->rsp->atv_status.color     =   (( ( (rspByteBuffer[8]  )) >> Si2158_ATV_STATUS_RESPONSE_COLOR_LSB     ) & Si2158_ATV_STATUS_RESPONSE_COLOR_MASK     );
+
+    return NO_Si2158_ERROR;
+}
+#endif /* Si2158_ATV_STATUS_CMD */
+
+#ifdef    Si2158_TUNER_STATUS_CMD
+ /*---------------------------------------------------*/
+/* Si2158_TUNER_STATUS COMMAND                     */
+/*---------------------------------------------------*/
+unsigned char Si2158_L1_TUNER_STATUS    (L1_Si2158_Context *api,
+                                         unsigned char   intack)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[12];
+    api->rsp->tuner_status.STATUS = api->status;
+
+    SiTRACE("Si2158 TUNER_STATUS ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((intack > Si2158_TUNER_STATUS_CMD_INTACK_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("INTACK %d ", intack );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2158_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2158_TUNER_STATUS_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( intack & Si2158_TUNER_STATUS_CMD_INTACK_MASK ) << Si2158_TUNER_STATUS_CMD_INTACK_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing TUNER_STATUS bytes!\n");
+      return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    error_code = Si2158_pollForResponse(api, 12, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling TUNER_STATUS response\n");
+      return error_code;
+    }
+
+    api->rsp->tuner_status.tcint    =   (( ( (rspByteBuffer[1]  )) >> Si2158_TUNER_STATUS_RESPONSE_TCINT_LSB    ) & Si2158_TUNER_STATUS_RESPONSE_TCINT_MASK    );
+    api->rsp->tuner_status.rssilint =   (( ( (rspByteBuffer[1]  )) >> Si2158_TUNER_STATUS_RESPONSE_RSSILINT_LSB ) & Si2158_TUNER_STATUS_RESPONSE_RSSILINT_MASK );
+    api->rsp->tuner_status.rssihint =   (( ( (rspByteBuffer[1]  )) >> Si2158_TUNER_STATUS_RESPONSE_RSSIHINT_LSB ) & Si2158_TUNER_STATUS_RESPONSE_RSSIHINT_MASK );
+    api->rsp->tuner_status.tc       =   (( ( (rspByteBuffer[2]  )) >> Si2158_TUNER_STATUS_RESPONSE_TC_LSB       ) & Si2158_TUNER_STATUS_RESPONSE_TC_MASK       );
+    api->rsp->tuner_status.rssil    =   (( ( (rspByteBuffer[2]  )) >> Si2158_TUNER_STATUS_RESPONSE_RSSIL_LSB    ) & Si2158_TUNER_STATUS_RESPONSE_RSSIL_MASK    );
+    api->rsp->tuner_status.rssih    =   (( ( (rspByteBuffer[2]  )) >> Si2158_TUNER_STATUS_RESPONSE_RSSIH_LSB    ) & Si2158_TUNER_STATUS_RESPONSE_RSSIH_MASK    );
+    api->rsp->tuner_status.rssi     = (((( ( (rspByteBuffer[3]  )) >> Si2158_TUNER_STATUS_RESPONSE_RSSI_LSB     ) & Si2158_TUNER_STATUS_RESPONSE_RSSI_MASK) <<Si2158_TUNER_STATUS_RESPONSE_RSSI_SHIFT ) >>Si2158_TUNER_STATUS_RESPONSE_RSSI_SHIFT     );
+    api->rsp->tuner_status.freq     =   (( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 ) | (rspByteBuffer[6]  << 16 ) | (rspByteBuffer[7]  << 24 )) >> Si2158_TUNER_STATUS_RESPONSE_FREQ_LSB     ) & Si2158_TUNER_STATUS_RESPONSE_FREQ_MASK     );
+    api->rsp->tuner_status.mode     =   (( ( (rspByteBuffer[8]  )) >> Si2158_TUNER_STATUS_RESPONSE_MODE_LSB     ) & Si2158_TUNER_STATUS_RESPONSE_MODE_MASK     );
+    api->rsp->tuner_status.vco_code = (((( ( (rspByteBuffer[10] ) | (rspByteBuffer[11] << 8 )) >> Si2158_TUNER_STATUS_RESPONSE_VCO_CODE_LSB ) & Si2158_TUNER_STATUS_RESPONSE_VCO_CODE_MASK) <<Si2158_TUNER_STATUS_RESPONSE_VCO_CODE_SHIFT ) >>Si2158_TUNER_STATUS_RESPONSE_VCO_CODE_SHIFT );
+
+    return NO_Si2158_ERROR;
+}
+#endif /* Si2158_TUNER_STATUS_CMD */
+#ifdef    Si2158_STANDBY_CMD
+ /*---------------------------------------------------*/
+/* Si2158_STANDBY COMMAND                          */
+/*---------------------------------------------------*/
+unsigned char Si2158_L1_STANDBY         (L1_Si2158_Context *api,
+                                         unsigned char   type)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[1];
+    api->rsp->standby.STATUS = api->status;
+
+    SiTRACE("Si2158 STANDBY ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((type > Si2158_STANDBY_CMD_TYPE_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("TYPE %d ", type );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2158_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2158_STANDBY_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( type & Si2158_STANDBY_CMD_TYPE_MASK ) << Si2158_STANDBY_CMD_TYPE_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing STANDBY bytes!\n");
+      return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    error_code = Si2158_pollForResponse(api, 1, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling STANDBY response\n");
+      return error_code;
+    }
+
+
+    return NO_Si2158_ERROR;
+}
+#endif /* Si2158_STANDBY_CMD */
+#ifdef    Si2158_SET_PROPERTY_CMD
+ /*---------------------------------------------------*/
+/* Si2158_SET_PROPERTY COMMAND                     */
+/*---------------------------------------------------*/
+unsigned char Si2158_L1_SET_PROPERTY    (L1_Si2158_Context *api,
+                                         unsigned char   reserved,
+                                         unsigned int    prop,
+                                         unsigned int    data)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[6];
+    unsigned char rspByteBuffer[4];
+    api->rsp->set_property.STATUS = api->status;
+
+    SiTRACE("Si2158 SET_PROPERTY ");
+  #ifdef   DEBUG_RANGE_CHECK
+    SiTRACE("RESERVED %d ", reserved );
+    SiTRACE("PROP %d "    , prop     );
+    SiTRACE("DATA %d "    , data     );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2158_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2158_SET_PROPERTY_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( reserved & Si2158_SET_PROPERTY_CMD_RESERVED_MASK ) << Si2158_SET_PROPERTY_CMD_RESERVED_LSB);
+    cmdByteBuffer[2] = (unsigned char) ( ( prop     & Si2158_SET_PROPERTY_CMD_PROP_MASK     ) << Si2158_SET_PROPERTY_CMD_PROP_LSB    );
+    cmdByteBuffer[3] = (unsigned char) ((( prop     & Si2158_SET_PROPERTY_CMD_PROP_MASK     ) << Si2158_SET_PROPERTY_CMD_PROP_LSB    )>>8);
+    cmdByteBuffer[4] = (unsigned char) ( ( data     & Si2158_SET_PROPERTY_CMD_DATA_MASK     ) << Si2158_SET_PROPERTY_CMD_DATA_LSB    );
+    cmdByteBuffer[5] = (unsigned char) ((( data     & Si2158_SET_PROPERTY_CMD_DATA_MASK     ) << Si2158_SET_PROPERTY_CMD_DATA_LSB    )>>8);
+
+    if (L0_WriteCommandBytes(api->i2c, 6, cmdByteBuffer) != 6) {
+      SiTRACE("Error writing SET_PROPERTY bytes!\n");
+      return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    error_code = Si2158_pollForResponse(api, 4, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling SET_PROPERTY response\n");
+      return error_code;
+    }
+
+    api->rsp->set_property.reserved =   (( ( (rspByteBuffer[1]  )) >> Si2158_SET_PROPERTY_RESPONSE_RESERVED_LSB ) & Si2158_SET_PROPERTY_RESPONSE_RESERVED_MASK );
+    api->rsp->set_property.data     =   (( ( (rspByteBuffer[2]  ) | (rspByteBuffer[3]  << 8 )) >> Si2158_SET_PROPERTY_RESPONSE_DATA_LSB     ) & Si2158_SET_PROPERTY_RESPONSE_DATA_MASK     );
+
+    return NO_Si2158_ERROR;
+}
+#endif /* Si2158_SET_PROPERTY_CMD */
+#ifdef    Si2158_AGC_OVERRIDE_CMD
+ /*---------------------------------------------------*/
+/* Si2158_AGC_OVERRIDE COMMAND                     */
+/*---------------------------------------------------*/
+unsigned char Si2158_L1_AGC_OVERRIDE    (L1_Si2158_Context *api,
+                                         unsigned char   force_max_gain,
+                                         unsigned char   force_top_gain)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[1];
+    api->rsp->agc_override.STATUS = api->status;
+
+    SiTRACE("Si2158 AGC_OVERRIDE ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((force_max_gain > Si2158_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("FORCE_MAX_GAIN %d ", force_max_gain );
+    if ((force_top_gain > Si2158_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("FORCE_TOP_GAIN %d ", force_top_gain );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2158_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2158_AGC_OVERRIDE_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( force_max_gain & Si2158_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_MASK ) << Si2158_AGC_OVERRIDE_CMD_FORCE_MAX_GAIN_LSB|
+                                         ( force_top_gain & Si2158_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_MASK ) << Si2158_AGC_OVERRIDE_CMD_FORCE_TOP_GAIN_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing AGC_OVERRIDE bytes!\n");
+      return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    error_code = Si2158_pollForResponse(api, 1, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling AGC_OVERRIDE response\n");
+      return error_code;
+    }
+
+
+    return NO_Si2158_ERROR;
+}
+#endif /* Si2158_AGC_OVERRIDE_CMD */
+#ifdef    Si2158_ATV_CW_TEST_CMD
+ /*---------------------------------------------------*/
+/* Si2158_ATV_CW_TEST COMMAND                      */
+/*---------------------------------------------------*/
+unsigned char Si2158_L1_ATV_CW_TEST     (L1_Si2158_Context *api,
+                                         unsigned char   pc_lock)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[1];
+    api->rsp->atv_cw_test.STATUS = api->status;
+
+    SiTRACE("Si2158 ATV_CW_TEST ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((pc_lock > Si2158_ATV_CW_TEST_CMD_PC_LOCK_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("PC_LOCK %d ", pc_lock );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2158_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2158_ATV_CW_TEST_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( pc_lock & Si2158_ATV_CW_TEST_CMD_PC_LOCK_MASK ) << Si2158_ATV_CW_TEST_CMD_PC_LOCK_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing ATV_CW_TEST bytes!\n");
+      return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    error_code = Si2158_pollForResponse(api, 1, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling ATV_CW_TEST response\n");
+      return error_code;
+    }
+
+
+    return NO_Si2158_ERROR;
+}
+#endif /* Si2158_ATV_CW_TEST_CMD */
+#ifdef    Si2158_ATV_RESTART_CMD
+ /*---------------------------------------------------*/
+/* Si2158_ATV_RESTART COMMAND                      */
+/*---------------------------------------------------*/
+unsigned char Si2158_L1_ATV_RESTART     (L1_Si2158_Context *api)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[1];
+    unsigned char rspByteBuffer[1];
+    api->rsp->atv_restart.STATUS = api->status;
+
+    SiTRACE("Si2158 ATV_RESTART ");
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2158_ATV_RESTART_CMD;
+
+    if (L0_WriteCommandBytes(api->i2c, 1, cmdByteBuffer) != 1) {
+      SiTRACE("Error writing ATV_RESTART bytes!\n");
+      return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    error_code = Si2158_pollForResponse(api, 1, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling ATV_RESTART response\n");
+      return error_code;
+    }
+
+
+    return NO_Si2158_ERROR;
+}
+#endif /* Si2158_ATV_RESTART_CMD */
+#ifdef    Si2158_CONFIG_PINS_CMD
+ /*---------------------------------------------------*/
+/* Si2158_CONFIG_PINS COMMAND                      */
+/*---------------------------------------------------*/
+unsigned char Si2158_L1_CONFIG_PINS     (L1_Si2158_Context *api,
+                                         unsigned char   gpio1_mode,
+                                         unsigned char   gpio1_read,
+                                         unsigned char   gpio2_mode,
+                                         unsigned char   gpio2_read,
+                                         unsigned char   reserved1,
+                                         unsigned char   reserved2,
+                                         unsigned char   reserved3)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[6];
+    unsigned char rspByteBuffer[6];
+    api->rsp->config_pins.STATUS = api->status;
+
+    SiTRACE("Si2158 CONFIG_PINS ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((gpio1_mode > Si2158_CONFIG_PINS_CMD_GPIO1_MODE_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("GPIO1_MODE %d ", gpio1_mode );
+    if ((gpio1_read > Si2158_CONFIG_PINS_CMD_GPIO1_READ_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("GPIO1_READ %d ", gpio1_read );
+    if ((gpio2_mode > Si2158_CONFIG_PINS_CMD_GPIO2_MODE_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("GPIO2_MODE %d ", gpio2_mode );
+    if ((gpio2_read > Si2158_CONFIG_PINS_CMD_GPIO2_READ_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("GPIO2_READ %d ", gpio2_read );
+    if ((reserved1  > Si2158_CONFIG_PINS_CMD_RESERVED1_MAX )  || (reserved1  < Si2158_CONFIG_PINS_CMD_RESERVED1_MIN ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED1 %d " , reserved1  );
+    if ((reserved2  > Si2158_CONFIG_PINS_CMD_RESERVED2_MAX )  || (reserved2  < Si2158_CONFIG_PINS_CMD_RESERVED2_MIN ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED2 %d " , reserved2  );
+    if ((reserved3  > Si2158_CONFIG_PINS_CMD_RESERVED3_MAX )  || (reserved3  < Si2158_CONFIG_PINS_CMD_RESERVED3_MIN ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED3 %d " , reserved3  );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2158_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2158_CONFIG_PINS_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( gpio1_mode & Si2158_CONFIG_PINS_CMD_GPIO1_MODE_MASK ) << Si2158_CONFIG_PINS_CMD_GPIO1_MODE_LSB|
+                                         ( gpio1_read & Si2158_CONFIG_PINS_CMD_GPIO1_READ_MASK ) << Si2158_CONFIG_PINS_CMD_GPIO1_READ_LSB);
+    cmdByteBuffer[2] = (unsigned char) ( ( gpio2_mode & Si2158_CONFIG_PINS_CMD_GPIO2_MODE_MASK ) << Si2158_CONFIG_PINS_CMD_GPIO2_MODE_LSB|
+                                         ( gpio2_read & Si2158_CONFIG_PINS_CMD_GPIO2_READ_MASK ) << Si2158_CONFIG_PINS_CMD_GPIO2_READ_LSB);
+    cmdByteBuffer[3] = (unsigned char) ( ( reserved1  & Si2158_CONFIG_PINS_CMD_RESERVED1_MASK  ) << Si2158_CONFIG_PINS_CMD_RESERVED1_LSB );
+    cmdByteBuffer[4] = (unsigned char) ( ( reserved2  & Si2158_CONFIG_PINS_CMD_RESERVED2_MASK  ) << Si2158_CONFIG_PINS_CMD_RESERVED2_LSB );
+    cmdByteBuffer[5] = (unsigned char) ( ( reserved3  & Si2158_CONFIG_PINS_CMD_RESERVED3_MASK  ) << Si2158_CONFIG_PINS_CMD_RESERVED3_LSB );
+
+    if (L0_WriteCommandBytes(api->i2c, 6, cmdByteBuffer) != 6) {
+      SiTRACE("Error writing CONFIG_PINS bytes!\n");
+      return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    error_code = Si2158_pollForResponse(api, 6, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling CONFIG_PINS response\n");
+      return error_code;
+    }
+
+    api->rsp->config_pins.gpio1_mode  =   (( ( (rspByteBuffer[1]  )) >> Si2158_CONFIG_PINS_RESPONSE_GPIO1_MODE_LSB  ) & Si2158_CONFIG_PINS_RESPONSE_GPIO1_MODE_MASK  );
+    api->rsp->config_pins.gpio1_state =   (( ( (rspByteBuffer[1]  )) >> Si2158_CONFIG_PINS_RESPONSE_GPIO1_STATE_LSB ) & Si2158_CONFIG_PINS_RESPONSE_GPIO1_STATE_MASK );
+    api->rsp->config_pins.gpio2_mode  =   (( ( (rspByteBuffer[2]  )) >> Si2158_CONFIG_PINS_RESPONSE_GPIO2_MODE_LSB  ) & Si2158_CONFIG_PINS_RESPONSE_GPIO2_MODE_MASK  );
+    api->rsp->config_pins.gpio2_state =   (( ( (rspByteBuffer[2]  )) >> Si2158_CONFIG_PINS_RESPONSE_GPIO2_STATE_LSB ) & Si2158_CONFIG_PINS_RESPONSE_GPIO2_STATE_MASK );
+    api->rsp->config_pins.reserved1   =   (( ( (rspByteBuffer[3]  )) >> Si2158_CONFIG_PINS_RESPONSE_RESERVED1_LSB   ) & Si2158_CONFIG_PINS_RESPONSE_RESERVED1_MASK   );
+    api->rsp->config_pins.reserved2   =   (( ( (rspByteBuffer[4]  )) >> Si2158_CONFIG_PINS_RESPONSE_RESERVED2_LSB   ) & Si2158_CONFIG_PINS_RESPONSE_RESERVED2_MASK   );
+    api->rsp->config_pins.reserved3   =   (( ( (rspByteBuffer[5]  )) >> Si2158_CONFIG_PINS_RESPONSE_RESERVED3_LSB   ) & Si2158_CONFIG_PINS_RESPONSE_RESERVED3_MASK   );
+
+    return NO_Si2158_ERROR;
+}
+#endif /* Si2158_CONFIG_PINS_CMD */
+#ifdef    Si2158_DTV_RESTART_CMD
+ /*---------------------------------------------------*/
+/* Si2158_DTV_RESTART COMMAND                      */
+/*---------------------------------------------------*/
+unsigned char Si2158_L1_DTV_RESTART     (L1_Si2158_Context *api)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[1];
+    unsigned char rspByteBuffer[1];
+    api->rsp->dtv_restart.STATUS = api->status;
+
+    SiTRACE("Si2158 DTV_RESTART ");
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2158_DTV_RESTART_CMD;
+
+    if (L0_WriteCommandBytes(api->i2c, 1, cmdByteBuffer) != 1) {
+      SiTRACE("Error writing DTV_RESTART bytes!\n");
+      return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    error_code = Si2158_pollForResponse(api, 1, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling DTV_RESTART response\n");
+      return error_code;
+    }
+
+
+    return NO_Si2158_ERROR;
+}
+#endif /* Si2158_DTV_RESTART_CMD */
+#ifdef    Si2158_EXIT_BOOTLOADER_CMD
+ /*---------------------------------------------------*/
+/* Si2158_EXIT_BOOTLOADER COMMAND                  */
+/*---------------------------------------------------*/
+unsigned char Si2158_L1_EXIT_BOOTLOADER (L1_Si2158_Context *api,
+                                         unsigned char   func,
+                                         unsigned char   ctsien)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[2];
+    unsigned char rspByteBuffer[1];
+    api->rsp->exit_bootloader.STATUS = api->status;
+
+    SiTRACE("Si2158 EXIT_BOOTLOADER ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((func   > Si2158_EXIT_BOOTLOADER_CMD_FUNC_MAX  ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("FUNC %d "  , func   );
+    if ((ctsien > Si2158_EXIT_BOOTLOADER_CMD_CTSIEN_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("CTSIEN %d ", ctsien );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2158_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2158_EXIT_BOOTLOADER_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( func   & Si2158_EXIT_BOOTLOADER_CMD_FUNC_MASK   ) << Si2158_EXIT_BOOTLOADER_CMD_FUNC_LSB  |
+                                         ( ctsien & Si2158_EXIT_BOOTLOADER_CMD_CTSIEN_MASK ) << Si2158_EXIT_BOOTLOADER_CMD_CTSIEN_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 2, cmdByteBuffer) != 2) {
+      SiTRACE("Error writing EXIT_BOOTLOADER bytes!\n");
+      return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    error_code = Si2158_pollForResponse(api, 1, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling EXIT_BOOTLOADER response\n");
+      return error_code;
+    }
+
+
+    return NO_Si2158_ERROR;
+}
+#endif /* Si2158_EXIT_BOOTLOADER_CMD */
+#ifdef    Si2158_FINE_TUNE_CMD
+ /*---------------------------------------------------*/
+/* Si2158_FINE_TUNE COMMAND                        */
+/*---------------------------------------------------*/
+unsigned char Si2158_L1_FINE_TUNE       (L1_Si2158_Context *api,
+                                         unsigned char   persistence,
+                                         unsigned char   apply_to_lif,
+                                                   int   offset_500hz)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[4];
+    unsigned char rspByteBuffer[1];
+    api->rsp->fine_tune.STATUS = api->status;
+
+    SiTRACE("Si2158 FINE_TUNE ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((persistence  > Si2158_FINE_TUNE_CMD_PERSISTENCE_MAX ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("PERSISTENCE %d " , persistence  );
+    if ((apply_to_lif > Si2158_FINE_TUNE_CMD_APPLY_TO_LIF_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("APPLY_TO_LIF %d ", apply_to_lif );
+    if ((offset_500hz > Si2158_FINE_TUNE_CMD_OFFSET_500HZ_MAX)  || (offset_500hz < Si2158_FINE_TUNE_CMD_OFFSET_500HZ_MIN) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("OFFSET_500HZ %d ", offset_500hz );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2158_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2158_FINE_TUNE_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( persistence  & Si2158_FINE_TUNE_CMD_PERSISTENCE_MASK  ) << Si2158_FINE_TUNE_CMD_PERSISTENCE_LSB |
+                                         ( apply_to_lif & Si2158_FINE_TUNE_CMD_APPLY_TO_LIF_MASK ) << Si2158_FINE_TUNE_CMD_APPLY_TO_LIF_LSB);
+    cmdByteBuffer[2] = (unsigned char) ( ( offset_500hz & Si2158_FINE_TUNE_CMD_OFFSET_500HZ_MASK ) << Si2158_FINE_TUNE_CMD_OFFSET_500HZ_LSB);
+    cmdByteBuffer[3] = (unsigned char) ((( offset_500hz & Si2158_FINE_TUNE_CMD_OFFSET_500HZ_MASK ) << Si2158_FINE_TUNE_CMD_OFFSET_500HZ_LSB)>>8);
+
+    if (L0_WriteCommandBytes(api->i2c, 4, cmdByteBuffer) != 4) {
+      SiTRACE("Error writing FINE_TUNE bytes!\n");
+      return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    error_code = Si2158_pollForResponse(api, 1, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling FINE_TUNE response\n");
+      return error_code;
+    }
+
+
+    return NO_Si2158_ERROR;
+}
+#endif /* Si2158_FINE_TUNE_CMD */
+#ifdef    Si2158_GET_PROPERTY_CMD
+ /*---------------------------------------------------*/
+/* Si2158_GET_PROPERTY COMMAND                     */
+/*---------------------------------------------------*/
+unsigned char Si2158_L1_GET_PROPERTY    (L1_Si2158_Context *api,
+                                         unsigned char   reserved,
+                                         unsigned int    prop)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[4];
+    unsigned char rspByteBuffer[4];
+    api->rsp->get_property.STATUS = api->status;
+
+    SiTRACE("Si2158 GET_PROPERTY ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((reserved > Si2158_GET_PROPERTY_CMD_RESERVED_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED %d ", reserved );
+    SiTRACE("PROP %d "    , prop     );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2158_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2158_GET_PROPERTY_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( reserved & Si2158_GET_PROPERTY_CMD_RESERVED_MASK ) << Si2158_GET_PROPERTY_CMD_RESERVED_LSB);
+    cmdByteBuffer[2] = (unsigned char) ( ( prop     & Si2158_GET_PROPERTY_CMD_PROP_MASK     ) << Si2158_GET_PROPERTY_CMD_PROP_LSB    );
+    cmdByteBuffer[3] = (unsigned char) ((( prop     & Si2158_GET_PROPERTY_CMD_PROP_MASK     ) << Si2158_GET_PROPERTY_CMD_PROP_LSB    )>>8);
+
+    if (L0_WriteCommandBytes(api->i2c, 4, cmdByteBuffer) != 4) {
+      SiTRACE("Error writing GET_PROPERTY bytes!\n");
+      return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    error_code = Si2158_pollForResponse(api, 4, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling GET_PROPERTY response\n");
+      return error_code;
+    }
+
+    api->rsp->get_property.reserved =   (( ( (rspByteBuffer[1]  )) >> Si2158_GET_PROPERTY_RESPONSE_RESERVED_LSB ) & Si2158_GET_PROPERTY_RESPONSE_RESERVED_MASK );
+    api->rsp->get_property.data     =   (( ( (rspByteBuffer[2]  ) | (rspByteBuffer[3]  << 8 )) >> Si2158_GET_PROPERTY_RESPONSE_DATA_LSB     ) & Si2158_GET_PROPERTY_RESPONSE_DATA_MASK     );
+
+    return NO_Si2158_ERROR;
+}
+#endif /* Si2158_GET_PROPERTY_CMD */
+#ifdef    Si2158_GET_REV_CMD
+ /*---------------------------------------------------*/
+/* Si2158_GET_REV COMMAND                          */
+/*---------------------------------------------------*/
+unsigned char Si2158_L1_GET_REV         (L1_Si2158_Context *api)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[1];
+    unsigned char rspByteBuffer[10];
+    api->rsp->get_rev.STATUS = api->status;
+
+    SiTRACE("Si2158 GET_REV ");
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2158_GET_REV_CMD;
+
+    if (L0_WriteCommandBytes(api->i2c, 1, cmdByteBuffer) != 1) {
+      SiTRACE("Error writing GET_REV bytes!\n");
+      return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    error_code = Si2158_pollForResponse(api, 10, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling GET_REV response\n");
+      return error_code;
+    }
+
+    api->rsp->get_rev.pn       =   (( ( (rspByteBuffer[1]  )) >> Si2158_GET_REV_RESPONSE_PN_LSB       ) & Si2158_GET_REV_RESPONSE_PN_MASK       );
+    api->rsp->get_rev.fwmajor  =   (( ( (rspByteBuffer[2]  )) >> Si2158_GET_REV_RESPONSE_FWMAJOR_LSB  ) & Si2158_GET_REV_RESPONSE_FWMAJOR_MASK  );
+    api->rsp->get_rev.fwminor  =   (( ( (rspByteBuffer[3]  )) >> Si2158_GET_REV_RESPONSE_FWMINOR_LSB  ) & Si2158_GET_REV_RESPONSE_FWMINOR_MASK  );
+    api->rsp->get_rev.patch    =   (( ( (rspByteBuffer[4]  ) | (rspByteBuffer[5]  << 8 )) >> Si2158_GET_REV_RESPONSE_PATCH_LSB    ) & Si2158_GET_REV_RESPONSE_PATCH_MASK    );
+    api->rsp->get_rev.cmpmajor =   (( ( (rspByteBuffer[6]  )) >> Si2158_GET_REV_RESPONSE_CMPMAJOR_LSB ) & Si2158_GET_REV_RESPONSE_CMPMAJOR_MASK );
+    api->rsp->get_rev.cmpminor =   (( ( (rspByteBuffer[7]  )) >> Si2158_GET_REV_RESPONSE_CMPMINOR_LSB ) & Si2158_GET_REV_RESPONSE_CMPMINOR_MASK );
+    api->rsp->get_rev.cmpbuild =   (( ( (rspByteBuffer[8]  )) >> Si2158_GET_REV_RESPONSE_CMPBUILD_LSB ) & Si2158_GET_REV_RESPONSE_CMPBUILD_MASK );
+    api->rsp->get_rev.chiprev  =   (( ( (rspByteBuffer[9]  )) >> Si2158_GET_REV_RESPONSE_CHIPREV_LSB  ) & Si2158_GET_REV_RESPONSE_CHIPREV_MASK  );
+
+    return NO_Si2158_ERROR;
+}
+#endif /* Si2158_GET_REV_CMD */
+#ifdef    Si2158_PART_INFO_CMD
+ /*---------------------------------------------------*/
+/* Si2158_PART_INFO COMMAND                        */
+/*---------------------------------------------------*/
+unsigned char Si2158_L1_PART_INFO       (L1_Si2158_Context *api)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[1];
+    unsigned char rspByteBuffer[13];
+    api->rsp->part_info.STATUS = api->status;
+
+    SiTRACE("Si2158 PART_INFO ");
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2158_PART_INFO_CMD;
+
+    if (L0_WriteCommandBytes(api->i2c, 1, cmdByteBuffer) != 1) {
+      SiTRACE("Error writing PART_INFO bytes!\n");
+      return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    error_code = Si2158_pollForResponse(api, 13, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling PART_INFO response\n");
+      return error_code;
+    }
+
+    api->rsp->part_info.chiprev  =   (( ( (rspByteBuffer[1]  )) >> Si2158_PART_INFO_RESPONSE_CHIPREV_LSB  ) & Si2158_PART_INFO_RESPONSE_CHIPREV_MASK  );
+    api->rsp->part_info.part     =   (( ( (rspByteBuffer[2]  )) >> Si2158_PART_INFO_RESPONSE_PART_LSB     ) & Si2158_PART_INFO_RESPONSE_PART_MASK     );
+    api->rsp->part_info.pmajor   =   (( ( (rspByteBuffer[3]  )) >> Si2158_PART_INFO_RESPONSE_PMAJOR_LSB   ) & Si2158_PART_INFO_RESPONSE_PMAJOR_MASK   );
+    api->rsp->part_info.pminor   =   (( ( (rspByteBuffer[4]  )) >> Si2158_PART_INFO_RESPONSE_PMINOR_LSB   ) & Si2158_PART_INFO_RESPONSE_PMINOR_MASK   );
+    api->rsp->part_info.pbuild   =   (( ( (rspByteBuffer[5]  )) >> Si2158_PART_INFO_RESPONSE_PBUILD_LSB   ) & Si2158_PART_INFO_RESPONSE_PBUILD_MASK   );
+    api->rsp->part_info.reserved =   (( ( (rspByteBuffer[6]  ) | (rspByteBuffer[7]  << 8 )) >> Si2158_PART_INFO_RESPONSE_RESERVED_LSB ) & Si2158_PART_INFO_RESPONSE_RESERVED_MASK );
+    api->rsp->part_info.serial   =   (( ( (rspByteBuffer[8]  ) | (rspByteBuffer[9]  << 8 ) | (rspByteBuffer[10] << 16 ) | (rspByteBuffer[11] << 24 )) >> Si2158_PART_INFO_RESPONSE_SERIAL_LSB   ) & Si2158_PART_INFO_RESPONSE_SERIAL_MASK   );
+    api->rsp->part_info.romid    =   (( ( (rspByteBuffer[12] )) >> Si2158_PART_INFO_RESPONSE_ROMID_LSB    ) & Si2158_PART_INFO_RESPONSE_ROMID_MASK    );
+
+    return NO_Si2158_ERROR;
+}
+#endif /* Si2158_PART_INFO_CMD */
+#ifdef    Si2158_POWER_DOWN_CMD
+ /*---------------------------------------------------*/
+/* Si2158_POWER_DOWN COMMAND                       */
+/*---------------------------------------------------*/
+unsigned char Si2158_L1_POWER_DOWN      (L1_Si2158_Context *api)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[1];
+    unsigned char rspByteBuffer[1];
+    api->rsp->power_down.STATUS = api->status;
+
+    SiTRACE("Si2158 POWER_DOWN ");
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2158_POWER_DOWN_CMD;
+
+    if (L0_WriteCommandBytes(api->i2c, 1, cmdByteBuffer) != 1) {
+      SiTRACE("Error writing POWER_DOWN bytes!\n");
+      return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    error_code = Si2158_pollForResponse(api, 1, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling POWER_DOWN response\n");
+      return error_code;
+    }
+
+
+    return NO_Si2158_ERROR;
+}
+#endif /* Si2158_POWER_DOWN_CMD */
+#ifdef    Si2158_POWER_DOWN_HW_CMD
+ /*---------------------------------------------------*/
+/* Si2158_POWER_DOWN_HW COMMAND                    */
+/*---------------------------------------------------*/
+unsigned char Si2158_L1_POWER_DOWN_HW   (L1_Si2158_Context *api,
+                                         unsigned char   subcode,
+                                         unsigned char   pd_xo_osc,
+                                         unsigned char   reserved1,
+                                         unsigned char   en_xout,
+                                         unsigned char   reserved2,
+                                         unsigned char   pd_ldo,
+                                         unsigned char   reserved3,
+                                         unsigned char   reserved4,
+                                         unsigned char   reserved5,
+                                         unsigned char   reserved6,
+                                         unsigned char   reserved7,
+                                         unsigned char   reserved8)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[10];
+    unsigned char rspByteBuffer[1];
+    api->rsp->power_down_hw.STATUS = api->status;
+
+    SiTRACE("Si2158 POWER_DOWN_HW ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((subcode   > Si2158_POWER_DOWN_HW_CMD_SUBCODE_MAX  ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("SUBCODE %d "  , subcode   );
+    if ((pd_xo_osc > Si2158_POWER_DOWN_HW_CMD_PD_XO_OSC_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("PD_XO_OSC %d ", pd_xo_osc );
+    if ((reserved1 > Si2158_POWER_DOWN_HW_CMD_RESERVED1_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED1 %d ", reserved1 );
+    if ((en_xout   > Si2158_POWER_DOWN_HW_CMD_EN_XOUT_MAX  ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("EN_XOUT %d "  , en_xout   );
+    if ((reserved2 > Si2158_POWER_DOWN_HW_CMD_RESERVED2_MAX)  || (reserved2 < Si2158_POWER_DOWN_HW_CMD_RESERVED2_MIN) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED2 %d ", reserved2 );
+    if ((pd_ldo    > Si2158_POWER_DOWN_HW_CMD_PD_LDO_MAX   ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("PD_LDO %d "   , pd_ldo    );
+    if ((reserved3 > Si2158_POWER_DOWN_HW_CMD_RESERVED3_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED3 %d ", reserved3 );
+    if ((reserved4 > Si2158_POWER_DOWN_HW_CMD_RESERVED4_MAX)  || (reserved4 < Si2158_POWER_DOWN_HW_CMD_RESERVED4_MIN) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED4 %d ", reserved4 );
+    if ((reserved5 > Si2158_POWER_DOWN_HW_CMD_RESERVED5_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED5 %d ", reserved5 );
+    if ((reserved6 > Si2158_POWER_DOWN_HW_CMD_RESERVED6_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED6 %d ", reserved6 );
+    if ((reserved7 > Si2158_POWER_DOWN_HW_CMD_RESERVED7_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED7 %d ", reserved7 );
+    if ((reserved8 > Si2158_POWER_DOWN_HW_CMD_RESERVED8_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED8 %d ", reserved8 );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2158_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2158_POWER_DOWN_HW_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( subcode   & Si2158_POWER_DOWN_HW_CMD_SUBCODE_MASK   ) << Si2158_POWER_DOWN_HW_CMD_SUBCODE_LSB  );
+    cmdByteBuffer[2] = (unsigned char) ( ( pd_xo_osc & Si2158_POWER_DOWN_HW_CMD_PD_XO_OSC_MASK ) << Si2158_POWER_DOWN_HW_CMD_PD_XO_OSC_LSB|
+                                         ( reserved1 & Si2158_POWER_DOWN_HW_CMD_RESERVED1_MASK ) << Si2158_POWER_DOWN_HW_CMD_RESERVED1_LSB|
+                                         ( en_xout   & Si2158_POWER_DOWN_HW_CMD_EN_XOUT_MASK   ) << Si2158_POWER_DOWN_HW_CMD_EN_XOUT_LSB  |
+                                         ( reserved2 & Si2158_POWER_DOWN_HW_CMD_RESERVED2_MASK ) << Si2158_POWER_DOWN_HW_CMD_RESERVED2_LSB);
+    cmdByteBuffer[3] = (unsigned char) ( ( pd_ldo    & Si2158_POWER_DOWN_HW_CMD_PD_LDO_MASK    ) << Si2158_POWER_DOWN_HW_CMD_PD_LDO_LSB   );
+    cmdByteBuffer[4] = (unsigned char) ( ( reserved3 & Si2158_POWER_DOWN_HW_CMD_RESERVED3_MASK ) << Si2158_POWER_DOWN_HW_CMD_RESERVED3_LSB);
+    cmdByteBuffer[5] = (unsigned char) ( ( reserved4 & Si2158_POWER_DOWN_HW_CMD_RESERVED4_MASK ) << Si2158_POWER_DOWN_HW_CMD_RESERVED4_LSB);
+    cmdByteBuffer[6] = (unsigned char) ( ( reserved5 & Si2158_POWER_DOWN_HW_CMD_RESERVED5_MASK ) << Si2158_POWER_DOWN_HW_CMD_RESERVED5_LSB);
+    cmdByteBuffer[7] = (unsigned char) ( ( reserved6 & Si2158_POWER_DOWN_HW_CMD_RESERVED6_MASK ) << Si2158_POWER_DOWN_HW_CMD_RESERVED6_LSB);
+    cmdByteBuffer[8] = (unsigned char) ( ( reserved7 & Si2158_POWER_DOWN_HW_CMD_RESERVED7_MASK ) << Si2158_POWER_DOWN_HW_CMD_RESERVED7_LSB);
+    cmdByteBuffer[9] = (unsigned char) ( ( reserved8 & Si2158_POWER_DOWN_HW_CMD_RESERVED8_MASK ) << Si2158_POWER_DOWN_HW_CMD_RESERVED8_LSB);
+
+    if (L0_WriteCommandBytes(api->i2c, 10, cmdByteBuffer) != 10) {
+      SiTRACE("Error writing POWER_DOWN_HW bytes!\n");
+      return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    error_code = Si2158_pollForResponse(api, 1, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling POWER_DOWN_HW response\n");
+      return error_code;
+    }
+
+
+    return NO_Si2158_ERROR;
+}
+#endif /* Si2158_POWER_DOWN_HW_CMD */
+#ifdef    Si2158_POWER_UP_CMD
+ /*---------------------------------------------------*/
+/* Si2158_POWER_UP COMMAND                         */
+/*---------------------------------------------------*/
+unsigned char Si2158_L1_POWER_UP        (L1_Si2158_Context *api,
+                                         unsigned char   subcode,
+                                         unsigned char   clock_mode,
+                                         unsigned char   en_xout,
+                                         unsigned char   pd_ldo,
+                                         unsigned char   reserved2,
+                                         unsigned char   reserved3,
+                                         unsigned char   reserved4,
+                                         unsigned char   reserved5,
+                                         unsigned char   reserved6,
+                                         unsigned char   reserved7,
+                                         unsigned char   reset,
+                                         unsigned char   clock_freq,
+                                         unsigned char   reserved8,
+                                         unsigned char   func,
+                                         unsigned char   ctsien,
+                                         unsigned char   wake_up)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[15];
+    unsigned char rspByteBuffer[1];
+    api->rsp->power_up.STATUS = api->status;
+
+    SiTRACE("Si2158 POWER_UP ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((subcode    > Si2158_POWER_UP_CMD_SUBCODE_MAX   ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("SUBCODE %d "   , subcode    );
+    if ((clock_mode > Si2158_POWER_UP_CMD_CLOCK_MODE_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("CLOCK_MODE %d ", clock_mode );
+    if ((en_xout    > Si2158_POWER_UP_CMD_EN_XOUT_MAX   ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("EN_XOUT %d "   , en_xout    );
+    if ((pd_ldo     > Si2158_POWER_UP_CMD_PD_LDO_MAX    ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("PD_LDO %d "    , pd_ldo     );
+    if ((reserved2  > Si2158_POWER_UP_CMD_RESERVED2_MAX ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED2 %d " , reserved2  );
+    if ((reserved3  > Si2158_POWER_UP_CMD_RESERVED3_MAX )  || (reserved3  < Si2158_POWER_UP_CMD_RESERVED3_MIN ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED3 %d " , reserved3  );
+    if ((reserved4  > Si2158_POWER_UP_CMD_RESERVED4_MAX )  || (reserved4  < Si2158_POWER_UP_CMD_RESERVED4_MIN ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED4 %d " , reserved4  );
+    if ((reserved5  > Si2158_POWER_UP_CMD_RESERVED5_MAX )  || (reserved5  < Si2158_POWER_UP_CMD_RESERVED5_MIN ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED5 %d " , reserved5  );
+    if ((reserved6  > Si2158_POWER_UP_CMD_RESERVED6_MAX )  || (reserved6  < Si2158_POWER_UP_CMD_RESERVED6_MIN ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED6 %d " , reserved6  );
+    if ((reserved7  > Si2158_POWER_UP_CMD_RESERVED7_MAX )  || (reserved7  < Si2158_POWER_UP_CMD_RESERVED7_MIN ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED7 %d " , reserved7  );
+    if ((reset      > Si2158_POWER_UP_CMD_RESET_MAX     )  || (reset      < Si2158_POWER_UP_CMD_RESET_MIN     ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESET %d "     , reset      );
+    if ((clock_freq > Si2158_POWER_UP_CMD_CLOCK_FREQ_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("CLOCK_FREQ %d ", clock_freq );
+    if ((reserved8  > Si2158_POWER_UP_CMD_RESERVED8_MAX ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("RESERVED8 %d " , reserved8  );
+    if ((func       > Si2158_POWER_UP_CMD_FUNC_MAX      ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("FUNC %d "      , func       );
+    if ((ctsien     > Si2158_POWER_UP_CMD_CTSIEN_MAX    ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("CTSIEN %d "    , ctsien     );
+    if ((wake_up    > Si2158_POWER_UP_CMD_WAKE_UP_MAX   )  || (wake_up    < Si2158_POWER_UP_CMD_WAKE_UP_MIN   ) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("WAKE_UP %d "   , wake_up    );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2158_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2158_POWER_UP_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( subcode    & Si2158_POWER_UP_CMD_SUBCODE_MASK    ) << Si2158_POWER_UP_CMD_SUBCODE_LSB   );
+    cmdByteBuffer[2] = (unsigned char) ( ( clock_mode & Si2158_POWER_UP_CMD_CLOCK_MODE_MASK ) << Si2158_POWER_UP_CMD_CLOCK_MODE_LSB|
+                                         ( en_xout    & Si2158_POWER_UP_CMD_EN_XOUT_MASK    ) << Si2158_POWER_UP_CMD_EN_XOUT_LSB   );
+    cmdByteBuffer[3] = (unsigned char) ( ( pd_ldo     & Si2158_POWER_UP_CMD_PD_LDO_MASK     ) << Si2158_POWER_UP_CMD_PD_LDO_LSB    );
+    cmdByteBuffer[4] = (unsigned char) ( ( reserved2  & Si2158_POWER_UP_CMD_RESERVED2_MASK  ) << Si2158_POWER_UP_CMD_RESERVED2_LSB );
+    cmdByteBuffer[5] = (unsigned char) ( ( reserved3  & Si2158_POWER_UP_CMD_RESERVED3_MASK  ) << Si2158_POWER_UP_CMD_RESERVED3_LSB );
+    cmdByteBuffer[6] = (unsigned char) ( ( reserved4  & Si2158_POWER_UP_CMD_RESERVED4_MASK  ) << Si2158_POWER_UP_CMD_RESERVED4_LSB );
+    cmdByteBuffer[7] = (unsigned char) ( ( reserved5  & Si2158_POWER_UP_CMD_RESERVED5_MASK  ) << Si2158_POWER_UP_CMD_RESERVED5_LSB );
+    cmdByteBuffer[8] = (unsigned char) ( ( reserved6  & Si2158_POWER_UP_CMD_RESERVED6_MASK  ) << Si2158_POWER_UP_CMD_RESERVED6_LSB );
+    cmdByteBuffer[9] = (unsigned char) ( ( reserved7  & Si2158_POWER_UP_CMD_RESERVED7_MASK  ) << Si2158_POWER_UP_CMD_RESERVED7_LSB );
+    cmdByteBuffer[10] = (unsigned char) ( ( reset      & Si2158_POWER_UP_CMD_RESET_MASK      ) << Si2158_POWER_UP_CMD_RESET_LSB     );
+    cmdByteBuffer[11] = (unsigned char) ( ( clock_freq & Si2158_POWER_UP_CMD_CLOCK_FREQ_MASK ) << Si2158_POWER_UP_CMD_CLOCK_FREQ_LSB);
+    cmdByteBuffer[12] = (unsigned char) ( ( reserved8  & Si2158_POWER_UP_CMD_RESERVED8_MASK  ) << Si2158_POWER_UP_CMD_RESERVED8_LSB );
+    cmdByteBuffer[13] = (unsigned char) ( ( func       & Si2158_POWER_UP_CMD_FUNC_MASK       ) << Si2158_POWER_UP_CMD_FUNC_LSB      |
+                                         ( ctsien     & Si2158_POWER_UP_CMD_CTSIEN_MASK     ) << Si2158_POWER_UP_CMD_CTSIEN_LSB    );
+    cmdByteBuffer[14] = (unsigned char) ( ( wake_up    & Si2158_POWER_UP_CMD_WAKE_UP_MASK    ) << Si2158_POWER_UP_CMD_WAKE_UP_LSB   );
+
+    if (L0_WriteCommandBytes(api->i2c, 15, cmdByteBuffer) != 15) {
+      SiTRACE("Error writing POWER_UP bytes!\n");
+      return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    error_code = Si2158_pollForResponse(api, 1, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling POWER_UP response\n");
+      return error_code;
+    }
+
+
+    return NO_Si2158_ERROR;
+}
+#endif /* Si2158_POWER_UP_CMD */
+#ifdef    Si2158_TUNER_TUNE_FREQ_CMD
+ /*---------------------------------------------------*/
+/* Si2158_TUNER_TUNE_FREQ COMMAND                  */
+/*---------------------------------------------------*/
+unsigned char Si2158_L1_TUNER_TUNE_FREQ (L1_Si2158_Context *api,
+                                         unsigned char   mode,
+                                         unsigned long   freq)
+{
+    unsigned char error_code = 0;
+    unsigned char cmdByteBuffer[8];
+    unsigned char rspByteBuffer[1];
+    api->rsp->tuner_tune_freq.STATUS = api->status;
+
+    SiTRACE("Si2158 TUNER_TUNE_FREQ ");
+  #ifdef   DEBUG_RANGE_CHECK
+    if ((mode > Si2158_TUNER_TUNE_FREQ_CMD_MODE_MAX) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("MODE %d ", mode );
+    if ((freq > Si2158_TUNER_TUNE_FREQ_CMD_FREQ_MAX)  || (freq < Si2158_TUNER_TUNE_FREQ_CMD_FREQ_MIN) ) {error_code++; SiTRACE("\nOut of range: ");}; SiTRACE("FREQ %d ", freq );
+    if (error_code) {
+      SiTRACE("%d out of range parameters\n", error_code);
+      return ERROR_Si2158_PARAMETER_OUT_OF_RANGE;
+    }
+  #endif /* DEBUG_RANGE_CHECK */
+
+    SiTRACE("\n");
+    cmdByteBuffer[0] = Si2158_TUNER_TUNE_FREQ_CMD;
+    cmdByteBuffer[1] = (unsigned char) ( ( mode & Si2158_TUNER_TUNE_FREQ_CMD_MODE_MASK ) << Si2158_TUNER_TUNE_FREQ_CMD_MODE_LSB);
+    cmdByteBuffer[2] = (unsigned char)0x00;
+    cmdByteBuffer[3] = (unsigned char)0x00;
+    cmdByteBuffer[4] = (unsigned char) ( ( freq & Si2158_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << Si2158_TUNER_TUNE_FREQ_CMD_FREQ_LSB);
+    cmdByteBuffer[5] = (unsigned char) ((( freq & Si2158_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << Si2158_TUNER_TUNE_FREQ_CMD_FREQ_LSB)>>8);
+    cmdByteBuffer[6] = (unsigned char) ((( freq & Si2158_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << Si2158_TUNER_TUNE_FREQ_CMD_FREQ_LSB)>>16);
+    cmdByteBuffer[7] = (unsigned char) ((( freq & Si2158_TUNER_TUNE_FREQ_CMD_FREQ_MASK ) << Si2158_TUNER_TUNE_FREQ_CMD_FREQ_LSB)>>24);
+
+    if (L0_WriteCommandBytes(api->i2c, 8, cmdByteBuffer) != 8) {
+      SiTRACE("Error writing TUNER_TUNE_FREQ bytes!\n");
+      return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    error_code = Si2158_pollForResponse(api, 1, rspByteBuffer);
+    if (error_code) {
+      SiTRACE("Error polling TUNER_TUNE_FREQ response\n");
+      return error_code;
+    }
+
+
+    return NO_Si2158_ERROR;
+}
+#endif /* Si2158_TUNER_TUNE_FREQ_CMD */
+
+  /* --------------------------------------------*/
+  /* SEND_COMMAND2 FUNCTION                      */
+  /* --------------------------------------------*/
+unsigned char   Si2158_L1_SendCommand2(L1_Si2158_Context *api, unsigned int cmd_code) {
+    switch (cmd_code) {
+    #ifdef        Si2158_AGC_OVERRIDE_CMD
+     case         Si2158_AGC_OVERRIDE_CMD_CODE:
+       return Si2158_L1_AGC_OVERRIDE (api, api->cmd->agc_override.force_max_gain, api->cmd->agc_override.force_top_gain );
+     break;
+    #endif /*     Si2158_AGC_OVERRIDE_CMD */
+    #ifdef        Si2158_ATV_CW_TEST_CMD
+     case         Si2158_ATV_CW_TEST_CMD_CODE:
+       return Si2158_L1_ATV_CW_TEST (api, api->cmd->atv_cw_test.pc_lock );
+     break;
+    #endif /*     Si2158_ATV_CW_TEST_CMD */
+    #ifdef        Si2158_ATV_RESTART_CMD
+     case         Si2158_ATV_RESTART_CMD_CODE:
+       return Si2158_L1_ATV_RESTART (api );
+     break;
+    #endif /*     Si2158_ATV_RESTART_CMD */
+    #ifdef        Si2158_ATV_STATUS_CMD
+     case         Si2158_ATV_STATUS_CMD_CODE:
+       return Si2158_L1_ATV_STATUS (api, api->cmd->atv_status.intack );
+     break;
+    #endif /*     Si2158_ATV_STATUS_CMD */
+    #ifdef        Si2158_CONFIG_CLOCKS_CMD
+     case         Si2158_CONFIG_CLOCKS_CMD_CODE:
+       return Si2158_L1_CONFIG_CLOCKS (api, api->cmd->config_clocks.subcode, api->cmd->config_clocks.clock_mode, api->cmd->config_clocks.en_xout );
+     break;
+    #endif /*     Si2158_CONFIG_CLOCKS_CMD */
+    #ifdef        Si2158_CONFIG_PINS_CMD
+     case         Si2158_CONFIG_PINS_CMD_CODE:
+       return Si2158_L1_CONFIG_PINS (api, api->cmd->config_pins.gpio1_mode, api->cmd->config_pins.gpio1_read, api->cmd->config_pins.gpio2_mode, api->cmd->config_pins.gpio2_read, api->cmd->config_pins.reserved1, api->cmd->config_pins.reserved2, api->cmd->config_pins.reserved3 );
+     break;
+    #endif /*     Si2158_CONFIG_PINS_CMD */
+    #ifdef        Si2158_DTV_RESTART_CMD
+     case         Si2158_DTV_RESTART_CMD_CODE:
+       return Si2158_L1_DTV_RESTART (api );
+     break;
+    #endif /*     Si2158_DTV_RESTART_CMD */
+    #ifdef        Si2158_DTV_STATUS_CMD
+     case         Si2158_DTV_STATUS_CMD_CODE:
+       return Si2158_L1_DTV_STATUS (api, api->cmd->dtv_status.intack );
+     break;
+    #endif /*     Si2158_DTV_STATUS_CMD */
+    #ifdef        Si2158_EXIT_BOOTLOADER_CMD
+     case         Si2158_EXIT_BOOTLOADER_CMD_CODE:
+       return Si2158_L1_EXIT_BOOTLOADER (api, api->cmd->exit_bootloader.func, api->cmd->exit_bootloader.ctsien );
+     break;
+    #endif /*     Si2158_EXIT_BOOTLOADER_CMD */
+    #ifdef        Si2158_FINE_TUNE_CMD
+     case         Si2158_FINE_TUNE_CMD_CODE:
+       return Si2158_L1_FINE_TUNE (api, api->cmd->fine_tune.persistence, api->cmd->fine_tune.apply_to_lif, api->cmd->fine_tune.offset_500hz );
+     break;
+    #endif /*     Si2158_FINE_TUNE_CMD */
+    #ifdef        Si2158_GET_PROPERTY_CMD
+     case         Si2158_GET_PROPERTY_CMD_CODE:
+       return Si2158_L1_GET_PROPERTY (api, api->cmd->get_property.reserved, api->cmd->get_property.prop );
+     break;
+    #endif /*     Si2158_GET_PROPERTY_CMD */
+    #ifdef        Si2158_GET_REV_CMD
+     case         Si2158_GET_REV_CMD_CODE:
+       return Si2158_L1_GET_REV (api );
+     break;
+    #endif /*     Si2158_GET_REV_CMD */
+    #ifdef        Si2158_PART_INFO_CMD
+     case         Si2158_PART_INFO_CMD_CODE:
+       return Si2158_L1_PART_INFO (api );
+     break;
+    #endif /*     Si2158_PART_INFO_CMD */
+    #ifdef        Si2158_POWER_DOWN_CMD
+     case         Si2158_POWER_DOWN_CMD_CODE:
+       return Si2158_L1_POWER_DOWN (api );
+     break;
+    #endif /*     Si2158_POWER_DOWN_CMD */
+    #ifdef        Si2158_POWER_DOWN_HW_CMD
+     case         Si2158_POWER_DOWN_HW_CMD_CODE:
+       return Si2158_L1_POWER_DOWN_HW (api, api->cmd->power_down_hw.subcode, api->cmd->power_down_hw.pd_xo_osc, api->cmd->power_down_hw.reserved1, api->cmd->power_down_hw.en_xout, api->cmd->power_down_hw.reserved2, api->cmd->power_down_hw.pd_ldo, api->cmd->power_down_hw.reserved3, api->cmd->power_down_hw.reserved4, api->cmd->power_down_hw.reserved5, api->cmd->power_down_hw.reserved6, api->cmd->power_down_hw.reserved7, api->cmd->power_down_hw.reserved8 );
+     break;
+    #endif /*     Si2158_POWER_DOWN_HW_CMD */
+    #ifdef        Si2158_POWER_UP_CMD
+     case         Si2158_POWER_UP_CMD_CODE:
+       return Si2158_L1_POWER_UP (api, api->cmd->power_up.subcode, api->cmd->power_up.clock_mode, api->cmd->power_up.en_xout, api->cmd->power_up.pd_ldo, api->cmd->power_up.reserved2, api->cmd->power_up.reserved3, api->cmd->power_up.reserved4, api->cmd->power_up.reserved5, api->cmd->power_up.reserved6, api->cmd->power_up.reserved7, api->cmd->power_up.reset, api->cmd->power_up.clock_freq, api->cmd->power_up.reserved8, api->cmd->power_up.func, api->cmd->power_up.ctsien, api->cmd->power_up.wake_up );
+     break;
+    #endif /*     Si2158_POWER_UP_CMD */
+    #ifdef        Si2158_SET_PROPERTY_CMD
+     case         Si2158_SET_PROPERTY_CMD_CODE:
+       return Si2158_L1_SET_PROPERTY (api, api->cmd->set_property.reserved, api->cmd->set_property.prop, api->cmd->set_property.data );
+     break;
+    #endif /*     Si2158_SET_PROPERTY_CMD */
+    #ifdef        Si2158_STANDBY_CMD
+     case         Si2158_STANDBY_CMD_CODE:
+       return Si2158_L1_STANDBY (api, api->cmd->standby.type );
+     break;
+    #endif /*     Si2158_STANDBY_CMD */
+    #ifdef        Si2158_TUNER_STATUS_CMD
+     case         Si2158_TUNER_STATUS_CMD_CODE:
+       return Si2158_L1_TUNER_STATUS (api, api->cmd->tuner_status.intack );
+     break;
+    #endif /*     Si2158_TUNER_STATUS_CMD */
+    #ifdef        Si2158_TUNER_TUNE_FREQ_CMD
+     case         Si2158_TUNER_TUNE_FREQ_CMD_CODE:
+       return Si2158_L1_TUNER_TUNE_FREQ (api, api->cmd->tuner_tune_freq.mode, api->cmd->tuner_tune_freq.freq );
+     break;
+    #endif /*     Si2158_TUNER_TUNE_FREQ_CMD */
+   default : break;
+    }
+     return 0;
+  }
+
+/***********************************************************************************************************************
+  Si2158_L1_API_ERROR_TEXT function
+  Use:        Error information function
+              Used to retrieve a text based on an error code
+  Returns:    the error text
+  Parameter:  error_code the error code.
+  Porting:    Useful for application development for debug purposes.
+  Porting:    May not be required for the final application, can be removed if not used.
+ ***********************************************************************************************************************/
+char*            Si2158_L1_API_ERROR_TEXT(unsigned char error_code) {
+    switch (error_code) {
+        case NO_Si2158_ERROR                     : return (char *)"No Si2158 error";
+        case ERROR_Si2158_ALLOCATING_CONTEXT     : return (char *)"Error while allocating Si2158 context";
+        case ERROR_Si2158_PARAMETER_OUT_OF_RANGE : return (char *)"Si2158 parameter(s) out of range";
+        case ERROR_Si2158_SENDING_COMMAND        : return (char *)"Error while sending Si2158 command";
+        case ERROR_Si2158_CTS_TIMEOUT            : return (char *)"Si2158 CTS timeout";
+        case ERROR_Si2158_ERR                    : return (char *)"Si2158 Error (status 'err' bit 1)";
+        case ERROR_Si2158_POLLING_CTS            : return (char *)"Si2158 Error while polling CTS";
+        case ERROR_Si2158_POLLING_RESPONSE       : return (char *)"Si2158 Error while polling response";
+        case ERROR_Si2158_LOADING_FIRMWARE       : return (char *)"Si2158 Error while loading firmware";
+        case ERROR_Si2158_LOADING_BOOTBLOCK      : return (char *)"Si2158 Error while loading bootblock";
+        case ERROR_Si2158_STARTING_FIRMWARE      : return (char *)"Si2158 Error while starting firmware";
+        case ERROR_Si2158_SW_RESET               : return (char *)"Si2158 Error during software reset";
+        case ERROR_Si2158_INCOMPATIBLE_PART      : return (char *)"Si2158 Error Incompatible part";
+/* _specific_error_text_string_insertion_start */
+        case ERROR_Si2158_TUNINT_TIMEOUT         : return (char *)"Si2158 Error TUNINT Timeout";
+        case ERROR_Si2158_xTVINT_TIMEOUT         : return (char *)"Si2158 Error xTVINT Timeout";
+/* _specific_error_text_string_insertion_point */
+        default                                  : return (char *)"Unknown Si2158 error code";
+    }
+}
+/***********************************************************************************************************************
+  Si2158_L1_CheckStatus function
+  Use:        Status information function
+              Used to retrieve the status byte
+  Returns:    0 if no error
+  Parameter:  error_code the error code.
+ ***********************************************************************************************************************/
+unsigned char    Si2158_L1_CheckStatus   (L1_Si2158_Context *api) {
+    unsigned char rspByteBuffer[1];
+    return Si2158_pollForResponse(api, 1, rspByteBuffer);
+}
+/***********************************************************************************************************************
+  Si2158_L1_API_Init function
+  Use:        software initialisation function
+              Used to initialize the software context
+  Returns:    0 if no error
+  Comments:   It should be called first and once only when starting the application
+  Parameter:   **ppapi         a pointer to the api context to initialize
+  Parameter:  add            the Si2158 I2C address
+  Porting:    Allocation errors need to be properly managed.
+  Porting:    I2C initialization needs to be adapted to use the available I2C functions
+ ***********************************************************************************************************************/
+unsigned char    Si2158_L1_API_Init      (L1_Si2158_Context *api, int add) {
+    api->i2c = &(api->i2cObj);
+
+    L0_Init(api->i2c);
+    L0_SetAddress(api->i2c, add, 0);
+
+    api->cmd    = &(api->cmdObj);
+    api->rsp    = &(api->rspObj);
+    api->prop   = &(api->propObj);
+    api->status = &(api->statusObj);
+
+    api->part             = Si2158_part;
+    api->chiprev          = Si2158_chiprev;
+    api->partMajorVersion = Si2158_partMajorVersion;
+    api->partMinorVersion = Si2158_partMinorVersion;
+    api->partRomid        = Si2158_partRomid;
+
+    return NO_Si2158_ERROR;
+}
+/***********************************************************************************************************************
+  Si2158_L1_API_Patch function
+  Use:        Patch information function
+              Used to send a number of bytes to the Si2158. Useful to download the firmware.
+  Returns:    0 if no error
+  Parameter:  error_code the error code.
+  Porting:    Useful for application development for debug purposes.
+  Porting:    May not be required for the final application, can be removed if not used.
+ ***********************************************************************************************************************/
+unsigned char    Si2158_L1_API_Patch     (L1_Si2158_Context *api, int iNbBytes, unsigned char *pucDataBuffer) {
+    unsigned char res;
+    unsigned char rspByteBuffer[1];
+
+    SiTRACE("Si2158 Patch %d bytes\n",iNbBytes);
+
+    res = (unsigned char)L0_WriteCommandBytes(api->i2c, iNbBytes, pucDataBuffer);
+    if (res!=iNbBytes) {
+      SiTRACE("Si2158_L1_API_Patch error 0x%02x writing bytes: %s\n", res, Si2158_L1_API_ERROR_TEXT(res) );
+      return res;
+    }
+
+    res = Si2158_pollForResponse(api, 1, rspByteBuffer);
+    if (res != NO_Si2158_ERROR) {
+      SiTRACE("Si2158_L1_API_Patch error 0x%02x polling response: %s\n", res, Si2158_L1_API_ERROR_TEXT(res) );
+      return ERROR_Si2158_POLLING_RESPONSE;
+    }
+
+    return NO_Si2158_ERROR;
+}
+
+/************************************************************************************************************************
+  NAME: Si2158_Configure
+  DESCRIPTION: Setup Si2158 video filters, GPIOs/clocks, Common Properties startup, etc.
+  Parameter:  Pointer to Si2158 Context
+  Returns:    I2C transaction error code, NO_Si2158_ERROR if successful
+************************************************************************************************************************/
+int Si2158_Configure           (L1_Si2158_Context *api)
+{
+    int return_code;
+    return_code = NO_Si2158_ERROR;
+/* _specific_configure_insertion_start */
+ #ifdef USING_ALIF_FILTER
+    if ((return_code = Si2158_LoadVideofilter(api,ALIF_VIDFILT_TABLE,ALIF_VIDFILT_LINES)) != NO_Si2158_ERROR)
+       return return_code;
+  #endif
+     /* load DTV video filter file */
+  #ifdef USING_DLIF_FILTER
+     if ((return_code = Si2158_LoadVideofilter(api,DLIF_VIDFILT_TABLE,DLIF_VIDFILT_LINES)) != NO_Si2158_ERROR)
+       return return_code;
+  #endif
+    /* _specific_configure_insertion_point */
+    /* Set All Properties startup configuration */
+    Si2158_setupAllDefaults     (api);
+    Si2158_downloadAllProperties(api);
+
+    return return_code;
+}
+/************************************************************************************************************************
+  NAME: Si2158_PowerUpWithPatch
+  DESCRIPTION: Send Si2158 API PowerUp Command with PowerUp to bootloader,
+  Check the Chip rev and part, and ROMID are compared to expected values.
+  Load the Firmware Patch then Start the Firmware.
+  Programming Guide Reference:    Flowchart A.2 (POWER_UP with patch flowchart)
+
+  Parameter:  pointer to Si2158 Context
+  Returns:    Si2158/I2C transaction error code, NO_Si2158_ERROR if successful
+************************************************************************************************************************/
+int Si2158_PowerUpWithPatch    (L1_Si2158_Context *api)
+{
+    int return_code;
+    return_code = NO_Si2158_ERROR;
+
+    /* always wait for CTS prior to POWER_UP command */
+    if ((return_code = Si2158_pollForCTS  (api)) != NO_Si2158_ERROR) {
+        SiTRACE ("Si2158_pollForCTS error 0x%02x\n", return_code);
+        return return_code;
+    }
+
+    if ((return_code = Si2158_L1_POWER_UP (api,
+                            Si2158_POWER_UP_CMD_SUBCODE_CODE,
+                            Si2158_POWER_UP_CMD_CLOCK_MODE_XTAL,
+                            Si2158_POWER_UP_CMD_EN_XOUT_DIS_XOUT,
+                            Si2158_POWER_UP_CMD_PD_LDO_LDO_POWER_UP,
+                            Si2158_POWER_UP_CMD_RESERVED2_RESERVED,
+                            Si2158_POWER_UP_CMD_RESERVED3_RESERVED,
+                            Si2158_POWER_UP_CMD_RESERVED4_RESERVED,
+                            Si2158_POWER_UP_CMD_RESERVED5_RESERVED,
+                            Si2158_POWER_UP_CMD_RESERVED6_RESERVED,
+                            Si2158_POWER_UP_CMD_RESERVED7_RESERVED,
+                            Si2158_POWER_UP_CMD_RESET_RESET,
+                            Si2158_POWER_UP_CMD_CLOCK_FREQ_CLK_24MHZ,
+                            Si2158_POWER_UP_CMD_RESERVED8_RESERVED,
+                            Si2158_POWER_UP_CMD_FUNC_BOOTLOADER,
+                            Si2158_POWER_UP_CMD_CTSIEN_DISABLE,
+                            Si2158_POWER_UP_CMD_WAKE_UP_WAKE_UP
+                            )) != NO_Si2158_ERROR)
+    {
+        SiTRACE ("Si2158_L1_POWER_UP error 0x%02x: %s\n", return_code, Si2158_L1_API_ERROR_TEXT((unsigned char)return_code) );
+        return return_code;
+    }
+
+    /* Get the Part Info from the chip.   This command is only valid in Bootloader mode */
+    if ((return_code = Si2158_L1_PART_INFO(api)) != NO_Si2158_ERROR) {
+        SiTRACE ("Si2158_L1_PART_INFO error 0x%02x: %s\n", return_code, Si2158_L1_API_ERROR_TEXT((unsigned char)return_code) );
+        return return_code;
+    }
+    SiTRACE("chiprev %d\n",        api->rsp->part_info.chiprev);
+    SiTRACE("part    Si21%d\n",    api->rsp->part_info.part   );
+    SiTRACE("pmajor  %d\n",        api->rsp->part_info.pmajor );
+    if (api->rsp->part_info.pmajor >= 0x30) {
+    SiTRACE("pmajor '%c'\n",       api->rsp->part_info.pmajor );
+    }
+    SiTRACE("pminor  %d\n",        api->rsp->part_info.pminor );
+    if (api->rsp->part_info.pminor >= 0x30) {
+    SiTRACE("pminor '%c'\n",       api->rsp->part_info.pminor );
+    }
+    SiTRACE("romid %3d/0x%02x\n",  api->rsp->part_info.romid,  api->rsp->part_info.romid );
+#ifdef    PART_INTEGRITY_CHECKS
+    /* Check the Chip revision, part and ROMID against expected values and report an error if incompatible */
+    if (api->rsp->part_info.chiprev != api->chiprev) {
+        SiTRACE ("INCOMPATIBLE PART error chiprev %d (expected %d)\n", api->rsp->part_info.chiprev, api->chiprev);
+        return_code = ERROR_Si2158_INCOMPATIBLE_PART;
+    }
+    /* Part Number is represented as the last 2 digits */
+    if (api->rsp->part_info.part != api->part) {
+        SiTRACE ("INCOMPATIBLE PART error part   %d (expected %d)\n", api->rsp->part_info.part, api->part);
+        return_code = ERROR_Si2158_INCOMPATIBLE_PART;
+    }
+    /* Part Major Version in ASCII */
+    if (api->rsp->part_info.pmajor != api->partMajorVersion) {
+        SiTRACE ("INCOMPATIBLE PART error pmajor %d (expected %d)\n", api->rsp->part_info.pmajor, api->partMajorVersion);
+        return_code = ERROR_Si2158_INCOMPATIBLE_PART;
+    }
+    /* Part Minor Version in ASCII */
+    if (api->rsp->part_info.pminor != api->partMinorVersion) {
+        SiTRACE ("INCOMPATIBLE PART error pminor %d (expected %d)\n", api->rsp->part_info.pminor, api->partMinorVersion);
+        return_code = ERROR_Si2158_INCOMPATIBLE_PART;
+    }
+    /* ROMID in byte representation */
+    if (api->rsp->part_info.romid != api->partRomid) {
+        SiTRACE ("INCOMPATIBLE PART error romid %3d (expected %2d)\n", api->rsp->part_info.romid, api->partRomid);
+        return_code = ERROR_Si2158_INCOMPATIBLE_PART;
+    }
+    if (return_code != NO_Si2158_ERROR) return return_code;
+#endif /* PART_INTEGRITY_CHECKS */
+      /* Load the Firmware based on ROMID */
+    if (api->rsp->part_info.romid == 0x32)
+    {
+      /* Load the Firmware */
+        if ((return_code = Si2158_LoadFirmware(api, Si2158_FW_0_Eb15, FIRMWARE_LINES_0_Eb15)) != NO_Si2158_ERROR) {
+         SiTRACE ("Si2158_LoadFirmware error 0x%02x: %s\n", return_code, Si2158_L1_API_ERROR_TEXT((unsigned char)return_code) );
+         return return_code;
+       }
+    }
+    else if (api->rsp->part_info.romid == 0x33) /* if Si2158-A20 part load firmware patch (currently a dummy patch , 20bx) */
+    {
+        /* This dummy patch (20bx) will skip the loadFirmware function and boot from NVM only.
+           When a new patch is available for the Si2158-A20, include the patch file and replace the firmware array and size in the function below */
+        if ((return_code = Si2158_LoadFirmware_16(api, Si2158_FW_2_0bx, FIRMWARE_LINES_2_0bx)) != NO_Si2158_ERROR)
+        {
+          SiTRACE ("Si2158_LoadFirmware_16 error 0x%02x: %s\n", return_code, Si2158_L1_API_ERROR_TEXT((unsigned char)return_code) );
+          return return_code;
+        }
+    }
+    else
+    {
+        SiTRACE ("INCOMPATIBLE PART error ROMID 0x%02x (expected 0x%02x)\n", api->rsp->part_info.romid, api->partRomid);
+        return ERROR_Si2158_INCOMPATIBLE_PART;
+    }
+
+    /*Start the Firmware */
+    if ((return_code = Si2158_StartFirmware(api)) != NO_Si2158_ERROR) { /* Start firmware */
+        SiTRACE ("Si2158_StartFirmware error 0x%02x: %s\n", return_code, Si2158_L1_API_ERROR_TEXT((unsigned char)return_code) );
+        return return_code;
+    }
+
+    return NO_Si2158_ERROR;
+}
+/************************************************************************************************************************
+  NAME: Si2158_LoadFirmware_16
+  DESCRIPTON: Load firmware from firmware_struct array in Si2158_Firmware_x_y_build_z.h file into Si2158
+              Requires Si2158 to be in bootloader mode after PowerUp
+  Programming Guide Reference:    Flowchart A.3 (Download FW PATCH flowchart)
+
+  Parameter:  Si2158 Context (I2C address)
+  Parameter:  pointer to firmware_struct array
+  Parameter:  number of lines in firmware table array (size in bytes / firmware_struct)
+  Returns:    Si2158/I2C transaction error code, NO_Si2158_ERROR if successful
+************************************************************************************************************************/
+int Si2158_LoadFirmware_16        (L1_Si2158_Context *api, firmware_struct fw_table[], int nbLines)
+{
+    int return_code;
+    int line;
+    return_code = NO_Si2158_ERROR;
+
+    SiTRACE ("Si2158_LoadFirmware_16 starting...\n");
+    SiTRACE ("Si2158_LoadFirmware_16 nbLines %d\n", nbLines);
+
+    /* for each line in fw_table */
+    for (line = 0; line < nbLines; line++)
+    {
+		if (fw_table[line].firmware_len > 0)  /* don't download if length is 0 , e.g. dummy firmware */
+		{
+			/* send firmware_len bytes (up to 16) to Si2158 */
+			if ((return_code = Si2158_L1_API_Patch(api, fw_table[line].firmware_len, fw_table[line].firmware_table)) != NO_Si2158_ERROR)
+			{
+			  SiTRACE("Si2158_LoadFirmware_16 error 0x%02x patching line %d: %s\n", return_code, line, Si2158_L1_API_ERROR_TEXT((unsigned char)return_code) );
+			  if (line == 0) {
+			  SiTRACE("The firmware is incompatible with the part!\n");
+			  }
+			  return ERROR_Si2158_LOADING_FIRMWARE;
+			}
+			//if (line==3) SiTraceConfiguration("traces suspend");
+		}
+    }
+    //SiTraceConfiguration("traces resume");
+    SiTRACE ("Si2158_LoadFirmware_16 complete...\n");
+    return NO_Si2158_ERROR;
+}
+/************************************************************************************************************************
+  NAME: Si2158_LoadFirmware
+  DESCRIPTON: Load firmware from FIRMWARE_TABLE array in Si2158_Firmware_x_y_build_z.h file into Si2158
+              Requires Si2158 to be in bootloader mode after PowerUp
+  Programming Guide Reference:    Flowchart A.3 (Download FW PATCH flowchart)
+
+  Parameter:  Si2158 Context (I2C address)
+  Parameter:  pointer to firmware table array
+  Parameter:  number of lines in firmware table array (size in bytes / BYTES_PER_LINE)
+  Returns:    Si2158/I2C transaction error code, NO_Si2158_ERROR if successful
+************************************************************************************************************************/
+int Si2158_LoadFirmware        (L1_Si2158_Context *api, unsigned char fw_table[], int nbLines)
+{
+    int return_code;
+    int line;
+    return_code = NO_Si2158_ERROR;
+
+    SiTRACE ("Si2158_LoadFirmware starting...\n");
+    SiTRACE ("Si2158_LoadFirmware nbLines %d\n", nbLines);
+
+    /* for each line in fw_table */
+    for (line = 0; line < nbLines; line++)
+    {
+        /* send Si2158_BYTES_PER_LINE fw bytes to Si2158 */
+        if ((return_code = Si2158_L1_API_Patch(api, Si2158_BYTES_PER_LINE, fw_table + Si2158_BYTES_PER_LINE*line)) != NO_Si2158_ERROR)
+        {
+          SiTRACE("Si2158_LoadFirmware error 0x%02x patching line %d: %s\n", return_code, line, Si2158_L1_API_ERROR_TEXT((unsigned char)return_code) );
+          if (line == 0) {
+          SiTRACE("The firmware is incompatible with the part!\n");
+          }
+          return ERROR_Si2158_LOADING_FIRMWARE;
+        }
+        //if (line==3) SiTraceConfiguration("traces suspend");
+    }
+    //SiTraceConfiguration("traces resume");
+    SiTRACE ("Si2158_LoadFirmware complete...\n");
+    return NO_Si2158_ERROR;
+}
+/************************************************************************************************************************
+  NAME: Si2158_StartFirmware
+  DESCRIPTION: Start Si2158 firmware (put the Si2158 into run mode)
+  Parameter:   Si2158 Context (I2C address)
+  Parameter (passed by Reference):   ExitBootloadeer Response Status byte : tunint, atvint, dtvint, err, cts
+  Returns:     I2C transaction error code, NO_Si2158_ERROR if successful
+************************************************************************************************************************/
+int Si2158_StartFirmware       (L1_Si2158_Context *api)
+{
+
+    if (Si2158_L1_EXIT_BOOTLOADER(api, Si2158_EXIT_BOOTLOADER_CMD_FUNC_TUNER, Si2158_EXIT_BOOTLOADER_CMD_CTSIEN_OFF) != NO_Si2158_ERROR)
+    {
+        return ERROR_Si2158_STARTING_FIRMWARE;
+    }
+
+    return NO_Si2158_ERROR;
+}
+
+/************************************************************************************************************************
+  NAME: Si2158_Init
+  DESCRIPTION:Reset and Initialize Si2158
+  Parameter:  Si2158 Context (I2C address)
+  Returns:    I2C transaction error code, NO_Si2158_ERROR if successful
+************************************************************************************************************************/
+int Si2158_Init                (L1_Si2158_Context *api)
+{
+    int return_code;
+    SiTRACE("Si2158_Init starting...\n");
+
+    if ((return_code = Si2158_PowerUpWithPatch(api)) != NO_Si2158_ERROR) {   /* PowerUp into bootloader */
+        SiTRACE ("Si2158_PowerUpWithPatch error 0x%02x: %s\n", return_code, Si2158_L1_API_ERROR_TEXT((unsigned char)return_code) );
+        return return_code;
+    }
+    /* At this point, FW is loaded and started.  */
+    Si2158_Configure(api);
+    SiTRACE("Si2158_Init complete...\n");
+    return NO_Si2158_ERROR;
+}
+/***********************************************************************************************************************
+  Si2158_L1_SetProperty function
+  Use:        property set function
+              Used to call L1_SET_PROPERTY with the property Id and data provided.
+  Parameter: *api     the Si2158 context
+  Parameter: prop     the property Id
+  Parameter: data     the property bytes
+  Returns:    0 if no error, an error code otherwise
+ ***********************************************************************************************************************/
+unsigned char Si2158_L1_SetProperty(L1_Si2158_Context *api, unsigned int prop, int  data)  {
+    unsigned char  reserved          = 0;
+    return Si2158_L1_SET_PROPERTY (api, reserved, prop, data);
+}
+  /* --------------------------------------------*/
+  /* SET_PROPERTY2 FUNCTION                      */
+  /* --------------------------------------------*/
+unsigned char Si2158_L1_SetProperty2(L1_Si2158_Context *api, unsigned int prop_code) {
+    int data;
+#ifdef    Si2158_GET_PROPERTY_STRING
+    char msg[1000];
+#endif /* Si2158_GET_PROPERTY_STRING */
+    switch (prop_code) {
+    #ifdef        Si2158_ATV_AFC_RANGE_PROP
+     case         Si2158_ATV_AFC_RANGE_PROP_CODE:
+       data = (api->prop->atv_afc_range.range_khz & Si2158_ATV_AFC_RANGE_PROP_RANGE_KHZ_MASK) << Si2158_ATV_AFC_RANGE_PROP_RANGE_KHZ_LSB ;
+     break;
+    #endif /*     Si2158_ATV_AFC_RANGE_PROP */
+    #ifdef        Si2158_ATV_AGC_SPEED_PROP
+     case         Si2158_ATV_AGC_SPEED_PROP_CODE:
+       data = (api->prop->atv_agc_speed.if_agc_speed & Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK) << Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB ;
+     break;
+    #endif /*     Si2158_ATV_AGC_SPEED_PROP */
+    #ifdef        Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP
+     case         Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_CODE:
+       data = (api->prop->atv_agc_speed_low_rssi.if_agc_speed & Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_MASK) << Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_LSB  |
+              (api->prop->atv_agc_speed_low_rssi.thld         & Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_MASK        ) << Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_THLD_LSB ;
+     break;
+    #endif /*     Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP */
+    #ifdef        Si2158_ATV_ARTIFICIAL_SNOW_PROP
+     case         Si2158_ATV_ARTIFICIAL_SNOW_PROP_CODE:
+       data = (api->prop->atv_artificial_snow.gain   & Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_MASK  ) << Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_LSB  |
+              (api->prop->atv_artificial_snow.offset & Si2158_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_MASK) << Si2158_ATV_ARTIFICIAL_SNOW_PROP_OFFSET_LSB ;
+     break;
+    #endif /*     Si2158_ATV_ARTIFICIAL_SNOW_PROP */
+    #ifdef        Si2158_ATV_CONFIG_IF_PORT_PROP
+     case         Si2158_ATV_CONFIG_IF_PORT_PROP_CODE:
+       data = (api->prop->atv_config_if_port.atv_out_type   & Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_MASK  ) << Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LSB  |
+              (api->prop->atv_config_if_port.atv_agc_source & Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_MASK) << Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_LSB ;
+     break;
+    #endif /*     Si2158_ATV_CONFIG_IF_PORT_PROP */
+    #ifdef        Si2158_ATV_EXT_AGC_PROP
+     case         Si2158_ATV_EXT_AGC_PROP_CODE:
+       data = (api->prop->atv_ext_agc.min_10mv & Si2158_ATV_EXT_AGC_PROP_MIN_10MV_MASK) << Si2158_ATV_EXT_AGC_PROP_MIN_10MV_LSB  |
+              (api->prop->atv_ext_agc.max_10mv & Si2158_ATV_EXT_AGC_PROP_MAX_10MV_MASK) << Si2158_ATV_EXT_AGC_PROP_MAX_10MV_LSB ;
+     break;
+    #endif /*     Si2158_ATV_EXT_AGC_PROP */
+    #ifdef        Si2158_ATV_IEN_PROP
+     case         Si2158_ATV_IEN_PROP_CODE:
+       data = (api->prop->atv_ien.chlien & Si2158_ATV_IEN_PROP_CHLIEN_MASK) << Si2158_ATV_IEN_PROP_CHLIEN_LSB  |
+              (api->prop->atv_ien.pclien & Si2158_ATV_IEN_PROP_PCLIEN_MASK) << Si2158_ATV_IEN_PROP_PCLIEN_LSB ;
+     break;
+    #endif /*     Si2158_ATV_IEN_PROP */
+    #ifdef        Si2158_ATV_INT_SENSE_PROP
+     case         Si2158_ATV_INT_SENSE_PROP_CODE:
+       data = (api->prop->atv_int_sense.chlnegen & Si2158_ATV_INT_SENSE_PROP_CHLNEGEN_MASK) << Si2158_ATV_INT_SENSE_PROP_CHLNEGEN_LSB  |
+              (api->prop->atv_int_sense.pclnegen & Si2158_ATV_INT_SENSE_PROP_PCLNEGEN_MASK) << Si2158_ATV_INT_SENSE_PROP_PCLNEGEN_LSB  |
+              (api->prop->atv_int_sense.chlposen & Si2158_ATV_INT_SENSE_PROP_CHLPOSEN_MASK) << Si2158_ATV_INT_SENSE_PROP_CHLPOSEN_LSB  |
+              (api->prop->atv_int_sense.pclposen & Si2158_ATV_INT_SENSE_PROP_PCLPOSEN_MASK) << Si2158_ATV_INT_SENSE_PROP_PCLPOSEN_LSB ;
+     break;
+    #endif /*     Si2158_ATV_INT_SENSE_PROP */
+    #ifdef        Si2158_ATV_LIF_FREQ_PROP
+     case         Si2158_ATV_LIF_FREQ_PROP_CODE:
+       data = (api->prop->atv_lif_freq.offset & Si2158_ATV_LIF_FREQ_PROP_OFFSET_MASK) << Si2158_ATV_LIF_FREQ_PROP_OFFSET_LSB ;
+     break;
+    #endif /*     Si2158_ATV_LIF_FREQ_PROP */
+    #ifdef        Si2158_ATV_LIF_OUT_PROP
+     case         Si2158_ATV_LIF_OUT_PROP_CODE:
+       data = (api->prop->atv_lif_out.offset & Si2158_ATV_LIF_OUT_PROP_OFFSET_MASK) << Si2158_ATV_LIF_OUT_PROP_OFFSET_LSB  |
+              (api->prop->atv_lif_out.amp    & Si2158_ATV_LIF_OUT_PROP_AMP_MASK   ) << Si2158_ATV_LIF_OUT_PROP_AMP_LSB ;
+     break;
+    #endif /*     Si2158_ATV_LIF_OUT_PROP */
+    #ifdef        Si2158_ATV_PGA_TARGET_PROP
+     case         Si2158_ATV_PGA_TARGET_PROP_CODE:
+       data = (api->prop->atv_pga_target.pga_target      & Si2158_ATV_PGA_TARGET_PROP_PGA_TARGET_MASK     ) << Si2158_ATV_PGA_TARGET_PROP_PGA_TARGET_LSB  |
+              (api->prop->atv_pga_target.override_enable & Si2158_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_MASK) << Si2158_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_LSB ;
+     break;
+    #endif /*     Si2158_ATV_PGA_TARGET_PROP */
+    #ifdef        Si2158_ATV_RF_TOP_PROP
+     case         Si2158_ATV_RF_TOP_PROP_CODE:
+       data = (api->prop->atv_rf_top.atv_rf_top & Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_MASK) << Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_LSB ;
+     break;
+    #endif /*     Si2158_ATV_RF_TOP_PROP */
+    #ifdef        Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP
+     case         Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_CODE:
+       data = (api->prop->atv_rsq_rssi_threshold.lo & Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK) << Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB  |
+              (api->prop->atv_rsq_rssi_threshold.hi & Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK) << Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB ;
+     break;
+    #endif /*     Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP */
+    #ifdef        Si2158_ATV_VIDEO_MODE_PROP
+     case         Si2158_ATV_VIDEO_MODE_PROP_CODE:
+       data = (api->prop->atv_video_mode.video_sys       & Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_MASK      ) << Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_LSB  |
+              (api->prop->atv_video_mode.color           & Si2158_ATV_VIDEO_MODE_PROP_COLOR_MASK          ) << Si2158_ATV_VIDEO_MODE_PROP_COLOR_LSB  |
+              (api->prop->atv_video_mode.invert_spectrum & Si2158_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_MASK) << Si2158_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_LSB ;
+     break;
+    #endif /*     Si2158_ATV_VIDEO_MODE_PROP */
+    #ifdef        Si2158_ATV_VSNR_CAP_PROP
+     case         Si2158_ATV_VSNR_CAP_PROP_CODE:
+       data = (api->prop->atv_vsnr_cap.atv_vsnr_cap & Si2158_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_MASK) << Si2158_ATV_VSNR_CAP_PROP_ATV_VSNR_CAP_LSB ;
+     break;
+    #endif /*     Si2158_ATV_VSNR_CAP_PROP */
+    #ifdef        Si2158_CRYSTAL_TRIM_PROP
+     case         Si2158_CRYSTAL_TRIM_PROP_CODE:
+       data = (api->prop->crystal_trim.xo_cap & Si2158_CRYSTAL_TRIM_PROP_XO_CAP_MASK) << Si2158_CRYSTAL_TRIM_PROP_XO_CAP_LSB ;
+     break;
+    #endif /*     Si2158_CRYSTAL_TRIM_PROP */
+    #ifdef        Si2158_DTV_AGC_FREEZE_INPUT_PROP
+     case         Si2158_DTV_AGC_FREEZE_INPUT_PROP_CODE:
+       data = (api->prop->dtv_agc_freeze_input.level & Si2158_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_MASK) << Si2158_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_LSB  |
+              (api->prop->dtv_agc_freeze_input.pin   & Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_MASK  ) << Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_LSB ;
+     break;
+    #endif /*     Si2158_DTV_AGC_FREEZE_INPUT_PROP */
+    #ifdef        Si2158_DTV_AGC_SPEED_PROP
+     case         Si2158_DTV_AGC_SPEED_PROP_CODE:
+       data = (api->prop->dtv_agc_speed.if_agc_speed & Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_MASK) << Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_LSB  |
+              (api->prop->dtv_agc_speed.agc_decim    & Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_MASK   ) << Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_LSB ;
+     break;
+    #endif /*     Si2158_DTV_AGC_SPEED_PROP */
+    #ifdef        Si2158_DTV_CONFIG_IF_PORT_PROP
+     case         Si2158_DTV_CONFIG_IF_PORT_PROP_CODE:
+       data = (api->prop->dtv_config_if_port.dtv_out_type   & Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_MASK  ) << Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LSB  |
+              (api->prop->dtv_config_if_port.dtv_agc_source & Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_MASK) << Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_AGC_SOURCE_LSB ;
+     break;
+    #endif /*     Si2158_DTV_CONFIG_IF_PORT_PROP */
+    #ifdef        Si2158_DTV_EXT_AGC_PROP
+     case         Si2158_DTV_EXT_AGC_PROP_CODE:
+       data = (api->prop->dtv_ext_agc.min_10mv & Si2158_DTV_EXT_AGC_PROP_MIN_10MV_MASK) << Si2158_DTV_EXT_AGC_PROP_MIN_10MV_LSB  |
+              (api->prop->dtv_ext_agc.max_10mv & Si2158_DTV_EXT_AGC_PROP_MAX_10MV_MASK) << Si2158_DTV_EXT_AGC_PROP_MAX_10MV_LSB ;
+     break;
+    #endif /*     Si2158_DTV_EXT_AGC_PROP */
+    #ifdef        Si2158_DTV_FILTER_SELECT_PROP
+     case         Si2158_DTV_FILTER_SELECT_PROP_CODE:
+       data = (api->prop->dtv_filter_select.filter & Si2158_DTV_FILTER_SELECT_PROP_FILTER_MASK) << Si2158_DTV_FILTER_SELECT_PROP_FILTER_LSB ;
+     break;
+    #endif /*     Si2158_DTV_FILTER_SELECT_PROP */
+    #ifdef        Si2158_DTV_IEN_PROP
+     case         Si2158_DTV_IEN_PROP_CODE:
+       data = (api->prop->dtv_ien.chlien & Si2158_DTV_IEN_PROP_CHLIEN_MASK) << Si2158_DTV_IEN_PROP_CHLIEN_LSB ;
+     break;
+    #endif /*     Si2158_DTV_IEN_PROP */
+    #ifdef        Si2158_DTV_INITIAL_AGC_SPEED_PROP
+     case         Si2158_DTV_INITIAL_AGC_SPEED_PROP_CODE:
+       data = (api->prop->dtv_initial_agc_speed.if_agc_speed & Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_MASK) << Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_LSB  |
+              (api->prop->dtv_initial_agc_speed.agc_decim    & Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_MASK   ) << Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_LSB ;
+     break;
+    #endif /*     Si2158_DTV_INITIAL_AGC_SPEED_PROP */
+    #ifdef        Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP
+     case         Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_CODE:
+       data = (api->prop->dtv_initial_agc_speed_period.period & Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_MASK) << Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_PERIOD_LSB ;
+     break;
+    #endif /*     Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP */
+    #ifdef        Si2158_DTV_INTERNAL_ZIF_PROP
+     case         Si2158_DTV_INTERNAL_ZIF_PROP_CODE:
+       data = (api->prop->dtv_internal_zif.atsc   & Si2158_DTV_INTERNAL_ZIF_PROP_ATSC_MASK  ) << Si2158_DTV_INTERNAL_ZIF_PROP_ATSC_LSB  |
+              (api->prop->dtv_internal_zif.qam_us & Si2158_DTV_INTERNAL_ZIF_PROP_QAM_US_MASK) << Si2158_DTV_INTERNAL_ZIF_PROP_QAM_US_LSB  |
+              (api->prop->dtv_internal_zif.dvbt   & Si2158_DTV_INTERNAL_ZIF_PROP_DVBT_MASK  ) << Si2158_DTV_INTERNAL_ZIF_PROP_DVBT_LSB  |
+              (api->prop->dtv_internal_zif.dvbc   & Si2158_DTV_INTERNAL_ZIF_PROP_DVBC_MASK  ) << Si2158_DTV_INTERNAL_ZIF_PROP_DVBC_LSB  |
+              (api->prop->dtv_internal_zif.isdbt  & Si2158_DTV_INTERNAL_ZIF_PROP_ISDBT_MASK ) << Si2158_DTV_INTERNAL_ZIF_PROP_ISDBT_LSB  |
+              (api->prop->dtv_internal_zif.isdbc  & Si2158_DTV_INTERNAL_ZIF_PROP_ISDBC_MASK ) << Si2158_DTV_INTERNAL_ZIF_PROP_ISDBC_LSB  |
+              (api->prop->dtv_internal_zif.dtmb   & Si2158_DTV_INTERNAL_ZIF_PROP_DTMB_MASK  ) << Si2158_DTV_INTERNAL_ZIF_PROP_DTMB_LSB ;
+     break;
+    #endif /*     Si2158_DTV_INTERNAL_ZIF_PROP */
+    #ifdef        Si2158_DTV_INT_SENSE_PROP
+     case         Si2158_DTV_INT_SENSE_PROP_CODE:
+       data = (api->prop->dtv_int_sense.chlnegen & Si2158_DTV_INT_SENSE_PROP_CHLNEGEN_MASK) << Si2158_DTV_INT_SENSE_PROP_CHLNEGEN_LSB  |
+              (api->prop->dtv_int_sense.chlposen & Si2158_DTV_INT_SENSE_PROP_CHLPOSEN_MASK) << Si2158_DTV_INT_SENSE_PROP_CHLPOSEN_LSB ;
+     break;
+    #endif /*     Si2158_DTV_INT_SENSE_PROP */
+    #ifdef        Si2158_DTV_LIF_FREQ_PROP
+     case         Si2158_DTV_LIF_FREQ_PROP_CODE:
+       data = (api->prop->dtv_lif_freq.offset & Si2158_DTV_LIF_FREQ_PROP_OFFSET_MASK) << Si2158_DTV_LIF_FREQ_PROP_OFFSET_LSB ;
+     break;
+    #endif /*     Si2158_DTV_LIF_FREQ_PROP */
+    #ifdef        Si2158_DTV_LIF_OUT_PROP
+     case         Si2158_DTV_LIF_OUT_PROP_CODE:
+       data = (api->prop->dtv_lif_out.offset & Si2158_DTV_LIF_OUT_PROP_OFFSET_MASK) << Si2158_DTV_LIF_OUT_PROP_OFFSET_LSB  |
+              (api->prop->dtv_lif_out.amp    & Si2158_DTV_LIF_OUT_PROP_AMP_MASK   ) << Si2158_DTV_LIF_OUT_PROP_AMP_LSB ;
+     break;
+    #endif /*     Si2158_DTV_LIF_OUT_PROP */
+    #ifdef        Si2158_DTV_MODE_PROP
+     case         Si2158_DTV_MODE_PROP_CODE:
+       data = (api->prop->dtv_mode.bw              & Si2158_DTV_MODE_PROP_BW_MASK             ) << Si2158_DTV_MODE_PROP_BW_LSB  |
+              (api->prop->dtv_mode.modulation      & Si2158_DTV_MODE_PROP_MODULATION_MASK     ) << Si2158_DTV_MODE_PROP_MODULATION_LSB  |
+              (api->prop->dtv_mode.invert_spectrum & Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_MASK) << Si2158_DTV_MODE_PROP_INVERT_SPECTRUM_LSB ;
+     break;
+    #endif /*     Si2158_DTV_MODE_PROP */
+    #ifdef        Si2158_DTV_PGA_LIMITS_PROP
+     case         Si2158_DTV_PGA_LIMITS_PROP_CODE:
+       data = (api->prop->dtv_pga_limits.min & Si2158_DTV_PGA_LIMITS_PROP_MIN_MASK) << Si2158_DTV_PGA_LIMITS_PROP_MIN_LSB  |
+              (api->prop->dtv_pga_limits.max & Si2158_DTV_PGA_LIMITS_PROP_MAX_MASK) << Si2158_DTV_PGA_LIMITS_PROP_MAX_LSB ;
+     break;
+    #endif /*     Si2158_DTV_PGA_LIMITS_PROP */
+    #ifdef        Si2158_DTV_PGA_TARGET_PROP
+     case         Si2158_DTV_PGA_TARGET_PROP_CODE:
+       data = (api->prop->dtv_pga_target.pga_target      & Si2158_DTV_PGA_TARGET_PROP_PGA_TARGET_MASK     ) << Si2158_DTV_PGA_TARGET_PROP_PGA_TARGET_LSB  |
+              (api->prop->dtv_pga_target.override_enable & Si2158_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_MASK) << Si2158_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_LSB ;
+     break;
+    #endif /*     Si2158_DTV_PGA_TARGET_PROP */
+    #ifdef        Si2158_DTV_RF_TOP_PROP
+     case         Si2158_DTV_RF_TOP_PROP_CODE:
+       data = (api->prop->dtv_rf_top.dtv_rf_top & Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_MASK) << Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_LSB ;
+     break;
+    #endif /*     Si2158_DTV_RF_TOP_PROP */
+    #ifdef        Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP
+     case         Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_CODE:
+       data = (api->prop->dtv_rsq_rssi_threshold.lo & Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_MASK) << Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_LO_LSB  |
+              (api->prop->dtv_rsq_rssi_threshold.hi & Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_MASK) << Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_HI_LSB ;
+     break;
+    #endif /*     Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP */
+    #ifdef        Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP
+     case         Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_CODE:
+       data = (api->prop->dtv_zif_dc_canceller_bw.bandwidth & Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_MASK) << Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_LSB ;
+     break;
+    #endif /*     Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP */
+    #ifdef        Si2158_MASTER_IEN_PROP
+     case         Si2158_MASTER_IEN_PROP_CODE:
+       data = (api->prop->master_ien.tunien & Si2158_MASTER_IEN_PROP_TUNIEN_MASK) << Si2158_MASTER_IEN_PROP_TUNIEN_LSB  |
+              (api->prop->master_ien.atvien & Si2158_MASTER_IEN_PROP_ATVIEN_MASK) << Si2158_MASTER_IEN_PROP_ATVIEN_LSB  |
+              (api->prop->master_ien.dtvien & Si2158_MASTER_IEN_PROP_DTVIEN_MASK) << Si2158_MASTER_IEN_PROP_DTVIEN_LSB  |
+              (api->prop->master_ien.errien & Si2158_MASTER_IEN_PROP_ERRIEN_MASK) << Si2158_MASTER_IEN_PROP_ERRIEN_LSB  |
+              (api->prop->master_ien.ctsien & Si2158_MASTER_IEN_PROP_CTSIEN_MASK) << Si2158_MASTER_IEN_PROP_CTSIEN_LSB ;
+     break;
+    #endif /*     Si2158_MASTER_IEN_PROP */
+    #ifdef        Si2158_TUNER_BLOCKED_VCO_PROP
+     case         Si2158_TUNER_BLOCKED_VCO_PROP_CODE:
+       data = (api->prop->tuner_blocked_vco.vco_code & Si2158_TUNER_BLOCKED_VCO_PROP_VCO_CODE_MASK) << Si2158_TUNER_BLOCKED_VCO_PROP_VCO_CODE_LSB ;
+     break;
+    #endif /*     Si2158_TUNER_BLOCKED_VCO_PROP */
+    #ifdef        Si2158_TUNER_IEN_PROP
+     case         Si2158_TUNER_IEN_PROP_CODE:
+       data = (api->prop->tuner_ien.tcien    & Si2158_TUNER_IEN_PROP_TCIEN_MASK   ) << Si2158_TUNER_IEN_PROP_TCIEN_LSB  |
+              (api->prop->tuner_ien.rssilien & Si2158_TUNER_IEN_PROP_RSSILIEN_MASK) << Si2158_TUNER_IEN_PROP_RSSILIEN_LSB  |
+              (api->prop->tuner_ien.rssihien & Si2158_TUNER_IEN_PROP_RSSIHIEN_MASK) << Si2158_TUNER_IEN_PROP_RSSIHIEN_LSB ;
+     break;
+    #endif /*     Si2158_TUNER_IEN_PROP */
+    #ifdef        Si2158_TUNER_INT_SENSE_PROP
+     case         Si2158_TUNER_INT_SENSE_PROP_CODE:
+       data = (api->prop->tuner_int_sense.tcnegen    & Si2158_TUNER_INT_SENSE_PROP_TCNEGEN_MASK   ) << Si2158_TUNER_INT_SENSE_PROP_TCNEGEN_LSB  |
+              (api->prop->tuner_int_sense.rssilnegen & Si2158_TUNER_INT_SENSE_PROP_RSSILNEGEN_MASK) << Si2158_TUNER_INT_SENSE_PROP_RSSILNEGEN_LSB  |
+              (api->prop->tuner_int_sense.rssihnegen & Si2158_TUNER_INT_SENSE_PROP_RSSIHNEGEN_MASK) << Si2158_TUNER_INT_SENSE_PROP_RSSIHNEGEN_LSB  |
+              (api->prop->tuner_int_sense.tcposen    & Si2158_TUNER_INT_SENSE_PROP_TCPOSEN_MASK   ) << Si2158_TUNER_INT_SENSE_PROP_TCPOSEN_LSB  |
+              (api->prop->tuner_int_sense.rssilposen & Si2158_TUNER_INT_SENSE_PROP_RSSILPOSEN_MASK) << Si2158_TUNER_INT_SENSE_PROP_RSSILPOSEN_LSB  |
+              (api->prop->tuner_int_sense.rssihposen & Si2158_TUNER_INT_SENSE_PROP_RSSIHPOSEN_MASK) << Si2158_TUNER_INT_SENSE_PROP_RSSIHPOSEN_LSB ;
+     break;
+    #endif /*     Si2158_TUNER_INT_SENSE_PROP */
+    #ifdef        Si2158_TUNER_LO_INJECTION_PROP
+     case         Si2158_TUNER_LO_INJECTION_PROP_CODE:
+       data = (api->prop->tuner_lo_injection.band_1 & Si2158_TUNER_LO_INJECTION_PROP_BAND_1_MASK) << Si2158_TUNER_LO_INJECTION_PROP_BAND_1_LSB  |
+              (api->prop->tuner_lo_injection.band_2 & Si2158_TUNER_LO_INJECTION_PROP_BAND_2_MASK) << Si2158_TUNER_LO_INJECTION_PROP_BAND_2_LSB  |
+              (api->prop->tuner_lo_injection.band_3 & Si2158_TUNER_LO_INJECTION_PROP_BAND_3_MASK) << Si2158_TUNER_LO_INJECTION_PROP_BAND_3_LSB ;
+     break;
+    #endif /*     Si2158_TUNER_LO_INJECTION_PROP */
+    #ifdef        Si2158_TUNER_RETURN_LOSS_PROP
+     case         Si2158_TUNER_RETURN_LOSS_PROP_CODE:
+       data = (api->prop->tuner_return_loss.config & Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_MASK) << Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_LSB  |
+              (api->prop->tuner_return_loss.mode   & Si2158_TUNER_RETURN_LOSS_PROP_MODE_MASK  ) << Si2158_TUNER_RETURN_LOSS_PROP_MODE_LSB ;
+     break;
+    #endif /*     Si2158_TUNER_RETURN_LOSS_PROP */
+   default : break;
+    }
+#ifdef    Si2158_GET_PROPERTY_STRING
+    Si2158_L1_FillPropertyStringText(api, prop_code, (char*)" ", msg);
+    SiTRACE("%s\n",msg);
+#endif /* Si2158_GET_PROPERTY_STRING */
+    return Si2158_L1_SetProperty(api, prop_code & 0xffff , data);
+  }
+
+/////////////////////////////////////////////////////////////////////////////////////
+void Si2158_setupATVDefaults        (L1_Si2158_Context *api)
+{
+  SiTRACE("Si2158_setupATVDefaults       \n");
+  api->prop->atv_afc_range.range_khz              =  1000; /* (default  1000) */
+
+  api->prop->atv_agc_speed.if_agc_speed           = Si2158_ATV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO ; /* (default 'AUTO') */
+
+  api->prop->atv_agc_speed_low_rssi.if_agc_speed  = Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_IF_AGC_SPEED_158 ; /* (default '158') */
+  api->prop->atv_agc_speed_low_rssi.thld          =  -128; /* (default  -128) */
+
+  api->prop->atv_artificial_snow.gain             = Si2158_ATV_ARTIFICIAL_SNOW_PROP_GAIN_AUTO   ; /* (default 'AUTO') */
+  api->prop->atv_artificial_snow.offset           =     0; /* (default     0) */
+
+  api->prop->atv_config_if_port.atv_out_type      = Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_OUT_TYPE_LIF_DIFF_IF1   ; /* (default 'LIF_DIFF_IF1') */
+  api->prop->atv_config_if_port.atv_agc_source    = Si2158_ATV_CONFIG_IF_PORT_PROP_ATV_AGC_SOURCE_INTERNAL     ; /* (default 'INTERNAL') */
+
+  api->prop->atv_ext_agc.min_10mv                 =    50; /* (default    50) */
+  api->prop->atv_ext_agc.max_10mv                 =   200; /* (default   200) */
+
+  api->prop->atv_ien.chlien                       = Si2158_ATV_IEN_PROP_CHLIEN_ENABLE  ; /* (default 'ENABLE') */
+  api->prop->atv_ien.pclien                       = Si2158_ATV_IEN_PROP_PCLIEN_DISABLE ; /* (default 'DISABLE') */
+
+  api->prop->atv_int_sense.chlnegen               = Si2158_ATV_INT_SENSE_PROP_CHLNEGEN_DISABLE ; /* (default 'DISABLE') */
+  api->prop->atv_int_sense.pclnegen               = Si2158_ATV_INT_SENSE_PROP_PCLNEGEN_DISABLE ; /* (default 'DISABLE') */
+  api->prop->atv_int_sense.chlposen               = Si2158_ATV_INT_SENSE_PROP_CHLPOSEN_ENABLE  ; /* (default 'ENABLE') */
+  api->prop->atv_int_sense.pclposen               = Si2158_ATV_INT_SENSE_PROP_PCLPOSEN_ENABLE  ; /* (default 'ENABLE') */
+
+  api->prop->atv_lif_freq.offset                  =  5000; /* (default  5000) */
+
+  api->prop->atv_lif_out.offset                   =   148; /* (default   148) */
+  api->prop->atv_lif_out.amp                      =   100; /* (default   100) */
+
+  api->prop->atv_pga_target.pga_target            =     0; /* (default     0) */
+  api->prop->atv_pga_target.override_enable       = Si2158_ATV_PGA_TARGET_PROP_OVERRIDE_ENABLE_DISABLE ; /* (default 'DISABLE') */
+
+  api->prop->atv_rf_top.atv_rf_top                = Si2158_ATV_RF_TOP_PROP_ATV_RF_TOP_AUTO ; /* (default 'AUTO') */
+
+  api->prop->atv_rsq_rssi_threshold.lo            =   -70; /* (default   -70) */
+  api->prop->atv_rsq_rssi_threshold.hi            =     0; /* (default     0) */
+
+  api->prop->atv_video_mode.video_sys             = Si2158_ATV_VIDEO_MODE_PROP_VIDEO_SYS_B              ; /* (default 'B') */
+  api->prop->atv_video_mode.color                 = Si2158_ATV_VIDEO_MODE_PROP_COLOR_PAL_NTSC           ; /* (default 'PAL_NTSC') */
+  api->prop->atv_video_mode.invert_spectrum       = Si2158_ATV_VIDEO_MODE_PROP_INVERT_SPECTRUM_INVERTED ; /* (default 'INVERTED') */
+
+  api->prop->atv_vsnr_cap.atv_vsnr_cap            =     0; /* (default     0) */
+
+}
+
+void Si2158_setupCOMMONDefaults     (L1_Si2158_Context *api)
+{
+  SiTRACE("Si2158_setupCOMMONDefaults    \n");
+  api->prop->crystal_trim.xo_cap                  =     8; /* (default     8) */
+
+  api->prop->master_ien.tunien                    = Si2158_MASTER_IEN_PROP_TUNIEN_OFF ; /* (default 'OFF') */
+  api->prop->master_ien.atvien                    = Si2158_MASTER_IEN_PROP_ATVIEN_OFF ; /* (default 'OFF') */
+  api->prop->master_ien.dtvien                    = Si2158_MASTER_IEN_PROP_DTVIEN_OFF ; /* (default 'OFF') */
+  api->prop->master_ien.errien                    = Si2158_MASTER_IEN_PROP_ERRIEN_OFF ; /* (default 'OFF') */
+  api->prop->master_ien.ctsien                    = Si2158_MASTER_IEN_PROP_CTSIEN_OFF ; /* (default 'OFF') */
+
+}
+
+void Si2158_setupDTVDefaults        (L1_Si2158_Context *api)
+{
+  SiTRACE("Si2158_setupDTVDefaults       \n");
+  api->prop->dtv_agc_freeze_input.level           = Si2158_DTV_AGC_FREEZE_INPUT_PROP_LEVEL_LOW  ; /* (default 'LOW') */
+  api->prop->dtv_agc_freeze_input.pin             = Si2158_DTV_AGC_FREEZE_INPUT_PROP_PIN_NONE   ; /* (default 'NONE') */
+
+  api->prop->dtv_agc_speed.if_agc_speed           = Si2158_DTV_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO ; /* (default 'AUTO') */
+  api->prop->dtv_agc_speed.agc_decim              = Si2158_DTV_AGC_SPEED_PROP_AGC_DECIM_OFF     ; /* (default 'OFF') */
+
+  api->prop->dtv_config_if_port.dtv_out_type      = Si2158_DTV_CONFIG_IF_PORT_PROP_DTV_OUT_TYPE_LIF_IF2   ; /* (default 'LIF_IF2') */
+  api->prop->dtv_config_if_port.dtv_agc_source    =     0; /* (default     0) */
+
+  api->prop->dtv_ext_agc.min_10mv                 =    50; /* (default    50) */
+  api->prop->dtv_ext_agc.max_10mv                 =   200; /* (default   200) */
+
+  api->prop->dtv_filter_select.filter             = Si2158_DTV_FILTER_SELECT_PROP_FILTER_CUSTOM1 ; /* (default 'CUSTOM1') */
+
+  api->prop->dtv_ien.chlien                       = Si2158_DTV_IEN_PROP_CHLIEN_ENABLE ; /* (default 'ENABLE') */
+
+  api->prop->dtv_initial_agc_speed.if_agc_speed   = Si2158_DTV_INITIAL_AGC_SPEED_PROP_IF_AGC_SPEED_AUTO ; /* (default 'AUTO') */
+  api->prop->dtv_initial_agc_speed.agc_decim      = Si2158_DTV_INITIAL_AGC_SPEED_PROP_AGC_DECIM_OFF     ; /* (default 'OFF') */
+
+  api->prop->dtv_initial_agc_speed_period.period  =     0; /* (default     0) */
+
+  api->prop->dtv_internal_zif.atsc                = Si2158_DTV_INTERNAL_ZIF_PROP_ATSC_LIF   ; /* (default 'LIF') */
+  api->prop->dtv_internal_zif.qam_us              = Si2158_DTV_INTERNAL_ZIF_PROP_QAM_US_LIF ; /* (default 'LIF') */
+  api->prop->dtv_internal_zif.dvbt                = Si2158_DTV_INTERNAL_ZIF_PROP_DVBT_LIF   ; /* (default 'LIF') */
+  api->prop->dtv_internal_zif.dvbc                = Si2158_DTV_INTERNAL_ZIF_PROP_DVBC_LIF   ; /* (default 'LIF') */
+  api->prop->dtv_internal_zif.isdbt               = Si2158_DTV_INTERNAL_ZIF_PROP_ISDBT_LIF  ; /* (default 'LIF') */
+  api->prop->dtv_internal_zif.isdbc               = Si2158_DTV_INTERNAL_ZIF_PROP_ISDBC_LIF  ; /* (default 'LIF') */
+  api->prop->dtv_internal_zif.dtmb                = Si2158_DTV_INTERNAL_ZIF_PROP_DTMB_LIF   ; /* (default 'LIF') */
+
+  api->prop->dtv_int_sense.chlnegen               = Si2158_DTV_INT_SENSE_PROP_CHLNEGEN_DISABLE ; /* (default 'DISABLE') */
+  api->prop->dtv_int_sense.chlposen               = Si2158_DTV_INT_SENSE_PROP_CHLPOSEN_ENABLE  ; /* (default 'ENABLE') */
+
+  api->prop->dtv_lif_freq.offset                  =  5000; /* (default  5000) */
+
+  api->prop->dtv_lif_out.offset                   =   148; /* (default   148) */
+  api->prop->dtv_lif_out.amp                      =    27; /* (default    27) */
+
+  api->prop->dtv_mode.bw                          = Si2158_DTV_MODE_PROP_BW_BW_8MHZ              ; /* (default 'BW_8MHZ') */
+  api->prop->dtv_mode.modulation                  = Si2158_DTV_MODE_PROP_MODULATION_DVBT         ; /* (default 'DVBT') */
+  api->prop->dtv_mode.invert_spectrum             =     0; /* (default     0) */
+
+  api->prop->dtv_pga_limits.min                   =    -1; /* (default    -1) */
+  api->prop->dtv_pga_limits.max                   =    -1; /* (default    -1) */
+
+  api->prop->dtv_pga_target.pga_target            =     0; /* (default     0) */
+  api->prop->dtv_pga_target.override_enable       = Si2158_DTV_PGA_TARGET_PROP_OVERRIDE_ENABLE_DISABLE ; /* (default 'DISABLE') */
+
+  api->prop->dtv_rf_top.dtv_rf_top                = Si2158_DTV_RF_TOP_PROP_DTV_RF_TOP_AUTO ; /* (default 'AUTO') */
+
+  api->prop->dtv_rsq_rssi_threshold.lo            =   -80; /* (default   -80) */
+  api->prop->dtv_rsq_rssi_threshold.hi            =     0; /* (default     0) */
+
+  api->prop->dtv_zif_dc_canceller_bw.bandwidth    = Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_BANDWIDTH_DEFAULT ; /* (default 'DEFAULT') */
+
+}
+
+void Si2158_setupTUNERDefaults      (L1_Si2158_Context *api)
+{
+  SiTRACE("Si2158_setupTUNERDefaults     \n");
+  api->prop->tuner_blocked_vco.vco_code           = 0x8000; /* (default 0x8000) */
+
+  api->prop->tuner_ien.tcien                      = Si2158_TUNER_IEN_PROP_TCIEN_ENABLE     ; /* (default 'ENABLE') */
+  api->prop->tuner_ien.rssilien                   = Si2158_TUNER_IEN_PROP_RSSILIEN_DISABLE ; /* (default 'DISABLE') */
+  api->prop->tuner_ien.rssihien                   = Si2158_TUNER_IEN_PROP_RSSIHIEN_DISABLE ; /* (default 'DISABLE') */
+
+  api->prop->tuner_int_sense.tcnegen              = Si2158_TUNER_INT_SENSE_PROP_TCNEGEN_DISABLE    ; /* (default 'DISABLE') */
+  api->prop->tuner_int_sense.rssilnegen           = Si2158_TUNER_INT_SENSE_PROP_RSSILNEGEN_DISABLE ; /* (default 'DISABLE') */
+  api->prop->tuner_int_sense.rssihnegen           = Si2158_TUNER_INT_SENSE_PROP_RSSIHNEGEN_DISABLE ; /* (default 'DISABLE') */
+  api->prop->tuner_int_sense.tcposen              = Si2158_TUNER_INT_SENSE_PROP_TCPOSEN_ENABLE     ; /* (default 'ENABLE') */
+  api->prop->tuner_int_sense.rssilposen           = Si2158_TUNER_INT_SENSE_PROP_RSSILPOSEN_ENABLE  ; /* (default 'ENABLE') */
+  api->prop->tuner_int_sense.rssihposen           = Si2158_TUNER_INT_SENSE_PROP_RSSIHPOSEN_ENABLE  ; /* (default 'ENABLE') */
+
+  api->prop->tuner_lo_injection.band_1            = Si2158_TUNER_LO_INJECTION_PROP_BAND_1_HIGH_SIDE ; /* (default 'HIGH_SIDE') */
+  api->prop->tuner_lo_injection.band_2            = Si2158_TUNER_LO_INJECTION_PROP_BAND_2_LOW_SIDE  ; /* (default 'LOW_SIDE') */
+  api->prop->tuner_lo_injection.band_3            = Si2158_TUNER_LO_INJECTION_PROP_BAND_3_LOW_SIDE  ; /* (default 'LOW_SIDE') */
+
+  api->prop->tuner_return_loss.config             = Si2158_TUNER_RETURN_LOSS_PROP_CONFIG_127         ; /* (default '127') */
+  api->prop->tuner_return_loss.mode               = Si2158_TUNER_RETURN_LOSS_PROP_MODE_TERRESTRIAL   ; /* (default 'TERRESTRIAL') */
+
+}
+
+void Si2158_setupAllDefaults       (L1_Si2158_Context *api)
+{
+  Si2158_setupATVDefaults       (api);
+  Si2158_setupCOMMONDefaults    (api);
+  Si2158_setupDTVDefaults       (api);
+  Si2158_setupTUNERDefaults     (api);
+}
+
+ /*****************************************************************************************
+ NAME: Si2158_downloadATVProperties
+  DESCRIPTION: Setup Si2158 ATV properties configuration
+  This function will download all the ATV configuration properties.
+  The function SetupATVDefaults() should be called before the first call to this function.
+  Parameter:  Pointer to Si2158 Context
+  Returns:    I2C transaction error code, NO_Si2158_ERROR if successful
+  Programming Guide Reference:    ATV setup flowchart
+******************************************************************************************/
+int  Si2158_downloadATVProperties(L1_Si2158_Context *api)
+{
+  SiTRACE("Si2158_downloadATVProperties     \n");
+#ifdef    Si2158_ATV_AFC_RANGE_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_ATV_AFC_RANGE_PROP_CODE               ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_ATV_AFC_RANGE_PROP */
+#ifdef    Si2158_ATV_AGC_SPEED_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_ATV_AGC_SPEED_PROP_CODE               ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_ATV_AGC_SPEED_PROP */
+#ifdef    Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP_CODE      ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_ATV_AGC_SPEED_LOW_RSSI_PROP */
+#ifdef    Si2158_ATV_ARTIFICIAL_SNOW_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_ATV_ARTIFICIAL_SNOW_PROP_CODE         ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_ATV_ARTIFICIAL_SNOW_PROP */
+#ifdef    Si2158_ATV_CONFIG_IF_PORT_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_ATV_CONFIG_IF_PORT_PROP_CODE          ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_ATV_CONFIG_IF_PORT_PROP */
+#ifdef    Si2158_ATV_EXT_AGC_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_ATV_EXT_AGC_PROP_CODE                 ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_ATV_EXT_AGC_PROP */
+#ifdef    Si2158_ATV_IEN_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_ATV_IEN_PROP_CODE                     ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_ATV_IEN_PROP */
+#ifdef    Si2158_ATV_INT_SENSE_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_ATV_INT_SENSE_PROP_CODE               ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_ATV_INT_SENSE_PROP */
+#ifdef    Si2158_ATV_LIF_FREQ_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_ATV_LIF_FREQ_PROP_CODE                ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_ATV_LIF_FREQ_PROP */
+#ifdef    Si2158_ATV_LIF_OUT_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_ATV_LIF_OUT_PROP_CODE                 ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_ATV_LIF_OUT_PROP */
+#ifdef    Si2158_ATV_PGA_TARGET_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_ATV_PGA_TARGET_PROP_CODE              ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_ATV_PGA_TARGET_PROP */
+#ifdef    Si2158_ATV_RF_TOP_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_ATV_RF_TOP_PROP_CODE                  ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_ATV_RF_TOP_PROP */
+#ifdef    Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP_CODE      ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_ATV_RSQ_RSSI_THRESHOLD_PROP */
+#ifdef    Si2158_ATV_VIDEO_MODE_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_ATV_VIDEO_MODE_PROP_CODE              ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_ATV_VIDEO_MODE_PROP */
+#ifdef    Si2158_ATV_VSNR_CAP_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_ATV_VSNR_CAP_PROP_CODE                ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_ATV_VSNR_CAP_PROP */
+return NO_Si2158_ERROR;
+}
+
+ /*****************************************************************************************
+ NAME: Si2158_downloadCOMMONProperties
+  DESCRIPTION: Setup Si2158 COMMON properties configuration
+  This function will download all the COMMON configuration properties.
+  The function SetupCOMMONDefaults() should be called before the first call to this function.
+  Parameter:  Pointer to Si2158 Context
+  Returns:    I2C transaction error code, NO_Si2158_ERROR if successful
+  Programming Guide Reference:    COMMON setup flowchart
+******************************************************************************************/
+int  Si2158_downloadCOMMONProperties(L1_Si2158_Context *api)
+{
+  SiTRACE("Si2158_downloadCOMMONProperties                \n");
+#ifdef    Si2158_CRYSTAL_TRIM_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_CRYSTAL_TRIM_PROP_CODE                ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_CRYSTAL_TRIM_PROP */
+#ifdef    Si2158_MASTER_IEN_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_MASTER_IEN_PROP_CODE                  ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_MASTER_IEN_PROP */
+return NO_Si2158_ERROR;
+}
+
+ /*****************************************************************************************
+ NAME: Si2158_downloadDTVProperties
+  DESCRIPTION: Setup Si2158 DTV properties configuration
+  This function will download all the DTV configuration properties.
+  The function SetupDTVDefaults() should be called before the first call to this function.
+  Parameter:  Pointer to Si2158 Context
+  Returns:    I2C transaction error code, NO_Si2158_ERROR if successful
+  Programming Guide Reference:    DTV setup flowchart
+******************************************************************************************/
+int  Si2158_downloadDTVProperties(L1_Si2158_Context *api)
+{
+  SiTRACE("Si2158_downloadDTVProperties                  \n");
+#ifdef    Si2158_DTV_AGC_FREEZE_INPUT_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_DTV_AGC_FREEZE_INPUT_PROP_CODE        ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_DTV_AGC_FREEZE_INPUT_PROP */
+#ifdef    Si2158_DTV_AGC_SPEED_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_DTV_AGC_SPEED_PROP_CODE               ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_DTV_AGC_SPEED_PROP */
+#ifdef    Si2158_DTV_CONFIG_IF_PORT_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_DTV_CONFIG_IF_PORT_PROP_CODE          ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_DTV_CONFIG_IF_PORT_PROP */
+#ifdef    Si2158_DTV_EXT_AGC_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_DTV_EXT_AGC_PROP_CODE                 ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_DTV_EXT_AGC_PROP */
+#ifdef    Si2158_DTV_FILTER_SELECT_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_DTV_FILTER_SELECT_PROP_CODE           ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_DTV_FILTER_SELECT_PROP */
+#ifdef    Si2158_DTV_IEN_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_DTV_IEN_PROP_CODE                     ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_DTV_IEN_PROP */
+#ifdef    Si2158_DTV_INITIAL_AGC_SPEED_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_DTV_INITIAL_AGC_SPEED_PROP_CODE       ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_DTV_INITIAL_AGC_SPEED_PROP */
+#ifdef    Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP_CODE) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_DTV_INITIAL_AGC_SPEED_PERIOD_PROP */
+#ifdef    Si2158_DTV_INTERNAL_ZIF_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_DTV_INTERNAL_ZIF_PROP_CODE            ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_DTV_INTERNAL_ZIF_PROP */
+#ifdef    Si2158_DTV_INT_SENSE_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_DTV_INT_SENSE_PROP_CODE               ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_DTV_INT_SENSE_PROP */
+#ifdef    Si2158_DTV_LIF_FREQ_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_DTV_LIF_FREQ_PROP_CODE                ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_DTV_LIF_FREQ_PROP */
+#ifdef    Si2158_DTV_LIF_OUT_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_DTV_LIF_OUT_PROP_CODE                 ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_DTV_LIF_OUT_PROP */
+#ifdef    Si2158_DTV_MODE_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_DTV_MODE_PROP_CODE                    ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_DTV_MODE_PROP */
+#ifdef    Si2158_DTV_PGA_LIMITS_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_DTV_PGA_LIMITS_PROP_CODE              ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_DTV_PGA_LIMITS_PROP */
+#ifdef    Si2158_DTV_PGA_TARGET_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_DTV_PGA_TARGET_PROP_CODE              ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_DTV_PGA_TARGET_PROP */
+#ifdef    Si2158_DTV_RF_TOP_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_DTV_RF_TOP_PROP_CODE                  ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_DTV_RF_TOP_PROP */
+#ifdef    Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP_CODE      ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_DTV_RSQ_RSSI_THRESHOLD_PROP */
+#ifdef    Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP_CODE     ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_DTV_ZIF_DC_CANCELLER_BW_PROP */
+return NO_Si2158_ERROR;
+}
+
+ /*****************************************************************************************
+ NAME: Si2158_downloadTUNERProperties
+  DESCRIPTION: Setup Si2158 TUNER properties configuration
+  This function will download all the TUNER configuration properties.
+  The function SetupTUNERDefaults() should be called before the first call to this function.
+  Parameter:  Pointer to Si2158 Context
+  Returns:    I2C transaction error code, NO_Si2158_ERROR if successful
+  Programming Guide Reference:    TUNER setup flowchart
+******************************************************************************************/
+int  Si2158_downloadTUNERProperties(L1_Si2158_Context *api)
+{
+  SiTRACE("Si2158_downloadTUNERProperties     \n");
+#ifdef    Si2158_TUNER_BLOCKED_VCO_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_TUNER_BLOCKED_VCO_PROP_CODE           ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_TUNER_BLOCKED_VCO_PROP */
+#ifdef    Si2158_TUNER_IEN_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_TUNER_IEN_PROP_CODE                   ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_TUNER_IEN_PROP */
+#ifdef    Si2158_TUNER_INT_SENSE_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_TUNER_INT_SENSE_PROP_CODE             ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_TUNER_INT_SENSE_PROP */
+#ifdef    Si2158_TUNER_LO_INJECTION_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_TUNER_LO_INJECTION_PROP_CODE          ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_TUNER_LO_INJECTION_PROP */
+#ifdef    Si2158_TUNER_RETURN_LOSS_PROP
+  if (Si2158_L1_SetProperty2(api, Si2158_TUNER_RETURN_LOSS_PROP_CODE           ) != NO_Si2158_ERROR) {return ERROR_Si2158_SENDING_COMMAND;}
+#endif /* Si2158_TUNER_RETURN_LOSS_PROP */
+return NO_Si2158_ERROR;
+}
+int Si2158_downloadAllProperties       (L1_Si2158_Context *api)
+{
+  Si2158_downloadATVProperties       (api);
+  Si2158_downloadCOMMONProperties    (api);
+  Si2158_downloadDTVProperties       (api);
+  Si2158_downloadTUNERProperties     (api);
+  return 0;
+}
+ /************************************************************************************************************************
+  NAME: Si2158_Tune
+  DESCRIPTIION: Tune Si2158 in specified mode (ATV/DTV) at center frequency, wait for TUNINT and xTVINT with timeout
+
+  Parameter:  Pointer to Si2158 Context (I2C address)
+  Parameter:  Mode (ATV or DTV) use Si2158_TUNER_TUNE_FREQ_CMD_MODE_ATV or Si2158_TUNER_TUNE_FREQ_CMD_MODE_DTV constants
+  Parameter:  frequency (Hz) as a unsigned long integer
+  Parameter:  rsp - commandResp structure to returns tune status info.
+  Returns:    0 if channel found.  A nonzero value means either an error occurred or channel not locked.
+  Programming Guide Reference:    Flowchart A.7 (Tune flowchart)
+************************************************************************************************************************/
+ int  Si2158_Tune              (L1_Si2158_Context *api, unsigned char mode, unsigned long freq)
+{
+    int return_code = 0;
+  int timeout     = 150;
+  u32 ulCount, ulTick, ulDelay;
+  ulCount = 0;
+  ulTick = 3;
+  ulDelay = timeout/ulTick;
+
+    //start_time = system_time();
+
+    if (Si2158_L1_TUNER_TUNE_FREQ (api,
+                                   mode,
+                                   freq) != NO_Si2158_ERROR)
+    {
+        return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    /* wait for TUNINT, timeout is 150ms */
+    //while ( (system_time() - start_time) < timeout )
+    while ( ulCount <= ulTick )
+    {
+        if ((return_code = Si2158_L1_CheckStatus(api)) != 0)
+            return return_code;
+        if (api->status->tunint)
+            break;
+            
+        delayMS(ulDelay);
+        ulCount++;
+    }
+    if (!api->status->tunint) {
+      SiTRACE("Timeout waiting for TUNINT\n");
+      return ERROR_Si2158_TUNINT_TIMEOUT;
+    }
+
+    /* wait for xTVINT, timeout is 350ms for ATVINT and 20 ms for DTVINT */
+    //start_time = system_time();
+    timeout    = ((mode==Si2158_TUNER_TUNE_FREQ_CMD_MODE_ATV) ? 350 : 20);
+    ulCount = 0;
+    ulTick = 2;
+    ulDelay = timeout/ulTick;
+    
+    //while ( (system_time() - start_time) < timeout )
+    while ( ulCount <= ulTick )
+    {
+        if ((return_code = Si2158_L1_CheckStatus(api)) != 0)
+            return return_code;
+        if (mode==Si2158_TUNER_TUNE_FREQ_CMD_MODE_ATV)
+        {
+         if (api->status->atvint)
+            break;
+        }
+        else
+        {
+         if (api->status->dtvint)
+            break;
+        }
+        delayMS(ulDelay);
+        ulCount++;
+    }
+
+    if (mode==Si2158_TUNER_TUNE_FREQ_CMD_MODE_ATV)
+    {
+      if (api->status->atvint)
+      {
+        SiTRACE("ATV Tune Successful\n");
+               return NO_Si2158_ERROR;
+            }
+      else
+        SiTRACE("Timeout waiting for ATVINT\n");
+    }
+    else
+    {
+        if (api->status->dtvint)
+        {
+          SiTRACE("DTV Tune Successful\n");
+          return NO_Si2158_ERROR;
+        }
+        else
+          SiTRACE("Timeout waiting for DTVINT\n");
+    }
+
+    return ERROR_Si2158_xTVINT_TIMEOUT;
+}
+
+ /************************************************************************************************************************
+  NAME: Si2158_DTVTune
+  DESCRIPTION: Update DTV_MODE and tune DTV mode at center frequency
+  Parameter:  Pointer to Si2158 Context (I2C address)
+  Parameter:  frequency (Hz)
+  Parameter:  bandwidth , 6,7 or 8 MHz
+  Parameter:  modulation,  e.g. use constant Si2158_DTV_MODE_PROP_MODULATION_DVBT for DVBT mode
+  Parameter:  rsp - commandResp structure to returns tune status info.
+  Returns:    I2C transaction error code, 0 if successful
+  Programming Guide Reference:    Flowchart A.7 (Tune flowchart)
+************************************************************************************************************************/
+int  Si2158_DTVTune           (L1_Si2158_Context *api, unsigned long freq, unsigned char bw, unsigned char modulation, unsigned char invert_spectrum)
+{
+    int return_code;
+    return_code = NO_Si2158_ERROR;
+
+    /* update DTV_MODE_PROP property */
+    api->prop->dtv_mode.bw = bw;
+    api->prop->dtv_mode.invert_spectrum = invert_spectrum;
+    api->prop->dtv_mode.modulation = modulation;
+    if (Si2158_L1_SetProperty2(api, Si2158_DTV_MODE_PROP) != NO_Si2158_ERROR)
+    {
+      return ERROR_Si2158_SENDING_COMMAND;
+    }
+
+    return_code = Si2158_Tune (api, Si2158_TUNER_TUNE_FREQ_CMD_MODE_DTV, freq);
+
+    return return_code;
+}
diff -urN a/drivers/media/pci/cx23885/cimax2.c b/drivers/media/pci/cx23885/cimax2.c
--- a/drivers/media/pci/cx23885/cimax2.c	2013-03-21 04:11:19.000000000 +0800
+++ b/drivers/media/pci/cx23885/cimax2.c	2013-03-31 22:03:29.000000000 +0800
@@ -415,7 +415,7 @@
 	return state->status;
 }
 
-int netup_ci_init(struct cx23885_tsport *port)
+int netup_ci_init(struct cx23885_tsport *port, bool isDVBSky)
 {
 	struct netup_ci_state *state;
 	u8 cimax_init[34] = {
@@ -464,6 +464,11 @@
 		goto err;
 	}
 
+	if(isDVBSky) {
+		cimax_init[32] = 0x22;
+		cimax_init[33] = 0x00;
+	}
+
 	port->port_priv = state;
 
 	switch (port->nr) {
@@ -537,3 +542,19 @@
 	dvb_ca_en50221_release(&state->ca);
 	kfree(state);
 }
+
+/* CI irq handler for DVBSky board*/
+int dvbsky_ci_slot_status(struct cx23885_dev *dev)
+{
+	struct cx23885_tsport *port = NULL;
+	struct netup_ci_state *state = NULL;
+
+	ci_dbg_print("%s:\n", __func__);
+
+	port = &dev->ts1;
+	state = port->port_priv;
+	schedule_work(&state->work);
+	ci_dbg_print("%s: Wakeup CI0\n", __func__);
+
+	return 1;
+}
diff -urN a/drivers/media/pci/cx23885/cimax2.h b/drivers/media/pci/cx23885/cimax2.h
--- a/drivers/media/pci/cx23885/cimax2.h	2013-03-21 04:11:19.000000000 +0800
+++ b/drivers/media/pci/cx23885/cimax2.h	2013-01-30 12:34:37.000000000 +0800
@@ -41,7 +41,9 @@
 extern int netup_ci_slot_status(struct cx23885_dev *dev, u32 pci_status);
 extern int netup_poll_ci_slot_status(struct dvb_ca_en50221 *en50221,
 						int slot, int open);
-extern int netup_ci_init(struct cx23885_tsport *port);
+extern int netup_ci_init(struct cx23885_tsport *port, bool isDVBSky);
 extern void netup_ci_exit(struct cx23885_tsport *port);
 
+extern int dvbsky_ci_slot_status(struct cx23885_dev *dev);
+
 #endif
diff -urN a/drivers/media/pci/cx23885/cx23885-cards.c b/drivers/media/pci/cx23885/cx23885-cards.c
--- a/drivers/media/pci/cx23885/cx23885-cards.c	2013-03-21 04:11:19.000000000 +0800
+++ b/drivers/media/pci/cx23885/cx23885-cards.c	2013-03-31 22:07:39.000000000 +0800
@@ -569,9 +569,42 @@
 		.name		= "TeVii S471",
 		.portb		= CX23885_MPEG_DVB,
 	},
-	[CX23885_BOARD_PROF_8000] = {
-		.name		= "Prof Revolution DVB-S2 8000",
+	[CX23885_BOARD_BST_PS8512] = {
+		.name		= "Bestunar PS8512",
 		.portb		= CX23885_MPEG_DVB,
+	},
+	[CX23885_BOARD_DVBSKY_S950] = {
+		.name		= "DVBSKY S950",
+		.portb		= CX23885_MPEG_DVB,
+	},
+	[CX23885_BOARD_DVBSKY_S952] = {
+		.name		= "DVBSKY S952",
+		.portb		= CX23885_MPEG_DVB,
+		.portc		= CX23885_MPEG_DVB,
+	},
+	[CX23885_BOARD_DVBSKY_S950_CI] = {
+		.ci_type	= 3,
+		.name		= "DVBSKY S950CI DVB-S2 CI",
+		.portb		= CX23885_MPEG_DVB,
+	},
+	[CX23885_BOARD_DVBSKY_C2800E_CI] = {
+		.ci_type	= 3,
+		.name		= "DVBSKY C2800E DVB-C CI",
+		.portb		= CX23885_MPEG_DVB,
+	},
+	[CX23885_BOARD_DVBSKY_T9580] = {
+		.name		= "DVBSKY T9580",
+		.portb		= CX23885_MPEG_DVB,
+		.portc		= CX23885_MPEG_DVB,
+	},
+	[CX23885_BOARD_DVBSKY_T980_CI] = {
+		.ci_type	= 3,
+		.name		= "DVBSKY T980CI DVB-T2/C CI",
+		.portb		= CX23885_MPEG_DVB,
+	},		
+	[CX23885_BOARD_PROF_8000] = {
+		.name		= "Prof Revolution DVB-S2 8000",
+		.portb		= CX23885_MPEG_DVB,
 	}
 };
 const unsigned int cx23885_bcount = ARRAY_SIZE(cx23885_boards);
@@ -785,9 +818,37 @@
 		.subdevice = 0x9022,
 		.card      = CX23885_BOARD_TEVII_S471,
 	}, {
-		.subvendor = 0x8000,
-		.subdevice = 0x3034,
-		.card      = CX23885_BOARD_PROF_8000,
+		.subvendor = 0x14f1,
+		.subdevice = 0x8512,
+		.card      = CX23885_BOARD_BST_PS8512,
+	}, {
+		.subvendor = 0x4254,
+		.subdevice = 0x0950,
+		.card      = CX23885_BOARD_DVBSKY_S950,		
+	}, {
+		.subvendor = 0x4254,
+		.subdevice = 0x0952,
+		.card      = CX23885_BOARD_DVBSKY_S952,
+	}, {
+		.subvendor = 0x4254,
+		.subdevice = 0x950C,
+		.card      = CX23885_BOARD_DVBSKY_S950_CI,
+	}, {
+		.subvendor = 0x4254,
+		.subdevice = 0x2800,
+		.card      = CX23885_BOARD_DVBSKY_C2800E_CI,
+	}, {
+		.subvendor = 0x4254,
+		.subdevice = 0x9580,
+		.card      = CX23885_BOARD_DVBSKY_T9580,
+	}, {
+		.subvendor = 0x4254,
+		.subdevice = 0x980C,
+		.card      = CX23885_BOARD_DVBSKY_T980_CI,
+	}, {
+		.subvendor = 0x8000,
+		.subdevice = 0x3034,
+		.card      = CX23885_BOARD_PROF_8000,
 	},
 };
 const unsigned int cx23885_idcount = ARRAY_SIZE(cx23885_subids);
@@ -1167,7 +1228,7 @@
 		cx_set(GP0_IO, 0x00040004);
 		break;
 	case CX23885_BOARD_TBS_6920:
-	case CX23885_BOARD_PROF_8000:
+	case CX23885_BOARD_PROF_8000:	
 		cx_write(MC417_CTL, 0x00000036);
 		cx_write(MC417_OEN, 0x00001000);
 		cx_set(MC417_RWD, 0x00000002);
@@ -1301,9 +1362,85 @@
 		/* enable irq */
 		cx_write(GPIO_ISM, 0x00000000);/* INTERRUPTS active low*/
 		break;
+	case CX23885_BOARD_DVBSKY_S950:
+	case CX23885_BOARD_BST_PS8512:			
+		cx23885_gpio_enable(dev, GPIO_2, 1);
+		cx23885_gpio_clear(dev, GPIO_2);
+		msleep(100);		
+		cx23885_gpio_set(dev, GPIO_2);
+		break;
+	case CX23885_BOARD_DVBSKY_S952:
+	case CX23885_BOARD_DVBSKY_T9580:
+		cx_write(MC417_CTL, 0x00000037);/* enable GPIO3-18 pins */
+		
+		cx23885_gpio_enable(dev, GPIO_2, 1);
+		cx23885_gpio_enable(dev, GPIO_11, 1);
+		
+		cx23885_gpio_clear(dev, GPIO_2);
+		cx23885_gpio_clear(dev, GPIO_11);
+		msleep(100);		
+		cx23885_gpio_set(dev, GPIO_2);
+		cx23885_gpio_set(dev, GPIO_11);	
+		break;
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T980_CI:
+		/* GPIO-0 INTA from CiMax, input
+		   GPIO-1 reset CiMax, output, high active
+		   GPIO-2 reset demod, output, low active
+		   GPIO-3 to GPIO-10 data/addr for CAM
+		   GPIO-11 ~CS0 to CiMax1
+		   GPIO-12 ~CS1 to CiMax2
+		   GPIO-13 ADL0 load LSB addr
+		   GPIO-14 ADL1 load MSB addr
+		   GPIO-15 ~RDY from CiMax
+		   GPIO-17 ~RD to CiMax
+		   GPIO-18 ~WR to CiMax
+		 */
+		cx_set(GP0_IO, 0x00060002); /* GPIO 1/2 as output */
+		cx_clear(GP0_IO, 0x00010004); /*GPIO 0 as input*/
+		mdelay(100);/* reset delay */
+		cx_set(GP0_IO, 0x00060004); /* GPIO as out, reset high */
+		cx_clear(GP0_IO, 0x00010002);
+		cx_write(MC417_CTL, 0x00000037);/* enable GPIO3-18 pins */
+		/* GPIO-15 IN as ~ACK, rest as OUT */
+		cx_write(MC417_OEN, 0x00001000);
+		/* ~RD, ~WR high; ADL0, ADL1 low; ~CS0, ~CS1 high */
+		cx_write(MC417_RWD, 0x0000c300);
+		/* enable irq */
+		cx_write(GPIO_ISM, 0x00000000);/* INTERRUPTS active low*/
+		break;
 	}
 }
 
+static int cx23885_ir_patch(struct i2c_adapter *i2c, u8 reg, u8 mask)
+{
+	struct i2c_msg msgs[2];
+	u8 tx_buf[2], rx_buf[1];
+	/* Write register address */
+	tx_buf[0] = reg;
+	msgs[0].addr = 0x4c;
+	msgs[0].flags = 0;
+	msgs[0].len = 1;
+	msgs[0].buf = (char *) tx_buf;
+	/* Read data from register */
+	msgs[1].addr = 0x4c;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = 1;
+	msgs[1].buf = (char *) rx_buf;	
+	
+	i2c_transfer(i2c, msgs, 2);
+
+	tx_buf[0] = reg;
+	tx_buf[1] = rx_buf[0] | mask;
+	msgs[0].addr = 0x4c;
+	msgs[0].flags = 0;
+	msgs[0].len = 2;
+	msgs[0].buf = (char *) tx_buf;
+	
+	return i2c_transfer(i2c, msgs, 1);
+}
+
 int cx23885_ir_init(struct cx23885_dev *dev)
 {
 	static struct v4l2_subdev_io_pin_config ir_rxtx_pin_cfg[] = {
@@ -1388,6 +1525,24 @@
 		v4l2_subdev_call(dev->sd_cx25840, core, s_io_pin_config,
 				 ir_rx_pin_cfg_count, ir_rx_pin_cfg);
 		break;
+	case CX23885_BOARD_BST_PS8512:
+	case CX23885_BOARD_DVBSKY_S950:
+	case CX23885_BOARD_DVBSKY_S952:
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T9580:
+	case CX23885_BOARD_DVBSKY_T980_CI:
+		dev->sd_ir = cx23885_find_hw(dev, CX23885_HW_AV_CORE);
+		if (dev->sd_ir == NULL) {
+			ret = -ENODEV;
+			break;
+		}
+		v4l2_subdev_call(dev->sd_cx25840, core, s_io_pin_config,
+				 ir_rx_pin_cfg_count, ir_rx_pin_cfg);
+				 
+		cx23885_ir_patch(&(dev->i2c_bus[2].i2c_adap),0x1f,0x80);
+		cx23885_ir_patch(&(dev->i2c_bus[2].i2c_adap),0x23,0x80);
+		break;
 	case CX23885_BOARD_HAUPPAUGE_HVR1250:
 		if (!enable_885_ir)
 			break;
@@ -1420,6 +1575,13 @@
 	case CX23885_BOARD_TERRATEC_CINERGY_T_PCIE_DUAL:
 	case CX23885_BOARD_TEVII_S470:
 	case CX23885_BOARD_HAUPPAUGE_HVR1250:
+	case CX23885_BOARD_BST_PS8512:
+	case CX23885_BOARD_DVBSKY_S950:
+	case CX23885_BOARD_DVBSKY_S952:
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T9580:
+	case CX23885_BOARD_DVBSKY_T980_CI:
 		cx23885_irq_remove(dev, PCI_MSK_AV_CORE);
 		/* sd_ir is a duplicate pointer to the AV Core, just clear it */
 		dev->sd_ir = NULL;
@@ -1464,6 +1626,13 @@
 	case CX23885_BOARD_TERRATEC_CINERGY_T_PCIE_DUAL:
 	case CX23885_BOARD_TEVII_S470:
 	case CX23885_BOARD_HAUPPAUGE_HVR1250:
+	case CX23885_BOARD_BST_PS8512:
+	case CX23885_BOARD_DVBSKY_S950:
+	case CX23885_BOARD_DVBSKY_S952:
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T9580:
+	case CX23885_BOARD_DVBSKY_T980_CI:
 		if (dev->sd_ir)
 			cx23885_irq_add_enable(dev, PCI_MSK_AV_CORE);
 		break;
@@ -1549,6 +1718,11 @@
 		ts1->ts_clk_en_val = 0x1; /* Enable TS_CLK */
 		ts1->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
 		break;
+	case CX23885_BOARD_BST_PS8512:
+	case CX23885_BOARD_DVBSKY_S950:
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T980_CI:
 	case CX23885_BOARD_TEVII_S470:
 	case CX23885_BOARD_TEVII_S471:
 	case CX23885_BOARD_DVBWORLD_2005:
@@ -1581,6 +1755,22 @@
 		ts2->ts_clk_en_val = 0x1; /* Enable TS_CLK */
 		ts2->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
 		break;
+	case CX23885_BOARD_DVBSKY_S952:
+		ts1->gen_ctrl_val  = 0x5; /* Parallel */
+		ts1->ts_clk_en_val = 0x1; /* Enable TS_CLK */
+		ts1->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
+		ts2->gen_ctrl_val  = 0xe; /* Serial bus + punctured clock */
+		ts2->ts_clk_en_val = 0x1; /* Enable TS_CLK */
+		ts2->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
+		break;
+	case CX23885_BOARD_DVBSKY_T9580:
+		ts1->gen_ctrl_val  = 0x5; /* Parallel */
+		ts1->ts_clk_en_val = 0x1; /* Enable TS_CLK */
+		ts1->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
+		ts2->gen_ctrl_val  = 0x8; /* Serial bus */
+		ts2->ts_clk_en_val = 0x1; /* Enable TS_CLK */
+		ts2->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
+		break;		
 	case CX23885_BOARD_HAUPPAUGE_HVR1250:
 	case CX23885_BOARD_HAUPPAUGE_HVR1500:
 	case CX23885_BOARD_HAUPPAUGE_HVR1500Q:
@@ -1636,6 +1826,13 @@
 	case CX23885_BOARD_MPX885:
 	case CX23885_BOARD_MYGICA_X8507:
 	case CX23885_BOARD_TERRATEC_CINERGY_T_PCIE_DUAL:
+	case CX23885_BOARD_BST_PS8512:
+	case CX23885_BOARD_DVBSKY_S950:
+	case CX23885_BOARD_DVBSKY_S952:
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T9580:
+	case CX23885_BOARD_DVBSKY_T980_CI:
 		dev->sd_cx25840 = v4l2_i2c_new_subdev(&dev->v4l2_dev,
 				&dev->i2c_bus[2].i2c_adap,
 				"cx25840", 0x88 >> 1, NULL);
diff -urN a/drivers/media/pci/cx23885/cx23885-core.c b/drivers/media/pci/cx23885/cx23885-core.c
--- a/drivers/media/pci/cx23885/cx23885-core.c	2013-03-21 04:11:19.000000000 +0800
+++ b/drivers/media/pci/cx23885/cx23885-core.c	2013-03-31 22:10:36.000000000 +0800
@@ -1909,6 +1909,10 @@
 			(pci_status & PCI_MSK_GPIO0))
 		handled += altera_ci_irq(dev);
 
+	if (cx23885_boards[dev->board].ci_type == 3 &&
+			(pci_status & PCI_MSK_GPIO0))
+		handled += dvbsky_ci_slot_status(dev);
+		
 	if (ts1_status) {
 		if (cx23885_boards[dev->board].portb == CX23885_MPEG_DVB)
 			handled += cx23885_irq_ts(ts1, ts1_status);
@@ -2144,6 +2148,9 @@
 		cx23885_irq_add_enable(dev, PCI_MSK_GPIO1 | PCI_MSK_GPIO0);
 		break;
 	case CX23885_BOARD_NETUP_DUAL_DVB_T_C_CI_RF:
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T980_CI:
 		cx23885_irq_add_enable(dev, PCI_MSK_GPIO0);
 		break;
 	}
diff -urN a/drivers/media/pci/cx23885/cx23885-dvb.c b/drivers/media/pci/cx23885/cx23885-dvb.c
--- a/drivers/media/pci/cx23885/cx23885-dvb.c	2013-03-21 04:11:19.000000000 +0800
+++ b/drivers/media/pci/cx23885/cx23885-dvb.c	2013-03-31 22:12:40.000000000 +0800
@@ -51,6 +51,9 @@
 #include "stv6110.h"
 #include "lnbh24.h"
 #include "cx24116.h"
+#include "m88ds3103.h"
+#include "m88dc2800.h"
+#include "si2168.h"
 #include "cimax2.h"
 #include "lgs8gxx.h"
 #include "netup-eeprom.h"
@@ -63,8 +66,8 @@
 #include "stv0367.h"
 #include "drxk.h"
 #include "mt2063.h"
-#include "stv090x.h"
-#include "stb6100.h"
+#include "stv090x.h"
+#include "stb6100.h"
 #include "stb6100_cfg.h"
 
 static unsigned int debug;
@@ -492,42 +495,142 @@
 	.if_khz = 5380,
 };
 
-static struct stv090x_config prof_8000_stv090x_config = {
-        .device                 = STV0903,
-        .demod_mode             = STV090x_SINGLE,
-        .clk_mode               = STV090x_CLK_EXT,
-        .xtal                   = 27000000,
-        .address                = 0x6A,
-        .ts1_mode               = STV090x_TSMODE_PARALLEL_PUNCTURED,
-        .repeater_level         = STV090x_RPTLEVEL_64,
-        .adc1_range             = STV090x_ADC_2Vpp,
-        .diseqc_envelope_mode   = false,
-
-        .tuner_get_frequency    = stb6100_get_frequency,
-        .tuner_set_frequency    = stb6100_set_frequency,
-        .tuner_set_bandwidth    = stb6100_set_bandwidth,
-        .tuner_get_bandwidth    = stb6100_get_bandwidth,
-};
-
-static struct stb6100_config prof_8000_stb6100_config = {
-	.tuner_address = 0x60,
-	.refclock = 27000000,
-};
 
-static int p8000_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)
+/* bst control */
+int bst_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)
 {
 	struct cx23885_tsport *port = fe->dvb->priv;
 	struct cx23885_dev *dev = port->dev;
+	
+	cx23885_gpio_enable(dev, GPIO_1, 1);
+	cx23885_gpio_enable(dev, GPIO_0, 1);
+
+	switch (voltage) {
+	case SEC_VOLTAGE_13:
+		cx23885_gpio_set(dev, GPIO_1);
+		cx23885_gpio_clear(dev, GPIO_0);
+		break;
+	case SEC_VOLTAGE_18:
+		cx23885_gpio_set(dev, GPIO_1);
+		cx23885_gpio_set(dev, GPIO_0);
+		break;
+	case SEC_VOLTAGE_OFF:
+		cx23885_gpio_clear(dev, GPIO_1);
+		cx23885_gpio_clear(dev, GPIO_0);
+		break;
+	}
+	return 0;
+}
 
-	if (voltage == SEC_VOLTAGE_18)
-		cx_write(MC417_RWD, 0x00001e00);
-	else if (voltage == SEC_VOLTAGE_13)
-		cx_write(MC417_RWD, 0x00001a00);
-	else
-		cx_write(MC417_RWD, 0x00001800);
+int dvbsky_set_voltage_sec(struct dvb_frontend *fe, fe_sec_voltage_t voltage)
+{
+	struct cx23885_tsport *port = fe->dvb->priv;
+	struct cx23885_dev *dev = port->dev;
+	
+	cx23885_gpio_enable(dev, GPIO_12, 1);
+	cx23885_gpio_enable(dev, GPIO_13, 1);
+
+	switch (voltage) {
+	case SEC_VOLTAGE_13:
+		cx23885_gpio_set(dev, GPIO_13);
+		cx23885_gpio_clear(dev, GPIO_12);
+		break;
+	case SEC_VOLTAGE_18:
+		cx23885_gpio_set(dev, GPIO_13);
+		cx23885_gpio_set(dev, GPIO_12);
+		break;
+	case SEC_VOLTAGE_OFF:
+		cx23885_gpio_clear(dev, GPIO_13);
+		cx23885_gpio_clear(dev, GPIO_12);
+		break;
+	}
 	return 0;
 }
 
+/* bestunar single dvb-s2 */
+static struct m88ds3103_config bst_ds3103_config = {
+	.demod_address = 0x68,
+	.ci_mode = 0,
+	.pin_ctrl = 0x82,
+	.ts_mode = 0,
+	.set_voltage = bst_set_voltage,
+};
+/* DVBSKY dual dvb-s2 */
+static struct m88ds3103_config dvbsky_ds3103_config_pri = {
+	.demod_address = 0x68,
+	.ci_mode = 0,
+	.pin_ctrl = 0x82,
+	.ts_mode = 0,
+	.set_voltage = bst_set_voltage,	
+};
+static struct m88ds3103_config dvbsky_ds3103_config_sec = {
+	.demod_address = 0x68,
+	.ci_mode = 0,
+	.pin_ctrl = 0x82,
+	.ts_mode = 1,
+	.set_voltage = dvbsky_set_voltage_sec,	
+};
+
+static struct m88ds3103_config dvbsky_ds3103_ci_config = {
+	.demod_address = 0x68,
+	.ci_mode = 2,
+	.pin_ctrl = 0x82,
+	.ts_mode = 0,
+};
+
+static struct m88dc2800_config dvbsky_dc2800_config = {
+	.demod_address = 0x1c,
+	.ts_mode = 3,	
+};
+
+static struct si2168_config dvbsky_si2168_config_pci_p = {
+	.ts_bus_mode = 2,
+	.ts_clock_mode = 0,
+	.start_ctrl = NULL,
+};
+
+static struct si2168_config dvbsky_si2168_config_pci_s = {
+	.ts_bus_mode = 1,
+	.ts_clock_mode = 0,
+	.start_ctrl = NULL,
+};
+
+static struct stv090x_config prof_8000_stv090x_config = {
+        .device                 = STV0903,
+        .demod_mode             = STV090x_SINGLE,
+        .clk_mode               = STV090x_CLK_EXT,
+        .xtal                   = 27000000,
+        .address                = 0x6A,
+        .ts1_mode               = STV090x_TSMODE_PARALLEL_PUNCTURED,
+        .repeater_level         = STV090x_RPTLEVEL_64,
+        .adc1_range             = STV090x_ADC_2Vpp,
+        .diseqc_envelope_mode   = false,
+
+        .tuner_get_frequency    = stb6100_get_frequency,
+        .tuner_set_frequency    = stb6100_set_frequency,
+        .tuner_set_bandwidth    = stb6100_set_bandwidth,
+        .tuner_get_bandwidth    = stb6100_get_bandwidth,
+};
+
+static struct stb6100_config prof_8000_stb6100_config = {
+	.tuner_address = 0x60,
+	.refclock = 27000000,
+};
+
+static int p8000_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)
+{
+	struct cx23885_tsport *port = fe->dvb->priv;
+	struct cx23885_dev *dev = port->dev;
+
+	if (voltage == SEC_VOLTAGE_18)
+		cx_write(MC417_RWD, 0x00001e00);
+	else if (voltage == SEC_VOLTAGE_13)
+		cx_write(MC417_RWD, 0x00001a00);
+	else
+		cx_write(MC417_RWD, 0x00001800);
+	return 0;
+}
+
 static int cx23885_dvb_set_frontend(struct dvb_frontend *fe)
 {
 	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
@@ -1225,23 +1328,90 @@
 					&tevii_ds3000_config,
 					&i2c_bus->i2c_adap);
 		break;
-	case CX23885_BOARD_PROF_8000:
-		i2c_bus = &dev->i2c_bus[0];
+	case CX23885_BOARD_BST_PS8512:
+	case CX23885_BOARD_DVBSKY_S950:
+		i2c_bus = &dev->i2c_bus[1];	
+		fe0->dvb.frontend = dvb_attach(m88ds3103_attach,
+					&bst_ds3103_config,
+					&i2c_bus->i2c_adap);
+		break;	
+			
+	case CX23885_BOARD_DVBSKY_S952:
+		switch (port->nr) {
+		/* port B */
+		case 1:
+			i2c_bus = &dev->i2c_bus[1];
+			fe0->dvb.frontend = dvb_attach(m88ds3103_attach,
+						&dvbsky_ds3103_config_pri,
+						&i2c_bus->i2c_adap);
+			break;
+		/* port C */
+		case 2:
+			i2c_bus = &dev->i2c_bus[0];
+			fe0->dvb.frontend = dvb_attach(m88ds3103_attach,
+						&dvbsky_ds3103_config_sec,
+						&i2c_bus->i2c_adap);	
+			break;
+		}
+		break;
 
-		fe0->dvb.frontend = dvb_attach(stv090x_attach,
-						&prof_8000_stv090x_config,
-						&i2c_bus->i2c_adap,
-						STV090x_DEMODULATOR_0);
-		if (fe0->dvb.frontend != NULL) {
-			if (!dvb_attach(stb6100_attach,
-					fe0->dvb.frontend,
-					&prof_8000_stb6100_config,
-					&i2c_bus->i2c_adap))
-				goto frontend_detach;
+	case CX23885_BOARD_DVBSKY_S950_CI:
+		i2c_bus = &dev->i2c_bus[1];	
+		fe0->dvb.frontend = dvb_attach(m88ds3103_attach,
+					&dvbsky_ds3103_ci_config,
+					&i2c_bus->i2c_adap);
+		break;
+				
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+		i2c_bus = &dev->i2c_bus[1];	
+		fe0->dvb.frontend = dvb_attach(m88dc2800_attach,
+					&dvbsky_dc2800_config,
+					&i2c_bus->i2c_adap);
+		break;
 
-			fe0->dvb.frontend->ops.set_voltage = p8000_set_voltage;
+	case CX23885_BOARD_DVBSKY_T9580:
+		switch (port->nr) {
+		/* port B */
+		case 1:
+			i2c_bus = &dev->i2c_bus[1];
+			fe0->dvb.frontend = dvb_attach(m88ds3103_attach,
+						&dvbsky_ds3103_config_pri,
+						&i2c_bus->i2c_adap);
+			break;
+		/* port C */
+		case 2:
+			i2c_bus = &dev->i2c_bus[0];
+			fe0->dvb.frontend = dvb_attach(si2168_attach,
+						&dvbsky_si2168_config_pci_s,
+						&i2c_bus->i2c_adap);	
+			break;
 		}
 		break;
+
+	case CX23885_BOARD_DVBSKY_T980_CI:
+		i2c_bus = &dev->i2c_bus[1];	
+		fe0->dvb.frontend = dvb_attach(si2168_attach,
+					&dvbsky_si2168_config_pci_p,
+					&i2c_bus->i2c_adap);
+		break;
+				
+	case CX23885_BOARD_PROF_8000:
+		i2c_bus = &dev->i2c_bus[0];
+
+		fe0->dvb.frontend = dvb_attach(stv090x_attach,
+						&prof_8000_stv090x_config,
+						&i2c_bus->i2c_adap,
+						STV090x_DEMODULATOR_0);
+		if (fe0->dvb.frontend != NULL) {
+			if (!dvb_attach(stb6100_attach,
+					fe0->dvb.frontend,
+					&prof_8000_stb6100_config,
+					&i2c_bus->i2c_adap))
+				goto frontend_detach;
+
+			fe0->dvb.frontend->ops.set_voltage = p8000_set_voltage;
+		}
+		break;
 	default:
 		printk(KERN_INFO "%s: The frontend of your DVB/ATSC card "
 			" isn't supported yet\n",
@@ -1289,7 +1459,7 @@
 		printk(KERN_INFO "NetUP Dual DVB-S2 CI card port%d MAC=%pM\n",
 			port->nr, port->frontends.adapter.proposed_mac);
 
-		netup_ci_init(port);
+		netup_ci_init(port, false);
 		break;
 		}
 	case CX23885_BOARD_NETUP_DUAL_DVB_T_C_CI_RF: {
@@ -1316,6 +1486,42 @@
 		memcpy(port->frontends.adapter.proposed_mac, eeprom + 0xa0, 6);
 		break;
 		}
+	case CX23885_BOARD_BST_PS8512:
+	case CX23885_BOARD_DVBSKY_S950:
+	case CX23885_BOARD_DVBSKY_S952:
+	case CX23885_BOARD_DVBSKY_T9580:{
+		u8 eeprom[256]; /* 24C02 i2c eeprom */
+
+		if(port->nr > 2)
+			break;
+
+		dev->i2c_bus[0].i2c_client.addr = 0xa0 >> 1;
+		tveeprom_read(&dev->i2c_bus[0].i2c_client, eeprom, sizeof(eeprom));
+		printk(KERN_INFO "DVBSKY PCIe MAC= %pM\n", eeprom + 0xc0+(port->nr-1)*8);
+		memcpy(port->frontends.adapter.proposed_mac, eeprom + 0xc0 + 
+			(port->nr-1)*8, 6);
+		break;
+		}
+	case CX23885_BOARD_DVBSKY_S950_CI: {
+		u8 eeprom[256]; /* 24C02 i2c eeprom */
+
+		if(port->nr > 2)
+			break;
+
+		dev->i2c_bus[0].i2c_client.addr = 0xa0 >> 1;
+		tveeprom_read(&dev->i2c_bus[0].i2c_client, eeprom, sizeof(eeprom));
+		printk(KERN_INFO "DVBSKY PCIe MAC= %pM\n", eeprom + 0xc0+(port->nr-1)*8);
+		memcpy(port->frontends.adapter.proposed_mac, eeprom + 0xc0 + 
+			(port->nr-1)*8, 6);
+			
+		netup_ci_init(port, true);
+		break;
+		}
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T980_CI: {
+		netup_ci_init(port, true);
+		break;
+		}		
 	}
 
 	return ret;
@@ -1398,6 +1604,9 @@
 
 	switch (port->dev->board) {
 	case CX23885_BOARD_NETUP_DUAL_DVBS2_CI:
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T980_CI:
 		netup_ci_exit(port);
 		break;
 	case CX23885_BOARD_NETUP_DUAL_DVB_T_C_CI_RF:
diff -urN a/drivers/media/pci/cx23885/cx23885.h b/drivers/media/pci/cx23885/cx23885.h
--- a/drivers/media/pci/cx23885/cx23885.h	2013-03-21 04:11:19.000000000 +0800
+++ b/drivers/media/pci/cx23885/cx23885.h	2013-03-31 22:18:05.000000000 +0800
@@ -91,6 +91,13 @@
 #define CX23885_BOARD_TEVII_S471               35
 #define CX23885_BOARD_HAUPPAUGE_HVR1255_22111  36
 #define CX23885_BOARD_PROF_8000                37
+#define CX23885_BOARD_BST_PS8512	       38
+#define CX23885_BOARD_DVBSKY_S952	       39
+#define CX23885_BOARD_DVBSKY_S950	       40
+#define CX23885_BOARD_DVBSKY_S950_CI	       41
+#define CX23885_BOARD_DVBSKY_C2800E_CI	       42
+#define CX23885_BOARD_DVBSKY_T9580	       43
+#define CX23885_BOARD_DVBSKY_T980_CI	       44
 
 #define GPIO_0 0x00000001
 #define GPIO_1 0x00000002
@@ -229,7 +236,7 @@
 	 */
 	u32			clk_freq;
 	struct cx23885_input    input[MAX_CX23885_INPUT];
-	int			ci_type; /* for NetUP */
+	int			ci_type; /* 1 and 2 for NetUP, 3 for DVBSky. */
 	/* Force bottom field first during DMA (888 workaround) */
 	u32                     force_bff;
 };
diff -urN a/drivers/media/pci/cx23885/cx23885-input.c b/drivers/media/pci/cx23885/cx23885-input.c
--- a/drivers/media/pci/cx23885/cx23885-input.c	2013-03-21 04:11:19.000000000 +0800
+++ b/drivers/media/pci/cx23885/cx23885-input.c	2013-03-31 22:15:04.000000000 +0800
@@ -89,6 +89,13 @@
 	case CX23885_BOARD_TERRATEC_CINERGY_T_PCIE_DUAL:
 	case CX23885_BOARD_TEVII_S470:
 	case CX23885_BOARD_HAUPPAUGE_HVR1250:
+	case CX23885_BOARD_BST_PS8512:
+	case CX23885_BOARD_DVBSKY_S950:
+	case CX23885_BOARD_DVBSKY_S952:
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T9580:
+	case CX23885_BOARD_DVBSKY_T980_CI:
 		/*
 		 * The only boards we handle right now.  However other boards
 		 * using the CX2388x integrated IR controller should be similar
@@ -140,6 +147,13 @@
 	case CX23885_BOARD_HAUPPAUGE_HVR1850:
 	case CX23885_BOARD_HAUPPAUGE_HVR1290:
 	case CX23885_BOARD_HAUPPAUGE_HVR1250:
+	case CX23885_BOARD_BST_PS8512:
+	case CX23885_BOARD_DVBSKY_S950:
+	case CX23885_BOARD_DVBSKY_S952:
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T9580:
+	case CX23885_BOARD_DVBSKY_T980_CI:
 		/*
 		 * The IR controller on this board only returns pulse widths.
 		 * Any other mode setting will fail to set up the device.
@@ -289,6 +303,19 @@
 		/* A guess at the remote */
 		rc_map = RC_MAP_TEVII_NEC;
 		break;
+	case CX23885_BOARD_BST_PS8512:
+	case CX23885_BOARD_DVBSKY_S950:
+	case CX23885_BOARD_DVBSKY_S952:
+	case CX23885_BOARD_DVBSKY_S950_CI:
+	case CX23885_BOARD_DVBSKY_C2800E_CI:
+	case CX23885_BOARD_DVBSKY_T9580:
+	case CX23885_BOARD_DVBSKY_T980_CI:
+		/* Integrated CX2388[58] IR controller */
+		driver_type = RC_DRIVER_IR_RAW;
+		allowed_protos = RC_BIT_ALL;
+		/* A guess at the remote */
+		rc_map = RC_MAP_DVBSKY;
+		break;
 	default:
 		return -ENODEV;
 	}
diff -urN a/drivers/media/pci/cx23885/Kconfig b/drivers/media/pci/cx23885/Kconfig
--- a/drivers/media/pci/cx23885/Kconfig	2013-03-21 04:11:19.000000000 +0800
+++ b/drivers/media/pci/cx23885/Kconfig	2013-02-14 22:57:51.000000000 +0800
@@ -23,6 +23,9 @@
 	select DVB_STB6100 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_STV6110 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_CX24116 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_M88DS3103 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_M88DC2800 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_SI2168 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_STV0900 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_DS3000 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_STV0367 if MEDIA_SUBDRV_AUTOSELECT
diff -urN a/drivers/media/pci/cx88/cx88-cards.c b/drivers/media/pci/cx88/cx88-cards.c
--- a/drivers/media/pci/cx88/cx88-cards.c	2013-03-21 04:11:19.000000000 +0800
+++ b/drivers/media/pci/cx88/cx88-cards.c	2013-03-31 21:55:58.000000000 +0800
@@ -2309,6 +2309,18 @@
 		} },
 		.mpeg           = CX88_MPEG_DVB,
 	},
+	[CX88_BOARD_BST_PS8312] = {
+		.name           = "Bestunar PS8312 DVB-S/S2",
+		.tuner_type     = UNSET,
+		.radio_type     = UNSET,
+		.tuner_addr     = ADDR_UNSET,
+		.radio_addr     = ADDR_UNSET,
+		.input          = { {
+			.type   = CX88_VMUX_DVB,
+			.vmux   = 0,
+		} },
+		.mpeg           = CX88_MPEG_DVB,
+	},
 };
 
 /* ------------------------------------------------------------------ */
@@ -2813,6 +2825,10 @@
 		.subvendor = 0x1822,
 		.subdevice = 0x0023,
 		.card      = CX88_BOARD_TWINHAN_VP1027_DVBS,
+	}, {
+		.subvendor = 0x14f1,
+		.subdevice = 0x8312,
+		.card      = CX88_BOARD_BST_PS8312,
 	},
 };
 
@@ -3547,6 +3563,12 @@
 		cx_write(MO_SRST_IO, 1);
 		msleep(100);
 		break;
+	case  CX88_BOARD_BST_PS8312:
+		cx_write(MO_GP1_IO, 0x808000);
+		msleep(100);
+		cx_write(MO_GP1_IO, 0x808080);
+		msleep(100);
+		break;
 	} /*end switch() */
 
 
diff -urN a/drivers/media/pci/cx88/cx88-dvb.c b/drivers/media/pci/cx88/cx88-dvb.c
--- a/drivers/media/pci/cx88/cx88-dvb.c	2013-03-21 04:11:19.000000000 +0800
+++ b/drivers/media/pci/cx88/cx88-dvb.c	2013-01-31 10:42:51.000000000 +0800
@@ -54,6 +54,7 @@
 #include "stv0288.h"
 #include "stb6000.h"
 #include "cx24116.h"
+#include "m88ds3103.h"
 #include "stv0900.h"
 #include "stb6100.h"
 #include "stb6100_proc.h"
@@ -458,6 +459,56 @@
 		return core->prev_set_voltage(fe, voltage);
 	return 0;
 }
+/*CX88_BOARD_BST_PS8312*/
+static int bst_dvbs_set_voltage(struct dvb_frontend *fe,
+				      fe_sec_voltage_t voltage)
+{
+	struct cx8802_dev *dev= fe->dvb->priv;
+	struct cx88_core *core = dev->core;
+
+	cx_write(MO_GP1_IO, 0x111111);
+	switch (voltage) {
+		case SEC_VOLTAGE_13:
+			cx_write(MO_GP1_IO, 0x020200);
+			break;
+		case SEC_VOLTAGE_18:
+			cx_write(MO_GP1_IO, 0x020202);
+			break;
+		case SEC_VOLTAGE_OFF:
+			cx_write(MO_GP1_IO, 0x111100);
+			break;
+	}
+
+	if (core->prev_set_voltage)
+		return core->prev_set_voltage(fe, voltage);
+	return 0;
+}
+
+static int bst_dvbs_set_voltage_v2(struct dvb_frontend *fe,
+				      fe_sec_voltage_t voltage)
+{
+	struct cx8802_dev *dev= fe->dvb->priv;
+	struct cx88_core *core = dev->core;
+
+	cx_write(MO_GP1_IO, 0x111101);
+	switch (voltage) {
+		case SEC_VOLTAGE_13:
+			cx_write(MO_GP1_IO, 0x020200);
+			break;
+		case SEC_VOLTAGE_18:
+
+			cx_write(MO_GP1_IO, 0x020202);
+			break;
+		case SEC_VOLTAGE_OFF:
+
+			cx_write(MO_GP1_IO, 0x111110);
+			break;
+	}
+
+	if (core->prev_set_voltage)
+		return core->prev_set_voltage(fe, voltage);
+	return 0;
+}
 
 static int vp1027_set_voltage(struct dvb_frontend *fe,
 				    fe_sec_voltage_t voltage)
@@ -700,6 +751,11 @@
 	.set_ts_params = ds3000_set_ts_param,
 };
 
+static struct m88ds3103_config dvbsky_ds3103_config = {
+	.demod_address = 0x68,
+	.set_ts_params = ds3000_set_ts_param,
+};
+
 static const struct stv0900_config prof_7301_stv0900_config = {
 	.demod_address = 0x6a,
 /*	demod_mode = 0,*/
@@ -1470,6 +1526,35 @@
 			fe0->dvb.frontend->ops.set_voltage =
 							tevii_dvbs_set_voltage;
 		break;
+	case CX88_BOARD_BST_PS8312:
+		fe0->dvb.frontend = dvb_attach(m88ds3103_attach,
+						&dvbsky_ds3103_config,
+						&core->i2c_adap);
+		if (fe0->dvb.frontend != NULL){
+			int ret;
+			u8 b0[] = { 0x60 };
+			u8 b1[2] = { 0 };
+			struct i2c_msg msg[] = {
+				{
+				.addr = 0x50,
+				.flags = 0,
+				.buf = b0,
+				.len = 1
+				}, {
+				.addr = 0x50,
+				.flags = I2C_M_RD,
+				.buf = b1,
+				.len = 2
+				}
+			};
+			ret = i2c_transfer(&core->i2c_adap, msg, 2);
+			printk("PS8312: config = %02x, %02x", b1[0],b1[1]);
+			if(b1[0] == 0xaa)
+				fe0->dvb.frontend->ops.set_voltage = bst_dvbs_set_voltage_v2;
+			else			
+				fe0->dvb.frontend->ops.set_voltage = bst_dvbs_set_voltage;
+		}
+		break;
 	case CX88_BOARD_OMICOM_SS4_PCI:
 	case CX88_BOARD_TBS_8920:
 	case CX88_BOARD_PROF_7300:
diff -urN a/drivers/media/pci/cx88/cx88.h b/drivers/media/pci/cx88/cx88.h
--- a/drivers/media/pci/cx88/cx88.h	2013-03-21 04:11:19.000000000 +0800
+++ b/drivers/media/pci/cx88/cx88.h	2013-01-28 13:21:36.000000000 +0800
@@ -238,6 +238,7 @@
 #define CX88_BOARD_WINFAST_DTV1800H_XC4000 88
 #define CX88_BOARD_WINFAST_TV2000_XP_GLOBAL_6F36 89
 #define CX88_BOARD_WINFAST_TV2000_XP_GLOBAL_6F43 90
+#define CX88_BOARD_BST_PS8312              91
 
 enum cx88_itype {
 	CX88_VMUX_COMPOSITE1 = 1,
diff -urN a/drivers/media/pci/cx88/cx88-input.c b/drivers/media/pci/cx88/cx88-input.c
--- a/drivers/media/pci/cx88/cx88-input.c	2013-03-21 04:11:19.000000000 +0800
+++ b/drivers/media/pci/cx88/cx88-input.c	2013-01-26 14:52:03.000000000 +0800
@@ -419,6 +419,10 @@
 		rc_type          = RC_BIT_NEC;
 		ir->sampling     = 0xff00; /* address */
 		break;
+	case CX88_BOARD_BST_PS8312:
+		ir_codes         = RC_MAP_DVBSKY;
+		ir->sampling     = 0xff00; /* address */
+		break;
 	}
 
 	if (!ir_codes) {
diff -urN a/drivers/media/pci/cx88/Kconfig b/drivers/media/pci/cx88/Kconfig
--- a/drivers/media/pci/cx88/Kconfig	2013-03-21 04:11:19.000000000 +0800
+++ b/drivers/media/pci/cx88/Kconfig	2013-01-31 10:42:58.000000000 +0800
@@ -57,6 +57,7 @@
 	select DVB_ISL6421 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_S5H1411 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_CX24116 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_M88DS3103 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_STV0299 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_STV0288 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_STB6000 if MEDIA_SUBDRV_AUTOSELECT
diff -urN a/drivers/media/rc/keymaps/Makefile b/drivers/media/rc/keymaps/Makefile
--- a/drivers/media/rc/keymaps/Makefile	2013-03-21 04:11:19.000000000 +0800
+++ b/drivers/media/rc/keymaps/Makefile	2013-03-31 22:22:13.000000000 +0800
@@ -27,6 +27,7 @@
 			rc-dm1105-nec.o \
 			rc-dntv-live-dvb-t.o \
 			rc-dntv-live-dvbt-pro.o \
+			rc-dvbsky.o \
 			rc-em-terratec.o \
 			rc-encore-enltv2.o \
 			rc-encore-enltv.o \
diff -urN a/drivers/media/rc/keymaps/rc-dvbsky.c b/drivers/media/rc/keymaps/rc-dvbsky.c
--- a/drivers/media/rc/keymaps/rc-dvbsky.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/rc/keymaps/rc-dvbsky.c	2013-01-26 14:52:49.000000000 +0800
@@ -0,0 +1,78 @@
+/* rc-dvbsky.c - Keytable for Dvbsky Remote Controllers
+ *
+ * keymap imported from ir-keymaps.c
+ *
+ *
+ * Copyright (c) 2010-2012 by Nibble Max <nibble.max@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <media/rc-map.h>
+#include <linux/module.h>
+/*
+ * This table contains the complete RC5 code, instead of just the data part
+ */
+
+static struct rc_map_table rc5_dvbsky[] = {
+	{ 0x0000, KEY_0 },
+	{ 0x0001, KEY_1 },
+	{ 0x0002, KEY_2 },
+	{ 0x0003, KEY_3 },
+	{ 0x0004, KEY_4 },
+	{ 0x0005, KEY_5 },
+	{ 0x0006, KEY_6 },
+	{ 0x0007, KEY_7 },
+	{ 0x0008, KEY_8 },
+	{ 0x0009, KEY_9 },
+	{ 0x000a, KEY_MUTE },
+	{ 0x000d, KEY_OK },
+	{ 0x000b, KEY_STOP },
+	{ 0x000c, KEY_EXIT },
+	{ 0x000e, KEY_CAMERA }, /*Snap shot*/
+	{ 0x000f, KEY_SUBTITLE }, /*PIP*/
+	{ 0x0010, KEY_VOLUMEUP },
+	{ 0x0011, KEY_VOLUMEDOWN },
+	{ 0x0012, KEY_FAVORITES },
+	{ 0x0013, KEY_LIST }, /*Info*/
+	{ 0x0016, KEY_PAUSE },
+	{ 0x0017, KEY_PLAY },
+	{ 0x001f, KEY_RECORD },
+	{ 0x0020, KEY_CHANNELDOWN },
+	{ 0x0021, KEY_CHANNELUP },
+	{ 0x0025, KEY_POWER2 },
+	{ 0x0026, KEY_REWIND },
+	{ 0x0027, KEY_FASTFORWARD },
+	{ 0x0029, KEY_LAST },
+	{ 0x002b, KEY_MENU },
+	{ 0x002c, KEY_EPG },
+	{ 0x002d, KEY_ZOOM },
+};
+
+static struct rc_map_list rc5_dvbsky_map = {
+	.map = {
+		.scan    = rc5_dvbsky,
+		.size    = ARRAY_SIZE(rc5_dvbsky),
+		.rc_type = RC_TYPE_RC5,
+		.name    = RC_MAP_DVBSKY,
+	}
+};
+
+static int __init init_rc_map_rc5_dvbsky(void)
+{
+	return rc_map_register(&rc5_dvbsky_map);
+}
+
+static void __exit exit_rc_map_rc5_dvbsky(void)
+{
+	rc_map_unregister(&rc5_dvbsky_map);
+}
+
+module_init(init_rc_map_rc5_dvbsky)
+module_exit(exit_rc_map_rc5_dvbsky)
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Nibble Max <nibble.max@gmail.com>");
diff -urN a/drivers/media/usb/dvb-usb-v2/dvbsky.c b/drivers/media/usb/dvb-usb-v2/dvbsky.c
--- a/drivers/media/usb/dvb-usb-v2/dvbsky.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/media/usb/dvb-usb-v2/dvbsky.c	2013-03-31 22:26:05.000000000 +0800
@@ -0,0 +1,721 @@
+/*
+ * Driver for DVBSky USB2.0 receiver
+ *
+ * Copyright (C) 2013 Max nibble <nibble.max@gmail.com>
+ *
+ * CIMax code is copied and modified from:
+ * CIMax2(R) SP2 driver in conjunction with NetUp Dual DVB-S2 CI card
+ * Copyright (C) 2009 NetUP Inc.
+ * Copyright (C) 2009 Igor M. Liplianin <liplianin@netup.ru>
+ * Copyright (C) 2009 Abylay Ospan <aospan@netup.ru>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "dvb_ca_en50221.h"
+#include "dvb_usb.h"
+#include "si2168.h"
+#include "m88ds3103.h"
+
+static int dvbsky_debug;
+module_param(dvbsky_debug, int, 0644);
+MODULE_PARM_DESC(dvbsky_debug, "Activates dvbsky usb debugging (default:0)");
+
+#define DVBSKY_CI_CTL		0x04
+#define DVBSKY_CI_RD		1
+
+#define dprintk(args...) \
+	do { \
+		if (dvbsky_debug) \
+			printk(KERN_INFO "dvbsky_usb: " args); \
+	} while (0)
+
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+
+struct dvbsky_state {
+	struct mutex stream_mutex;
+	u8 has_ci;
+	u8 ci_attached;
+	struct dvb_ca_en50221 ci;
+	unsigned long next_status_checked_time;
+	u8 ci_i2c_addr;
+	u8 current_ci_flag;
+	int ci_status;
+};
+
+static int dvbsky_stream_ctrl(struct dvb_usb_device *d, u8 onoff)
+{
+	struct dvbsky_state *state = d_to_priv(d);
+	int ret;
+	u8 obuf_pre[3] = { 0x37, 0, 0 };
+	u8 obuf_post[3] = { 0x36, 3, 0 };
+	dprintk("%s() -off \n", __func__);
+	mutex_lock(&state->stream_mutex);
+	ret = dvb_usbv2_generic_write(d, obuf_pre, 3);
+	if (!ret && onoff) {
+		msleep(10);
+		ret = dvb_usbv2_generic_write(d, obuf_post, 3);
+		dprintk("%s() -on \n", __func__);
+	}
+	mutex_unlock(&state->stream_mutex);
+	return ret;
+}
+
+/* CI opertaions */
+static int dvbsky_ci_read_i2c(struct i2c_adapter *i2c_adap, u8 addr, u8 reg,
+						u8 *buf, int len)
+{
+	int ret;
+	struct i2c_msg msg[] = {
+		{
+			.addr	= addr,
+			.flags	= 0,
+			.buf	= &reg,
+			.len	= 1
+		}, {
+			.addr	= addr,
+			.flags	= I2C_M_RD,
+			.buf	= buf,
+			.len	= len
+		}
+	};
+	
+	ret = i2c_transfer(i2c_adap, msg, 2);
+	
+	if (ret != 2) {
+		dprintk("%s: error, Reg = 0x%02x, Status = %d\n", __func__, reg, ret);
+		return -1;
+	}
+	return 0;
+}
+
+static int dvbsky_ci_write_i2c(struct i2c_adapter *i2c_adap, u8 addr, u8 reg,
+						u8 *buf, int len)
+{
+	int ret;
+	u8 buffer[len + 1];
+
+	struct i2c_msg msg = {
+		.addr	= addr,
+		.flags	= 0,
+		.buf	= &buffer[0],
+		.len	= len + 1
+	};
+
+	buffer[0] = reg;
+	memcpy(&buffer[1], buf, len);
+
+	ret = i2c_transfer(i2c_adap, &msg, 1);
+
+	if (ret != 1) {
+		dprintk("%s: error, Reg=[0x%02x], Status=%d\n", __func__, reg, ret);
+		return -1;
+	}
+	return 0;
+}
+
+static int dvbsky_ci_op_cam(struct dvb_ca_en50221 *ci, int slot,
+				u8 flag, u8 read, int addr, u8 data)
+{
+	struct dvb_usb_device *d = ci->data;
+	struct dvbsky_state *state = d_to_priv(d);	
+	u8 store;
+	int ret;
+	u8 command[4], respond[2], command_size, respond_size;
+
+	/*dprintk("%s()\n", __func__);*/
+	if (0 != slot)
+		return -EINVAL;
+
+	if (state->current_ci_flag != flag) {
+		ret = dvbsky_ci_read_i2c(&d->i2c_adap, state->ci_i2c_addr,
+				0, &store, 1);
+		if (ret != 0)
+			return ret;
+
+		store &= ~0x0c;
+		store |= flag;
+
+		ret = dvbsky_ci_write_i2c(&d->i2c_adap, state->ci_i2c_addr,
+				0, &store, 1);
+		if (ret != 0)
+			return ret;
+	}
+	state->current_ci_flag = flag;
+
+	command[1] = (u8)((addr >> 8) & 0xff); /*high part of address*/
+	command[2] = (u8)(addr & 0xff); /*low part of address*/
+	if (read) {
+		command[0] = 0x71;
+		command_size = 3;
+		respond_size = 2;
+	} else {
+		command[0] = 0x70;
+		command[3] = data;
+		command_size = 4;
+		respond_size = 1;
+	}
+	ret = dvb_usbv2_generic_rw(d, command, command_size, respond, respond_size);
+
+	return (read) ? respond[1] : 0;
+}
+
+static int dvbsky_ci_read_attribute_mem(struct dvb_ca_en50221 *ci,
+						int slot, int addr)
+{
+	return dvbsky_ci_op_cam(ci, slot, 0, DVBSKY_CI_RD, addr, 0);
+}
+
+static int dvbsky_ci_write_attribute_mem(struct dvb_ca_en50221 *ci,
+						int slot, int addr, u8 data)
+{
+	return dvbsky_ci_op_cam(ci, slot, 0, 0, addr, data);
+}
+
+static int dvbsky_ci_read_cam_ctl(struct dvb_ca_en50221 *ci, int slot, u8 addr)
+{
+	return dvbsky_ci_op_cam(ci, slot, DVBSKY_CI_CTL, DVBSKY_CI_RD, addr, 0);
+}
+
+static int dvbsky_ci_write_cam_ctl(struct dvb_ca_en50221 *ci, int slot,
+							u8 addr, u8 data)
+{
+	return dvbsky_ci_op_cam(ci, slot, DVBSKY_CI_CTL, 0, addr, data);
+}
+
+static int dvbsky_ci_slot_reset(struct dvb_ca_en50221 *ci, int slot)
+{
+	struct dvb_usb_device *d = ci->data;
+	struct dvbsky_state *state = d_to_priv(d);
+	u8 buf =  0x80;
+	int ret;
+	dprintk("%s() slot=%d\n", __func__, slot);
+
+	if (0 != slot)
+		return -EINVAL;
+
+	udelay(500);
+	ret = dvbsky_ci_write_i2c(&d->i2c_adap, state->ci_i2c_addr,
+							0, &buf, 1);
+
+	if (ret != 0)
+		return ret;
+
+	udelay(500);
+
+	buf = 0x00;
+	ret = dvbsky_ci_write_i2c(&d->i2c_adap, state->ci_i2c_addr,
+							0, &buf, 1);
+	msleep(1000);
+	dprintk("%s() slot=%d complete\n", __func__, slot);
+	return 0;
+
+}
+
+static int dvbsky_ci_slot_shutdown(struct dvb_ca_en50221 *ci, int slot)
+{
+	/* not implemented */
+	dprintk("%s()\n", __func__);
+	return 0;
+}
+
+static int dvbsky_ci_slot_ts_enable(struct dvb_ca_en50221 *ci, int slot)
+{
+	struct dvb_usb_device *d = ci->data;
+	struct dvbsky_state *state = d_to_priv(d);
+	u8 buf;
+	int ret;
+
+	dprintk("%s()\n", __func__);
+	if (0 != slot)
+		return -EINVAL;
+
+	dvbsky_ci_read_i2c(&d->i2c_adap, state->ci_i2c_addr,
+			0, &buf, 1);
+	buf |= 0x60;
+
+	ret = dvbsky_ci_write_i2c(&d->i2c_adap, state->ci_i2c_addr,
+							0, &buf, 1);
+	return ret;
+}
+
+static int dvbsky_ci_poll_slot_status(struct dvb_ca_en50221 *ci, int slot,
+	int open)
+{
+	struct dvb_usb_device *d = ci->data;
+	struct dvbsky_state *state = d_to_priv(d);
+	int ret = 0;
+	u8 buf = 0;
+	/*dprintk("%s()\n", __func__);*/
+
+	/* CAM module INSERT/REMOVE processing. slow operation because of i2c
+	 * transfers */
+	if (time_after(jiffies, state->next_status_checked_time)) {
+		ret = dvbsky_ci_read_i2c(&d->i2c_adap, state->ci_i2c_addr,
+				0, &buf, 1);
+
+		/*dprintk("%s() status=%x\n", __func__, buf);*/
+		
+		state->next_status_checked_time = jiffies
+			+ msecs_to_jiffies(1000);
+
+		if (ret != 0)
+			return 0;
+
+		if (buf & 1) {
+			state->ci_status = DVB_CA_EN50221_POLL_CAM_PRESENT |
+				DVB_CA_EN50221_POLL_CAM_READY;
+		}
+		else
+			state->ci_status = 0;
+	}
+	/*dprintk("%s() ret=%x\n", __func__, state->ci_status);*/
+	return state->ci_status;
+}
+
+static int dvbsky_ci_init(struct dvb_usb_device *d)
+{
+	struct dvbsky_state *state = d_to_priv(d);
+	int ret;
+	u8 cimax_init[34] = {
+		0x00, /* module A control*/
+		0x00, /* auto select mask high A */
+		0x00, /* auto select mask low A */
+		0x00, /* auto select pattern high A */
+		0x00, /* auto select pattern low A */
+		0x44, /* memory access time A */
+		0x00, /* invert input A */
+		0x00, /* RFU */
+		0x00, /* RFU */
+		0x00, /* module B control*/
+		0x00, /* auto select mask high B */
+		0x00, /* auto select mask low B */
+		0x00, /* auto select pattern high B */
+		0x00, /* auto select pattern low B */
+		0x44, /* memory access time B */
+		0x00, /* invert input B */
+		0x00, /* RFU */
+		0x00, /* RFU */
+		0x00, /* auto select mask high Ext */
+		0x00, /* auto select mask low Ext */
+		0x00, /* auto select pattern high Ext */
+		0x00, /* auto select pattern low Ext */
+		0x00, /* RFU */
+		0x02, /* destination - module A */
+		0x01, /* power on (use it like store place) */
+		0x00, /* RFU */
+		0x00, /* int status read only */
+		0x00, /* Max: Disable the interrupt in USB solution.*/
+		0x05, /* EXTINT=active-high, INT=push-pull */
+		0x00, /* USCG1 */
+		0x04, /* ack active low */
+		0x00, /* LOCK = 0 */
+		0x22, /* serial mode, rising in, rising out, MSB first*/
+		0x00  /* synchronization */
+	};	
+	dprintk("%s()\n", __func__);
+	state->current_ci_flag = 0xff;
+	state->ci_status = 0;
+	state->next_status_checked_time = jiffies + msecs_to_jiffies(1000);
+	state->ci_i2c_addr = 0x40;
+
+	state->ci.owner               = THIS_MODULE;
+	state->ci.read_attribute_mem  = dvbsky_ci_read_attribute_mem;
+	state->ci.write_attribute_mem = dvbsky_ci_write_attribute_mem;
+	state->ci.read_cam_control    = dvbsky_ci_read_cam_ctl;
+	state->ci.write_cam_control   = dvbsky_ci_write_cam_ctl;
+	state->ci.slot_reset          = dvbsky_ci_slot_reset;
+	state->ci.slot_shutdown       = dvbsky_ci_slot_shutdown;
+	state->ci.slot_ts_enable      = dvbsky_ci_slot_ts_enable;
+	state->ci.poll_slot_status    = dvbsky_ci_poll_slot_status;
+	state->ci.data                = d;
+
+	ret = dvbsky_ci_write_i2c(&d->i2c_adap, state->ci_i2c_addr,
+						0, &cimax_init[0], 34);
+	/* lock registers */
+	ret |= dvbsky_ci_write_i2c(&d->i2c_adap, state->ci_i2c_addr,
+						0x1f, &cimax_init[0x18], 1);
+	/* power on slots */
+	ret |= dvbsky_ci_write_i2c(&d->i2c_adap, state->ci_i2c_addr,
+						0x18, &cimax_init[0x18], 1);
+	if (0 != ret)
+		return ret;
+		
+	ret = dvb_ca_en50221_init(&d->adapter[0].dvb_adap, &state->ci, 0, 1);
+	if (ret)
+		return ret;
+	state->ci_attached = 1;
+	dprintk("%s() complete.\n", __func__);
+	return 0;
+}
+
+static void dvbsky_ci_release(struct dvb_usb_device *d)
+{
+	struct dvbsky_state *state = d_to_priv(d);
+
+	/* detach CI */
+	if (state->ci_attached)
+		dvb_ca_en50221_release(&state->ci);
+
+	return;
+}
+
+static int dvbsky_streaming_ctrl(struct dvb_frontend *fe, int onoff)
+{
+	struct dvb_usb_device *d = fe_to_d(fe);
+	/*dprintk("%s() %d\n", __func__, onoff);*/
+	return dvbsky_stream_ctrl(d, (onoff == 0) ? 0 : 1);
+}
+
+/* GPIO */
+static int dvbsky_gpio_ctrl(struct dvb_usb_device *d, u8 gport, u8 value)
+{
+	u8 obuf[64], ibuf[64];
+	obuf[0] = 0x0e;
+	obuf[1] = gport;
+	obuf[2] = value;
+	return dvb_usbv2_generic_rw(d, obuf, 3, ibuf, 1);
+}
+
+/* I2C */
+static int dvbsky_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],
+	int num)
+{
+	struct dvb_usb_device *d = i2c_get_adapdata(adap);
+	int ret = 0;
+	u8 ibuf[64], obuf[64]; 
+
+	if (mutex_lock_interruptible(&d->i2c_mutex) < 0)
+		return -EAGAIN;
+
+	if (num > 2) {
+		printk(KERN_ERR "dvbsky_usb: too many i2c messages[%d] than 2.", num);
+		ret = -EOPNOTSUPP;
+		goto i2c_error;
+	}
+		
+	if(num == 1) {
+		if (msg[0].len > 60) {
+			printk(KERN_ERR "dvbsky_usb: too many i2c bytes[%d] than 60.", msg[0].len);
+			ret = -EOPNOTSUPP;
+			goto i2c_error;
+		}
+		if (msg[0].flags & I2C_M_RD) {
+			/* single read */
+			obuf[0] = 0x09;
+			obuf[1] = 0;
+			obuf[2] = msg[0].len;
+			obuf[3] = msg[0].addr;
+			ret = dvb_usbv2_generic_rw(d, obuf, 4, ibuf, msg[0].len + 1);
+			/*dprintk("%s(): read status = %d\n", __func__, ibuf[0]);*/
+			if (!ret)
+				memcpy(msg[0].buf, &ibuf[1], msg[0].len);
+		} else {
+			/* write */
+			obuf[0] = 0x08;
+			obuf[1] = msg[0].addr;
+			obuf[2] = msg[0].len;
+			memcpy(&obuf[3], msg[0].buf, msg[0].len);
+			ret = dvb_usbv2_generic_rw(d, obuf, msg[0].len + 3, ibuf, 1);
+			/*dprintk("%s(): write status = %d\n", __func__, ibuf[0]);*/
+		}
+	} else {
+		if ((msg[0].len > 60) || (msg[1].len > 60)) {
+			printk(KERN_ERR "dvbsky_usb: too many i2c bytes[w-%d][r-%d] than 60.", msg[0].len, msg[1].len);
+			ret = -EOPNOTSUPP;
+			goto i2c_error;
+		}
+		/* write then read */
+		obuf[0] = 0x09;
+		obuf[1] = msg[0].len;
+		obuf[2] = msg[1].len;
+		obuf[3] = msg[0].addr;
+		memcpy(&obuf[4], msg[0].buf, msg[0].len);
+		ret = dvb_usbv2_generic_rw(d, obuf, msg[0].len + 4, ibuf, msg[1].len + 1);
+		/*dprintk("%s(): write then read status = %d\n", __func__, ibuf[0]);*/
+		if (!ret)
+			memcpy(msg[1].buf, &ibuf[1], msg[1].len);
+	}
+i2c_error:
+	mutex_unlock(&d->i2c_mutex);
+	return (ret) ? ret : num;
+}
+
+static u32 dvbsky_i2c_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_I2C;
+}
+
+static struct i2c_algorithm dvbsky_i2c_algo = {
+	.master_xfer   = dvbsky_i2c_xfer,
+	.functionality = dvbsky_i2c_func,
+};
+
+static int dvbsky_rc_query(struct dvb_usb_device *d)
+{
+	u32 code = 0xffff;
+	u8 obuf[2], ibuf[2], toggle;
+	int ret;
+	obuf[0] = 0x10;
+	ret = dvb_usbv2_generic_rw(d, obuf, 1, ibuf, 2);
+	if(ret == 0)
+		code = (ibuf[0] << 8) | ibuf[1];
+
+	if (code != 0xffff) {
+		dprintk("rc code: %x", code);
+		toggle = (code & 0x800) ? 1 : 0;
+		code &= 0x3f;
+		rc_keydown(d->rc_dev, code, toggle);
+	}
+	return 0;
+}
+
+static int dvbsky_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)
+{
+	rc->allowed_protos = RC_BIT_RC5;
+	rc->query          = dvbsky_rc_query;
+	rc->interval       = 300;
+	return 0;
+}
+
+static int dvbsky_sync_ctrl(struct dvb_frontend *fe)
+{
+	struct dvb_usb_device *d = fe_to_d(fe);
+	return dvbsky_stream_ctrl(d, 1);
+}
+
+static int dvbsky_usb_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)
+{
+	struct dvb_usb_device *d = fe_to_d(fe);
+	u8 value;
+
+	if (voltage == SEC_VOLTAGE_OFF)
+		value = 0;
+	else
+		value = 1;
+	return dvbsky_gpio_ctrl(d, 0x80, value);
+}
+
+static struct si2168_config dvbsky_usb_si2168_config = {
+	.ts_bus_mode = 2,
+	.ts_clock_mode = 1,
+	.start_ctrl = NULL,
+};
+
+static int dvbsky_t680c_attach(struct dvb_usb_adapter *adap)
+{
+	struct dvbsky_state *state = adap_to_priv(adap);
+	struct dvb_usb_device *d = adap_to_d(adap);
+	int ret = 0;
+	
+	dprintk("%s, build on %s %s()\n", __func__, __DATE__,__TIME__);
+	
+	dvbsky_gpio_ctrl(d, 0x83, 0);
+	msleep(50);
+	dvbsky_gpio_ctrl(d, 0x83, 1);
+	msleep(20);
+	
+	adap->fe[0] = dvb_attach(si2168_attach,
+				&dvbsky_usb_si2168_config,
+				&d->i2c_adap);
+	if (!adap->fe[0]) {
+		printk(KERN_ERR "dvbsky_t680c_attach fail.");
+		ret = -ENODEV;
+	}
+	
+	state->has_ci = 1;
+
+	return ret;
+}
+
+static int dvbsky_read_mac_addr(struct dvb_usb_adapter *adap, u8 mac[6])
+{
+	struct dvb_usb_device *d = adap_to_d(adap);
+	u8 obuf[] = { 0x1e, 0x00 };
+	u8 ibuf[6] = { 0 };
+	struct i2c_msg msg[] = {
+		{
+			.addr = 0x51,
+			.flags = 0,
+			.buf = obuf,
+			.len = 2,
+		}, {
+			.addr = 0x51,
+			.flags = I2C_M_RD,
+			.buf = ibuf,
+			.len = 6,
+
+		}
+	};
+	
+	if (i2c_transfer(&d->i2c_adap, msg, 2) == 2)
+		memcpy(mac, ibuf, 6);
+
+	printk(KERN_INFO "dvbsky_usb MAC address=%pM\n", mac);
+	
+	return 0;
+}
+
+static struct m88ds3103_config dvbsky_usb_ds3103_config = {
+	.demod_address = 0x68,
+	.ci_mode = 1,
+	.pin_ctrl = 0x83,
+	.ts_mode = 0,
+	.start_ctrl = dvbsky_sync_ctrl,
+	.set_voltage = dvbsky_usb_set_voltage,
+};
+
+static int dvbsky_s960_attach(struct dvb_usb_adapter *adap)
+{
+	struct dvbsky_state *state = adap_to_priv(adap);
+	struct dvb_usb_device *d = adap_to_d(adap);
+	int ret = 0;
+	
+	dprintk("%s()\n", __func__);
+
+	dvbsky_gpio_ctrl(d, 0x04, 1);
+		
+	dvbsky_gpio_ctrl(d, 0x83, 0);
+	msleep(50);
+	dvbsky_gpio_ctrl(d, 0x83, 1);
+	msleep(20);
+	
+	adap->fe[0] = dvb_attach(m88ds3103_attach,
+				&dvbsky_usb_ds3103_config,
+				&d->i2c_adap);
+	if (!adap->fe[0]) {
+		printk(KERN_ERR "dvbsky_s960_attach fail.");
+		ret = -ENODEV;
+	}
+	
+	state->has_ci = 0;
+
+	return ret;
+}
+
+static int dvbsky_identify_state(struct dvb_usb_device *d, const char **name)
+{
+	return WARM;
+}
+
+static int dvbsky_init(struct dvb_usb_device *d)
+{
+	struct dvbsky_state *state = d_to_priv(d);
+	int ret;
+
+	/* use default interface */
+	ret = usb_set_interface(d->udev, 0, 0);
+	if (ret)
+		return ret;
+
+	mutex_init(&state->stream_mutex);
+	
+	/* attach CI */
+	if (state->has_ci) {
+		dvbsky_gpio_ctrl(d, 0xc0, 1);
+		msleep(100);
+		dvbsky_gpio_ctrl(d, 0xc0, 0);
+		msleep(50);
+		state->ci_attached = 0;
+		ret = dvbsky_ci_init(d);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
+
+static void dvbsky_exit(struct dvb_usb_device *d)
+{
+	return dvbsky_ci_release(d);
+}
+
+/* DVB USB Driver stuff */
+static struct dvb_usb_device_properties dvbsky_t680c_props = {
+	.driver_name = KBUILD_MODNAME,
+	.owner = THIS_MODULE,
+	.adapter_nr = adapter_nr,
+	.size_of_priv = sizeof(struct dvbsky_state),
+
+	.generic_bulk_ctrl_endpoint = 0x01,
+	.generic_bulk_ctrl_endpoint_response = 0x81,
+
+	.i2c_algo         = &dvbsky_i2c_algo,
+	.frontend_attach  = dvbsky_t680c_attach,
+	.init             = dvbsky_init,
+	.get_rc_config    = dvbsky_get_rc_config,
+	.streaming_ctrl   = dvbsky_streaming_ctrl,
+	.identify_state	  = dvbsky_identify_state,
+	.exit             = dvbsky_exit,
+
+	.num_adapters = 1,
+	.adapter = {
+		{
+			.stream = DVB_USB_STREAM_BULK(0x82, 8, 4096),
+		}
+	}
+};
+
+static struct dvb_usb_device_properties dvbsky_s960_props = {
+	.driver_name = KBUILD_MODNAME,
+	.owner = THIS_MODULE,
+	.adapter_nr = adapter_nr,
+	.size_of_priv = sizeof(struct dvbsky_state),
+
+	.generic_bulk_ctrl_endpoint = 0x01,
+	.generic_bulk_ctrl_endpoint_response = 0x81,
+
+	.i2c_algo         = &dvbsky_i2c_algo,
+	.frontend_attach  = dvbsky_s960_attach,
+	.init             = dvbsky_init,
+	.get_rc_config    = dvbsky_get_rc_config,
+	.streaming_ctrl   = dvbsky_streaming_ctrl,
+	.identify_state	  = dvbsky_identify_state,
+	.exit             = dvbsky_exit,
+	.read_mac_address = dvbsky_read_mac_addr,
+
+	.num_adapters = 1,
+	.adapter = {
+		{
+			.stream = DVB_USB_STREAM_BULK(0x82, 8, 4096),
+		}
+	}
+};
+
+static const struct usb_device_id dvbsky_id_table[] = {
+	{ DVB_USB_DEVICE(0x0572, 0x680c,
+		&dvbsky_t680c_props, "DVBSky T680C", RC_MAP_DVBSKY) },
+	{ DVB_USB_DEVICE(0x0572, 0x6831,
+		&dvbsky_s960_props, "DVBSky S960/S860", RC_MAP_DVBSKY) },
+	{ }
+};
+MODULE_DEVICE_TABLE(usb, dvbsky_id_table);
+
+static struct usb_driver dvbsky_usb_driver = {
+	.name = KBUILD_MODNAME,
+	.id_table = dvbsky_id_table,
+	.probe = dvb_usbv2_probe,
+	.disconnect = dvb_usbv2_disconnect,
+	.suspend = dvb_usbv2_suspend,
+	.resume = dvb_usbv2_resume,
+	.reset_resume = dvb_usbv2_reset_resume,
+	.no_dynamic_id = 1,
+	.soft_unbind = 1,
+};
+
+module_usb_driver(dvbsky_usb_driver);
+
+MODULE_AUTHOR("Max nibble <nibble.max@gmail.com>");
+MODULE_DESCRIPTION("Driver for DVBSky USB2.0");
+MODULE_LICENSE("GPL");
diff -urN a/drivers/media/usb/dvb-usb-v2/Kconfig b/drivers/media/usb/dvb-usb-v2/Kconfig
--- a/drivers/media/usb/dvb-usb-v2/Kconfig	2013-03-21 04:11:19.000000000 +0800
+++ b/drivers/media/usb/dvb-usb-v2/Kconfig	2013-03-31 22:29:20.000000000 +0800
@@ -147,3 +147,11 @@
 	help
 	  Say Y here to support the Realtek RTL28xxU DVB USB receiver.
 
+config DVB_USB_DVBSKY
+	tristate "DVBSky USB2.0 support"
+	depends on DVB_USB_V2
+	select DVB_SI2168 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_M88DS3103 if MEDIA_SUBDRV_AUTOSELECT
+	help
+	  Say Y here to support the USB receivers from DVBSky.
+
diff -urN a/drivers/media/usb/dvb-usb-v2/Makefile b/drivers/media/usb/dvb-usb-v2/Makefile
--- a/drivers/media/usb/dvb-usb-v2/Makefile	2013-03-21 04:11:19.000000000 +0800
+++ b/drivers/media/usb/dvb-usb-v2/Makefile	2013-02-17 12:03:00.000000000 +0800
@@ -43,6 +43,9 @@
 dvb-usb-rtl28xxu-objs := rtl28xxu.o
 obj-$(CONFIG_DVB_USB_RTL28XXU) += dvb-usb-rtl28xxu.o
 
+dvb-usb-dvbsky-objs := dvbsky.o
+obj-$(CONFIG_DVB_USB_DVBSKY) += dvb-usb-dvbsky.o
+
 ccflags-y += -I$(srctree)/drivers/media/dvb-core
 ccflags-y += -I$(srctree)/drivers/media/dvb-frontends
 ccflags-y += -I$(srctree)/drivers/media/tuners
diff -urN a/include/media/rc-map.h b/include/media/rc-map.h
--- a/include/media/rc-map.h	2013-03-21 04:11:19.000000000 +0800
+++ b/include/media/rc-map.h	2013-03-31 21:42:43.000000000 +0800
@@ -118,6 +118,7 @@
 #define RC_MAP_DM1105_NEC                "rc-dm1105-nec"
 #define RC_MAP_DNTV_LIVE_DVBT_PRO        "rc-dntv-live-dvbt-pro"
 #define RC_MAP_DNTV_LIVE_DVB_T           "rc-dntv-live-dvb-t"
+#define RC_MAP_DVBSKY                    "rc-dvbsky"
 #define RC_MAP_EMPTY                     "rc-empty"
 #define RC_MAP_EM_TERRATEC               "rc-em-terratec"
 #define RC_MAP_ENCORE_ENLTV2             "rc-encore-enltv2"
