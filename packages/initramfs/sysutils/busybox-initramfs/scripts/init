#!/bin/sh

################################################################################
#      This file is part of OpenELEC - http://www.openelec.tv
#      Copyright (C) 2009-2012 Stephan Raue (stephan@openelec.tv)
#      Copyright (C) 2010-2011 Roman Weber (roman@openelec.tv)
#      Copyright (C) 2012 Yann CÃ©zard (eesprit@free.fr)
#
#  This Program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2, or (at your option)
#  any later version.
#
#  This Program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with OpenELEC.tv; see the file COPYING.  If not, write to
#  the Free Software Foundation, 51 Franklin Street, Suite 500, Boston, MA 02110, USA.
#  http://www.gnu.org/copyleft/gpl.html
################################################################################

# mount all needed special filesystems
  /bin/busybox mount -t devtmpfs none /dev
  /bin/busybox mount -t proc none /proc
  /bin/busybox mount -t sysfs none /sys

# set needed variables
  MODULE_DIR=/lib/modules

  UPDATE_DIR=/storage/.update
  UPDATE_KERNEL="KERNEL"
  UPDATE_SYSTEM="SYSTEM"
  IMAGE_KERNEL="KERNEL"
  IMAGE_SYSTEM="SYSTEM"

# iotimeout for media_check, disabled by default. typical value 5000.
  IO_TIMEOUT=0

  NBD_DEVS="0"

  INSTALLED_MEMORY=$(/bin/busybox cat /proc/meminfo | /bin/busybox grep 'MemTotal:' | /bin/busybox awk '{print $2}')
  SYSTEM_TORAM_LIMIT=1024000

# load any configuration
  [ -f "/etc/initramfs.conf" ] && . /etc/initramfs.conf

# hide kernel log messages on console
  echo '1 4 1 7' > /proc/sys/kernel/printk

# clear screen and hide cursor
  /bin/busybox clear
  echo 0 > /sys/devices/virtual/graphics/fbcon/cursor_blink

# is current device a Raspberry Pi?
  [ -n "$(/bin/busybox cat /proc/cpuinfo | /bin/busybox grep -E "Hardware.*:.*BCM2708")" ] && IS_RPI=Y

# parse command line arguments
  for arg in $(/bin/busybox cat /proc/cmdline); do
    case $arg in
      BOOT_IMAGE=*)
        IMAGE_KERNEL="${arg#*=}"
        ;;
      SYSTEM_IMAGE=*)
        IMAGE_SYSTEM="${arg#*=}"
        ;;
      boot=*)
        boot="${arg#*=}"
        # BOOT_TYPE: local, nfs, nbd, iscsi, cifs etc.
        BOOT_TYPE="$(echo "${boot}" | /bin/busybox sed -r "s/(.*)=.*/\1/" | /bin/busybox tr '[A-Z]' '[a-z]')"
        [ -n "$(echo "${BOOT_TYPE}" | /bin/busybox grep -E "^/|^label|^uuid")" ] && BOOT_TYPE="local"
        # Booting a Raspberry Pi from direct attached media, but not from SD card... so USB
        [ "${IS_RPI}" = "Y" -a "${BOOT_TYPE}" = "local" -a "${boot}" != "/dev/mmcblk0p1" ] && BOOT_TYPE="usb"
        BOOT_OPTIONS="$(echo "${boot}" | /bin/busybox sed -r "s/.*=(.*)/\1/")"
        ;;
      disk=*)
        disk="${arg#*=}"
        # DISK_TYPE: local, nfs, nbd, iscsi, cifs etc.
        DISK_TYPE="$(echo "${disk}" | /bin/busybox sed -r "s/(.*)=.*/\1/" | /bin/busybox tr '[A-Z]' '[a-z]')"
        [ -n "$(echo "${DISK_TYPE}" | /bin/busybox grep -E "^/|^label|^uuid")" ] && DISK_TYPE="local"
        DISK_OPTIONS="$(echo "${disk}" | /bin/busybox sed -r "s/.*=(.*)/\1/")"
        ;;
      debugging)
        DEBUG=yes
        ;;
      bootchart)
        BOOTCHART=yes
        ;;
      ssh)
        SSH=yes
        ;;
      progress)
        PROGRESS=yes
        ;;
      fastboot)
        FASTBOOT=yes
        ;;
      nosplash)
        SPLASH=no
        ;;
      noram)
        SYSTEM_TORAM=no
        ;;
      iotimeout=*)
        IO_TIMEOUT="${arg#*=}"
        ;;
      overlay)
        OVERLAY=yes
        ;;
      break=*)
        BREAK="${arg#*=}"
        ;;
    esac
  done

  [ "$FASTBOOT" = "yes" ] && IONICE="/bin/busybox ionice -c 1 -n 0" || IONICE=""

  [ "$DEBUG" = "yes" ] && exec 3>&1 || exec 3>/dev/null

  SILENT_OUT=3

  progress() {
    [ "$PROGRESS" = "yes" ] && echo "### $1 ###"
  }

  debug_shell() {
    echo "### Starting debugging shell... type  exit  to quit ###"

    # show cursor
    echo 0 > /sys/devices/virtual/graphics/fbcon/cursor_blink

    /bin/busybox sh </dev/tty1 >/dev/tty1 2>&1
  }

  error() {
  # Display fatal error message
  # $1:action which caused error, $2:message
    echo "*** Error in $BOOT_STEP: $1: $2 ***"
    if [ -z "$DEBUG" ]; then
      /bin/busybox halt
    else
      debug_shell
    fi
  }

  break_after() {
  # Start debug shell after boot step $1
    case $BREAK in
      all|*$1*)
        debug_shell
        ;;
    esac
  }

  countdown() {
    MESSAGE="$1"
    COUNT=${2:-10}
    while [ $COUNT -ge 0 ]; do
      [ $COUNT -eq 1 ] && S="" || S="s"
      echo -ne "${MESSAGE} \033[1;36m$COUNT second${S}\033[m\017...    \r"
      COUNT=$((${COUNT}-1))
      /bin/busybox usleep 1000000
    done
    echo
  }

  # Mount handlers
  # All handlers take the following parameters:
  # $1:target, $2:mountpoint, $3:mount options, [$4:fs type]

  mount_common() {
  # Common mount handler, handles block devices and filesystem images
    MOUNT_OPTIONS="-o $3"
    [ -n "$4" ] && MOUNT_OPTIONS="-t $4 $MOUNT_OPTIONS"

    for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15; do
      ERR_ENV=1

      $IONICE /bin/busybox mount $MOUNT_OPTIONS $1 $2 >&$SILENT_OUT 2>&1
      [ "$?" -eq "0" ] && ERR_ENV=0 && break

      /bin/busybox usleep 1000000
    done
    [ "$ERR_ENV" -ne "0" ] && error "mount_common" "Could not mount $1"
  }

  mount_cifs() {
  # Mount CIFS (Samba) share
    CIFS_SHARE="${1%%,*}"
    CIFS_OPTIONS="${1#*,}"
    [ "$CIFS_OPTIONS" = "$1" ] && CIFS_OPTIONS=

    mount_common "$CIFS_SHARE" "$2" "$3,$CIFS_OPTIONS" "cifs"
  }

  get_iscsistart_options() {
  # Convert kernel commandline ISCSI= options to iscsistart options
    IFS_SAVE="$IFS"
    IFS=,

    for arg in $1; do
      val="${arg#*=}"
      case "$arg" in
        iscsi_initiator=*)
          option="-i"
          ;;
        iscsi_target_name=*)
          option="-t"
          ;;
        iscsi_target_ip=*)
          option="-a"
          ;;
        iscsi_target_port=*)
          option="-p"
          ;;
        iscsi_target_group=*)
          option="-g"
          ;;
        iscsi_username=*)
          option="-u"
          ;;
        iscsi_password=*)
          option="-w"
          ;;
        iscsi_in_username=*)
          option="-U"
          ;;
        iscsi_in_password=*)
          option="-W"
          ;;
      esac
      echo "$option $val"
    done

    IFS="$IFS_SAVE"
  }

  mount_iscsi() {
  # Mount iSCSI target
    ISCSI_DEV="${1##*,}"
    ISCSI_OPTIONS="${1%,*}"

    if [ ! -f "/sbin/iscsistart" ]; then
      error "iscsistart" "iSCSI support not available"
    fi

    if [ "$ISCSI_OPTIONS" = "auto" ]; then
      progress "Network configuration based on iBFT"
      /sbin/iscsistart -N >&$SILENT_OUT 2>&1 || \
        error "iscsistart" "Unable to configure network"
      progress "iSCSI auto connect based on iBFT"
      /sbin/iscsistart -b >&$SILENT_OUT 2>&1 || \
        error "iscsistart" "Unable to auto connect"
    else
      /sbin/iscsistart $(get_iscsistart_options "$ISCSI_OPTIONS") >&$SILENT_OUT 2>&1 || \
        error "iscsistart" "Unable to connect to ISCSI target"
    fi

    mount_common "$ISCSI_DEV" "$2" "$3" "$4"
  }

  mount_nbd() {
  # Mount NBD device
    NBD_SERVER="${1%%:*}"
    NBD_PORT="${1#*:}"
    NBD_DEV="/dev/nbd$NBD_DEVS"

    $IONICE /bin/busybox nbd-client $NBD_SERVER $NBD_PORT $NBD_DEV >&$SILENT_OUT 2>&1 || \
      error "nbd-client" "Could not connect to NBD server $1"

    mount_common "$NBD_DEV" "$2" "$3" "$4"

    NBD_DEVS=$(( ${NBD_DEVS} + 1 ))
  }

  mount_nfs() {
  # Mount NFS export
    NFS_EXPORT="${1%%,*}"
    NFS_OPTIONS="${1#*,}"

    [ "$NFS_OPTIONS" = "$1" ] && NFS_OPTIONS=

    mount_common "$NFS_EXPORT" "$2" "$3,nolock,retrans=10,$NFS_OPTIONS" "nfs"
  }

  mount_part() {
  # Mount a local or network filesystem
  # $1:[TYPE=]target, $2:mountpoint, $3:mount options, [$4:fs type]
    progress "mount filesystem $1 ..."

    MOUNT_TARGET="${1#*=}"
    case $1 in
      LABEL=*|UUID=*|/*)
        MOUNT_CMD="mount_common"
        MOUNT_TARGET="$1"
        ;;
      CIFS=*|SMB=*)
        MOUNT_CMD="mount_cifs"
        ;;
      ISCSI=*)
        MOUNT_CMD="mount_iscsi"
        ;;
      NBD=*)
        MOUNT_CMD="mount_nbd"
        ;;
      NFS=*)
        MOUNT_CMD="mount_nfs"
        ;;
      *)
        error "mount_part" "Unknown filesystem $1"
        ;;
    esac
    $MOUNT_CMD "$MOUNT_TARGET" "$2" "$3" "$4"
  }

  mount_remount() {
  # Remount mount point ($1) with new rw/ro mode ($2) only when required.
    NEW_MODE="$2"
    if [ -z "$(/bin/busybox grep " $1 " /proc/mounts | /bin/busybox awk -v MODE="$NEW_MODE" '$4~"(^|,)"MODE"($|,)"')" ]; then
       /bin/busybox sync
       $IONICE /bin/busybox mount -o remount,$NEW_MODE /$1
    fi
  }

  update() {
    if [ -f "$UPDATE_DIR/$2" -a -f "$3/$4" ]; then
      [ "$3" = "/flash" ] && TARGET=$BOOT_TYPE || TARGET="local"
      echo "Updating $1 on $TARGET..."
      mount_remount "$3" "rw"
      $IONICE /bin/busybox mv $UPDATE_DIR/$2 $3/$4
      $IONICE /bin/busybox sync
      mount_remount "$3" "ro"
    fi
  }

  update_bootloader() {
    if [ -f "/flash/$IMAGE_SYSTEM" ]; then
    # /flash is normally filesystem with system image file
      export BOOT_ROOT="$1"
      export SYSTEM_ROOT="/sysroot"

      mount_part "/flash/$IMAGE_SYSTEM" "/sysroot" "ro,loop"

      if [ -f $SYSTEM_ROOT/usr/share/bootloader/update.sh ]; then
        [ "$1" = "/flash" ] && TARGET=$BOOT_TYPE || TARGET="local"
        echo "Updating Bootloader on $TARGET..."
        $IONICE /bin/busybox sh $SYSTEM_ROOT/usr/share/bootloader/update.sh
        $IONICE /bin/busybox sync
      fi

      /bin/busybox umount /sysroot
    fi
  }

  hfsdiskprep() {
    for DEVICE in /dev/sd*; do
      for device in $(/bin/busybox blkid $DEVICE); do
        case $device in
          TYPE=*)
            FS_TYPE=${device#TYPE=}
            ;;
        esac
      done

      if [ "$FS_TYPE" = "\"hfs\"" -o "$FS_TYPE" = "\"hfsplus\"" ]; then
        progress "check filesystem $DEVICE [$FS_TYPE]..."
        /bin/fsck_hfs -r -y $DEVICE >&$SILENT_OUT 2>&1
      fi
    done
  }

  load_modules() {
    progress "Loading kernel modules"

    [ ! -f "/etc/modules" ] && return
    for module in $(/bin/busybox cat /etc/modules); do
      progress "Loading kernel module $module"
      /bin/busybox insmod "$MODULE_DIR/$module.ko" || \
        progress "... Failed to load kernel module $module, skipping"
    done
  }

  load_splash() {
    progress "Loading bootsplash"

    if [ -e /dev/fb0 -a ! "$SPLASH" = "no" ]; then

      # set framebuffer to a default resolution (1024x768-32)
        if [ ! "$SWITCH_FRAMEBUFFER" = "no" ]; then
          fbset -g 1024 768 1024 768 32
        fi

      # load splash
        if [ -f /flash/oemsplash.png ]; then
          SPLASHIMAGE="/flash/oemsplash.png"
        elif [ -f /splash/splash.conf ]; then
          . /splash/splash.conf
        else
          SPLASHIMAGE="/splash/splash.png"
        fi

        ply-image $SPLASHIMAGE > /dev/null 2>&1
    fi
  }

  check_disks() {
    progress "Checking disks"

    if [ -x /bin/fsck_hfs ]; then
    # deal with hfs partitions
      hfsdiskprep
    fi
  }

  mount_flash() {
    progress "Mounting flash"

    mount_part "$boot" "/flash" "ro,noatime"
  }

  media_check() {
    if [ "$IO_TIMEOUT" -gt "0" ]; then
      progress "Media integrity check"

      [ "$IS_RPI" = "Y" ] && media_check_rpi
    fi
  }

#
# Determine how long it takes to write libc.so.6 (~1.2MB) to the
# Raspberry Pi SD memory card. This IO operation should complete in
# under 5 seconds - any longer and the SD card is likely to end
# up with corrupted boot files and/or secondary partition.
#
# To avoid this corruption, system will reboot and check again.
#
# Enable media_check by setting iotimeout > 0, eg. 5000.
#
  media_check_rpi() {

    # Show the following message which will appear momentarily when there
    # is no problem, but remain visible for entire duration of slow I/O
    # operation when there is a performance issue.
    echo "Media check - please wait..."

    # any decent sized (>512KB) file will do
    SOURCE="/lib/libc.so.6"

    # Get current time in miliseconds (discard remaining digits)
    IO_START=$(/bin/busybox grep "now at [0-9]* nsecs" /proc/timer_list | /bin/busybox sed -e "s/now at \(.*\)[0-9][0-9][0-9][0-9][0-9][0-9] nsecs/\1/")

    if [ "$BOOT_TYPE" = "local" ] ; then
      mount_remount "/flash" "rw"
      /bin/busybox cp "$SOURCE" "/flash/.openelec" 2>/dev/null
      CP_RES=$?
      /bin/busybox sync
      [ -f "/flash/.openelec" ] && ( /bin/busybox rm "/flash/.openelec" && /bin/busybox sync )
      mount_remount "/flash" "ro"
     else
      /bin/busybox mkdir /bootroot && mount_part "/dev/mmcblk0p1" "/bootroot" "rw,noatime"
      /bin/busybox cp "$SOURCE" "/bootroot/.openelec" 2>/dev/null
      CP_RES=$?
      /bin/busybox sync
      [ -f "/bootroot/.openelec" ] && ( /bin/busybox rm "/bootroot/.openelec" && /bin/busybox sync )
      /bin/busybox umount /bootroot && /bin/busybox rm -fr /bootroot
    fi

    IO_END=$(/bin/busybox grep "now at [0-9]* nsecs" /proc/timer_list | /bin/busybox sed -e "s/now at \(.*\)[0-9][0-9][0-9][0-9][0-9][0-9] nsecs/\1/")
    IO_TIME=$((${IO_END}-${IO_START}))

    progress "media_check: i/o time [$IO_TIME], timeout [$IO_TIMEOUT]"

    if [ $IO_TIME -gt $IO_TIMEOUT -o $CP_RES -ne 0 ]; then
      if [ $CP_RES -eq 0 ]; then
        echo "media_check: Write I/O interval ${IO_TIME}ms has exceeded iotimeout ${IO_TIMEOUT}ms"
      else
        echo "media_check: Write I/O failed, most likely due to mount point failure"
      fi
      echo "media_check: SD Card performance is low."
      countdown "media_check: Rebooting to improve performance in" 10
      /bin/busybox reboot
    fi

    # Use ESC M (reverse linefeed) to remove previous "Please wait"
    # message, leaving cursor on same line (top line of screen) ready
    # for version/build number.
    [ "$PROGRESS" != "yes" ] && echo -ne "\033M                            \r"
  }

  mount_storage() {
    progress "Mounting storage"

    if [ -n "$disk" ]; then
      if [ -n "$OVERLAY" ]; then
        OVERLAY_DIR="$(/bin/busybox cat /sys/class/net/eth0/address | /bin/busybox tr -d :)"

        mount_part "$disk" "/storage" "rw,noatime"
        /bin/busybox mkdir -p /storage/$OVERLAY_DIR
        /bin/busybox umount /storage

      # split $disk into $target,$options so we can append $OVERLAY_DIR
        options="${disk#*,}"
        target="${disk%%,*}"
        if [ "$options" = "$disk" ]; then
          disk="$target/$OVERLAY_DIR"
        else
          disk="$target/$OVERLAY_DIR,$options"
        fi
      fi

      mount_part "$disk" "/storage" "rw,noatime"
    fi
  }

  check_update() {
    progress "Checking for updates"

#    if [ -f "/flash/MACH_KERNEL" ]; then
#      IMAGE_KERNEL="MACH_KERNEL"
#    fi

    DO_REBOOT="0"
    MD5_NOCHECK="0"
    MD5_FAILED="0"

    if [ -f "$UPDATE_DIR/$UPDATE_KERNEL" -a -f "$UPDATE_DIR/$UPDATE_SYSTEM" ] ; then
      if [ -f "$UPDATE_DIR/.nocheck" ] ; then
        MD5_NOCHECK="1"
      fi

      # check md5 sums if .nocheck doesn't exist
      if [ "$MD5_NOCHECK" -eq "0" -a -f "$UPDATE_DIR/${UPDATE_KERNEL}.md5" -a -f "$UPDATE_DIR/${UPDATE_SYSTEM}.md5" ] ; then
        /bin/busybox sed  -i 's#target#/storage/.update#g' "$UPDATE_DIR/${UPDATE_KERNEL}.md5"
        /bin/busybox sed  -i 's#target#/storage/.update#g' "$UPDATE_DIR/${UPDATE_SYSTEM}.md5"

        echo "Checking ${UPDATE_KERNEL}.md5..."
        /bin/busybox md5sum -c "$UPDATE_DIR/${UPDATE_KERNEL}.md5" || MD5_FAILED="1"

        echo "Checking ${UPDATE_SYSTEM}.md5..."
        /bin/busybox md5sum -c "$UPDATE_DIR/${UPDATE_SYSTEM}.md5" || MD5_FAILED="1"
      else
        echo "missing ${UPDATE_KERNEL}.md5 or ${UPDATE_SYSTEM}.md5..."
        MD5_FAILED="1"
      fi

      # update if md5 check is ok or .nocheck exists
      if [ "$MD5_FAILED" -eq "0" -o "$MD5_NOCHECK" -eq "1" ] ; then
        if [ "$BOOT_TYPE" = "local" ] ; then
          update "Kernel" "$UPDATE_KERNEL" "/flash" "$IMAGE_KERNEL"
          update "System" "$UPDATE_SYSTEM" "/flash" "$IMAGE_SYSTEM"
          update_bootloader "/flash"
        else
          # Booted from remote fs, need mountpoint for boot media
          # in order to update kernel and any associated boot files
          /bin/busybox mkdir /bootroot

          #TODO: Where does PXE mount device with kernel?
          # Need sane alternative solution for non-RPi devices in order to update kernel.img
          [ "${IS_RPI}" = "Y" ] && mount_part "/dev/mmcblk0p1" "/bootroot" "rw,noatime"

          update "Kernel" "$UPDATE_KERNEL" "/bootroot" "$IMAGE_KERNEL"
          update "System" "$UPDATE_SYSTEM" "/flash" "$IMAGE_SYSTEM"
          update_bootloader "/bootroot"

          /bin/busybox umount /bootroot && /bin/busybox rm -fr /bootroot
        fi
        DO_REBOOT="1"
      else
        /bin/busybox rm "$UPDATE_DIR/$UPDATE_KERNEL"
        /bin/busybox rm "$UPDATE_DIR/$UPDATE_SYSTEM"
        /bin/busybox sync
        countdown "md5 check failed. normal startup in" 30
      fi
      /bin/busybox rm "$UPDATE_DIR/${UPDATE_KERNEL}.md5" &>/dev/null
      /bin/busybox rm "$UPDATE_DIR/${UPDATE_SYSTEM}.md5" &>/dev/null
    fi

    if [ "$DO_REBOOT" -eq "1" ]; then
      countdown "System rebooting in" 5
      /bin/busybox reboot
    fi
  }

  prepare_sysroot() {
    progress "Preparing system"

    if [ -f "/flash/$IMAGE_SYSTEM" ]; then
    # /flash is filesystem with system image file
      if [ "$SYSTEM_TORAM" = "no" -o "$INSTALLED_MEMORY" -lt "$SYSTEM_TORAM_LIMIT" ]; then
        mount_part "/flash/$IMAGE_SYSTEM" "/sysroot" "ro,loop"
      else
        progress "Loading System to RAM"
        /bin/busybox cp /flash/$IMAGE_SYSTEM /dev/$IMAGE_SYSTEM
        mount_part "/dev/$IMAGE_SYSTEM" "/sysroot" "ro,loop"
      fi

      /bin/busybox mount --move /flash /sysroot/flash
    else
    # /flash is actual root filesystem
      /bin/busybox mount --move /flash /sysroot
    fi

    if [ -n "$disk" ]; then
      /bin/busybox mount --move /storage /sysroot/storage
    fi

    [ -f "/sysroot/sbin/init" ] || error "final_check" "Could not find system."
  }

# main boot sequence
  for BOOT_STEP in \
      load_modules \
      check_disks \
      mount_flash \
      load_splash \
      media_check \
      mount_storage \
      check_update \
      prepare_sysroot; do
    $BOOT_STEP
    [ -n "$DEBUG" ] && break_after $BOOT_STEP
  done

  BOOT_STEP=final

# move some special filesystems
  /bin/busybox mount --move /dev /sysroot/dev
  /bin/busybox mount --move /proc /sysroot/proc
  /bin/busybox mount --move /sys /sysroot/sys

# switch to new sysroot and start real init
  exec /bin/busybox switch_root /sysroot /sbin/init

  error "switch_root" "Error in initramfs. Could not switch to new root"
