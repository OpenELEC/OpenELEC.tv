diff -Naurd mpfr-3.1.0-a/PATCHES mpfr-3.1.0-b/PATCHES
--- mpfr-3.1.0-a/PATCHES	2011-10-05 21:39:57.000000000 +0000
+++ mpfr-3.1.0-b/PATCHES	2011-10-05 21:39:57.000000000 +0000
@@ -0,0 +1 @@
+mpfr_unlikely
diff -Naurd mpfr-3.1.0-a/VERSION mpfr-3.1.0-b/VERSION
--- mpfr-3.1.0-a/VERSION	2011-10-03 08:17:15.000000000 +0000
+++ mpfr-3.1.0-b/VERSION	2011-10-05 21:39:57.000000000 +0000
@@ -1 +1 @@
-3.1.0
+3.1.0-p1
diff -Naurd mpfr-3.1.0-a/src/mpfr-impl.h mpfr-3.1.0-b/src/mpfr-impl.h
--- mpfr-3.1.0-a/src/mpfr-impl.h	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/mpfr-impl.h	2011-10-05 21:39:57.000000000 +0000
@@ -988,10 +988,11 @@
  ******************************************************/
 
 /* Theses macros help the compiler to determine if a test is
- * likely or unlikely. */
+   likely or unlikely. The !! is necessary in case x is larger
+   than a long. */
 #if __MPFR_GNUC(3,0) || __MPFR_ICC(8,1,0)
 # define MPFR_LIKELY(x) (__builtin_expect(!!(x),1))
-# define MPFR_UNLIKELY(x) (__builtin_expect((x),0))
+# define MPFR_UNLIKELY(x) (__builtin_expect(!!(x),0))
 #else
 # define MPFR_LIKELY(x) (x)
 # define MPFR_UNLIKELY(x) (x)
diff -Naurd mpfr-3.1.0-a/src/mpfr.h mpfr-3.1.0-b/src/mpfr.h
--- mpfr-3.1.0-a/src/mpfr.h	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/mpfr.h	2011-10-05 21:39:57.000000000 +0000
@@ -27,7 +27,7 @@
 #define MPFR_VERSION_MAJOR 3
 #define MPFR_VERSION_MINOR 1
 #define MPFR_VERSION_PATCHLEVEL 0
-#define MPFR_VERSION_STRING "3.1.0"
+#define MPFR_VERSION_STRING "3.1.0-p1"
 
 /* Macros dealing with MPFR VERSION */
 #define MPFR_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))
diff -Naurd mpfr-3.1.0-a/src/version.c mpfr-3.1.0-b/src/version.c
--- mpfr-3.1.0-a/src/version.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/version.c	2011-10-05 21:39:57.000000000 +0000
@@ -25,5 +25,5 @@
 const char *
 mpfr_get_version (void)
 {
-  return "3.1.0";
+  return "3.1.0-p1";
 }
diff -Naurd mpfr-3.1.0-a/PATCHES mpfr-3.1.0-b/PATCHES
--- mpfr-3.1.0-a/PATCHES	2011-10-14 10:43:32.000000000 +0000
+++ mpfr-3.1.0-b/PATCHES	2011-10-14 10:43:32.000000000 +0000
@@ -0,0 +1 @@
+lib-search-path
diff -Naurd mpfr-3.1.0-a/VERSION mpfr-3.1.0-b/VERSION
--- mpfr-3.1.0-a/VERSION	2011-10-05 21:39:57.000000000 +0000
+++ mpfr-3.1.0-b/VERSION	2011-10-14 10:43:32.000000000 +0000
@@ -1 +1 @@
-3.1.0-p1
+3.1.0-p2
diff -Naurd mpfr-3.1.0-a/src/mpfr.h mpfr-3.1.0-b/src/mpfr.h
--- mpfr-3.1.0-a/src/mpfr.h	2011-10-05 21:39:57.000000000 +0000
+++ mpfr-3.1.0-b/src/mpfr.h	2011-10-14 10:43:32.000000000 +0000
@@ -27,7 +27,7 @@
 #define MPFR_VERSION_MAJOR 3
 #define MPFR_VERSION_MINOR 1
 #define MPFR_VERSION_PATCHLEVEL 0
-#define MPFR_VERSION_STRING "3.1.0-p1"
+#define MPFR_VERSION_STRING "3.1.0-p2"
 
 /* Macros dealing with MPFR VERSION */
 #define MPFR_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))
diff -Naurd mpfr-3.1.0-a/src/version.c mpfr-3.1.0-b/src/version.c
--- mpfr-3.1.0-a/src/version.c	2011-10-05 21:39:57.000000000 +0000
+++ mpfr-3.1.0-b/src/version.c	2011-10-14 10:43:32.000000000 +0000
@@ -25,5 +25,5 @@
 const char *
 mpfr_get_version (void)
 {
-  return "3.1.0-p1";
+  return "3.1.0-p2";
 }
diff -Naurd mpfr-3.1.0-a/tests/Makefile.am mpfr-3.1.0-b/tests/Makefile.am
--- mpfr-3.1.0-a/tests/Makefile.am	2011-10-03 08:17:14.000000000 +0000
+++ mpfr-3.1.0-b/tests/Makefile.am	2011-10-03 08:17:14.000000000 +0000
@@ -65,8 +65,24 @@
 TESTS = $(check_PROGRAMS)
 TESTS_ENVIRONMENT = MPFR_QUIET=1 $(VALGRIND)
 
-# Option to prevent libtool from generating wrapper scripts for the tests.
+# The -no-install option prevents libtool from generating wrapper scripts
+# for the tests.
 # This is useful to easily run the test scripts under valgrind or gdb.
 # See discussion http://thread.gmane.org/gmane.comp.lib.gnulib.bugs/28033
 # http://article.gmane.org/gmane.comp.lib.gnulib.bugs/28140 in particular.
-AM_LDFLAGS = -no-install
+#
+# The -L$(top_builddir)/src/.libs option is necessary for some platforms,
+# such as HP-UX, when --with-gmp or --with-gmp-lib is used and an old MPFR
+# library is already installed in the corresponding lib directory: its
+# purpose is to make sure that the local .libs comes first in the library
+# search path (otherwise the tests are linked against the old MPFR library
+# by the LINK command -- see the generated Makefile). See:
+#   http://websympa.loria.fr/wwsympa/arc/mpfr/2011-10/msg00042.html
+#   http://websympa.loria.fr/wwsympa/arc/mpfr/2011-10/msg00043.html
+#   http://websympa.loria.fr/wwsympa/arc/mpfr/2011-10/msg00044.html
+#   http://websympa.loria.fr/wwsympa/arc/mpfr/2011-10/msg00066.html
+#   http://websympa.loria.fr/wwsympa/arc/mpfr/2011-10/msg00065.html
+# and
+#   http://debbugs.gnu.org/cgi/bugreport.cgi?bug=9728
+#
+AM_LDFLAGS = -no-install -L$(top_builddir)/src/.libs
diff -Naurd mpfr-3.1.0-a/tests/Makefile.in mpfr-3.1.0-b/tests/Makefile.in
--- mpfr-3.1.0-a/tests/Makefile.in	2011-10-03 08:17:35.000000000 +0000
+++ mpfr-3.1.0-b/tests/Makefile.in	2011-10-03 08:17:35.000000000 +0000
@@ -1124,11 +1124,27 @@
 TESTS = $(check_PROGRAMS)
 TESTS_ENVIRONMENT = MPFR_QUIET=1 $(VALGRIND)
 
-# Option to prevent libtool from generating wrapper scripts for the tests.
+# The -no-install option prevents libtool from generating wrapper scripts
+# for the tests.
 # This is useful to easily run the test scripts under valgrind or gdb.
 # See discussion http://thread.gmane.org/gmane.comp.lib.gnulib.bugs/28033
 # http://article.gmane.org/gmane.comp.lib.gnulib.bugs/28140 in particular.
-AM_LDFLAGS = -no-install
+#
+# The -L$(top_builddir)/src/.libs option is necessary for some platforms,
+# such as HP-UX, when --with-gmp or --with-gmp-lib is used and an old MPFR
+# library is already installed in the corresponding lib directory: its
+# purpose is to make sure that the local .libs comes first in the library
+# search path (otherwise the tests are linked against the old MPFR library
+# by the LINK command -- see the generated Makefile). See:
+#   http://websympa.loria.fr/wwsympa/arc/mpfr/2011-10/msg00042.html
+#   http://websympa.loria.fr/wwsympa/arc/mpfr/2011-10/msg00043.html
+#   http://websympa.loria.fr/wwsympa/arc/mpfr/2011-10/msg00044.html
+#   http://websympa.loria.fr/wwsympa/arc/mpfr/2011-10/msg00066.html
+#   http://websympa.loria.fr/wwsympa/arc/mpfr/2011-10/msg00065.html
+# and
+#   http://debbugs.gnu.org/cgi/bugreport.cgi?bug=9728
+#
+AM_LDFLAGS = -no-install -L$(top_builddir)/src/.libs
 all: all-am
 
 .SUFFIXES:
diff -Naurd mpfr-3.1.0-a/PATCHES mpfr-3.1.0-b/PATCHES
--- mpfr-3.1.0-a/PATCHES	2011-11-03 15:15:11.000000000 +0000
+++ mpfr-3.1.0-b/PATCHES	2011-11-03 15:15:11.000000000 +0000
@@ -0,0 +1 @@
+vasprintf
diff -Naurd mpfr-3.1.0-a/VERSION mpfr-3.1.0-b/VERSION
--- mpfr-3.1.0-a/VERSION	2011-10-14 10:43:32.000000000 +0000
+++ mpfr-3.1.0-b/VERSION	2011-11-03 15:15:11.000000000 +0000
@@ -1 +1 @@
-3.1.0-p2
+3.1.0-p3
diff -Naurd mpfr-3.1.0-a/src/mpfr.h mpfr-3.1.0-b/src/mpfr.h
--- mpfr-3.1.0-a/src/mpfr.h	2011-10-14 10:43:32.000000000 +0000
+++ mpfr-3.1.0-b/src/mpfr.h	2011-11-03 15:15:11.000000000 +0000
@@ -27,7 +27,7 @@
 #define MPFR_VERSION_MAJOR 3
 #define MPFR_VERSION_MINOR 1
 #define MPFR_VERSION_PATCHLEVEL 0
-#define MPFR_VERSION_STRING "3.1.0-p2"
+#define MPFR_VERSION_STRING "3.1.0-p3"
 
 /* Macros dealing with MPFR VERSION */
 #define MPFR_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))
diff -Naurd mpfr-3.1.0-a/src/vasprintf.c mpfr-3.1.0-b/src/vasprintf.c
--- mpfr-3.1.0-a/src/vasprintf.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/vasprintf.c	2011-11-03 15:15:11.000000000 +0000
@@ -1178,7 +1178,7 @@
   mpfr_exp_t exp;
   char * str;
   const int spec_g = (spec.spec == 'g' || spec.spec == 'G');
-  const int keep_trailing_zeros = spec_g && spec.alt;
+  const int keep_trailing_zeros = !spec_g || spec.alt;
 
   /* WARNING: an empty precision field is forbidden (it means precision = 6
      and it should have been changed to 6 before the function call) */
@@ -1356,7 +1356,7 @@
   else
     /* 1 <= |p| */
     {
-      size_t nsd;  /* Number of significant digits */
+      size_t str_len;
 
       /* Determine the position of the most significant decimal digit. */
       exp = floor_log10 (p);
@@ -1365,12 +1365,10 @@
         /* P is too large to print all its integral part digits */
         return -1;
 
-      np->ip_size = exp + 1;
-
-      nsd = spec.prec + np->ip_size;
       if (dec_info == NULL)
-        {
-          str = mpfr_get_str (NULL, &exp, 10, nsd, p, spec.rnd_mode);
+        { /* this case occurs with mpfr_printf ("%.0RUf", x) with x=9.5 */
+          str =
+            mpfr_get_str (NULL, &exp, 10, spec.prec+exp+1, p, spec.rnd_mode);
           register_string (np->sl, str);
         }
       else
@@ -1379,81 +1377,60 @@
           str = dec_info->str;
         }
       np->ip_ptr = MPFR_IS_NEG (p) ? ++str : str; /* skip sign */
+      str_len = strlen (str);
+
+      /* integral part */
+      if (exp > str_len)
+        /* mpfr_get_str gives no trailing zero when p is rounded up to the next
+           power of 10 (p integer, so no fractional part) */
+        {
+          np->ip_trailing_zeros = exp - str_len;
+          np->ip_size = str_len;
+        }
+      else
+        np->ip_size = exp;
 
       if (spec.group)
         /* thousands separator in integral part */
         np->thousands_sep = MPFR_THOUSANDS_SEPARATOR;
 
-      if (nsd == 0 || (spec_g && !spec.alt))
-        /* compute how much non-zero digits in integral and fractional
-           parts */
+      /* fractional part */
+      str += np->ip_size;
+      str_len -= np->ip_size;
+      if (!keep_trailing_zeros)
+        /* remove trailing zeros, if any */
         {
-          size_t str_len;
-          str_len = strlen (str); /* note: the sign has been skipped */
-
-          if (exp > str_len)
-            /* mpfr_get_str doesn't give the trailing zeros when p is a
-               multiple of 10 (p integer, so no fractional part) */
-            {
-              np->ip_trailing_zeros = exp - str_len;
-              np->ip_size = str_len;
-              if (spec.alt)
-                np->point = MPFR_DECIMAL_POINT;
-            }
-          else
-            /* str may contain some digits which are in fractional part */
+          char *ptr = str + str_len - 1; /* pointer to the last digit of
+                                            str */
+          while ((*ptr == '0') && (str_len != 0))
             {
-              char *ptr;
-
-              ptr = str + str_len - 1; /* points to the end of str */
-              str_len -= np->ip_size;  /* number of digits in fractional
-                                          part */
-
-              if (!keep_trailing_zeros)
-                /* remove trailing zeros, if any */
-                {
-                  while ((*ptr == '0') && (str_len != 0))
-                    {
-                      --ptr;
-                      --str_len;
-                    }
-                }
-
-              if (str_len > INT_MAX)
-                /* too many digits in fractional part */
-                return -1;
-
-              if (str_len != 0)
-                /* some digits in fractional part */
-                {
-                  np->point = MPFR_DECIMAL_POINT;
-                  np->fp_ptr = str + np->ip_size;
-                  np->fp_size = str_len;
-                }
+              --ptr;
+              --str_len;
             }
         }
-      else
-        /* spec.prec digits in fractional part */
+
+      if (str_len > 0)
+        /* some nonzero digits in fractional part */
         {
-          if (np->ip_size == exp - 1)
-            /* the absolute value of the number has been rounded up to a power
-               of ten.
-               Insert an additional zero in integral part and put the rest of
-               them in fractional part. */
-            np->ip_trailing_zeros = 1;
+          if (str_len > INT_MAX)
+            /* too many digits in fractional part */
+            return -1;
 
-          if (spec.prec != 0)
-            {
-              MPFR_ASSERTD (np->ip_size + np->ip_trailing_zeros == exp);
-              MPFR_ASSERTD (np->ip_size + spec.prec == nsd);
+          np->point = MPFR_DECIMAL_POINT;
+          np->fp_ptr = str;
+          np->fp_size = str_len;
+        }
 
-              np->point = MPFR_DECIMAL_POINT;
-              np->fp_ptr = str + np->ip_size;
-              np->fp_size = spec.prec;
-            }
-          else if (spec.alt)
-            np->point = MPFR_DECIMAL_POINT;
+      if (keep_trailing_zeros && str_len < spec.prec)
+        /* add missing trailing zeros */
+        {
+          np->point = MPFR_DECIMAL_POINT;
+          np->fp_trailing_zeros = spec.prec - np->fp_size;
         }
+
+      if (spec.alt)
+        /* add decimal point even if no digits follow it */
+        np->point = MPFR_DECIMAL_POINT;
     }
 
   return 0;
diff -Naurd mpfr-3.1.0-a/src/version.c mpfr-3.1.0-b/src/version.c
--- mpfr-3.1.0-a/src/version.c	2011-10-14 10:43:32.000000000 +0000
+++ mpfr-3.1.0-b/src/version.c	2011-11-03 15:15:11.000000000 +0000
@@ -25,5 +25,5 @@
 const char *
 mpfr_get_version (void)
 {
-  return "3.1.0-p2";
+  return "3.1.0-p3";
 }
diff -Naurd mpfr-3.1.0-a/tests/tsprintf.c mpfr-3.1.0-b/tests/tsprintf.c
--- mpfr-3.1.0-a/tests/tsprintf.c	2011-10-03 08:17:14.000000000 +0000
+++ mpfr-3.1.0-b/tests/tsprintf.c	2011-11-03 15:15:11.000000000 +0000
@@ -475,6 +475,18 @@
   check_sprintf ("-1.", "%- #0.1RG", x);
 
   /* precision zero */
+  mpfr_set_d (x, 9.5, MPFR_RNDN);
+  check_sprintf ("9",    "%.0RDf", x);
+  check_sprintf ("10",    "%.0RUf", x);
+
+  mpfr_set_d (x, 19.5, MPFR_RNDN);
+  check_sprintf ("19",    "%.0RDf", x);
+  check_sprintf ("20",    "%.0RUf", x);
+
+  mpfr_set_d (x, 99.5, MPFR_RNDN);
+  check_sprintf ("99",    "%.0RDf", x);
+  check_sprintf ("100",   "%.0RUf", x);
+
   mpfr_set_d (x, -9.5, MPFR_RNDN);
   check_sprintf ("-10",    "%.0RDf", x);
   check_sprintf ("-10",    "%.0RYf", x);
@@ -1078,6 +1090,23 @@
   mpfr_clear (x);
 }
 
+static void
+bug20111102 (void)
+{
+  mpfr_t t;
+  char s[100];
+
+  mpfr_init2 (t, 84);
+  mpfr_set_str (t, "999.99999999999999999999", 10, MPFR_RNDN);
+  mpfr_sprintf (s, "%.20RNg", t);
+  if (strcmp (s, "1000") != 0)
+    {
+      printf ("Error in bug20111102, expected 1000, got %s\n", s);
+      exit (1);
+    }
+  mpfr_clear (t);
+}
+
 /* In particular, the following test makes sure that the rounding
  * for %Ra and %Rb is not done on the MPFR number itself (as it
  * would overflow). Note: it has been reported on comp.std.c that
@@ -1161,6 +1190,7 @@
   locale = setlocale (LC_ALL, "C");
 #endif
 
+  bug20111102 ();
   native_types ();
   hexadecimal ();
   binary ();
diff -Naurd mpfr-3.1.0-a/PATCHES mpfr-3.1.0-b/PATCHES
--- mpfr-3.1.0-a/PATCHES	2011-11-28 12:22:52.000000000 +0000
+++ mpfr-3.1.0-b/PATCHES	2011-11-28 12:22:52.000000000 +0000
@@ -0,0 +1 @@
+gmp41compat
diff -Naurd mpfr-3.1.0-a/VERSION mpfr-3.1.0-b/VERSION
--- mpfr-3.1.0-a/VERSION	2011-11-03 15:15:11.000000000 +0000
+++ mpfr-3.1.0-b/VERSION	2011-11-28 12:22:52.000000000 +0000
@@ -1 +1 @@
-3.1.0-p3
+3.1.0-p4
diff -Naurd mpfr-3.1.0-a/doc/mpfr.info mpfr-3.1.0-b/doc/mpfr.info
--- mpfr-3.1.0-a/doc/mpfr.info	2011-10-03 09:43:04.000000000 +0000
+++ mpfr-3.1.0-b/doc/mpfr.info	2011-11-28 12:22:52.000000000 +0000
@@ -2994,11 +2994,12 @@
 
    * `mpfr_urandom' and `mpfr_urandomb' changed in MPFR 3.1.  Their
      behavior no longer depends on the platform (assuming this is also
-     true for GMP's random generator).  As a consequence, the returned
-     values can be different between MPFR 3.1 and previous MPFR
-     versions.  Note: as the reproducibility of these functions was not
-     specified before MPFR 3.1, the MPFR 3.1 behavior is _not_ regarded
-     as backward incompatible with previous versions.
+     true for GMP's random generator, which is not the case between GMP
+     4.1 and 4.2 if `gmp_randinit_default' is used).  As a consequence,
+     the returned values can be different between MPFR 3.1 and previous
+     MPFR versions.  Note: as the reproducibility of these functions
+     was not specified before MPFR 3.1, the MPFR 3.1 behavior is _not_
+     regarded as backward incompatible with previous versions.
 
 
 
@@ -4239,13 +4240,13 @@
 Node: Type and Macro Changes129308
 Node: Added Functions132029
 Node: Changed Functions134972
-Node: Removed Functions139167
-Node: Other Changes139579
-Node: Contributors141108
-Node: References143574
-Node: GNU Free Documentation License145315
-Node: Concept Index167758
-Node: Function and Type Index173677
+Node: Removed Functions139253
+Node: Other Changes139665
+Node: Contributors141194
+Node: References143660
+Node: GNU Free Documentation License145401
+Node: Concept Index167844
+Node: Function and Type Index173763
 
 End Tag Table
 
diff -Naurd mpfr-3.1.0-a/doc/mpfr.texi mpfr-3.1.0-b/doc/mpfr.texi
--- mpfr-3.1.0-a/doc/mpfr.texi	2011-10-03 08:17:14.000000000 +0000
+++ mpfr-3.1.0-b/doc/mpfr.texi	2011-11-28 12:22:52.000000000 +0000
@@ -3466,8 +3466,9 @@
 a lack of specification.
 
 @item @code{mpfr_urandom} and @code{mpfr_urandomb} changed in MPFR 3.1.
-Their behavior no longer depends on the platform (assuming this is also
-true for GMP's random generator).  As a consequence, the returned values
+Their behavior no longer depends on the platform (assuming this is also true
+for GMP's random generator, which is not the case between GMP 4.1 and 4.2 if
+@code{gmp_randinit_default} is used).  As a consequence, the returned values
 can be different between MPFR 3.1 and previous MPFR versions.
 Note: as the reproducibility of these functions was not specified
 before MPFR 3.1, the MPFR 3.1 behavior is @emph{not} regarded as
diff -Naurd mpfr-3.1.0-a/src/mpfr.h mpfr-3.1.0-b/src/mpfr.h
--- mpfr-3.1.0-a/src/mpfr.h	2011-11-03 15:15:11.000000000 +0000
+++ mpfr-3.1.0-b/src/mpfr.h	2011-11-28 12:22:52.000000000 +0000
@@ -27,7 +27,7 @@
 #define MPFR_VERSION_MAJOR 3
 #define MPFR_VERSION_MINOR 1
 #define MPFR_VERSION_PATCHLEVEL 0
-#define MPFR_VERSION_STRING "3.1.0-p3"
+#define MPFR_VERSION_STRING "3.1.0-p4"
 
 /* Macros dealing with MPFR VERSION */
 #define MPFR_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))
diff -Naurd mpfr-3.1.0-a/src/version.c mpfr-3.1.0-b/src/version.c
--- mpfr-3.1.0-a/src/version.c	2011-11-03 15:15:11.000000000 +0000
+++ mpfr-3.1.0-b/src/version.c	2011-11-28 12:22:52.000000000 +0000
@@ -25,5 +25,5 @@
 const char *
 mpfr_get_version (void)
 {
-  return "3.1.0-p3";
+  return "3.1.0-p4";
 }
diff -Naurd mpfr-3.1.0-a/tests/trandom.c mpfr-3.1.0-b/tests/trandom.c
--- mpfr-3.1.0-a/tests/trandom.c	2011-10-03 08:17:14.000000000 +0000
+++ mpfr-3.1.0-b/tests/trandom.c	2011-11-28 12:22:52.000000000 +0000
@@ -114,21 +114,29 @@
   mpfr_t x;
   gmp_randstate_t s;
 
+#if __MPFR_GMP(4,2,0)
+# define C1 "0.895943"
+# define C2 "0.848824"
+#else
+# define C1 "0.479652"
+# define C2 "0.648529"
+#endif
+
   gmp_randinit_default (s);
   gmp_randseed_ui (s, 42);
   mpfr_init2 (x, 17);
   mpfr_urandomb (x, s);
-  if (mpfr_cmp_str1 (x, "0.895943") != 0)
+  if (mpfr_cmp_str1 (x, C1) != 0)
     {
-      printf ("Error in bug20100914, expected 0.895943, got ");
+      printf ("Error in bug20100914, expected " C1 ", got ");
       mpfr_out_str (stdout, 10, 0, x, MPFR_RNDN);
       printf ("\n");
       exit (1);
     }
   mpfr_urandomb (x, s);
-  if (mpfr_cmp_str1 (x, "0.848824") != 0)
+  if (mpfr_cmp_str1 (x, C2) != 0)
     {
-      printf ("Error in bug20100914, expected 0.848824, got ");
+      printf ("Error in bug20100914, expected " C2 ", got ");
       mpfr_out_str (stdout, 10, 0, x, MPFR_RNDN);
       printf ("\n");
       exit (1);
diff -Naurd mpfr-3.1.0-a/tests/turandom.c mpfr-3.1.0-b/tests/turandom.c
--- mpfr-3.1.0-a/tests/turandom.c	2011-10-03 08:17:14.000000000 +0000
+++ mpfr-3.1.0-b/tests/turandom.c	2011-11-28 12:22:52.000000000 +0000
@@ -160,23 +160,29 @@
   mpfr_t x;
   gmp_randstate_t s;
 
+#if __MPFR_GMP(4,2,0)
+# define C1 "0.8488312"
+# define C2 "0.8156509"
+#else
+# define C1 "0.6485367"
+# define C2 "0.9362717"
+#endif
+
   gmp_randinit_default (s);
   gmp_randseed_ui (s, 42);
   mpfr_init2 (x, 17);
   mpfr_urandom (x, s, MPFR_RNDN);
-  /* the following values are obtained on a 32-bit computer, we should get
-     the same values on a 64-bit computer */
-  if (mpfr_cmp_str1 (x, "0.8488312") != 0)
+  if (mpfr_cmp_str1 (x, C1) != 0)
     {
-      printf ("Error in bug20100914, expected 0.8488312, got ");
+      printf ("Error in bug20100914, expected " C1 ", got ");
       mpfr_out_str (stdout, 10, 0, x, MPFR_RNDN);
       printf ("\n");
       exit (1);
     }
   mpfr_urandom (x, s, MPFR_RNDN);
-  if (mpfr_cmp_str1 (x, "0.8156509") != 0)
+  if (mpfr_cmp_str1 (x, C2) != 0)
     {
-      printf ("Error in bug20100914, expected 0.8156509, got ");
+      printf ("Error in bug20100914, expected " C2 ", got ");
       mpfr_out_str (stdout, 10, 0, x, MPFR_RNDN);
       printf ("\n");
       exit (1);
diff -Naurd mpfr-3.1.0-a/PATCHES mpfr-3.1.0-b/PATCHES
--- mpfr-3.1.0-a/PATCHES	2012-02-24 12:44:49.000000000 +0000
+++ mpfr-3.1.0-b/PATCHES	2012-02-24 12:44:49.000000000 +0000
@@ -0,0 +1 @@
+logging-freeze
diff -Naurd mpfr-3.1.0-a/VERSION mpfr-3.1.0-b/VERSION
--- mpfr-3.1.0-a/VERSION	2011-11-28 12:22:52.000000000 +0000
+++ mpfr-3.1.0-b/VERSION	2012-02-24 12:44:49.000000000 +0000
@@ -1 +1 @@
-3.1.0-p4
+3.1.0-p5
diff -Naurd mpfr-3.1.0-a/src/add_d.c mpfr-3.1.0-b/src/add_d.c
--- mpfr-3.1.0-a/src/add_d.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/add_d.c	2012-02-24 12:44:49.000000000 +0000
@@ -34,7 +34,7 @@
     (("b[%Pu]=%.*Rg c=%.20g rnd=%d",
       mpfr_get_prec(b), mpfr_log_prec, b, c, rnd_mode),
      ("a[%Pu]=%.*Rg inexact=%d",
-      mpfr_get_prec (a), mpfr_get_prec, a, inexact));
+      mpfr_get_prec (a), mpfr_log_prec, a, inexact));
 
   MPFR_SAVE_EXPO_MARK (expo);
 
diff -Naurd mpfr-3.1.0-a/src/add_ui.c mpfr-3.1.0-b/src/add_ui.c
--- mpfr-3.1.0-a/src/add_ui.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/add_ui.c	2012-02-24 12:44:49.000000000 +0000
@@ -29,7 +29,7 @@
   MPFR_LOG_FUNC
     (("x[%Pu]=%.*Rg u=%d rnd=%d",
       mpfr_get_prec(x), mpfr_log_prec, x, u, rnd_mode),
-     ("y[%Pu]=%.*Rg", mpfr_get_prec (y), mpfr_get_prec, y));
+     ("y[%Pu]=%.*Rg", mpfr_get_prec (y), mpfr_log_prec, y));
 
   if (MPFR_LIKELY(u != 0) )  /* if u=0, do nothing */
     {
diff -Naurd mpfr-3.1.0-a/src/mpfr.h mpfr-3.1.0-b/src/mpfr.h
--- mpfr-3.1.0-a/src/mpfr.h	2011-11-28 12:22:52.000000000 +0000
+++ mpfr-3.1.0-b/src/mpfr.h	2012-02-24 12:44:49.000000000 +0000
@@ -27,7 +27,7 @@
 #define MPFR_VERSION_MAJOR 3
 #define MPFR_VERSION_MINOR 1
 #define MPFR_VERSION_PATCHLEVEL 0
-#define MPFR_VERSION_STRING "3.1.0-p4"
+#define MPFR_VERSION_STRING "3.1.0-p5"
 
 /* Macros dealing with MPFR VERSION */
 #define MPFR_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))
diff -Naurd mpfr-3.1.0-a/src/mul_d.c mpfr-3.1.0-b/src/mul_d.c
--- mpfr-3.1.0-a/src/mul_d.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/mul_d.c	2012-02-24 12:44:49.000000000 +0000
@@ -34,7 +34,7 @@
     (("b[%Pu]=%.*Rg c=%.20g rnd=%d",
       mpfr_get_prec(b), mpfr_log_prec, b, c, rnd_mode),
      ("a[%Pu]=%.*Rg inexact=%d",
-      mpfr_get_prec (a), mpfr_get_prec, a, inexact));
+      mpfr_get_prec (a), mpfr_log_prec, a, inexact));
 
   MPFR_SAVE_EXPO_MARK (expo);
 
diff -Naurd mpfr-3.1.0-a/src/version.c mpfr-3.1.0-b/src/version.c
--- mpfr-3.1.0-a/src/version.c	2011-11-28 12:22:52.000000000 +0000
+++ mpfr-3.1.0-b/src/version.c	2012-02-24 12:44:49.000000000 +0000
@@ -25,5 +25,5 @@
 const char *
 mpfr_get_version (void)
 {
-  return "3.1.0-p4";
+  return "3.1.0-p5";
 }
diff -Naurd mpfr-3.1.0-a/PATCHES mpfr-3.1.0-b/PATCHES
--- mpfr-3.1.0-a/PATCHES	2012-02-24 13:50:05.000000000 +0000
+++ mpfr-3.1.0-b/PATCHES	2012-02-24 13:50:05.000000000 +0000
@@ -0,0 +1 @@
+logging-varfmt
diff -Naurd mpfr-3.1.0-a/VERSION mpfr-3.1.0-b/VERSION
--- mpfr-3.1.0-a/VERSION	2012-02-24 12:44:49.000000000 +0000
+++ mpfr-3.1.0-b/VERSION	2012-02-24 13:50:05.000000000 +0000
@@ -1 +1 @@
-3.1.0-p5
+3.1.0-p6
diff -Naurd mpfr-3.1.0-a/src/mpfr-impl.h mpfr-3.1.0-b/src/mpfr-impl.h
--- mpfr-3.1.0-a/src/mpfr-impl.h	2011-10-05 21:39:57.000000000 +0000
+++ mpfr-3.1.0-b/src/mpfr-impl.h	2012-02-24 13:50:05.000000000 +0000
@@ -1592,7 +1592,7 @@
   do                                                                    \
     if ((MPFR_LOG_INTERNAL_F & mpfr_log_type) &&                        \
         (mpfr_log_current <= mpfr_log_level))                           \
-      LOG_PRINT ("%s.%d:%s[%#Pu]=%.*Rf\n", __func__, __LINE__,          \
+      LOG_PRINT ("%s.%d:%s[%#Pu]=%.*Rg\n", __func__, __LINE__,          \
                  #x, mpfr_get_prec (x), mpfr_log_prec, x);              \
   while (0)
 
diff -Naurd mpfr-3.1.0-a/src/mpfr.h mpfr-3.1.0-b/src/mpfr.h
--- mpfr-3.1.0-a/src/mpfr.h	2012-02-24 12:44:49.000000000 +0000
+++ mpfr-3.1.0-b/src/mpfr.h	2012-02-24 13:50:05.000000000 +0000
@@ -27,7 +27,7 @@
 #define MPFR_VERSION_MAJOR 3
 #define MPFR_VERSION_MINOR 1
 #define MPFR_VERSION_PATCHLEVEL 0
-#define MPFR_VERSION_STRING "3.1.0-p5"
+#define MPFR_VERSION_STRING "3.1.0-p6"
 
 /* Macros dealing with MPFR VERSION */
 #define MPFR_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))
diff -Naurd mpfr-3.1.0-a/src/version.c mpfr-3.1.0-b/src/version.c
--- mpfr-3.1.0-a/src/version.c	2012-02-24 12:44:49.000000000 +0000
+++ mpfr-3.1.0-b/src/version.c	2012-02-24 13:50:05.000000000 +0000
@@ -25,5 +25,5 @@
 const char *
 mpfr_get_version (void)
 {
-  return "3.1.0-p5";
+  return "3.1.0-p6";
 }
diff -Naurd mpfr-3.1.0-a/PATCHES mpfr-3.1.0-b/PATCHES
--- mpfr-3.1.0-a/PATCHES	2012-03-08 15:17:03.000000000 +0000
+++ mpfr-3.1.0-b/PATCHES	2012-03-08 15:17:03.000000000 +0000
@@ -0,0 +1 @@
+large-prec
diff -Naurd mpfr-3.1.0-a/VERSION mpfr-3.1.0-b/VERSION
--- mpfr-3.1.0-a/VERSION	2012-02-24 13:50:05.000000000 +0000
+++ mpfr-3.1.0-b/VERSION	2012-03-08 15:17:03.000000000 +0000
@@ -1 +1 @@
-3.1.0-p6
+3.1.0-p7
diff -Naurd mpfr-3.1.0-a/src/add1.c mpfr-3.1.0-b/src/add1.c
--- mpfr-3.1.0-a/src/add1.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/add1.c	2012-03-08 15:17:03.000000000 +0000
@@ -44,12 +44,12 @@
   bq = MPFR_PREC(b);
   cq = MPFR_PREC(c);
 
-  an = (aq-1)/GMP_NUMB_BITS+1; /* number of limbs of a */
+  an = MPFR_PREC2LIMBS (aq); /* number of limbs of a */
   aq2 = (mpfr_prec_t) an * GMP_NUMB_BITS;
   sh = aq2 - aq;                  /* non-significant bits in low limb */
 
-  bn = (bq-1)/GMP_NUMB_BITS+1; /* number of limbs of b */
-  cn = (cq-1)/GMP_NUMB_BITS+1; /* number of limbs of c */
+  bn = MPFR_PREC2LIMBS (bq); /* number of limbs of b */
+  cn = MPFR_PREC2LIMBS (cq); /* number of limbs of c */
 
   ap = MPFR_MANT(a);
   bp = MPFR_MANT(b);
@@ -124,7 +124,7 @@
       dif = aq2 - diff_exp;
       /* dif is the number of bits of c which overlap with a' */
 
-      difn = (dif-1)/GMP_NUMB_BITS + 1;
+      difn = MPFR_PREC2LIMBS (dif);
       /* only the highest difn limbs from c have to be considered */
       if (MPFR_UNLIKELY(difn > cn))
         {
diff -Naurd mpfr-3.1.0-a/src/add1sp.c mpfr-3.1.0-b/src/add1sp.c
--- mpfr-3.1.0-a/src/add1sp.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/add1sp.c	2012-03-08 15:17:03.000000000 +0000
@@ -107,7 +107,7 @@
 
   /* Read prec and num of limbs */
   p = MPFR_PREC(b);
-  n = (p+GMP_NUMB_BITS-1)/GMP_NUMB_BITS;
+  n = MPFR_PREC2LIMBS (p);
   MPFR_UNSIGNED_MINUS_MODULO(sh, p);
   bx = MPFR_GET_EXP(b);
   d = (mpfr_uexp_t) (bx - MPFR_GET_EXP(c));
diff -Naurd mpfr-3.1.0-a/src/agm.c mpfr-3.1.0-b/src/agm.c
--- mpfr-3.1.0-a/src/agm.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/agm.c	2012-03-08 15:17:03.000000000 +0000
@@ -91,7 +91,7 @@
   q = MPFR_PREC(r);
   p = q + MPFR_INT_CEIL_LOG2(q) + 15;
   MPFR_ASSERTD (p >= 7); /* see algorithms.tex */
-  s = (p - 1) / GMP_NUMB_BITS + 1;
+  s = MPFR_PREC2LIMBS (p);
 
   /* b (op2) and a (op1) are the 2 operands but we want b >= a */
   compare = mpfr_cmp (op1, op2);
@@ -285,7 +285,7 @@
 
       /* Next iteration */
       MPFR_ZIV_NEXT (loop, p);
-      s = (p - 1) / GMP_NUMB_BITS + 1;
+      s = MPFR_PREC2LIMBS (p);
     }
   MPFR_ZIV_FREE (loop);
 
diff -Naurd mpfr-3.1.0-a/src/eq.c mpfr-3.1.0-b/src/eq.c
--- mpfr-3.1.0-a/src/eq.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/eq.c	2012-03-08 15:17:03.000000000 +0000
@@ -56,8 +56,8 @@
   if (uexp != vexp)
     return 0; /* no bit agree */
 
-  usize = (MPFR_PREC(u) - 1) / GMP_NUMB_BITS + 1;
-  vsize = (MPFR_PREC(v) - 1) / GMP_NUMB_BITS + 1;
+  usize = MPFR_LIMB_SIZE (u);
+  vsize = MPFR_LIMB_SIZE (v);
 
   if (vsize > usize) /* exchange u and v */
     {
diff -Naurd mpfr-3.1.0-a/src/exp.c mpfr-3.1.0-b/src/exp.c
--- mpfr-3.1.0-a/src/exp.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/exp.c	2012-03-08 15:17:03.000000000 +0000
@@ -133,7 +133,7 @@
               mp_size_t yn;
               int sh;
 
-              yn = 1 + (MPFR_PREC(y) - 1) / GMP_NUMB_BITS;
+              yn = MPFR_LIMB_SIZE (y);
               sh = (mpfr_prec_t) yn * GMP_NUMB_BITS - MPFR_PREC(y);
               MPFR_MANT(y)[0] += MPFR_LIMB_ONE << sh;
               inexact = 1;
diff -Naurd mpfr-3.1.0-a/src/get_d.c mpfr-3.1.0-b/src/get_d.c
--- mpfr-3.1.0-a/src/get_d.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/get_d.c	2012-03-08 15:17:03.000000000 +0000
@@ -100,7 +100,7 @@
           nbits += (1021 + e);
           MPFR_ASSERTD (nbits >= 1);
         }
-      np = (nbits + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;
+      np = MPFR_PREC2LIMBS (nbits);
       MPFR_ASSERTD ( np <= MPFR_LIMBS_PER_DOUBLE );
       carry = mpfr_round_raw_4 (tp, MPFR_MANT(src), MPFR_PREC(src), negative,
                                 nbits, rnd_mode);
diff -Naurd mpfr-3.1.0-a/src/get_flt.c mpfr-3.1.0-b/src/get_flt.c
--- mpfr-3.1.0-a/src/get_flt.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/get_flt.c	2012-03-08 15:17:03.000000000 +0000
@@ -92,7 +92,7 @@
           nbits += (125 + e);
           MPFR_ASSERTD (nbits >= 1);
         }
-      np = (nbits + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;
+      np = MPFR_PREC2LIMBS (nbits);
       MPFR_ASSERTD(np <= MPFR_LIMBS_PER_FLT);
       carry = mpfr_round_raw_4 (tp, MPFR_MANT(src), MPFR_PREC(src), negative,
                                 nbits, rnd_mode);
diff -Naurd mpfr-3.1.0-a/src/get_str.c mpfr-3.1.0-b/src/get_str.c
--- mpfr-3.1.0-a/src/get_str.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/get_str.c	2012-03-08 15:17:03.000000000 +0000
@@ -2351,7 +2351,7 @@
 
       /* the first digit will contain only r bits */
       prec = (m - 1) * pow2 + r; /* total number of bits */
-      n = (prec - 1) / GMP_NUMB_BITS + 1;
+      n = MPFR_PREC2LIMBS (prec);
 
       MPFR_TMP_MARK (marker);
       x1 = MPFR_TMP_LIMBS_ALLOC (n + 1);
@@ -2417,12 +2417,12 @@
       exact = 1;
 
       /* number of limbs */
-      n = 1 + (prec - 1) / GMP_NUMB_BITS;
+      n = MPFR_PREC2LIMBS (prec);
 
       /* a will contain the approximation of the mantissa */
       a = MPFR_TMP_LIMBS_ALLOC (n);
 
-      nx = 1 + (MPFR_PREC(x) - 1) / GMP_NUMB_BITS;
+      nx = MPFR_LIMB_SIZE (x);
 
       if ((mpfr_exp_t) m == g) /* final exponent is 0, no multiplication or
                                 division to perform */
diff -Naurd mpfr-3.1.0-a/src/init2.c mpfr-3.1.0-b/src/init2.c
--- mpfr-3.1.0-a/src/init2.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/init2.c	2012-03-08 15:17:03.000000000 +0000
@@ -51,7 +51,7 @@
      which both have an odd mantissa */
   MPFR_ASSERTN(p >= MPFR_PREC_MIN && p <= MPFR_PREC_MAX);
 
-  xsize = (mp_size_t) ((p - 1) / GMP_NUMB_BITS) + 1;
+  xsize = MPFR_PREC2LIMBS (p);
   tmp   = (mpfr_limb_ptr) (*__gmp_allocate_func)(MPFR_MALLOC_SIZE(xsize));
 
   MPFR_PREC(x) = p;                /* Set prec */
diff -Naurd mpfr-3.1.0-a/src/lngamma.c mpfr-3.1.0-b/src/lngamma.c
--- mpfr-3.1.0-a/src/lngamma.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/lngamma.c	2012-03-08 15:17:03.000000000 +0000
@@ -67,7 +67,7 @@
 
   /* Now, the unit bit is represented. */
 
-  prec = ((prec - 1) / GMP_NUMB_BITS + 1) * GMP_NUMB_BITS - expo;
+  prec = MPFR_PREC2LIMBS (prec) * GMP_NUMB_BITS - expo;
   /* number of represented fractional bits (including the trailing 0's) */
 
   x0 = *(MPFR_MANT (x) + prec / GMP_NUMB_BITS);
diff -Naurd mpfr-3.1.0-a/src/mpfr-impl.h mpfr-3.1.0-b/src/mpfr-impl.h
--- mpfr-3.1.0-a/src/mpfr-impl.h	2012-02-24 13:50:05.000000000 +0000
+++ mpfr-3.1.0-b/src/mpfr-impl.h	2012-03-09 12:06:26.000000000 +0000
@@ -646,10 +646,24 @@
  **************** mpfr_t properties *******************
  ******************************************************/
 
+/* In the following macro, p is usually a mpfr_prec_t, but this macro
+   works with other integer types (without integer overflow). Checking
+   that p >= 1 in debug mode is useful here because this macro can be
+   used on a computed precision (in particular, this formula does not
+   work for a degenerate case p = 0, and could give different results
+   on different platforms). But let us not use an assertion checking
+   in the MPFR_LAST_LIMB() and MPFR_LIMB_SIZE() macros below to avoid
+   too much expansion for assertions (in practice, this should be a
+   problem just when testing MPFR with the --enable-assert configure
+   option and the -ansi -pedantic-errors gcc compiler flags). */
+#define MPFR_PREC2LIMBS(p) \
+  (MPFR_ASSERTD ((p) >= 1), ((p) - 1) / GMP_NUMB_BITS + 1)
+
 #define MPFR_PREC(x)      ((x)->_mpfr_prec)
 #define MPFR_EXP(x)       ((x)->_mpfr_exp)
 #define MPFR_MANT(x)      ((x)->_mpfr_d)
-#define MPFR_LIMB_SIZE(x) ((MPFR_PREC((x))-1)/GMP_NUMB_BITS+1)
+#define MPFR_LAST_LIMB(x) ((MPFR_PREC (x) - 1) / GMP_NUMB_BITS)
+#define MPFR_LIMB_SIZE(x) (MPFR_LAST_LIMB (x) + 1)
 
 
 /******************************************************
@@ -749,7 +763,8 @@
 #define MPFR_IS_FP(x)       (!MPFR_IS_NAN(x) && !MPFR_IS_INF(x))
 #define MPFR_IS_SINGULAR(x) (MPFR_EXP(x) <= MPFR_EXP_INF)
 #define MPFR_IS_PURE_FP(x)  (!MPFR_IS_SINGULAR(x) && \
-  (MPFR_ASSERTD (MPFR_MANT(x)[MPFR_LIMB_SIZE(x)-1] & MPFR_LIMB_HIGHBIT), 1))
+  (MPFR_ASSERTD ((MPFR_MANT(x)[MPFR_LAST_LIMB(x)]  \
+                  & MPFR_LIMB_HIGHBIT) != 0), 1))
 
 #define MPFR_ARE_SINGULAR(x,y) \
   (MPFR_UNLIKELY(MPFR_IS_SINGULAR(x)) || MPFR_UNLIKELY(MPFR_IS_SINGULAR(y)))
@@ -1061,7 +1076,7 @@
 /* Set a number to 1 (Fast) - It doesn't check if 1 is in the exponent range */
 #define MPFR_SET_ONE(x)                                               \
 do {                                                                  \
-  mp_size_t _size = MPFR_LIMB_SIZE(x) - 1;                            \
+  mp_size_t _size = MPFR_LAST_LIMB(x);                                \
   MPFR_SET_POS(x);                                                    \
   MPFR_EXP(x) = 1;                                                    \
   MPN_ZERO ( MPFR_MANT(x), _size);                                    \
@@ -1213,8 +1228,8 @@
     _destp = MPFR_MANT (dest);                                              \
     if (MPFR_UNLIKELY (_destprec >= _srcprec))                              \
       {                                                                     \
-        _srcs  = (_srcprec  + GMP_NUMB_BITS-1)/GMP_NUMB_BITS;               \
-        _dests = (_destprec + GMP_NUMB_BITS-1)/GMP_NUMB_BITS - _srcs;       \
+        _srcs  = MPFR_PREC2LIMBS (_srcprec);                                \
+        _dests = MPFR_PREC2LIMBS (_destprec) - _srcs;                       \
         MPN_COPY (_destp + _dests, srcp, _srcs);                            \
         MPN_ZERO (_destp, _dests);                                          \
         inexact = 0;                                                        \
@@ -1227,8 +1242,8 @@
         mp_limb_t _rb, _sb, _ulp;                                           \
                                                                             \
         /* Compute Position and shift */                                    \
-        _srcs  = (_srcprec  + GMP_NUMB_BITS-1)/GMP_NUMB_BITS;               \
-        _dests = (_destprec + GMP_NUMB_BITS-1)/GMP_NUMB_BITS;               \
+        _srcs  = MPFR_PREC2LIMBS (_srcprec);                                \
+        _dests = MPFR_PREC2LIMBS (_destprec);                               \
         MPFR_UNSIGNED_MINUS_MODULO (_sh, _destprec);                        \
         _sp = (srcp) + _srcs - _dests;                                      \
                                                                             \
@@ -1372,7 +1387,7 @@
       if (MPFR_LIKELY (MPFR_PREC (dest) == MPFR_PREC (src)))            \
         {                                                               \
           MPN_COPY (MPFR_MANT (dest), MPFR_MANT (src),                  \
-                    (MPFR_PREC (src) + GMP_NUMB_BITS-1)/GMP_NUMB_BITS); \
+                    MPFR_LIMB_SIZE (src));                              \
           inexact = 0;                                                  \
         }                                                               \
       else                                                              \
@@ -1682,7 +1697,7 @@
  MPFR_ASSERTD (_prec >= MPFR_PREC_MIN);                                 \
  if (MPFR_UNLIKELY (_prec > MPFR_PREC_MAX))                             \
    mpfr_abort_prec_max ();                                              \
- _size = (mpfr_prec_t) (_prec + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;     \
+ _size = MPFR_PREC2LIMBS (_prec);                                       \
  if (MPFR_UNLIKELY (_size * (num) > MPFR_GROUP_STATIC_SIZE))            \
    {                                                                    \
      (g).alloc = (num) * _size * sizeof (mp_limb_t);                    \
@@ -1733,7 +1748,7 @@
  MPFR_ASSERTD (_prec >= MPFR_PREC_MIN);                                 \
  if (MPFR_UNLIKELY (_prec > MPFR_PREC_MAX))                             \
    mpfr_abort_prec_max ();                                              \
- _size = (mpfr_prec_t) (_prec + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;     \
+ _size = MPFR_PREC2LIMBS (_prec);                                       \
  (g).alloc = (num) * _size * sizeof (mp_limb_t);                        \
  if (MPFR_LIKELY (_oalloc == 0))                                        \
    (g).mant = (mp_limb_t *) (*__gmp_allocate_func) ((g).alloc);         \
@@ -1886,7 +1901,7 @@
        MPFR_NORETURN_ATTR;
 
 __MPFR_DECLSPEC void mpfr_rand_raw _MPFR_PROTO((mpfr_limb_ptr, gmp_randstate_t,
-                                                unsigned long));
+                                                mpfr_prec_t));
 
 __MPFR_DECLSPEC mpz_t* mpfr_bernoulli_internal _MPFR_PROTO((mpz_t*,
                                                             unsigned long));
diff -Naurd mpfr-3.1.0-a/src/mpfr.h mpfr-3.1.0-b/src/mpfr.h
--- mpfr-3.1.0-a/src/mpfr.h	2012-02-24 13:50:05.000000000 +0000
+++ mpfr-3.1.0-b/src/mpfr.h	2012-03-08 15:17:03.000000000 +0000
@@ -27,7 +27,7 @@
 #define MPFR_VERSION_MAJOR 3
 #define MPFR_VERSION_MINOR 1
 #define MPFR_VERSION_PATCHLEVEL 0
-#define MPFR_VERSION_STRING "3.1.0-p6"
+#define MPFR_VERSION_STRING "3.1.0-p7"
 
 /* Macros dealing with MPFR VERSION */
 #define MPFR_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))
diff -Naurd mpfr-3.1.0-a/src/mul.c mpfr-3.1.0-b/src/mul.c
--- mpfr-3.1.0-a/src/mul.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/mul.c	2012-03-08 15:17:03.000000000 +0000
@@ -93,15 +93,15 @@
 
   ax = MPFR_GET_EXP (b) + MPFR_GET_EXP (c);
 
-  bq = MPFR_PREC(b);
-  cq = MPFR_PREC(c);
+  bq = MPFR_PREC (b);
+  cq = MPFR_PREC (c);
 
-  MPFR_ASSERTD(bq+cq > bq); /* PREC_MAX is /2 so no integer overflow */
+  MPFR_ASSERTN ((mpfr_uprec_t) bq + cq <= MPFR_PREC_MAX);
 
-  bn = (bq+GMP_NUMB_BITS-1)/GMP_NUMB_BITS; /* number of limbs of b */
-  cn = (cq+GMP_NUMB_BITS-1)/GMP_NUMB_BITS; /* number of limbs of c */
+  bn = MPFR_PREC2LIMBS (bq); /* number of limbs of b */
+  cn = MPFR_PREC2LIMBS (cq); /* number of limbs of c */
   k = bn + cn; /* effective nb of limbs used by b*c (= tn or tn+1) below */
-  tn = (bq + cq + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;
+  tn = MPFR_PREC2LIMBS (bq + cq);
   /* <= k, thus no int overflow */
   MPFR_ASSERTD(tn <= k);
 
@@ -292,12 +292,12 @@
   bq = MPFR_PREC (b);
   cq = MPFR_PREC (c);
 
-  MPFR_ASSERTD (bq+cq > bq); /* PREC_MAX is /2 so no integer overflow */
+  MPFR_ASSERTN ((mpfr_uprec_t) bq + cq <= MPFR_PREC_MAX);
 
-  bn = (bq+GMP_NUMB_BITS-1)/GMP_NUMB_BITS; /* number of limbs of b */
-  cn = (cq+GMP_NUMB_BITS-1)/GMP_NUMB_BITS; /* number of limbs of c */
+  bn = MPFR_PREC2LIMBS (bq); /* number of limbs of b */
+  cn = MPFR_PREC2LIMBS (cq); /* number of limbs of c */
   k = bn + cn; /* effective nb of limbs used by b*c (= tn or tn+1) below */
-  tn = (bq + cq + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;
+  tn = MPFR_PREC2LIMBS (bq + cq);
   MPFR_ASSERTD (tn <= k); /* tn <= k, thus no int overflow */
 
   /* Check for no size_t overflow*/
diff -Naurd mpfr-3.1.0-a/src/pow.c mpfr-3.1.0-b/src/pow.c
--- mpfr-3.1.0-a/src/pow.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/pow.c	2012-03-08 15:17:03.000000000 +0000
@@ -136,7 +136,7 @@
      (b) all the 'z' bits are zero
   */
 
-  prec = ((prec - 1) / GMP_NUMB_BITS + 1) * GMP_NUMB_BITS - expo;
+  prec = MPFR_PREC2LIMBS (prec) * GMP_NUMB_BITS - expo;
   /* number of z+0 bits */
 
   yn = prec / GMP_NUMB_BITS;
diff -Naurd mpfr-3.1.0-a/src/print_raw.c mpfr-3.1.0-b/src/print_raw.c
--- mpfr-3.1.0-a/src/print_raw.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/print_raw.c	2012-03-08 15:17:03.000000000 +0000
@@ -84,7 +84,7 @@
   int i;
   mpfr_prec_t count = 0;
   char c;
-  mp_size_t n = (r - 1) / GMP_NUMB_BITS + 1;
+  mp_size_t n = MPFR_PREC2LIMBS (r);
 
   printf("%s ", str);
   for(n-- ; n>=0 ; n--)
@@ -109,7 +109,7 @@
   int i;
   mpfr_prec_t count = 0;
   char c;
-  mp_size_t n = (r - 1) / GMP_NUMB_BITS + 1;
+  mp_size_t n = MPFR_PREC2LIMBS (r);
 
   for(n-- ; n>=0 ; n--)
     {
diff -Naurd mpfr-3.1.0-a/src/round_prec.c mpfr-3.1.0-b/src/round_prec.c
--- mpfr-3.1.0-a/src/round_prec.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/round_prec.c	2012-03-08 15:17:03.000000000 +0000
@@ -55,12 +55,12 @@
 
   MPFR_ASSERTN(prec >= MPFR_PREC_MIN && prec <= MPFR_PREC_MAX);
 
-  nw = 1 + (prec - 1) / GMP_NUMB_BITS; /* needed allocated limbs */
+  nw = MPFR_PREC2LIMBS (prec); /* needed allocated limbs */
 
   /* check if x has enough allocated space for the significand */
   /* Get the number of limbs from the precision.
      (Compatible with all allocation methods) */
-  ow = (MPFR_PREC (x) + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;
+  ow = MPFR_LIMB_SIZE (x);
   if (nw > ow)
     {
       /* FIXME: Variable can't be created using custom allocation,
diff -Naurd mpfr-3.1.0-a/src/round_raw_generic.c mpfr-3.1.0-b/src/round_raw_generic.c
--- mpfr-3.1.0-a/src/round_raw_generic.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/round_raw_generic.c	2012-03-08 15:17:03.000000000 +0000
@@ -80,7 +80,7 @@
       (xprec <= yprec || MPFR_IS_LIKE_RNDZ (rnd_mode, neg)))
     return 0;
 
-  xsize = (xprec-1)/GMP_NUMB_BITS + 1;
+  xsize = MPFR_PREC2LIMBS (xprec);
   nw = yprec / GMP_NUMB_BITS;
   rw = yprec & (GMP_NUMB_BITS - 1);
 
diff -Naurd mpfr-3.1.0-a/src/set.c mpfr-3.1.0-b/src/set.c
--- mpfr-3.1.0-a/src/set.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/set.c	2012-03-08 15:17:03.000000000 +0000
@@ -48,8 +48,7 @@
       /* Same precision and b is not singular:
        * just copy the mantissa, and set the exponent and the sign
        * The result is exact. */
-      MPN_COPY (MPFR_MANT (a), MPFR_MANT (b),
-                (MPFR_PREC (b) + GMP_NUMB_BITS-1)/GMP_NUMB_BITS);
+      MPN_COPY (MPFR_MANT (a), MPFR_MANT (b), MPFR_LIMB_SIZE (b));
       MPFR_RET (0);
     }
   else
diff -Naurd mpfr-3.1.0-a/src/set_f.c mpfr-3.1.0-b/src/set_f.c
--- mpfr-3.1.0-a/src/set_f.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/set_f.c	2012-03-08 15:17:03.000000000 +0000
@@ -43,7 +43,7 @@
   if (SIZ(x) * MPFR_FROM_SIGN_TO_INT(MPFR_SIGN(y)) < 0)
     MPFR_CHANGE_SIGN (y);
 
-  sy = 1 + (MPFR_PREC(y) - 1) / GMP_NUMB_BITS;
+  sy = MPFR_LIMB_SIZE (y);
   my = MPFR_MANT(y);
   mx = PTR(x);
 
diff -Naurd mpfr-3.1.0-a/src/set_prec.c mpfr-3.1.0-b/src/set_prec.c
--- mpfr-3.1.0-a/src/set_prec.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/set_prec.c	2012-03-08 15:17:03.000000000 +0000
@@ -32,7 +32,7 @@
   MPFR_ASSERTN (p >= MPFR_PREC_MIN && p <= MPFR_PREC_MAX);
 
   /* Calculate the new number of limbs */
-  xsize = (p - 1) / GMP_NUMB_BITS + 1;
+  xsize = MPFR_PREC2LIMBS (p);
 
   /* Realloc only if the new size is greater than the old */
   xoldsize = MPFR_GET_ALLOC_SIZE (x);
diff -Naurd mpfr-3.1.0-a/src/setmax.c mpfr-3.1.0-b/src/setmax.c
--- mpfr-3.1.0-a/src/setmax.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/setmax.c	2012-03-08 15:17:03.000000000 +0000
@@ -32,7 +32,7 @@
   mp_limb_t *xp;
 
   MPFR_SET_EXP (x, e);
-  xn = 1 + (MPFR_PREC(x) - 1) / GMP_NUMB_BITS;
+  xn = MPFR_LIMB_SIZE (x);
   sh = (mpfr_prec_t) xn * GMP_NUMB_BITS - MPFR_PREC(x);
   xp = MPFR_MANT(x);
   xp[0] = MP_LIMB_T_MAX << sh;
diff -Naurd mpfr-3.1.0-a/src/sqr.c mpfr-3.1.0-b/src/sqr.c
--- mpfr-3.1.0-a/src/sqr.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/sqr.c	2012-03-08 15:17:03.000000000 +0000
@@ -56,11 +56,11 @@
   ax = 2 * MPFR_GET_EXP (b);
   bq = MPFR_PREC(b);
 
-  MPFR_ASSERTD (2 * bq > bq); /* PREC_MAX is /2 so no integer overflow */
+  MPFR_ASSERTN (2 * (mpfr_uprec_t) bq <= MPFR_PREC_MAX);
 
-  bn = MPFR_LIMB_SIZE(b); /* number of limbs of b */
-  tn = 1 + (2 * bq - 1) / GMP_NUMB_BITS; /* number of limbs of square,
-                                               2*bn or 2*bn-1 */
+  bn = MPFR_LIMB_SIZE (b); /* number of limbs of b */
+  tn = MPFR_PREC2LIMBS (2 * bq); /* number of limbs of square,
+                                    2*bn or 2*bn-1 */
 
   if (MPFR_UNLIKELY(bn > MPFR_SQR_THRESHOLD))
     return mpfr_mul (a, b, b, rnd_mode);
diff -Naurd mpfr-3.1.0-a/src/stack_interface.c mpfr-3.1.0-b/src/stack_interface.c
--- mpfr-3.1.0-a/src/stack_interface.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/stack_interface.c	2012-03-08 15:17:03.000000000 +0000
@@ -26,7 +26,7 @@
 size_t
 mpfr_custom_get_size (mpfr_prec_t prec)
 {
-  return (prec + GMP_NUMB_BITS -1) / GMP_NUMB_BITS * BYTES_PER_MP_LIMB;
+  return MPFR_PREC2LIMBS (prec) * BYTES_PER_MP_LIMB;
 }
 
 #undef mpfr_custom_init
diff -Naurd mpfr-3.1.0-a/src/strtofr.c mpfr-3.1.0-b/src/strtofr.c
--- mpfr-3.1.0-a/src/strtofr.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/strtofr.c	2012-03-08 15:17:03.000000000 +0000
@@ -467,7 +467,7 @@
       /* Set y to the value of the ~prec most significant bits of pstr->mant
          (as long as we guarantee correct rounding, we don't need to get
          exactly prec bits). */
-      ysize = (prec - 1) / GMP_NUMB_BITS + 1;
+      ysize = MPFR_PREC2LIMBS (prec);
       /* prec bits corresponds to ysize limbs */
       ysize_bits = ysize * GMP_NUMB_BITS;
       /* and to ysize_bits >= prec > MPFR_PREC (x) bits */
diff -Naurd mpfr-3.1.0-a/src/sub1sp.c mpfr-3.1.0-b/src/sub1sp.c
--- mpfr-3.1.0-a/src/sub1sp.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/sub1sp.c	2012-03-08 15:17:03.000000000 +0000
@@ -155,8 +155,8 @@
   MPFR_ASSERTD(MPFR_IS_PURE_FP(c));
 
   /* Read prec and num of limbs */
-  p = MPFR_PREC(b);
-  n = (p-1)/GMP_NUMB_BITS+1;
+  p = MPFR_PREC (b);
+  n = MPFR_PREC2LIMBS (p);
 
   /* Fast cmp of |b| and |c|*/
   bx = MPFR_GET_EXP (b);
diff -Naurd mpfr-3.1.0-a/src/urandomb.c mpfr-3.1.0-b/src/urandomb.c
--- mpfr-3.1.0-a/src/urandomb.c	2011-10-03 08:17:09.000000000 +0000
+++ mpfr-3.1.0-b/src/urandomb.c	2012-03-08 15:17:03.000000000 +0000
@@ -31,13 +31,20 @@
    a sufficient number of limbs */
 void
 mpfr_rand_raw (mpfr_limb_ptr mp, gmp_randstate_t rstate,
-               unsigned long int nbits)
+               mpfr_prec_t nbits)
 {
   mpz_t z;
 
+  MPFR_ASSERTN (nbits >= 1);
   /* To be sure to avoid the potential allocation of mpz_urandomb */
-  ALLOC(z) = SIZ(z) = ((nbits - 1) / GMP_NUMB_BITS) + 1;
+  ALLOC(z) = SIZ(z) = MPFR_PREC2LIMBS (nbits);
   PTR(z)   = mp;
+#if __MPFR_GMP(5,0,0)
+  /* Check for integer overflow (unless mp_bitcnt_t is signed,
+     but according to the GMP manual, this shouldn't happen).
+     Note: mp_bitcnt_t has been introduced in GMP 5.0.0. */
+  MPFR_ASSERTN ((mp_bitcnt_t) -1 < 0 || nbits <= (mp_bitcnt_t) -1);
+#endif
   mpz_urandomb (z, rstate, nbits);
 }
 
diff -Naurd mpfr-3.1.0-a/src/version.c mpfr-3.1.0-b/src/version.c
--- mpfr-3.1.0-a/src/version.c	2012-02-24 13:50:05.000000000 +0000
+++ mpfr-3.1.0-b/src/version.c	2012-03-08 15:17:03.000000000 +0000
@@ -25,5 +25,5 @@
 const char *
 mpfr_get_version (void)
 {
-  return "3.1.0-p6";
+  return "3.1.0-p7";
 }
diff -Naurd mpfr-3.1.0-a/tests/tinits.c mpfr-3.1.0-b/tests/tinits.c
--- mpfr-3.1.0-a/tests/tinits.c	2011-10-03 08:17:14.000000000 +0000
+++ mpfr-3.1.0-b/tests/tinits.c	2012-03-08 15:17:03.000000000 +0000
@@ -1,4 +1,4 @@
-/* Test file for mpfr_inits, mpfr_inits2 and mpfr_clears.
+/* Test file for mpfr_init2, mpfr_inits, mpfr_inits2 and mpfr_clears.
 
 Copyright 2003, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
 Contributed by the Arenaire and Caramel projects, INRIA.
@@ -20,18 +20,43 @@
 http://www.gnu.org/licenses/ or write to the Free Software Foundation, Inc.,
 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA. */
 
+#include <stdlib.h>
+
 #include "mpfr-test.h"
 
 int
 main (void)
 {
   mpfr_t a, b, c;
+  long large_prec;
 
   tests_start_mpfr ();
+
   mpfr_inits (a, b, c, (mpfr_ptr) 0);
   mpfr_clears (a, b, c, (mpfr_ptr) 0);
   mpfr_inits2 (200, a, b, c, (mpfr_ptr) 0);
   mpfr_clears (a, b, c, (mpfr_ptr) 0);
+
+  /* test for precision 2^31-1, see
+     https://gforge.inria.fr/tracker/index.php?func=detail&aid=13918 */
+  large_prec = 2147483647;
+  if (getenv ("MPFR_CHECK_LARGEMEM") != NULL)
+    {
+      /* We assume that the precision won't be increased internally. */
+      if (large_prec > MPFR_PREC_MAX)
+        large_prec = MPFR_PREC_MAX;
+      mpfr_inits2 (large_prec, a, b, (mpfr_ptr) 0);
+      mpfr_set_ui (a, 17, MPFR_RNDN);
+      mpfr_set (b, a, MPFR_RNDN);
+      if (mpfr_get_ui (a, MPFR_RNDN) != 17)
+        {
+          printf ("Error in mpfr_init2 with precision 2^31-1\n");
+          exit (1);
+        }
+      mpfr_clears (a, b, (mpfr_ptr) 0);
+    }
+
   tests_end_mpfr ();
+
   return 0;
 }
diff -Naurd mpfr-3.1.0-a/PATCHES mpfr-3.1.0-b/PATCHES
--- mpfr-3.1.0-a/PATCHES	2012-03-12 11:59:47.000000000 +0000
+++ mpfr-3.1.0-b/PATCHES	2012-03-12 11:59:47.000000000 +0000
@@ -0,0 +1 @@
+__gmp_const
diff -Naurd mpfr-3.1.0-a/VERSION mpfr-3.1.0-b/VERSION
--- mpfr-3.1.0-a/VERSION	2012-03-08 15:17:03.000000000 +0000
+++ mpfr-3.1.0-b/VERSION	2012-03-12 11:59:47.000000000 +0000
@@ -1 +1 @@
-3.1.0-p7
+3.1.0-p8
diff -Naurd mpfr-3.1.0-a/src/mpfr.h mpfr-3.1.0-b/src/mpfr.h
--- mpfr-3.1.0-a/src/mpfr.h	2012-03-08 15:17:03.000000000 +0000
+++ mpfr-3.1.0-b/src/mpfr.h	2012-03-12 11:59:47.000000000 +0000
@@ -27,7 +27,7 @@
 #define MPFR_VERSION_MAJOR 3
 #define MPFR_VERSION_MINOR 1
 #define MPFR_VERSION_PATCHLEVEL 0
-#define MPFR_VERSION_STRING "3.1.0-p7"
+#define MPFR_VERSION_STRING "3.1.0-p8"
 
 /* Macros dealing with MPFR VERSION */
 #define MPFR_VERSION_NUM(a,b,c) (((a) << 16L) | ((b) << 8) | (c))
@@ -39,6 +39,18 @@
 # include <gmp.h>
 #endif
 
+/* GMP's internal __gmp_const macro has been removed on 2012-03-04:
+     http://gmplib.org:8000/gmp/rev/d287cfaf6732
+   const is standard and now assumed to be available. If the __gmp_const
+   definition is no longer present in GMP, this probably means that GMP
+   assumes that const is available; thus let's define it to const.
+   Note: this is a temporary fix that can be backported to previous MPFR
+   versions. In the future, __gmp_const should be replaced by const like
+   in GMP. */
+#ifndef __gmp_const
+# define __gmp_const const
+#endif
+
 /* Avoid some problems with macro expansion if the user defines macros
    with the same name as keywords. By convention, identifiers and macro
    names starting with mpfr_ are reserved by MPFR. */
diff -Naurd mpfr-3.1.0-a/src/version.c mpfr-3.1.0-b/src/version.c
--- mpfr-3.1.0-a/src/version.c	2012-03-08 15:17:03.000000000 +0000
+++ mpfr-3.1.0-b/src/version.c	2012-03-12 11:59:47.000000000 +0000
@@ -25,5 +25,5 @@
 const char *
 mpfr_get_version (void)
 {
-  return "3.1.0-p7";
+  return "3.1.0-p8";
 }
